{
    "aL5GK2LVMWI": "Welcome to the Real Python Podcast. This is episode zero, a trailer for what's to come on the podcast. My name is Christopher Bailey, and I'll be your host. The Real Python Podcast is a weekly conversation about using Python in the real world. Interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. \n\nWe have a set of great guests already lined up for you. Experts in the industry, authors for Real Python, dedicated Python teachers and trainers, and people making contributions to the Python community. They're all ready to share their knowledge with you. I'm not a typical Python podcast host. I'm a self-taught developer, not an expert, so I'm here to ask probing questions and learn along with you. \n\nThough I do have some unique skills. I've been a teacher for over two decades. I want to facilitate discussions and bring your questions. I want to use those skills to help clarify the concepts my guests are presenting to get these types of responses from them. Each episode will include show notes with links to topics, tools, articles, and other resources discussed on the show. You can see those show notes inside your podcast player, but you can also find them at realpython.com/podcast. \n\nSo make sure you click subscribe in your favorite podcast app.",
    "NzD13-O_qQY": "Welcome to the Real Python Podcast. This is Episode 1 and my name is Christopher Bailey, your host. This week, I have a conversation with Gana Onyeanula, one of the authors here at Real Python. We talk about Python decorators and his background, do a little bit of introspection, discuss the Real Python editing process, and then we talk about some of the articles he's written for the site and touch on his talk at PyCon last year.\n\nOne programming note: In this episode, we discussed PyCon U.S. 2020. The episode was recorded at an earlier date and at this moment, PyCon U.S. 2020 is looking at its options for rescheduling or potential cancellation. I'll continue to give you additional updates on PyCon U.S. in upcoming episodes. And now, here's Episode 1. Let's get started.\n\n[Music]\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. Interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey, welcome to the podcast. Where are you joining me from?\n\nI'm in Oslo, Norway. I'm here in Colorado, where it's currently snowing. We were talking earlier about the weather, right?\n\nYeah, kind of envious of your snow, but well, probably gets it here as well. Do you want to start off by telling us a little bit about how you got involved with Python and eventually Real Python?\n\nSure. I've been coding essentially forever because my dad got a Commodore 64 when I was a young boy. I had a brief interaction with Python at a summer internship about 20 years ago. I got back into it in 2012 and was blown away by how quick and easy it was to write. I changed jobs in 2014 and started using Python for a project at a mapping authority. I started working with Fortran but eventually got deep into Python and did all kinds of stuff like compiling Fortran into Python modules and doing numpy work.\n\nIs the company using any Fortran anymore?\n\nNo, we're pure Python now. We got rid of essentially two hundred thousand lines of Fortran code and converted it into something much easier to handle in Python. It was a fun project to work on.\n\nAbout two years ago, I heard that Dan Bader had taken over the Real Python website. I already knew Dan a little bit from his newsletters, and when he mentioned that he was looking for authors, I sent him a note and got a trial article to write. Since then, I've written about seven or eight articles for Real Python and have been working on the team, doing tech reviews for other articles.\n\nThe publishing process at Real Python involves several steps, starting with writing an outline or article, which is reviewed and then written. The article is then sent for a technical review, followed by a didactic review to ensure it is useful for readers. Finally, a language edit is done to clean up any errors.\n\nIt has been a rewarding experience to learn more about writing and Python itself, as well as getting to know the team at Real Python. I have also been doing outline reviews for Real Python, which allows me to communicate with new authors and see articles before they are published.\n\nI also gave a talk at PyCon 2019 on plugins, which involves keeping configurable elements outside of the code itself to easily change them. I use decorators to register functions as plugins, allowing for dispatching functions based on configuration. This structure has been a helpful way of working for me.\n\nThe talk was a quick example of how plugins work and showed how they can be used for different purposes, such as reading data files and dispatching based on the file type.\n\nI have also worked on a Python timers article, which explores three ways of monitoring code using timers. The article demonstrates the use of classes, data classes, context managers, and decorators to create a timer class that can be used to time blocks of code.\n\nIn addition to my articles, I have developed a few PyPI packages, including pipelines and pigulfs, which are useful for dealing with configuration files.\n\nI am currently excited about the Raspberry Pi 4, which offers improved performance and features like dual video outputs and increased RAM. I have been exploring its capabilities, setting up Python environments, and learning more about its potential uses.\n\nI am also looking forward to the Python conference, where I will be running a decorators tutorial. It will be a great opportunity to meet people, share knowledge, and engage with the Python community.\n\nOverall, I am excited about the projects I am working on, the opportunities to learn and grow in Python, and the supportive community at Real Python. Thank you for listening, and I look forward to future conversations and collaborations in the Python world.",
    "d7_QXUzET8k": "Welcome to the Real Python Podcast. This is episode 2, and my name is Christopher Bailey, your host. This week, I talked to John Fincher, one of the authors here at Real Python. We discuss a couple of articles he's written recently for the site on Pygame and Arcade, and how writing games can help you develop your Python skills. So let's get started.\n\n[Music]\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. Interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com. Hey John, welcome to the podcast.\n\nHey, how you doing? Good. So why don't you give us a little bit of your programming background?\n\nSure. I actually learned to code back in high school. This was back in the early 1980s, and there was a programming class. I remember having some of the high school kids come to the junior high to show off these new Apple 2 computers that they had. I was enamored with all the graphics and cool stuff that they could do on them. So I thought, \"Hey, I got to learn how to do this stuff.\" I got into a programming class in high school, was playing video games, old style, pixelated video games like Snake Bite and Bomberman and Load Runner.\n\nYeah, Load Runner. I love Load Runner.\n\nYou know, we played all these games. I thought, \"I got to learn how to write these games.\" I got further and further into it and discovered that operating systems and databases are really cool because I also like math. I was really big into math and kind of joining the two of them. I remember my math teacher made some offhand comment about some graphing software that we were using, how they were graphing the equations and how it worked. It was just a throwaway comment on her part, but I sat there and said, she said, \"It's some difficult way that they're using to graph these things.\" I sat there and looked at it and said, \"How hard can it be?\" And that was pretty much it from there. I was hooked.\n\nYeah, definitely hooked. Went to college, got my degree in college, worked at a couple little places before doing database programming. And such before I got hired at Microsoft. I had been doing database programming, and they were just coming out. This was in 1995. I got hired a couple of weeks after Windows 95 launched. Wow. And Office 95 too came out, and they were looking for support people to help support all their new offerings for Office. So I wound up being a support person for Access 95 because I'd been doing databases and Access programming in my previous life. That turned into doing support for the operating system, which turned into doing support for this thing called Windows Embedded, which was a scaled-down embedded version of Windows. And that led me to a 20-some-odd-year career at Microsoft.\n\nWell, and I pause you there for a second. What would it be embedded into? Windows Embedded would go into things like cash registers. They would go into things like slot machines, video slot machines used in a lot. Oh, okay. They had that CE version for a little while. Windows CE II, that was like a Dreamcast, right? Right, yeah. When DOS EE was its own little operating system that turned into Windows Mobile that eventually became Windows Phone at some point. Yeah, okay. Windows Embedded started big, it started with Windows NT and tried to make it as small as it could. And then Windows XP Embedded, you know, and so that went into dedicated devices that could handle something as big as NT, more as big as XP. Okay. But in a dedicated way. And so from there, I was doing servicing work for it, and that led me into what was then called Windows SE, and I started doing servicing for the operating system. Basically, the reason why if you have a Windows machine, you have to reboot it once a month, yeah, because of security updates. That was us, okay? We're the reason we were doing security updates. And other updates for it. And I'm about four or five years ago, I learned about this group called TEALS, which would take computer professionals from industry and put them into schools to help teach kids computer science, teaching programming and such. And so the schools wanted to have a computer science program, but they didn't have teachers who knew computer science, okay? So we came in, we got a couple weeks of here's how you teach, and then got put into classrooms to help teach kids. And I found I loved doing that. I absolutely loved it. So after doing that, volunteering for a couple years and just growing disillusioned with what I was doing at Microsoft, I left and started teaching. I'd been teaching in high schools for a while. That's actually where I learned Python. That's we were teaching Python. I didn't know it. So I figured I better learn Python if I'm gonna teach this stuff, yeah. So cool. And then for the past year, I've been semi-retired. We moved from the Seattle area, moved to Illinois. There's not a lot of teaching opportunities around here. So I've been sitting at home, writing a lot, just trying to keep my creative juices flowing. Sure, you know, I can understand that. And that's how you kind of got wired into the Real Python, I guess. Yeah, yeah. I started, I was still doing volunteer teaching when Dan put out a call. He said he wanted writers. And I thought, hey, I could write this stuff. Why not? I started that was about two years ago. I've written, I know seven or eight articles so far. And I love doing that. I love doing the writing. I love doing the research that goes into it. All the learning, the new stuff, because, you know, I'm writing about some stuff that I know a little bit about, but not a lot. So I need to get up to speed really quickly. Cool. It sounds like you've been into games your whole career early on. And then now you're kind of getting into it with again with all your writing. Yeah, I started like, you know, like I said, I wanted to learn how to write games. Found out that it's, you know, they're really tough. They're not easy things to learn to do. I've started with games way back in the way back, but didn't do much with it. Okay. A couple years ago when I started teaching. One of the things that we did with the kids when we were teaching them how to write code, because they don't want to learn machine learning. That's not interesting to them. What's interesting to them is let's make these really cool, goofy little games. Yes. He's moving around on the screen. Yeah. Stuff they can control, share with their friends. Yeah. Exactly. You know, so we started working with them with Scratch and then moved to Python. That's when, okay. So how do you do all this stuff in Python? How do you make these things move? How do you... you know, Scratch and Snap kind of block languages have got a lot of that stuff built in. Python doesn't. So we had to figure out, how do you make sprites? How do you make them move? How do you move them around on the screen? How do you keep score? How do you handle collisions? Things like that. So it kind of brought it all back to me. And I decided, hey, I really like doing this. Let me see. I've got a couple of game ideas in mind. Let me see what I can do with those. Do you think that game programming is a good way for someone to learn programming in general? Yeah, I do. A lot of the basic ideas of computer science come into it in computer programming. You know, you need to have loops. You know, in order to keep the game going, you need to have conditionals so you can tell, you know, when, you know, when a game is over, when you've collected a coin or when you've hit a bad guy or when you've fallen off the edge of the world. You know, you need to know how to do how to do things, repeat them over and over again. So that leads you into, okay, maybe I write a function to do this, right? I want to have different kinds of enemies, maybe one of them flies, one of them walks, but other than that, they're both the same kind of thing. So, okay, now we start talking about classes and objects. And so it can lead you into object-oriented coding, yeah. So a lot of the basics are there. And you wind up learning a lot of the stuff without even knowing that you're doing it. You just kind of fall into it because, oh, I wanted to make my sprite guy. I wanted to make him run. So I needed to have this little loop that would animate the sprite. All of a sudden, you now you know how a loop works. So, yeah. So I was thinking that too when I was getting into converting your article on my game. And I said, that would be a good course to recreate, you know, as a video lesson. And I really found it fascinating how much you practice all of these game techniques, especially object-oriented stuff, as a person writing it. Think to yourself, okay, well, I don't want to have to rewrite all this code, and I want to be efficient, and like you said, like there can be two different types of enemies. They're both enemies. They might have similar, you know, attributes like health or something like that, but then they might vary from there. And then that you go into like, okay, this one has flying characteristics, and this one has ground-based characteristics, or what have you. And, and yeah, it's just such a great way to really practice all of those techniques. You're always wanting to make it more efficient because you want the game to be efficient also, you know, which is right, which is a big part of it, right? And even in that game, you know, you've got the enemies, you know, the one that's in the, the Py game article, you've got the enemies that are flying at you, and you've got clouds as well. And the clouds fly too, right? Now, it's not just, you can make a class out of out of just enemies, but enemies in clouds fly. That's their commonality. So it gets you to think in different terms, kind of outside the box, yeah. The clouds are just background, they don't really interact with anything, but they really behave just like those flying missiles do, you know, they travel from left to right. When they're off-screen, you need to get rid of them. So maybe there's a flying thing class, and you just need to differentiate between what's the thing that I can hit, the clouds, and what's the thing that I can't hit, the missiles. So it really gets you to kind of think outside the box, that yeah, the clouds are just background, they don't really interact with anything, but they really behave just like those flying missiles do, you know, they travel from left to right. When they're off-screen, you need to get rid of them. So maybe there's a flying thing class, and you just need to differentiate between what's the thing that I can hit, the clouds, and what's the thing that I can't hit, the missiles. So it really gets you to kind of think outside the box, that yeah, the clouds are just background, they don't really interact with anything, but they really behave just like those flying missiles do, you know, they travel from left to right. When they're off-screen, you need to get rid of them. So maybe there's a flying thing class, and you just need to differentiate between what's the thing that I can hit, the clouds, and what's the thing that I can't hit, the missiles",
    "031eQHFCXck": "Welcome to the Real Python Podcast. This is episode 3, and my name is Christopher Bailey, your host. This week, I talk with Brett Slatkin, the author of Effective Python. We talked about the revisions he made for the second edition of his book, updating it for the newest versions of Python 3, and who is the intended developer for the book.\n\nWe also talked about his work on Google App Engine and using Python at Google scale. There's a brief anecdote about working with Guido van Rossum, and we also talked about maintaining a large aging codebase. So let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. Interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey, Brett, welcome to the podcast. Thanks for having me on. I know it seems kind of redundant since you were just on Real Python and you're talking about your background. But could you tell us a little bit about how you got into programming?\n\nSure, yeah. I've been programming for a long time. I started around ten years old and had done some logo in elementary school and then ended up doing some Lego stuff. Finally, I got into C programming with C, and I was really lucky to have a lot of computers around in my life growing up. So I had access to that stuff, and I got to take advantage of it. From elementary school to junior high and then into high school and college, I just kept doing side projects and hacking on things. I took some classes at City College and eventually majored in Computer Engineering and did a lot more programming. So it's really just a long time in programming for very long time. I don't really remember a time I wasn't, and it's something I loved to do.\n\nCool. When did Python come into that?\n\nIt's kind of a funny story since Python is such a big part of my working life and life in general. I had come across the BitTorrent client in college, which was just kind of getting popular at the time. It was written in Python, and I was checking it out to see what the source code was like. I thought it was super ugly language. I really didn't like the look of it. I didn't like the dunder methods and all that kind of stuff. But I got to take a look at it. So a few years later, I ended up coming to Google for work. My intention was to be a C++ programmer in infrastructure, and I ended up being a Python programmer in infrastructure. So it kind of just worked itself out. My first day was, \"Hey, by the way, you're gonna work on this Python code base. Here's a book, and you know, go learn, and here are all the things you need to do.\" It was pretty overwhelming, but the good news was that the guy who wrote the book, Alex Martelli, who wrote Python in a Nutshell, including the latest, he was actually on the team. So they had a lot of great Python resources like him around to help me learn. So I was really lucky to be surrounded by great peers and mentors and have access to a lot of other great Python programmers who worked at Google who knew and understood the best practices.\n\nNice. You said you were working in infrastructure. What did that look like?\n\nGoogle has had a lot of computers for a long time. They still do. It's really hard to manage just one computer or two computers. It's not so bad, or even like a rack of 10 computers or 40 computers, depending on how dense it is. But once you get into thousands, tens of thousands, hundreds of thousands, or whatever the number is now, it just becomes really difficult to keep track of everything. Not only do you have to track inventory, but you need to be constantly doing physical repairs to the machines because maybe RAM only fails at a rate of 0.01%. I don't remember the number, but if you have a million machines or something like that, and it's that rate, then you have like this could be something daily. There's like thousands of machines every day that have RAM failing. So that's when people talk about scale. That's really what they mean. Oh, this is a scaling problem. It's like things when it's just at a lower scale, not a problem because it's so rare.\n\nYeah, I was working on a lot of tools to enable that to work at scale like the repairs process, reinstallation of machines, data center turn-ups, the cluster management tools that go into making modern cloud-type data centers possible. A lot of that was and continues to be in Python. Some crazy numbers that I don't even remember what it was, just the sheer number of machines being reinstalled per second at Google. That's like a number, you know, like machines being fixed and rebooted and reinstalled like a new copy of Linux because it was broken. There's like a dashboard there that you have this metric showing the amount of failures and the.\n\nI think it's changed a bunch since I used to work on it, but yeah, that's what it was. It's just this constant things breaking and dying and then having to be replaced. So the other thing was really cool about it was this combination of humans and machines. Like the machines, you try to automate as much as you possibly can, but you really do need physically leave someone to go in there and swap out parts or to move racks or whatever it is. So there was always a lot of human elements and even aux to that, that the software had to keep in mind, which I think is interesting, even though it's mostly back-end infrastructure type stuff. There still have to keep humans in mind as part of your design constraints and who you're trying to satisfy.\n\nTotally. As you bring it up, I'm thinking about, okay, is Python a great tool for doing that sort of infrastructure work?\n\nYeah, so it was. I think there's like a decision tree that I've written down somewhere, and it's kind of like, what language should I use for my projects? This is flame wars and bike sheds aside, right? I think that there's some simple things you can think about in order to make that decision. So for me, and I'm curious if you have any thoughts on this, like your view, but to me, like one of the first decisions is, is it a platform thing? So like if you're writing an iOS app, going with Swift is probably the right idea, right? And you know, you could try to do it with Python, but and you know, some people try to cross compile or transpile or other things like that, and it works sometimes, but same thing, Android, the number of boundaries that are gonna be less, right? Yeah, you kind of want to go with the flow with a lot of the platforms. So you know, same things like if you're making a game, maybe you want to use C# or C++ just because the platform SDKs are, you need to use that's what they're in.\n\nOkay, platform aside, then you get down to like these performance questions. And so to me, there's like really three kind of performance questions, which is like, there's latency, there's I/O, and there's kind of memory usage. And if you really do care a lot about latency performance, like if you can't afford a GC pause, then a language like C++, Rust, or one of these other kind of non-garbage collected languages that's super close to the metal, that's kind of the way you want to go because you can't afford even a real-time system that's managing an airplane or something like that. You just can't afford GC pauses. Okay, Python's a bad fit. Python's a bad fit. But for I/O bound, if you're purely I/O bound and you don't care a lot about CPU overhead or latency, then like Python's like an ideal language.\n\nOh, cool. So that's my view. And so like these systems for managing data centers are like perfect for Python because it's super flexible and you can be very effective. But it's a mostly an I/O bound problem. You've worked on a variety of different projects because I know it might be a long list. Maybe just describe like one of your favorite projects you've worked on at Google.\n\nSure. One of the most fun things I've done at Google, there was a project called Pub/Sub Hub Bub, which was over a decade now. That's what it is back in the day when RSS was a thing. You know, we were working on making RSS as fast as Twitter and feel very real time. So Brad Fitzpatrick and I built out this new protocol and the kind of hub, the relaying system that went with it. It was a ton of fun. It was written in Python on App Engine. It scaled to thousands of requests a second and millions of sites, tons of subscribers. It's still live today and actually being used by a lot of people. The infrastructure has been rewritten tons of different times, but our, sorry, Herman, we've rewritten and then like all the traffic has been migrated in multiple times, but it's still alive. But we had just a lot of fun getting off the ground and moving fast to get it working.\n\nYeah, I love Google Reader back in the day and using RSS. Yeah, I still have Flipboard and I play with it a bit, but I feel like it's a little hobbled a little bit. Yeah, trying to figure out like a good replacement for it. Yeah, I mean, NewsBlur was a great reader. It's still around as an RSS reader. I think that just in general, the ecosystem has continued to die. It's cool seeing Mastodon, you know, rise up and kind of fill some of the gap and at least in terms of personal updates. Yeah, I think that those times when Google Reader is still around or it's going to, I don't know if we'll ever have those times again. It was so special.\n\nThe guy does not newswire has done a new version, which is intriguing. Oh, cool. And has some nice uses there. But I was looking at your website and you've mentioned that you spend some time with a lobster, which I was not familiar with.\n\nYeah, it's just kind of an interesting site for learning news in the programming space.\n\nYeah, I mean, lobsters is a great site. If you feel that Hacker News is not technical anymore, which is how I felt about four years ago, it's a big instead that was when you shifted. Yeah, it's like maybe five years ago. Yeah, I think Hacker News is now like a weird, it's like, I don't know if you've ever seen the magazine Monocle, which is really interesting, but not a technical, yeah, you know, it's more of a lifestyle website than a technical website now. So there's still lots of technical content, don't get me wrong, but I just think that it's too hard to sift through it. So I really like lobsters for all the technical, so a lot of people that are saying, you know, I'm into development, but they're not truly, yeah, maybe it's shifted to be more focused on startups and startup culture, and business problems. So it's not, yeah, it's not that it's bad, it's just that it's different, and I wanted more technical content, more like Reddit programming or something like that. So tech lobsters, I think, feels a lot like Hacker News originally did to me.\n\nOh, cool. How did you start getting into writing books? You've now done two editions of Effective Python.\n\nYou know, I mean, I've always been a big fan of programming books, especially the Effective series. I've loved to blog about things, you know, for over a decade now, far longer. And then I was a TA a lot in school, so I do enjoy like education and helping people learn things. So I already had kind of a natural interest in it. I also really liked giving technical talks, both within Google and also outside at PyCon and other conferences. And so just kind of along the way, it just so happened that the publisher Pearson that publishes Effective C++, they actually reached out to me and said, \"Hey, we want to write a Python book. Do you want to do this?\" And I said, \"That's amazing because of course I do.\" And yeah, just kind of fell in my lap. I'm so lucky because if I had known they were looking, I would have totally tried to get the role. And it was, it just been thinking about writing a book on some kind of related topics anyway. So the stars aligned. I really got lucky there. So the first edition, you know, four or five years ago, the second edition just came out last fall. Just a real fun experience writing both of those. I could go on and on about that.\n\nYeah. So who's the intended developer for the Effective Python book?\n\nYeah. So I would say if you've read a beginner book and then you've done some coding projects, you know, you've scratched your own itch, you've written thousands or tens of thousands of lines of Python to the point where you've started to hurt in certain ways. Like, \"Oh man, like this is tough. Like, I don't know how to work through a class hierarchy or modules working with each other or I don't know how to collaborate with another person.\" I think you start feeling these natural limitations in your knowledge with Python once you actually start using the tool a lot. And that's like the perfect time to pick up Effective Python. I think if you just finished your beginner book and now you're like, \"Okay, I finished that. I'm going to keep reading. I'm going to keep learning.\" I would wait. I think you have to have written quite a bit of Python code to start really understanding the rationale. You're still so new. Yeah, I think it's worth taking some time to like use Python. So I'd say like read your beginner book, then go hack on things for a few months, and then pick up a book like Effective Python to kind of like hone your skills. It's also like the point of Effective Python is that you can jump around. So you're not supposed to read it straight through. So that's another thing that if you're not sure whether or not it's relevant to you, kind of look at the item titles and say, \"Oh yeah, I've hit that problem with dictionaries before. I wonder how I should solve that.\" So I think it's kind of the sweet spot where you can start looking for advice that's relevant to what you're currently doing or problems you're hitting. So that I'd say if you're not sure where you fit on that spectrum, go look at the list of items and see which of them actually speaks to you and your experience. If none of them do, then maybe write some more code.\n\nI was thinking about that. It's an interesting structure. I'm guessing that's the structure that was set up in the Effective series in general.\n\nYeah, that's like Scott Meyers. That was kind of his novel approach to programming education, essentially, was this structure of book. I think of it as like these topics that are sort of advice statements. Each one has like a heading of like, \"Know this. Prefer that over this. Avoid what's the benefit of writing in that style.\"\n\nSo Scott Meyers actually wrote a blog post called \"Effective Effective Books,\" where it's like an effective guide to writing an effective book, which is pretty funny.\n\nGreat. So I can send you a link to that. Essentially, it's like \"Take a stand.\" It's his advice, which is like, \"You should have an opinion.\" It's not enough to just describe what is available because if people want to know what's available, they can read the source code. They can read the developer documentation or the tutorial. What they want to know is the hard one from experience. Just because the feature exists doesn't mean you should use it. Yes, there's only one way to do in Python, perhaps, but ultimately there are many ways to do it. So what's the right way based on experience? Boom. So I think that's the main thing is trying to really say, exercise a scale of it. It's always do this, which is implied so you don't ever see the word \"always.\" Prefer this. Consider that. Avoid something or never, literally never do this. Yeah, there's also \"Know how to do X, Y, & Z,\" is kind of like just the more informational one. When it's like, \"Don't forget,\" like just an example of a kind of a small topic that you might have not realized, it's important to be aware of and keep this in your tool belt. Make sure that you are comfortable with this.\n\nCool. The first book came out in 2015, is that right?\n\nYeah.\n\nIn this rewrite, a lot of the changes in code at the time you were doing some in Python 3, but this book is almost entirely Python 3, hence the end of life with Python 2 in January, right? Were there sections that you were excited to rewrite in the new book?\n\nYeah. So the new book is entirely Python 3. There's no Python 2 in there at all. So that was great to shed that. That's a Python joke. So the, sorry. Yeah. I mean, I think the biggest thing is I had nothing on async/await in the original book. And I think a lot of people were excited about that in Python 3. There's a big focus of, we do have for a while. So I think that was something I was excited to do is to rip out a bunch of the old generator, send and throw behavior, the old way you still do coroutines in the original book. Item 40 was this whole game of life that I wrote using generator coroutines, and it's like my favorite part of the first book. And it's funny because now it's totally irrelevant because you should just use async functions instead. So that was a complete change in the advice and the tools available because of the evolution of Python. So that I was really excited to do that. The other ones I can think of were the typing module, the whole concept of gradual typing and types being added to Python was such a remote concept five years ago. I mean, people had talked about this and there were type annotations, a PEP for that a very long time ago, but it never had really come into its own. And then with mypy and the adoption of that by Dropbox and Guido's effort on that, it's really become something that's a key part of large-scale Python. In large-scale meaning like a lot of code, like millions and millions of lines and thousands and thousands of developers on the same codebase. So typing is interesting because it's cross-cutting. Typing is relevant to not just interfaces, but you know, correctness and testing. And so typing has its own element or item in the book. I think it's item 90, but it's also sprinkled into a few other of the items in there because it's like, oh, you can solve it this way or that way. And if you are using typing, then typing is",
    "KBCs5L4A-oM": "Welcome to the Real Python Podcast. This is episode 5. Have you wanted to explore using Python with electronics? Circuit Python is a great platform to get started with. This week, I talked with Thea Flowers. She has been creating several hardware projects that are based around Circuit Python. She talks about how she taught herself to design and prototype printed circuit boards, and I asked her about how someone would get started with Circuit Python. We also discuss several of her open-source projects. She was the conference co-chair for Pi Cascades, and I asked her about how people could get involved in volunteering for conferences. We also talked about building diversity in the community. This episode was recorded at an earlier date, and so much has changed in the last several weeks. I will ask Thea to come back for an update about her projects and about a recent honor bestowed upon her. So let's get started.\n\nMy name is Christopher Bailey, your host. The Real Python Podcast is a weekly conversation about using Python in the real world. Interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com. Hi Thea, welcome to the podcast.\n\nHi. Once you give us a little bit of your programming background?\n\nYes, it was a long time ago. I got into programming because of video games actually. When I was like 12 and 13, I wanted nothing more than to make video games. So I started programming in this tool called GameMaker, which is very different now than it was then. But back then, it was made by one guy and it had this drag-and-drop sort of interface for creating games. But you could also program in this scripting language called GameMaker Language or GML. I ended up learning GML and then eventually made a couple of little games. I'm never gonna show anybody ever.\n\nFrom there, I learned C and C++ and a couple of other languages, and that was all in high school basically. When I was graduating from high school, unfortunately, I didn't get a chance to go to college, so sort of weaseled my way into the industry, as I like to say. I ended up after failing to become a famous musician, I ended up working at a little web design firm in my hometown, writing PHP. Okay, yep. So that was fun. From there, I went to consulting and then eventually landed at Google. Yeah, we were talking a little bit just before we started. I just did a recording with Brett Slatkin, and you were mentioning a little bit about your indirect experience with him through App Engine.\n\nSo before I started at Google, I was working at a consultancy, and we did a lot of stuff with Google Cloud stuff at the time. We would migrate companies that are using like old-school Lotus Notes or Microsoft products or something like that over to Google Cloud. And inevitably, all these companies have some kind of like custom software that they would have that was built around their existing systems, be it Lotus Notes or whatever. And so I worked on this team who specialized in porting those apps or recreating these apps onto Google Cloud Platform. So I get to do a lot of App Engine and a lot of Python. I got heavily involved in the App Engine community because of that and definitely have experienced indirectly a lot of Brett Slatkin's work. Yeah. Did you approach Google or did they approach you?\n\nI approached Google. I was working in this consultancy and working a lot and not getting paid very much, and I also wanted to change from Atlanta, which was where I was living at the time. You know, I want to go out west because everyone wants to leave their hometown, right? Yes, I interviewed at a couple of companies, and Google was one on the top of the list. After ten interviews, well, I convinced them to hire me. So nice. So what are you working on currently at Google?\n\nSo I transferred to the Flutter team last year, the Flutter developer relations team. So at the moment, I am doing Flutter stuff. So I'm programming in Dart and creating examples and all kinds of cool stuff for Flutter. For those of you who don't know what Flutter is, it's a cross-platform UI toolkit which is really, really cool. It lets you design apps and run them on iOS, Android, and we have web coming very soon if not already launched. I don't know. I haven't been keeping up for the chat, and we have desktop support in beta or alpha or something like that, but it's coming, so it's pretty cool. Awesome.\n\nSo your Python background started with the App Engine. Oh, it actually started way before that. Oh, really? Okay. So, you know, I mentioned I wanted to make games in high school. That's what I did with my programming basically. Like any sort of programming I was doing was related to games. Okay. So at one point I wrote a 2D game engine, and I wanted a way to have it build every time that I made a commit, and Subversion just this is how old that is. Yeah, I was still using Subversion, get the just yet. I built a build bot using Python way back then. It was great, and I think it even used like because Jinja 2 didn't exist yet, right? So like I used like Cheeta templates. I think that was what it was. Oh, wow. I'm not familiar with that. It's old-school, so yeah, I used Python back when I was a teenager. Okay. You know, I did PHP for a while, and then yeah, when I moved to this consultancy, I was like they were all using Java at the time, which Java is a fine language or whatever, but it's not always a fine language for like rapid iteration and like responding quickly to customer demands when they change their mind. So I convinced them to try Python, and it worked out really well for me, I think.\n\nAnd since then, you've been along with getting your position at Google, you've been doing a lot of open-source projects and yeah, tell me about one of the ones you're working on right now. Yeah, absolutely. Yeah, I've kind of taken a step back from a lot of my sort of bigger open-source engagements. Okay, for my house really, like kind of you know turned down the knob on like how much I'm involved in a lot of different things that aren't projects that I sort of originated. Sure. So I'd say my biggest two open-source projects right now are NOx. So that's you know X, and NOx is very similar to Tox, but it uses Python as the configuration instead of any files. It seems to be doing well. I am NOT the only maintainer, which makes my life a lot easier. Yeah. Yeah, it's really great, and I never really expected that to get any adoption outside of like my personal projects and like the projects I had a say in at Google that but use it. But yeah, it's been going really well. The other like open-source thing that I'm kind of still sort of heavily involved in is conduct hotline com. Okay, which lets events sort of create a phone number that attendees can",
    "UyweT2Dy_WU": "Welcome to the Real Python Podcast. Are you interested in building REST APIs with Flask and SQLAlchemy? This week, I interviewed Doug Ferrell about his four-part Real Python series on Python REST APIs. We discussed the various Python tools and libraries used in the series, and Doug also shared his practices for continuous learning. Doug has worked in process control and embedded systems and has a long background in software development. He's currently a developer at Shutterfly and is developing tools for his internal customers. Currently, Doug is writing a book for Manning Publications called \"The Well-Grounded Python Developer.\" The book is currently available in early access. As always, don't forget to check out the show notes with links to all the different topics and tools that we discuss throughout the episode. Let's get started.\n\nMy name is Christopher Bailey, your host. The Real Python Podcast is a weekly conversation about using Python in the real world. Interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com. Hey Doug, welcome to the podcast.\n\nThank you very much, Chris. I'm glad to be here. Why don't you give us a little bit of your programming background?\n\nSure. I'm an older developer. I got started back in the 80s by buying my first personal computer, a RadioShack Color Computer, which I got hooked on and taught myself BASIC back then and a little bit of assembly language. I did some work at my senior of my degrees in physics. I have a BS in physics, but my senior project was building a very primitive CAT scanner with a Pascal-driven computer. I did some work as a process control engineer, working with gas pipelines and municipal water systems control systems. Then, I jumped over to the software development group and worked with Fortran and C. I've been a self-taught programmer ever since. I learned C++ and worked on embedded systems for a machine control company. I worked on a pick-and-place machine that assembles circuit boards with precision. I've always been interested in electronics and recently got into micro Python for control projects like building a polar graph based on the Goopie project. I also have a two-year degree in commercial art and have been getting back into painting.\n\nWow, that sounds like a lot of interesting projects you've worked on. Can you tell us about how you got into Python?\n\nAfter a few more jobs, I worked for a startup doing automation of hydraulic machinery and then worked for Grolier doing their online encyclopedia. I got into Python when they were considering moving towards Perl, but I discovered Python, which appealed to me because of its clean syntax and object-oriented nature. I've been working with Python for a long time now and it has become my go-to language for backend processing work.\n\nIt's great to hear about your journey into Python and how it has become a central part of your work. Can you tell us about the tools you used in your Python REST API series?\n\nI used Flask as the web server, SQLAlchemy to interface with the database, and Marshmallow for serialization. I also used Connexion for implementing the open API or Swagger to define the REST API. These tools helped me build a more sophisticated blogging application and demonstrate how to present a REST interface.\n\nIt's impressive to hear about the tools you used and how they helped you build a complex application. Can you tell us about your upcoming book, \"The Well-Grounded Python Developer\"?\n\nThe book is aimed at Python programmers who want to think like developers and tackle larger, more complex projects. It focuses on using Python tools to solve problems elegantly and beautifully. The goal is to help readers become more skilled craftsmen in their Python programming.\n\nThat sounds like a valuable resource for Python developers looking to level up their skills. Thank you for sharing your insights and experiences with us today, Doug.\n\nThank you, Chris. I really enjoyed our conversation.",
    "6tTI2Y8Xsd4": "Welcome to the Real Python Podcast. This is Episode 11. Have you wanted to get started with testing in Python? Maybe you feel a little nervous about diving in deeper than just confirming that your code runs. What are the tools needed and what would be the next steps to level up your Python testing? This week on the show, we have Anthony Shaw to discuss his article on the subject. Anthony is a member of the Real Python team and has written several articles for the site. We discussed getting started with the built-in Python features for testing and the advantages of a tool like Pytest. Anthony talks about his plugins for Pytest, and we touch on the next level of testing involving continuous integration. Anthony recently finished a talk for PyCon 2020 online titled \"Why is Python slow?\" He had the idea for the talk while working on his upcoming book about the C Python source code. \n\nI also want to give you an update on last week's episode with Kyle Stratus. Kyle was let go from his job due to the pandemic. Well, here's some good news. Kyle will be joining a Boston startup called Visit as a senior data engineer. Congratulations, Kyle! Alright, let's get started. \n\nMy name is Christopher Bailey, your host. The Real Python Podcast is a weekly conversation about using Python in the real world. Interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com. \n\nWelcome, Anthony. Hi, Chris. Great to be on the podcast. Yeah, thanks for joining me. I was just looking on Twitter and noticing that you were just wrapping up the details with your PyCon 2020 online talk. Yeah, I thought I managed to get it finished. So now that PyCon is virtual, we're not meeting face-to-face this year with everything going on. So, Python is virtual, and everyone who's been accepted to give a talk, they asked them to record their talk anyway, so they were comfortable to do so and then you submit it online, then it goes on to the YouTube channel. So, yeah, I've just finished putting mine pretty mine together. Have you done many of those recordings like that? I've done them for a couple of Pluralsight courses, okay, so I'm used to pre-scripted recording. But doing what was basically like it's supposed to be like a live presentation and recording and doing slides all at the same time was really too much for our brains to handle when I tried it. So I ended up really writing down what I was gonna say. I found that if I just tried to ad-lib it, then I just went off the rails. So yeah, I cheated a little bit, but I think I wasn't the only one to do that. No, I bet not. It's hard even just, you know, getting into the podcasting thing, just like, \"Okay, how am I gonna roll into these questions and remember what I'm gonna talk about?\" And kind of challenging to the creativity in a lot of ways. Yeah, if you're on stage, I think it's a bit different because you've kind of got this adrenaline kicking in, and if you make a mistake, you just keep going. Whereas like when you're recording, if you make a mistake, you can just stop and start again. But that's actually a negative because it just means that every time you make a mistake, you kick yourself and then you stop and restart, and it throws you off. Yeah, so it's actually quite challenging to do the whole thing end to end. Yeah, totally. \n\nWhat you talk about is the title of the talk is \"Why is Python slow?\" It's a pretty technical talk. It's really kind of looking into comparing Python's CPython specifically and their performance of CPython with certain benchmarks against other runtimes. In particular, I call that Node.js because I think it's quite similar, and JavaScript's quite a similar language to Python, sure. Not in terms of syntax, but in terms of like it's dynamically typed and interpreted. Cool! You've been spending a lot of time in the C side of Python lately with your book that you're working on. And I think I maybe saw a post that you have just finished it. Is that right? Yeah, I've just finished the book. The book is called \"C Python Internals,\" and it's a deep dive into the Python 3 interpreter, so the actual application that runs understands an executable your Python code. And it's been, yeah, it's been a year, I think, it has taken me to put the book together. So I'm really excited to have finished it. Oh, wow! And the talk kind of came off the back of that, actually, because I kind of discovered a few things while putting the book together related to perceptions about performance and realities about performance in Python. And I thought I could summarize those in 25 minutes and share it in a PyCon talk. That's cool. But the book is a lot more detailed. \n\nAlright, so who's the intended audience for that book? That's a really good question. It's very curious people, yeah, sure, so does the, I guess that's one of the audiences, the people who have a real passion for software engineering and like to understand how things work. So if you've been working with Python for a long time and there's kind of a curiosity like how does this thing actually work under the hood, yeah. But I appreciate that that's not a massive audience, you know, a lot of people are happy to just use it and don't care so much about how it works, or they don't have the time to dig into the details. So it's also got a lot of stuff in there for intermediate and advanced developers, teaching you about memory management, parallelism, and concurrency techniques you can use. Cool! Debugging, load profiling, benchmarking, a whole bunch of advanced techniques that the CPython project uses, and there's actually ways that you can reuse those in your own code as well. \n\nAlright, I have a couple of regular questions I ask, kind of weekly questions. I'm kind of a new one. Do you have any tricks or techniques or tips that kind of less known, you know, not necessarily hidden, but techniques that you use in Python? Yeah, sure. So one of my favorites, which I think I had referred to in the refactoring application but actually this trick I used a lot more in a project that I work on called Wiley, which is a code complexity analysis tool. Wiley looks at your code and says, oh, that module's super unmaintainable because it's got tons of nested loops and it's really complicated. So it kind of tells you that stuff as like a commit hook. So you can see if you've made a change, if it's made the code less maintainable or give you a warning. But in the code itself, I kind of built this data structure, and I was basically like creating a mapping type. \n\nOne of the other areas that you get into in your article is you talk a little bit about this concept of DRY, of, you know, don't repeat yourself. The idea with the DRY principle is that, yeah, you literally don't repeat yourself. You know, Python has lots of different ways to make your code a bit more functional. So you can split things up into functions, you can extract pieces of code. It also follows the single responsibility principle. So when you're testing, if you haven't followed these principles, that will actually make your testing harder. And that's kind of like a side effect. And it also is a bit of a code smell, which means that later down the line, if you want to refactor your code to have a new feature or like extend something or improve performance or something like that, all these principles become a lot more important further down the line. So don't repeat yourself idea is quite simple, which is that you know, don't have two classes or two parts of code which have more or less like the same block of code over. So, don't copy and paste code between segments. \n\nAlright, so let's move on to some more advanced things like being able to automate. How do you mean as far as like doing automation of your test? Is that something that you can do inside Pytest, or does that require additional tools? So, a kind of tool to help you run the tests, okay. Yes, but so there's a kind of problem I guess it's called a test Runner, and unit test and Pytest both have built-in test runners. Okay, once you write the tests, your tests are basically modules. So, you know, they're just Python files with classes and functions or just func. And in the Pytest example, when you run Pytest, it basically creates an application that discovers tests. Like the first stage is discovery, so you normally give it a path, like all my tests are in the folder called test, for example, and it will just go and look in that folder, find all the files that contain tests and find all the test functions within those files, and then queue them up and run them in sequence. So Pytest does that for you. You don't need to give it like an index or something; it will do test discovery for you. \n\nAnd if you're using an IDE or something like if you're using PyCharm, then it's got built-in unit test and Pytest support. Visual Studio Code can do that as well. And if you're using just like a plain text editor, then you can run either of those testing tools just on the console. So you could just run them on the console. So unit test, you just do Python -m unit test and then the folder that you want where your tests live, and Pytest you just do Pytest and the folder where your tests live. Okay, that's like the simplest way to get started, and it will just go and look in there, find what tests it can, and then run them and tell you whether or not they pass. \n\nAlright, like another level on top of that would be a tool like Tox. Can I guess it would be like if you're going to share this code and you're concerned about it running on different versions of Python? Yeah, so Tox is a tool that solves a couple of different problems. One is when you run unit tests or when you run Pytests, it's going to use the version of Python that you called it with. So if you've called it from a virtual environment, which you should be, it will use the version of Python that's in your virtual environment. So if it's 3.7, it'll test your code against 3.7, and if your tests use extra Python modules that you've installed into the virtual environment, you know, if you're using Django, for example, and you've got some Django extensions, then it's gonna use all those versions. If you wanted to, for example, like upgrade to Django 3, then you could go and create a whole new virtual environment. You could go and store all the new dependencies, copy all the code across, and then run the unit tests and see if they pass. But Tox basically gives you a way of automating that. So you pip install Tox, and then you run Tox. Tox QuickStart on the command line, and it will just ask you a couple of questions, and then it creates this configuration file, which you can keep it simple as you want, which is just saying, \"I want to run this command,\" which is normally like Pytest or Python -m unit test, so like run my tests. But Tox will actually create the virtual environments automatically. So it creates like a subfolder called Tox, and it goes and creates any number of virtual environments. It creates virtual environments, installs the dependencies, runs the tests, gives you the output, and then once it's finished, it tells you whether or not they passed. \n\nGreat, because I think of that with Django like you mentioned is now moving to version 3. It seems like such a rapid change, you know, like it seemed like Django was hovering in the ones for so long, and then just in the last like two years it's like, okay, version 2, version 3. I could see that trying to stay on top of those types of things could be very useful. Definitely, yeah, especially with extensions. If you're using a lot of Django extensions and you've wanted to upgrade to Python, not Python 3, Django 3, you'll probably find that some of those extensions are not compatible. This week, I want to shine a spotlight on a Real Python video course. It's about a topic most people think they already know. It's titled \"The Python Print Function: Go Beyond the Basics.\" In the course, Christopher Trudeau takes you on a journey beyond the fundamentals and shows off features like string formatting, pretty print, the parameters of sep and end, and flush, creating an animation with print, building more advanced user interfaces in your terminal, character encodings, escape sequences, printing to file streams, and debugging. I think it's a worthy investment of your time to learn a little bit more about a feature you use so often. \n\nWhat's something that you're excited about in the world of Python? Again, it could be like an event, a package, a coding tool, or hardware. Because I've been researching Python 3.9 a lot for the book, so 3.9 will be coming out later this year. There's a new experimental feature in 3.9 called sub interpreters, which, if you've ever used the multiprocessing package in Python, it's in the standard library. Multiprocessing is kind of like a simple way of starting multiple Pythons, so actually start like multiple PIs and processes, and you can give it like a queue of tasks. So if you've got something that's really CPU-intensive, Python will share that task amongst multiple cores or multiple CPUs. Out of the box, you have to kind of like schedule them on different Python processes, and the way to do that at the moment is to use like a third-party package to do that or to use the multiprocessing package. \n\nAnd if you're using multiprocessing, you can define a function, just like your worker function. You can define like a set of inputs, like a queue or something. And then you can say multiprocessing pool. You can give it a pool of processes, and it will spawn the placement processes and give them the data and give them the function to run. And then it'll get the results and give it all back to you. So it's a really nice way of doing parallel execution of stuff that's like really CPU-intensive, and it will split that stuff against all the cores on your machine. The big downside with multiprocessing is that it starts a separate Python process, which has quite a big overhead. And if you want to share data between the processes while it's running, it's quite tricky to do that. You've kind of got to use the pickled module, which is not super efficient and it's quite slow. So there's a new experimental feature coming in 3.9 called sub interpreters, which kind of like a lighter-weight version of doing that challenge. \n\nAlright, let's move on to one of the regular questions that I ask, which is, what's something you thought you knew about Python, but it turned out you were wrong about it? So this is, I guess the first almost. Python was in a tool, which probably doesn't even exist anymore, for making it was a map editor for Quake and Half-Life, the games. So this is already quite old and the map editor actually used Python too, like for doing a map rendering or something. I'm not really sure, but if that was the first time I even saw the word Python and using the map editor and it had the old Python logo, like the smiley snake, and so I probably like Python more naturally than I thought Python was a scripting tool like Perl or bash for doing those types of scripts. So, it's only really kind of one is you got to use pipes and later on I was like, \"Oh, you can actually use it for like all this other stuff.\" \n\nI want to thank Anthony Shaw for being my guest this week and I want to thank you for listening to the Real Python Podcast. Make sure you subscribe to the podcast in your favorite player, and if you like the show, leave us a five-star rating and a review. You can find show notes with links to all the topics we spoke about inside your podcast player or at realpython.com/podcast. And while you",
    "VLrc929JaOg": "Welcome to the Real Python Podcast. This is episode 12. Do you want to get started with web scraping using Python? Are you concerned about the potential legal implications? What are the tools that are required and what are some of the best practices? This week on the show, we have Kimberly Vessel to discuss her excellent tutorial created for PyCon 2020 online titled \"It's Officially Legal, So Let's Scrape the Web.\" \n\nWe discussed getting started with web scraping and cover tools and techniques. Kimberly gives advice on finding elements inside of the HTML and techniques for cleaning your data. She also notes a recent change to the legal landscape regarding scraping the web. \n\nKimberly is a senior data scientist at Metis Data Science Bootcamp in New York City. She also holds a PhD in Applied Mathematics. We talked a bit about her switch from academia to data science and discussed her passion for data storytelling and visualizations. \n\nMy name is Christopher Bailey, your host. The Real Python Podcast is a weekly conversation about using Python in the real world. Interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com. \n\nHi Kimberly, welcome to the podcast. \n\nKimberly: Hi, thanks for having me. \n\nChristopher: Yeah, so I wanted to get a little background on your bootcamp. Is the name Metis, is that right? \n\nKimberly: Yes, I teach full-time at an immersive boot camp called Metis, where we teach data science. It is 12 weeks long, and the students do five separate individual projects throughout the course. \n\nChristopher: Do you guys steer them in a particular direction for the projects? \n\nKimberly: Yes, the projects have themes. The first one is exploratory data analysis, the second one regression, and then we have classification and NLP. The final project is totally up to them. \n\nChristopher: Could you go into what NLP is a little bit? I think we're going to talk about that more as we go into web scraping. \n\nKimberly: NLP is natural language processing, where you convert text data into numbers to be analyzed. \n\nChristopher: Part of why I wanted you to come on the podcast was to talk a little bit about the PyCon tutorial that you did as a jumping-off point for our conversation about web scraping. \n\nKimberly: Yes, the title of the tutorial, \"It's Officially Legal, So Let's Scrape the Web,\" was inspired by a recent case, Haiku Labs versus LinkedIn, which provided clarity on web scraping legality. \n\nChristopher: What are good projects for people to look at with doing web scraping, and reasons for them to approach this topic?\n\nKimberly: I think any project that interests them. There is a wealth of information on the web, from sports data to dollar figures about apartment rentals to text data for NLP projects. Web scraping empowers you to access all this information in an automated way.\n\nChristopher: What tools do you use for web scraping?\n\nKimberly: In my tutorial, I use requests to get the HTML from the internet and then BeautifulSoup for parsing the information.\n\nChristopher: What techniques do you use for finding elements on a page?\n\nKimberly: I look for unique attributes like IDs or classes to locate specific items. If that doesn't work, I navigate the DOM to find elements by their position on the page.\n\nChristopher: How much HTML knowledge do you need to dive into web scraping?\n\nKimberly: You don't need to be an HTML expert, but having foundational knowledge helps in identifying elements on a page.\n\nChristopher: How do you clean the data extracted from web scraping?\n\nKimberly: I often use regex for cleaning data, but Python's string methods like replace can also be useful for removing unwanted characters.\n\nChristopher: Are there other tools like Selenium that expand on web scraping?\n\nKimberly: Yes, Scrapy is a popular package for designing web scraping projects, and it offers cloud services for scraping at scale.\n\nChristopher: What are you excited about in Python?\n\nKimberly: I'm excited about the upcoming PyOhio event and exploring new NLP packages for natural language processing projects.\n\nChristopher: What do you want to learn next in Python?\n\nKimberly: I want to dive deeper into data visualization, especially tools like GeoPandas for mapping data.\n\nChristopher: Do you have any hidden Python tips or tricks to share?\n\nKimberly: One lesser-known function in Pandas is `transform`, which can be useful for aggregating data by group while maintaining the same dimensions.\n\nChristopher: Thank you for being on the podcast, Kimberly.\n\nKimberly: Thank you for having me.",
    "xDVIbvcgPP0": "Welcome to the Real Python Podcast. This is Episode 13. If you want to work with PDFs in Python, maybe you want to extract text, merge and concatenate files, or even create PDFs from scratch. Are you interested in building hardware projects using a Raspberry Pi? This week on the show, we have David Amos from the Real Python team to discuss his recent article on working with PDFs. David also brings a few other articles from the wider Python community for us to discuss. David searches for the latest Python news, links, and articles to produce PyCoders Weekly with Dan Bader. PyCoders Weekly is a free email newsletter for those interested in Python development.\n\nAlong with David's article on PDFs, we discussed another recent Real Python article on building physical projects with the Raspberry Pi. We also discuss articles from the community about the PEPs of Python 3.9. Why you should stop using datetime.now, and various dependency tools in Python.\n\nAlright, let's get started. My name is Christopher Bailey, your host. The Real Python Podcast is a weekly conversation about using Python in the real world. Interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com. Hey David, welcome to the podcast.\n\nHey, thanks for having me.\n\nYeah, so we're doing something slightly different this week. I brought David on board. It's a bit of an experiment and we're gonna try this out. We're also gonna continue to ask the weekly questions at the end. So like I said, we're just gonna alternate between these topics and kind of go in-depth. And of course, all this stuff is gonna be heavily connected through lots of show notes and links. Please check that stuff out, either in your podcast player or again at realpython.com/podcast. David, what's your first topic?\n\nThe first one I've got is an article written by Brett Cannon called \"The Many Ways to Pass Code to Python from the Terminal.\" Brett Cannon, for those that don't know who he is, he works for Microsoft and he's the manager for the distributed development team of the Python extension for Visual Studio Code. So if you use Python and VS Code, he's one of the managers for that project. He's also a member of the Python steering council. He put together this article called \"The Many Ways to Pass Code to Python from the Terminal.\" So most people are probably familiar with running a .py file by just typing Python and then the path to that file. That's a pretty common way of running a Python program. But there's lots of other ways to pass code to Python from the terminal, some of which I had never even heard of before. The first one he mentions is piping from standard in, which you can do if you have, for example, you can echo something on the UNIX terminal, pipe that into a Python command, and it'll execute whatever you echo. You can also redirect a file into Python using a little less than symbol or the left carat. So these are kind of your standard UNIX-type ways of shuffling data around on the terminal. Another one, and this one is actually pretty useful, is running Python with the -C flag, which allows you to pass a string into Python and have it just run that string. So if you do Python -C and then in quotes, print \"hi\", it'll run that print function and print \"hi\" on the terminal. You can do this if you need to check just a couple of lines of code without having to actually launch the REPL. Using the -m flag to run a package, and I think some people, this is going to be a little bit less familiar than using Python with a file path, but I think it's relatively common these days. If a lot of people that use the venv package from the standard library run that as a package. You do the Python -m to create your virtual environment. So this is how if you have a package that specifies a dunder main.py file, then it'll run that package. A couple of them that I thought were kind of surprising and I'd never heard of before is you can actually run a directory, which I guess in retrospect it's sort of like running a package kind of. But I'd never really thought of it that way. So if you just have a directory that has a dunder main.py, you can run that directory as if it were a package. But the one that was really surprising to me is executing a zip file. This is something I had no idea that you could do and had never even thought about it. But if you have a zip file that contains a dunder main.py, then you can point Python at that and I guess it will decompress that and run whatever is in there. That's very cool. Another article I want to mention is the PEPs of Python 3.9 by Jake Edge at lwn.net. Python 3.9, the beta release is already out. I think a couple of weeks ago now. So it's going into what's going on with the PEPs that are in there. The first one he goes into is PEP 616, which is about string methods that can remove prefixes and suffixes. You might think of like the existing methods that can allow you to remove strip things from the beginning. Our strip and L strip. The problem with them is that they remove all the characters that you include in there. They're not specifically like what you'd set up as a prefix or a suffix at the end of a string. And so this is being much more specific and having done a real deep dive on string methods, I could see how these could be added and could be useful in certain circumstances. For sure, yeah, get something a little more specific and cause maybe a little less confusion or errors. The next one is actually right next in order. PEP 617 is about a new PEG parser for CPython. And it was proposed by Guido van Rossum himself and a couple others. Python, originally developed by Guido 30 odd years ago, is currently using an LL1 parser and parses things from left to right and left most derivation. It kind of just goes through, grab each individual token and kind of combine them together. And the PEG parser is parsing expression grammar. And so one of the reasons for, I guess, he worked with the LL originally had to do with, I guess, memory and the limits of computers and memory. If you even go back 20 years ago, it's pretty drastic compared today. And computers have so much more of that memory now, even Raspberry Pi, something I'll talk about later, come with incredible amounts of memory. And we're not quite needing to do the parsing quite the same way. But anyway, it kind of goes into that. And Guido has a separate series of articles on Medium about PEG parsers in case you're interested in learning a little more about what the proposal is. And I think the proposal actually talks about it having not only the LL1 parser, but the PEG parser kind of both running in 3.9, which it may then think the goal is to have it replaced in 3.10 anyway. So his whole idea is going to allow for a lot more flexibility in the evolution of the language and how the language is parsed. So getting some deep computer science there. Yeah, from what I understand about it, there's some parts of the language that require some real kind of hacky type things that they had to do to get them to parse correctly or to be understood correctly. And that this is going to alleviate some of that and allow them to write, I guess, some cleaner code around those sections and just handle it more naturally, which I think is always a good thing.\n\nAbsolutely. And it looks like there's possibly a little bit of a performance boost from it, like around the order of like 10%. That's good. The next one is PEP 615, which is support for the IANA time zone database to be built into the standard library. And IANA, the Internet Assigned Numbers Authority, standard that's out there. Before that, you would have to kind of usually import additional time zone packages to help with that. That'll be kind of nice to have that built in.\n\nThe article touches on PEP 593, which kind of goes a little deeper into type hints with flexible function and variable annotations. And the last one I want to touch on is just PEP 602, which I spoke briefly about with Lucas Langa when he was on episode 7. He's the current release manager for Python 3.8 and 3.9. He mentioned how one of the big changes was for them to switch over to this yearly release standard, this annual release cycle for Python compared to an 18-month cycle. And he was talking that he was thinking back in episode 7 that he was going to be the release manager for Python 3.10. And actually, they have found a different release manager. His name is Pablo Galindo Salgado. He's going to be the next release manager, which once the first beta comes out, that's when they actually start looking at 3.10 and so we start working on that soon.\n\nWhat's your next article?\n\nWell, actually, I want to clarify something real quick I just realized about the PEG parser. Yeah, go ahead. So it's not that there's necessarily a 10% boost in performance, it's that the performance is within 10% of the existing parser. So it could be okay, it's like a plus or minus there. So sure, okay. So yeah, which shouldn't be a big hit one way or the other. Hopefully, exactly. Good. Okay. Thanks for clarifying. Yeah, I just happened to notice that as I was reading through this. Well, the next thing I've got is perhaps a little biased, but it's one of my own that we just released on realpython.com weeks ago now. Or I don't know the exact date, but it's creating and modifying PDF files in Python. It's obviously about PDF files. It's a thorough introduction to working with PDFs in Python, but it's not an exhaustive reference. So it's really geared towards newcomers to the Python language and it's people who want to find practical uses for Python in the real world. And some of the things that it covers are how to read text from a PDF, how to extract text from a PDF into a text file, how to concatenate files, which is where you take all the pages from one PDF and then all the pages from a second PDF and just sort of tack those pages on from the second one in order and place. And then also how to merge files. So if you have two PDFs and you want to maybe insert the pages from one PDF in the middle of another one, that's what would be merging those two files. We also talked about how to crop pages, rotate pages, encrypt and decrypt PDF files with passwords, and also get into a bit of creating PDF files using the report lab package. Oh, nice, which is a popular third-party package for creating PDFs programmatically with Python. Yeah, I've been interested in that report lab tool. I was working on a project for this environmental science company and we were constantly trying to make tools for them that were kind of paperless, if you will. Yeah, and so I was using what I would argue is still one of the most clunky things that Adobe's ever created, which is Adobe Acrobat. In some ways, I think creating PDFs programmatically can be more consistent and more straightforward. So I'm intrigued to read more about it there. Yeah, so report lab is a very powerful package. You can do a lot with it. Because of its power, it's actually they can be kind of complex. So this is a very gentle introduction to getting started with that, but it doesn't really touch on a lot of the more powerful features in report lab. So it's just kind of a whet your appetite a little bit, kind of show you explain some of the basics of the different things that are needed there to create PDFs and then this new set you up to take a deep dive.\n\nYeah, I've been interested in that report lab tool. I was working on a project for this environmental science company and we were constantly trying to make tools for them that were kind of paperless. Yeah, and so I was using what I would argue is still one of the most clunky things that Adobe's ever created, which is Adobe Acrobat. In some ways, I think creating PDFs programmatically can be more consistent and more straightforward. So I'm intrigued to read more about it there.\n\nYeah, so report lab is a very powerful package. You can do a lot with it because of its power. It's actually, it can be kind of complex. So this is a very gentle introduction to getting started with that, but it doesn't really touch on a lot of the more powerful features in report lab. So it's just kind of a whet your appetite a little bit, kind of show you, explain some of the basics of the different things that are needed there to create PDFs and then this new set you up to take a deep dive.\n\nYeah, I've been interested in that report lab tool. I was working on a project for this environmental science company and we were constantly trying to make tools for them that were kind of paperless. Yeah, and so I was using what I would argue is still one of the most clunky things that Adobe's ever created, which is Adobe Acrobat. In some ways, I think creating PDFs programmatically can be more consistent and more straightforward. So I'm intrigued to read more about it there.\n\nYeah, so report lab is a very powerful package. You can do a lot with it because of its power. It's actually, it can be kind of complex. So this is a very gentle introduction to getting started with that, but it doesn't really touch on a lot of the more powerful features in report lab. So it's just kind of a whet your appetite a little bit, kind of show you, explain some of the basics of the different things that are needed there to create PDFs and then this new set you up to take a deep dive.\n\nYeah, I've been interested in that report lab tool. I was working on a project for this environmental science company and we were constantly trying to make tools for them that were kind of paperless. Yeah, and so I was using what I would argue is still one of the most clunky things that Adobe's ever created, which is Adobe Acrobat. In some ways, I think creating PDFs programmatically can be more consistent and more straightforward. So I'm intrigued to read more about it there.\n\nYeah, so report lab is a very powerful package. You can do a lot with it because of its power. It's actually, it can be kind of complex. So this is a very gentle introduction to getting started with that, but it doesn't really touch on a lot of the more powerful features in report lab. So it's just kind of a whet your appetite a little bit, kind of show you, explain some of the basics of the different things that are needed there to create PDFs and then this new set you up to take a deep dive. \n\nYeah, I've been interested in that report lab tool. I was working on a project for this environmental science company and we were constantly trying to make tools for them that were kind of paperless. Yeah, and so I was using what I would argue is still one of the most clunky things that Adobe's ever created, which is Adobe Acrobat. In some ways, I think creating PDFs programmatically can be more consistent and more straightforward. So I'm intrigued to read more about it there. \n\nYeah, so report lab is a very powerful package. You can do a lot with it because of its power. It's actually, it can be kind of complex. So this is a very gentle introduction to getting started with that, but it doesn't really touch on a lot of the more powerful features in report lab. So it's just kind of a whet your appetite a little bit, kind of show you, explain some of the basics of the different things that are needed there to create PDFs and then this new set you up to take a deep dive. \n\nYeah, I've been interested in that report lab tool. I was working on a project for this environmental science company and we were constantly trying to make tools for them that were kind of paperless. Yeah, and so I was using what I would argue is still one of the most clunky things that Adobe's ever created, which is Adobe Acrobat. In some ways, I think creating PDFs programmatically can be more consistent and more straightforward. So I'm intrigued to read more about it there. \n\nYeah, so report lab is a very powerful package. You can do a lot with it because of its power. It's actually, it can be kind of complex. So this is a very gentle introduction to getting started with that, but it doesn't really touch on a lot of the more powerful features in report lab. So it's just kind of a whet your appetite a little bit, kind of show you, explain some of the basics of the different things that are needed there to create PDFs and then this new set you up to take a deep dive. \n\nYeah, I've been interested in that report lab tool. I was working on a project for this environmental science company and we were constantly trying to make tools for them that were kind of paperless. Yeah, and so I was using what I would argue is still one of the most clunky things that Adobe's ever created, which is Adobe Acrobat. In some ways, I think creating PDFs programmatically can be more consistent and more straightforward. So I'm intrigued to read more about it there. \n\nYeah, so report lab is a very powerful package. You can do a lot with it because of its power. It's actually, it can be kind of complex. So this is a very gentle introduction to getting started with that, but it doesn't really touch on a lot of the more powerful features in report lab. So it's just kind of a whet your appetite a little bit, kind of show you, explain some of the basics of the different things that are needed there to create PDFs and then this new set you up to take a deep dive. \n\nYeah, I've been interested in that report lab tool. I was working on a project for this environmental science company and we were constantly trying to make tools for them that were kind of paperless. Yeah, and so I was using what I would argue is still one of the most clunky things that Adobe's ever created, which is Adobe Acrobat. In some ways, I think creating PDFs programmatically can be more consistent and more straightforward. So I'm intrigued to read more about it there. \n\nYeah, so report lab is a very powerful package. You can do a lot with it because of its power. It's actually, it can be kind of complex. So this is a very gentle introduction to getting started with that, but it doesn't really touch on a lot of the more powerful features in report lab. So it's just kind of a whet your appetite a little bit, kind of show you, explain some of the basics of the different things that are needed there to create PDFs and then this new set you up to take a deep dive. \n\nYeah, I've been interested in that report lab tool.",
    "amHbhsBLcIo": "Welcome to the Real Python Podcast. This is Episode 14. Would you like to run your Python code in the cloud without having to become an infrastructure engineer? Do you want to have Python functions that run when triggered by specific events? This week on the show, we have Anthony Chiu to discuss serverless computing and running Python functions in the cloud. Anthony is a program manager for Microsoft's Azure Functions. We discuss the advantages of serverless computing over virtual machines, containers, and other infrastructure options for running your Python code in the cloud. Anthony also talks about the types of projects suited for this type of platform, including data science, machine learning, and creating APIs.\n\nMy name is Christopher Bailey, your host. The Real Python Podcast is a weekly conversation about using Python in the real world. Interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with the community of experts at realpython.com.\n\nHey, Anthony. I want to welcome you to the podcast. Thanks, nice to be here. I know all the stuff with Microsoft, the Build conference just kind of ended. Were some of the things that you were involved in there? Yeah, I was involved in a few talks. Thankfully, I wasn't the main presenter, so my main goal was to be there to read out audience questions. One of the cool things that we did was we ran it for 48 hours straight and every session we ran them three times in different time zones. So we were able to interact with different people around the world. I'm not sure if we published the number of people that attended, but it was huge. It was really cool because typically we only get about 5 or 6,000 people out to the Build conference. It's our smaller developer conference, but being online, we just opened up the doors and a lot of people came. Yeah, nice. They got to see the inside of our house and stuff like that.\n\nWhat is it that you do currently for Microsoft? I'm a program manager at Microsoft on our serverless computing platform, Azure Functions. That's kind of partly why I wanted to have you on here, to talk about serverless computing and how that could be useful for people looking to do Python in that space. Maybe we should start a little bit of background and talk about what serverless computing is. So serverless computing, at its core, I guess there's three things that we look at. One, as the name sort of implies, you kind of don't think about the servers. Obviously, somewhere there is a data center, there is a server, but we try to abstract that away from you as much as possible so you don't think about the server at all. And then the other part is you focus on just writing the code that is triggered whenever an event happens. So you write this code that only has business logic because the platform itself is actually listening for events and responding to events and then triggering your code. If you kind of think about a typical Django or Flask application, you sort of have to set up that application, a lot of boilerplate, and then you get to write that code that you want to write for your business logic. Right, the interesting part is that you trigger off of HTTP, but for us, not before. A lot of serverless platforms, you can respond to other events as well, like things appearing in a queue, or some object putting and preparing an object storage. Okay, so somebody could be dropping files somewhere, yeah, things appearing in databases, those can all kind of trigger a function to run. So yes, there are a couple of things, and another thing is because you don't think about the servers at all, there is sort of like, you know, it kind of feels like you have infinite scale, that whenever you have one event running or maybe you have like all of a sudden you have like a hundred events or thousand events. More coming in at the same time, we make sure that there's enough infrastructure there to spin out as many copies of your functions as you need to respond to these events. And then when nothing's happening, we actually scale you all the way down. And then at least me to the last part of serverless, which is you typically pay by paper only what you use. Okay, so that within the function that we'll just be doing your function execution. So that would be how much memory and CPU your function uses while he's running and how long it ran for. Okay, and it's literally like fractions and fractions of a penny for every execution. And I think like we give you a million executions for free every month, and a lot of the other platforms do that as well, so you can get a lot of stuff done for basically free on these server platforms. Cool. So again, kind of going back a little bit to think about, you know, the differences in the common setup that someone might think about for cloud computing several years ago or even, you know, depending on what you're trying to do, would be the idea of a virtual machine and picking out, you know, a particular amount of RAM that the thing needs, an operating system that it needs, and then maybe even you're having like, has to have some sort of storage on board it for the virtual machine, and then like the next level of that would be moving into something like, like Docker or something, right? Yeah. And then in that case, you're, you, I had Tonya Hollerad on and we were talking a little bit about the advantages there and sort of the portability of code, developing locally and being able to then take this code and put it up in the cloud and have it work there or move it around at different places. And you're not having to worry about all the management of the machine. This is even going up another level of abstraction, sort of right? Yep. Exactly. Yeah. So you're not even kind of worrying about what your application itself is made of, of like whether it's, you know, like what web framework you're using. You're just writing that piece of code and then you're just relying on the cloud provider to run that piece of code when you told it that it needs to be run. Okay. So it's gonna figure out what it's going to need to respond to the code that you've written. Yeah. Absolutely. So yeah. Like I already mentioned a few of the events that can trigger functions. So you can even have a timer running. So you can say, hey, trigger my function every five minutes. And like the platform is going to just wake your function up, right? And kind of call it every five minutes. And you get and you go gets to run. So your code can be just a couple lines of code doing something simple because but because it's just code, you can bring in any packages that you want and actually do some pretty complex stuff with it if you wanted to. Nice. And I was noticing I spoke to Tonya actually last week a little bit before having this conversation with you. And she had done a talk on IICON 2020, a sponsored Microsoft talk talking a little bit about doing Azure functions there and gave a demonstration. And in her case, I think it was an example where it was a timer and it was a triggering a particular event to go out to the web, grab this information, pull the data in, do the data processing and all that stuff. But what I was impressed with is that setting it all up, she was doing most of it just inside of VS Code and using the not only the Python plugin for VS Code, but also there's an Azure Functions thing that you can add to it. Is that right? Yep. So yes, our primary development platform or like the development tool that we kind of support is VS Code. So we have an extension there that allows you to just start up a magic functions application on your local computer. One thing we haven't talked about yet is that Azure Functions itself is all open source. So what that allows us to do is basically ship you that same runtime that we run in the cloud to your machine so that you're actually running the same runtime locally on your machine and you're able to attach a debugger to your code and actually step through your app as if it was running in the cloud. Okay. Yeah. And if you wanted to, you can also deploy it to the cloud from there as well, testing it and going through everything. So what I was wondering about is, so in that particular case with this idea of it being triggered basically, there's nothing really running at all except for just things sort of a secretly waiting for events to happen, right? Yeah. So we have some stuff running in the platform that's actually listening for these events so that if your application hasn't been running for a while, we actually turn it all off. But then we still have things in our platform, something we call the scale controller that actually listens to all these events on behalf of your application. Okay, so that when, you know, like a month later your poison's like this folder that you're America that you're observing in, in blob storage finally gets a file appearing in there and we will notice that and then wake up your app and then call it. And then your application will go and pick up the file, do what it needs to do with it. And then if nothing happens for another month, we'll just kind of shut you down for another month until something happens again, okay.\n\nYou may use a term there that I see kind of thrown around a lot and it's kind of a funny term and I just kind of wanted maybe you could dive a little deeper into it, blob storage, yeah. So it's this object storage. So typically people putting files into a very highly scalable kind of a container that's in the cloud. Typically you can access it using HTTP, but there's other ways of accessing it as well. You can potentially mount it as a file share, okay, but is this a fancy term for a giant hard drive in the cloud that I don't want to deal with, okay. So you can use it the one that I'm familiar with is S3, is it similar to that in some ways, yep. So blob storage is basically Azure's version of S3, yes, okay. And so you can like you said, you can have it so that like, I think of like Django apps or Flask apps that potentially could store rarely use files or files that are a little bit larger than something you want to put inside of a database and put them in that kind of storage. But on top of that, you could use this in a different way where it can be kind of a shared storage between, well, I think of virtual machines sharing the storage, but in this case, it could be these functions that are checking in that blob storage and using resources from it. Is that right? You could share it, yeah, absolutely. You already mentioned that you can store kind of like application level data or user level data into blob storage, but internally within Azure Functions, we also use blob storage to store your code. So it kind of stores is a zip file that we mount directly into a function when it's executing. Okay, so that's kind of how we can kind of spin you out into like a hundred instances and they're all getting the same code. Okay, yeah, and then another thing that, especially for Python, that's useful is that you can actually mount like an arbitrary folder from blob storage into your function app. So what people have, what we've seen people do, something that we recommend people do in Python functions, because we're doing a lot of machine learning, is that typically if you need to kind of do any inference with the machine learning model, it would ship that model along with the application. So that makes your application code, your artifact kind of huge. And then every time you iterate on a new version of that machine learning model, you have to deploy a whole application again. That's not necessarily a great thing to do. Like it's totally doable and I've seen a lot of people be successful with that with a really kind of good CI/CD pipeline. But if you're just like, for instance, you have different teams doing writing the actual code that runs, like kind of like that serverless would sort of serve this function itself, like actually like writing the application code, but maybe you have another team of data scientists, they're actually iterating on these models. You might actually want these things at the point differently or separately, okay. And that's where like being able to mount a folder from blob storage into your function app is really useful because whenever the machine learning model needs to be updated, you can just update it in that folder, potentially yourself upload a new one. So you don't have to re-upload your function, maybe just reconfigure it a little bit, just pass it a new value, and there's using the new model. So it's really useful that way. So you know that we've agreed to pull a gap. Okay, it kind of brings up two thoughts I have, two kind of questions I have. Has Azure Functions always been friendly with Python errs? That's something that's kind of new, it's fairly new, new as in the last year or so. It became generally available within the last six or nine months, so yeah, it is fairly new. Functions, so the other languages that we support are, for Microsoft, we support C#, JavaScript, Java, and PowerShell, for a lot of automation scenarios. We also have another feature called custom handlers that allows you to bring your own language runtime to functions as well. So Python is one of the ones that we added fairly recently, and because of the",
    "XVw9qPhBcyg": "Welcome to the Real Python Podcast. This is Episode 15. Have you wanted to learn regular expressions in Python but don't know where to start? Or maybe you've stumbled into the dreaded pink setting with copy warning in pandas. This week on the show, David Amos returns from the Real Python team to discuss a two-part series on regex and Python. We also talked about another article about views versus copies in pandas and how to avoid that annoying setting with copy warning. David also brings a few other articles and projects from the wider Python community for us to discuss.\n\nEvery week, David searches for the latest Python news, links, and articles to produce \"PyCoder's Weekly\" with Dan Bader. PyCoder's Weekly is a free email newsletter for those interested in Python development. Along with the previously mentioned Real Python articles, we also discuss a few articles from the community about getting machine learning to production, combining Flask and Vue-based science with Python, and the fastest way to flatten the list in Python. Alright, let's get started.\n\nMy name is Christopher Bailey, your host. The Real Python Podcast is a weekly conversation about using Python in the real world. Interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com. Hey David, welcome back.\n\nHey, thanks, good to be back.\n\nYes, so we have a few different articles from Real Python we're going to talk about this week and then some outside ones. I'm kind of excited about a new segment we're going to talk about at the end about projects, which I think will be a lot of fun.\n\nOkay, I'm going to start it off and I'll talk about a recent article on Real Python. It's called \"Setting with Copy Warning in Pandas\" and the subtitle is \"Views versus Copies\". What's interesting is this is by Mirko as part of our Real Python team. I originally had taken this to try to see if I might be able to write an article and I kind of got stuck. I realized I'm not quite as much of an author as I thought. But I had done an outline and had studied it a lot and I was very interested in it. I think this is something that comes up a lot for people that are getting into data science and using pandas. I was told at my place of work at the time when these pink warnings would come up in my Jupyter notebook and I said, \"Hey, this doesn't look like this is running right the way that I wrote this.\" The guy I was working with was like, \"What does it say?\" I was like, \"Oh, that's just a warning.\" Okay, well, I don't think I should be having these all the time. I think it's something that's not uncommon, this sort of dreaded pink box that, you know, means that you may have an issue or you may not have an issue depending on the situation. And so it was really interesting to kind of do the research and learn about it. It really has a lot to do with how you are approaching filtering and then sort of assigning things inside of pandas. What can happen is this thing called chained assignment and it warns you, \"A value is trying to be set on a copy of a slice from a data frame.\" And then it warns you, \"Maybe you should be using that lock dot core, everyone pronounce it, and then a certain way of like, in these two values or parameters into it. Instead, what's weird is the chained assignment thing, you may not realize that you're doing it because you might have done it in a couple of steps. And so this article goes into depth talking about not only kind of what's happening behind the scenes, but also the times when that warning is actually really important because you might have created what's called a view instead of a copy and the assignment that you were trying to do might have actually not been applied. So you might not even have the correct data inside there, which is really important reason for the warning. And it goes into talking about the special methods that are inside of the NumPy and Pandas library. They're dunder get item and dunder set item and kind of how they work. And on top of that, what's kind of funny is I've heard people actually or seen other people say, \"Oh, you can just sort of get past this by going in and turning off that warning.\" There's actually a way to change how chained assignment works. And they're like, \"Oh, I want to be bothered with it.\" But again, you can't always be guaranteed that it's going to work. And so I definitely don't suggest that. And I think it's a good way to kind of get into it. And then one other thing that I thought was kind of interesting about it, the other reason that it can happen where you'll have issues with it not actually applying your assignments is because your data frame has a real mix of types of values in it. And Pandas will behave slightly differently if, say, all the values in the data frame say they're all floats or something like that compared to integers or objects or whatever. And so that kind of behavior will vary. And also the order that you do your assignments in. So I think it's a really, you know, anybody's in data science or is working with Pandas and has at least seen that warning, it's a really good way to kind of get a deep dive on like what's happening and how to get around it and do a little more proper work with Pandas inside there.\n\nThat's good. I mean, I think this idea of, um, it's just a warning and I'm just going to shut it off and ignore it is there's really not the right way to go at these things. I mean, warnings happen for a reason. They should, you should stop and think why did this occur? Yeah. And can I safely ignore it based on understanding what that warning actually means as opposed to just wanting to shut it up so that it's not annoying you anymore? Exactly. Yeah. This is a great article. Cool. So what do you got first one? I got is an article by a guy named Chris Conlin. That's the fastest way to flatten a list. And this was released on June 5th. So it's a recent article and he discusses six different methods for flattening a list of lists. So if you have a list that's got several other lists inside of it, then these methods will work. They don't work, say, if you have a list that has maybe just a single value and then a list and then maybe a few more single values and then another list. So it's like, it has to be a list of all lists in order for these methods to work. But he kind of compares these different ways of doing it. So he writes these six functions that each TV six different methods of flattening a list. And all of them loop over all of the sub lists and then add it to like or create a new like result list basically that that has the the flattened list in it. So that's kind of an important piece of the setup to know how he's going about it. So he's creating each one creates like an empty list called result, loops over the list in the list and then explores various ways to add those lists or extract them into the result list. Hopefully that that makes sense. So he looks at doing say like, okay, I'm going to result equals result plus using the plus operator with whatever list is inside my list of lists or using an Augmented assignment where you do that result plus equals the list using the extend method. So result that extend and then past the list to extend or using the append method where you loop over not only each list in your list of lists, but then also if you have a nested for loop that loops over each value in those sub lists and then append those values to the list. And then finally using a list comprehension to extract each value from each list in the list of lists. So lots of lists going on there, but there is six different ways, and the quiz, the question is this: which one of these is the fastest and how do they compare to each other? So he doesn't provide any of his timing code, so he doesn't show like how he actually came up with any of these values or anything, but it does have a couple of nice looking charts here that show that the slowest one is using the plus operator. So if you know how the plus operator works, it's probably not too surprising that that's actually the slowest because it's creating a whole new list each time. So when you do that result equals result plus list, that original result is recruiting a whole new one and assigning it back to the name result. So yeah, that makes sense that's going on. The fastest ones, which might be surprising, I wanted to guess. Yeah, I was hoping it was going to be the comprehension one, but it is not actually. Okay. The fastest one is using the plus equals operator. And that one is probably surprising because you think, well, plus equals is just sort of syntactic sugar, right, for like result equals result plus list. It should be the same thing as a result plus equals list. But that plus equals operator, the way it works under the hood, there's some additional optimizations there. And actually I tested it in a terminal, you do not it does not create a new list. Okay. The result list that you're like adding everything to stays stays the same, has the same memory address. Yeah, same ID or whatever. Yeah, so that one is, is the fastest, although a really close second is the extend method there. Kind of it's, it's actually kind of hard to call one a clear winner over the other looking at these at these charts. And then the other ones are kind of just in the middle. Yeah, just there, just there, you know, not really not impressing on one way or the other. Yeah, just yeah, just there, you know, so yeah, I think most people probably would have assumed like the list comprehension would probably have been fastest as well. But for that one, you're doing you've got a nested for loop. So you're looping over not only each list in the list of lists, but then also each value in each of those lists. So there's a lot, a lot more going on there. Okay. So one thing that is not listed in this article is in the itertools module, there's a chain function. Okay, which is used to chain iterables together, which is example almost exactly flattening the, you can think of it as one, well, I guess one application of chain is flattening a list. If you have a whole bunch of lists and you want to iterate over each item in all of those lists sequentially, you can use, you could pass them each as arguments to chain and then it'll treat them as if it were just one big list of values. So that's not in here and I didn't do any timing to compare what it's like, but I would kind of expect it to be faster, but but I don't know it'd be interesting to see how that other experiment is all these. Yeah. What are examples of like lists of lists and trying to think of like some kind of real world examples and we could put in their head a two-dimensional array is a really looking a common example, right? Do you have like a matrix of numbers like a data frame sort of, right? Yeah, sort of like a data frame. Data frame is right, right, very much more complicated than just a list of lists, but but yeah. One way in, in pure Python to represent a matrix would just be to use a list of lists where each list in the list is a row of the matrix, right? Okay, want to make sure if you were gonna have a good image of that in their head. Yeah, that's what I'm gonna talk about is from Test Driven IO and it's about combining Flask with the JavaScript framework view, which I'm pretty sure that's how it's pronounced, though I've heard it pronounced of vu, but I'm pretty sure it's intended to be like a view of something. It's by Jace Medlin. So Flask is a really great tool. In fact, I'm pretty excited. I'm gonna do an interview with Armin Ronacher coming up shortly. He was like mainly the creator of it. He created all the underlying frameworks that are there of sort of combined them all to create Flask and create this nice lightweight tool. Go and you should hear that coming in the feed soon. And we'll talk a bit about the 10 years of Flask here and what was he had to do with it. He was like mainly the creator of it. He created all the underneath underlying frameworks that are there of sort of combine them all to create you know, Flasks and create this nice lightweight tool. Go and this article goes into three different ways to sort of combine Flask and Vue. First is using a Jinja template, again part of Flask. Jinja template is this nice way of kind of inserting chunks of HTML into your Python code to kind of like allow it to kind of go back and forth. And it's a nice templating tool. You actually can see it in other frameworks such as Django that's popular out there. And I think in that one you're importing Vue into the actual templating. And then the next couple go into creating a single page application or abbreviated SPA. And that is where you're sort of separating the two completely. You're saying kind of front end, back end kind of idea. Whereas Flask is acting a bit more like an API and Vue is totally running all the front end sort of stuff. And then the last way is using what's called a Flask blueprint, which is a popular way of working with Flask today. Gotcha. Serving a Vue from an actual blueprint that you've created in Flask and it sort of, it's a little more combined the two of them in that case they're kind of working back and forth a little more. And it goes into, you know, how to set them all up. And then what's really nice is get a chance to kind of play with them all. There's a nice repository on GitHub where all the code is and you can kind of play around. And it goes into the pros and cons of each. And I figured, you know, if you're interested in kind of playing around with new front ends and trying out some of this new technology coming from JavaScript, I think it's a nice way to kind of get into it. Yeah, absolutely. I thought that was a really good overview. And like you mentioned, I really like the way it very clearly, I think there's like an architectural diagram for each type, you know, each way of combining these two things. And then it goes into the pros and cons and kind of gives you like this is when you should really consider using this method of combining them. So, you know, really if you're interested in using those two technologies, it kind of gives you a really good starting point to just sort of figure out how you're going to approach that and then kind of go from there. So, very cool. Yeah, there's like this little bonus area where if you're concerned about SEO, oh yeah, and you're going to be using Vue, and so there's like kind of this other technology kind underneath there, this thing called, I'm going to guess it's pronounced next and uxt, and how that could kind of optimize things for SEO, which depending on the type of site that you're creating, that might be important, right? Yeah, so what do you got next? Next I got another Real Python article, actually series of two articles on regular expressions. We, and before we move forward, I gotta clear the air and I just gotta ask, is it reg X or reg X? I have in my travels always heard it pronounced reg X, yeah, but I'm not really a big fighter on the GIF versus JIF pronunciation either. I've always called it a GIF, so whatever, soft G is following through here with reg X, it's a funny debate. Although I do have to say, if you're going to call them reg reg X's, then I ask that you also call them regular expressions just to be consistent, okay? All right, well now that's passed, we can move on. So this is by a by John Sturtz, who's a prolific Real Python author. He's written, it's got a massive series on all sorts of topics in Python. It's really an introduction to the Python language. Did two sections of his ongoing stuff there, though one about lists and tuples, and then went into the whole thing with strings and character data. So yeah, totally familiar with this work, it's good stuff. And so back in April, we released part one of the regular expressions mini series, and then just a couple weeks ago on June 3rd, we released part two. So we've now got that which is the last part. So we've now got a complete coverage of regular expressions and the RE or Remodel in Python. And it's a really cool introduction. I like the way it's structured. The first part starts with just gently introducing you to the RE module and how regular expressions work. And it's all using the search function from the Remodel. So you're not that if you've ever used RE module, there's like a billion functions in it. It can be kind of intimidating when you first, especially if you're not familiar with regular expressions, just seeing like everything. I mean, there's like find and find all and match and search and I mean, it's like all right. And then sub and I mean, there's just so many different things. So I really like that he just picks one that's kind of like a very common something you would use very commonly and we're just going to stick with that. And then kind of gently drop you into the world of regular expressions. So in part one, he introduces you to the search function which you pass it a regular expression pattern, okay, you pass to search a regular expression pattern and also a string that you want to search, okay, and it scans the string for a match for that pattern. If it finds a match, it returns something called a match object and if it doesn't, then it returns none, right? And he goes into what the match object is. So he gives an example of looking for the string one, two, three inside of another string. And if it matches, if it finds a match, it returns this match object. But what is this match object and he just sort of gently introduce you to and says, okay, it's got kind of two important things in it. It contains a tuple called the span, which is the in the start and end index of where the match was found and it's the first match that it finds in the string. And then a string of the actual match of the actual pattern. So that's kind of an overview of what this match object is. It's got it contains this information, he drops into regular expression meta characters. And these are all the different characters like your asterisk and your dollar sign and the plus sign and the question mark and all the stuff that you use in regular expressions. It makes them look really wild and exotic and difficult to understand, you know, breaks it down really clearly, what each one does and and how it works and and how you use them",
    "NOBn8r5t5A4": "Welcome to the Real Python Podcast. This is Episode 16. Are you using the Python library Pandas the right way? Do you wonder about getting better performance or how to optimize your data for analysis? What does normalization mean? This week on the show, we have Honest Banach to discuss her new book \"Thinking in Pandas.\" The inspiration behind Hannah's book came out of her talk at PyCon U.S. 2019. It was titled \"Thinking Like a Panda: Everything You Need to Know to Use Pandas the Right Way.\" We discussed several core concepts covered in the book, and she shares techniques for getting more performance when working with data in Pandas. We also talked about a recent PyCon U.S. online presentation about databases and migration. On a programming note, there was a little bit of noise on the recording this week. I did my best to edit it out, but beware you may hear a little bit of noise coming from Ana's connection. Alright, let's get started.\n\nMy name is Christopher Bailey, your host. The Real Python Podcast is a weekly conversation about using Python in the real world. Interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com. Hi Hannah.\n\nHello, welcome to the podcast. Oh, tell me a little bit about working for New Relic. What do you do there?\n\nI am on the security automation team. We basically write all the security automation tools, whatever those are. Right now, I'm working on fixing up an existing web application that was made by a previous employee, and I'm working with one other person. So, our team is only two people. It's definitely different.\n\nYeah, so it's like a Flask application, and then it has a Bokeh frontend. How much JavaScript stuff do you end up having to work with?\n\nWell, right now we're just focused on the backend. When I started a couple of months ago, they were actually transitioning their deploy from Amazon to New Relic's internal deploy system. In the process, we decided that for the next upcoming series of work, we didn't actually need a frontend at all. Yeah, so we just postponed that and decided to focus on the backend for the moment. We'll be redeploying the frontend and doing some frontend stuff probably at the end of the summer.\n\nI wanted to talk to you about two different things. One is your book that just came out, \"Thinking in Pandas,\" and then if we have time, we'll talk a little bit about the PyCon 2020 online talk that you did about databases, SQLAlchemy, and migration.\n\nTo start off, let's talk about \"Thinking in Pandas.\" The book just came out, is that right?\n\nYes, just this weekend. Very cool. I'll definitely include links to it, and it's on A-Press, right?\n\nYes, okay. So, who would be the intended reader for your book?\n\nIt's mostly aimed at beginners, but I think there's something in it for advanced or intermediate users as well. Usually, when you hear talk or read books about Pandas, it doesn't focus so much on performance, and my book really digs into the deep levels of performance. It talks about the data structures in Python and the data structures that Pandas is built on, which is NumPy. So, it goes in and talks about the performance of NumPy itself and touches on hardware performance as well. I think that's probably the most interesting part of the book. It's less focused on all the different ways you can use it in all the different APIs and more focused on how to use it correctly and get the best performance out of it.\n\nI definitely have seen that in previous workplaces where I had some working with some data scientists, and I could see sometimes, you know, them just shrugging and saying, \"Well, this is just gonna be slow,\" and I would always kind of wonder in the back of my head, like, couldn't there be something that they could be doing to make this be a little more efficient and not just simply run overnight and that kind of stuff.\n\nYeah, totally. It takes, and I think it really has to do with kind of like a user base, okay? A lot of the users that use Pandas are not, they don't necessarily have a software developer background, so they don't necessarily get that background with data structures and performance and memory management, all those details. So, it really tries to focus on that and kind of use that to explain why Pandas performs the way it does in certain circumstances.\n\nYou mentioned it briefly there. If you were to dive in a little deeper, talk about what are some of the underlying technology for Pandas?\n\nIt uses NumPy, and it uses an array underneath, and in essence, it uses C arrays. C, you know, they all expect it to be the same type, so that's like a huge performance kind of thing to note in itself. If you have different types for your columns, that can be a huge performance slowdown in itself. Which is something I talk about almost immediately. But then there's other performance benefits as well, like NumPy is built on vector registers which allow you to do the same computation across multiple columns at once. So, it's actually like a hardware speed up. Instead of adding one to a single value at a time, you can add one to like a bunch of values at a time inside your CPU. That's also mentioned in there.\n\nCan I stop you there for a second? I haven't heard anybody talk about that before, and that sounds really kind of cool. So, a vector, I mean registers are talking about areas of memory, correct?\n\nYes, inside of your CPU, you load your memory into registers, and registers are memory containers inside of your CPU where the computations are actually run and then written back into a register, and after that happens, right, then it takes that register value and eventually writes it back out to memory. But yeah, so like that's something to keep in mind too, and NumPy is taking advantage of that. So, memory in general is something else to take advantage of. You want to do, you're working with huge data sets, and so you want to do your computations. You don't want to keep loading memory into your CPU. That's very expensive, and so you kind of want to grab a chunk of memory and do a bunch of computations on it, and then write it back out to memory, and then load the next chunk. And that's kind of like where you might hear something like cache, like taking advantage of the size of your cache, and what that's talking about is like loading that memory into your cache, which is very close to your CPU, and then running computations on that, and then writing it back out. So you're avoiding like iterating over your entire data frame, okay? Each computation, and that's all happening with NumPy, which has written more at the C level than at the Python level.\n\nYes, so that's all in NumPy and extensions to NumPy. So like, NumPy does that, but there's other libraries from the author of Pandas that's also trying, it's kind of like a branch where he's hoping will eventually be like the back end of Pandas. And so that's what he's trying to do in there, is because Pandas wasn't initially written with that kind of like architecture in mind, but that's really where you get good performance meetups, is if you can do that kind of like chunk-based analysis.\n\nThat makes sense to me, like in processing based on chunks versus, you know, like I said, individual items row by row or column by column.\n\nYeah, and I mean that's, that's an essence, like, what you'll often hear people talk about in pandas when they say, you know, like, don't loop over your pandas data frame. It's that same kind of concept of doing things like somewhat in parallel, right? Or like in chunks versus just like row by row or column by column, yeah. I guess we could move into that a little bit in your 2019 PyCon talk, which I'll include links for, just kind of your impetus for getting in writing the book.\n\nYeah, so it, it talks about using an ORM, which is SQLAlchemy, and then doing database migrations using Alembic. Yeah, so to start off, let's talk about SQLAlchemy, and what does that do for you? What is it doing?\n\nIt's kind of like a scary thing, 'cause you run a raw SQL query on a production database. When you say that, do you mean the types of queries that are creating tables, creating columns, removing?\n\nYes, so moving data, creating a new database table, et cetera. It's really, and again, if you find yourself, if you're doing that, but you also have something like SQLAlchemy, where you have your table definitions defined in your code, you might again run the risk that your database table defined in your code does not match your database table that you just created in production, right? So there again, like it would be nice to know, are your table definitions and make sure those things match? But on top of that, it's nice to be able to track what changes you made to your database, and also be able to, god forbid, if something goes horribly awry, revert that change. And if you're working on, you know, as most of us do, like a project with multiple team members, it's nice to just be like, \"Hey, I wrote this migration script. Just run it, and you'll be where I am in the database version history.\"\n\nAnd it's really nice to be able to test it, right? And also, and also get review. Right, we as humans and developers, no matter how good we think we are, we are all prone to making stupid mistakes in migrations. It's one of the many areas in which we can make those mistakes, right? So, like, if you can get your teammate to review it and make sure that you didn't do something stupid, yeah, that's cool.\n\nYeah, you made some comparisons in your talk to it being a little bit like Git in the sense that the migrations can be labeled, and you know, you have a head that you can kind of choose where you're at within the levels of migration, if you...\n\nYeah, exactly. I mean, the idea is that you should be able to walk up to the latest revision and walk back to the original version that was released, and it should work regardless. And often, unfortunately, like the reality in the real world, I find, is that that's not always true, especially when migrating data. So, making changes to production, like some of those may, for example, like have to and I talked about this in my talk, like default some or migrate some existing data to a particular value, right? And like, once you've done that, it's very hard to undo that without tracking exactly which tables you changed, right? Like, which columns you changed, because your production data is going to continue on, like, you're going to have new rows in that database, right? And so, it's hard to sometimes revert a change. So, there's revert in that situation, like, may just be like nothing, and that's okay, but, but still, it's also hard to, it can be somewhat frustrating, I think, for developers to do migrations, like, oftentimes, those developers were not very, we're not always like super into like database stuff, you know, as much as like a database engineer would be, right?\n\nRight, goes back to your earlier talk on, yeah, right. So, like, we got a little annoyed that when we find that in order to do things correctly, we end up having to do like three or four migrations in a row in order to achieve some goal, yeah. And to that, I would say it's just like making a change in your code base, like you should treat it with the same amount of scrutiny and the same amount of carefulness that you do when making a feature change, like a feature may consist of many PRs in a row, and that's kind of the same as a database migration, and so it's very important if you want to do things right and you want to truly maintain the backwards compatibility and be able to revert your database back to its initial state, it's it's very important that you do things in order and you do things correctly and you take the time right as many migrations as it takes to do that and accomplish that.\n\nSo, better in smaller steps, yeah, potentially, yeah. And I think like in my talk, I go over like one particular change, basically, like from a high level, right, like one feature edition, but it ends up being like several database migrations, that's like a cascade, yeah.\n\nThat makes me think about, I recently had Athel Shop, I mentioned earlier about the C Python Turtles book, but he came on to talk about testing, and we talked a little bit about continuous integration, and you know, having a setup where as you commit to a git commit, that it will then run your tests against it, as opposed to we were joking, you know, how what could be common if you're developing by yourself, maybe you're using that state of working for Mo and I, all right, done for the day, commit, and how that might be fairly disastrous for all the different changes you might have made, yeah, so it might be good to make the smaller changes, have a test, no, it's thinking about that with the migrations, is there a sort of a testing kind of layer to that that you have to think about, yeah, so like the idea is that you should be able to walk up to the latest revision and walk back to the original version that was released, and it should work regardless, and often, unfortunately, like the reality in the real world, I find is that that's not always true, it especially when migrating data, so like making data changes to production, like some of those, you may, for example, like have to, and I talked about this in my talk, like default some or migrate some existing data to a particular value, right, and like once you've done that, it's very hard to undo that without tracking exactly which tables you changed, right, you're like which columns you changed, because your production data is going to continue on, right, and so it's hard to sometimes revert a change, so there revert in that situation, like may just be like nothing, and that's okay, but, but still, it's also hard to, it can be somewhat frustrating, I think, for developers to do migrations, like, oftentimes those developers were not very, we're not always like super into like database stuff, you know, as much as like a database engineer you're hunting, right, right, goes back to your earlier talk on, yeah, right, so like, we got a little annoyed that when we find that in order to do things correctly, we end up having to do like three or four migrations in a row in order to achieve some goal, yeah, and I to that I would say it's just like making a change in your code base, like you should treat it with the same amount of scrutiny and the same amount of carefulness that you do when making a feature change, like a feature may consist of many PRs in a",
    "8qOl1aZuQCo": "Welcome to the Real Python Podcast. This is Episode 17. Are you familiar with linear programming and how it can be used to solve resource optimization problems? Would you like to free your Python code from a clunky command line and start making convenient graphical user interfaces for your applications? This week on the show, David Amos is back with another batch of PyCoder's Weekly articles and projects. David talks about a recent Real Python article about linear programming in Python, and we discuss an article titled \"PySimpleGUI: The Simple Way to Create a GUI with Python.\" We also cover several other articles and projects from the Python community, including Python's reduce function, flaws in the pickle module, advanced PyTest techniques, and how to trick a neural network. Alright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com. Hey David, welcome back.\n\nHey, thanks. Alright, so you're ready to dive into some more articles here?\n\nI am. I think I'll start off today. Okay, I want to talk about a Real Python article. It's from Leodanis about Python's reduce function called \"Python reduce: From Functional to Pythonic Style.\" It's talking about how the reduce function, in some ways, is a bit of a holdover from the Python 2 days. Meanwhile, Python has moved on and has added a whole set of functions that are not only simpler and more Pythonic-looking ways of doing these types of functional things. This reduce function has sort of stayed the same the whole time, which is kind of interesting. It goes into very common things that you might have learned how to do with reduce, like simple summing or creating products, or even comparison kinds of things like finding the minimum and maximum. Those have kind of become almost built-in functions that are so much faster. It goes into the end of the article, showing you actually with time, and it's dramatic. The difference going from, oh gosh, it was like 18 seconds down to around a second, which is pretty amazing for something like summing. It also talks about other nice keywords of like \"all\" or \"any,\" doing those boolean types of operations where not only are written that sort of really fast optimized C level, but they also have exits, meaning that in the case of something like \"all\" where you're looking and kind of doing this sort of \"and\" type of operation, are all of these things is this and this and this and this all either true or false or whatever. In the case of the \"and\" function, it actually will exit out immediately if it finds one that isn't, which is so much smarter than it going through the entire. In the case of a data frame or a huge iterable or what have you, right? It kind of goes back into some of the stuff that I talked about in the previous episode with Hannah about working inside of Pandas. Python again has thought of ways to make it a little bit smoother and a lot faster and more optimized. And \"any\" is another one that's like that, it's sort of that or statement. And again, it would be nice if, again, if there's one example, then it would just exit out right away. But it's a very good article. I think it's really well written and it really goes into all the different ways to look at it, not only with reduce using a standard style function, but using it with a lambda and all the other kinds of functions inside of there. I think it's one of those things that maybe help you think if you're still wondering if that's something you should be using or where it's useful to still use it and all the options that are around, hopefully making your code a little bit more Pythonic.\n\nYeah, it is. It's a really interesting article. I mean, there's this whole debate around the whole map, filter, reduce thing and whether or not you should use it as opposed to say things like list comprehension, which you can achieve similar results. You know, it's a tool and there are times when it might make sense to use that tool. Yeah, and it's good to know how it works. There's something about functional programming that I find really attractive. And maybe it just comes from my math background from studying mathematics for such a long time, but I really like this idea of functions not having side effects. That's something that I just, these pure functions, it feels much more natural to me than a function having some sort of side effect. Like a good example would be something like the print function is not a pure function, right? It sends some text to the standard out and returns the value none. So there's like the side effect of like this text going somewhere and then it's just returning this none value. While it's a useful function, right, for debugging and for displaying output in a terminal and everything, but it somehow seems to like break this idealized version of whatever a function actually should be. So if you were to talk about the idea of like functional programming to kind of dive into a little deeper, like one of the core sort of tenants of it is that it's not affecting the inputs, right? And so you're basically, you know, say you're inputting A and B, A and B will be what they are at this, you know, at the start, at the end after the function has run, right? Okay, am I missing anything else about are there other core tenants about functional programming? Well, I mean, that's a big thing is yeah, not affecting the inputs and always having an output. But there's other things like there is sort of a focus on like these lists and arrays as the primary data structure for processing and everything. Recursion is something that's used quite a bit. And yeah, that was the one, yeah, functional programming. Yeah, in my mind I always think of it as like the pure functions. And I guess it's one of those things when I, you know, was studying computer science and in university and talking about functions and side effects, it was sort of like, wait a second, like this feels dirty, like this. I think that's just sort of the mathematical side of me coming out. I mean, I break my own values, I guess all the time and for sure in my own programming and that's just something I've always found real attractive about functional programming. But yeah, this is a great article and I also like that he compares reduce to the accumulate function from the itertools module. Yeah, yeah, which is new, right? I don't know that it's new. The accumulate function or, oh, I think the prod is the newish one, prod. Yeah, yeah, I'm sorry, okay, the built-in, yeah, it's sort of a complementary to sum. Yeah, yeah, summing over, yeah, coming with the math module, yep. Yeah, yeah, that's a cool new edition here. Cool. So what do you got? Speaking of math, I guess. Okay, that's my article. I've got one from Marco on the Real Python team. And Marco, next time we chat, I need to learn how to pronounce your last name. I'm not going to attempt it right now, but I hope to learn. So, so in the future I can correctly pronounce it because we will probably feature more of his articles. Yeah, he's got this great article called \"Hands-On Linear Programming Optimization with Python.\" So this is a topic that's actually pretty near and dear to my heart. I've done not a massive amount of linear programming, but it's a tool that I used quite a bit when I was studying mathematics, in particular studying graph theory, which maybe we can talk about when I'm done going through the article. So linear programming is a way to take like a set of linear equations, which are things like, you know, A x plus B y equals C. That's a linear equation. You have variables that don't have any sort of like exponent on them, the x and y's, and they have some coefficients, and they're equal. Or you can have linear inequalities where that equate that expression of x and y, or however many variables you have, is like less than or equal to some number, greater than equal, but you set up the system of equations or inequalities, and it's subject to some constraints. So a good example would be, well, I'll use the example that he's got in the article. So the example he gives is a resource allocation problem, and I'll just read off a little bit here. So say that a factory produces four different products, and the daily produced amount of the first product is x1, the amount produced of the second product is x2, and then for the third and fourth, would be x3, x4. So these are your variables. Okay. And the goal is to determine the profit maximizing daily production amount for each product, so you want to know how much should I produce each day to maximize my profits. But there's some constraints. And so the constraints are, you know, for example, what the profit for each unit of each product is. So like maybe product one has a profit of twenty dollars for each unit when you sell it. Product two has twelve dollars, product three forty, product four twenty five. These are just some arbitrary values. And you know that you can only produce so many units, like in total each day. I mean, because you only have so many people that work for you, you have so much capacity. So let's say maybe that's fifty. And then each product has raw materials that are consumed when you produce that product. So you have a couple of different raw materials that are used in each to produce all four different products, and they vary in how much amount, any, you know, the amounts that you need for each product. So you have this giant system of of, uh, linear equations and these constraints and everything. And the idea is I want to find out how knowing all the all the things that I do about this can I figure out how much of each product I should produce every day to maximize my profit. So this is an optimization problem that can be solved with linear programming. Merco goes on to describe a couple of different ways that you can approach solving these kinds of problems using the SciPy library and also one called PuLP or P-U-L-P, which I've spent a little bit of time trying to figure out what the U in PuLP means and I couldn't figure it out. I mean, I think LP is for linear programming, Pu I'm not sure. Python, it's probably Python and they just like added an out of out of vowel to be able to pronounce it. Yeah, I'm not sure. Yeah, that's probably the. Yeah, the built-in. Yeah, it's sort of a complementary to sum. So instead of summing over. Yeah, coming with the math module. Yep. Yeah, yeah, that's a cool new edition here. Cool. So what do you got? So speaking of math, I guess. Okay, that's my article. I've got one from, uh, Merco on the Real Python team. And Merco, next time we chat, I need to learn how to pronounce your last name. I'm not going to attempt it right now, but I hope to learn. So, so in the future I can correctly pronounce it because we will probably feature more of his articles. Yeah, he's got this great article called \"Hands-On Linear Programming Optimization with Python.\" So this is a topic that's actually pretty near and dear to my heart. I've done not a massive amount of linear programming, but it's a tool that I used quite a bit when I was studying mathematics, in particular studying graph theory, which maybe we can talk about when I'm done going through the article. So linear programming is a way to take like a set of linear equations, which are things like, you know, A x plus B y equals C. That's a linear equation. You have variables that don't have any sort of like exponent on them, the x and y's, and they have some coefficients, and they're equal. Or you can have linear inequalities where that equate that expression of x and y, or however many variables you have, is like less than or equal to some number, greater than equal, but you set up the system of equations or inequalities, and it's subject to some constraints. So a good example would be, well, I'll use the example that he's got in the article. So the example he gives is a resource allocation problem, and I'll just read off a little bit here. So say that a factory produces four different products, and the daily produced amount of the first product is x1, the amount produced of the second product is x2, and then for the third and fourth, would be x3, x4. So these are your variables. Okay. And the goal is to determine the profit maximizing daily production amount for each product, so you want to know how much should I produce each day to maximize my profits. But there's some constraints. And so the constraints are, you know, for example, what the profit for each unit of each product is. So like maybe product one has a profit of twenty dollars for each unit when you sell it. Product two has twelve dollars, product three forty, product four twenty five. These are just some arbitrary values. And you know that you can only produce so many units, like in total each day. I mean, because you only have so many people that work for you, you have so much capacity. So let's say maybe that's fifty. And then each product has raw materials that are consumed when you produce that product. So you have a couple of different raw materials that are used in each to produce all four different products, and they vary in how much amount, any, you know, the amounts that you need for each product. So you have this giant system of of, uh, linear equations and these constraints and everything. And the idea is I want to find out how knowing all the all the things that I do about this can I figure out how much of each product I should produce every day to maximize my profit. So this is an optimization problem that can be solved with linear programming. Merco goes on to describe a couple of different ways that you can approach solving these kinds of problems using the SciPy library and also one called PuLP or P-U-L-P, which I've spent a little bit of time trying to figure out what the U in PuLP means and I couldn't figure it out. I mean, I think LP is for linear programming, Pu I'm not sure. Python, it's probably Python and they just like added an out of out of vowel to be able to pronounce it. Yeah, I'm not sure. Yeah, that's probably the. Yeah, the built-in. Yeah, it's sort of a complementary to sum. Yeah, okay. So what do you got? So speaking of math, I guess. Okay, that's my article. I've got one from, uh, Merco on the Real Python team. And Merco, next time we chat, I need to learn how to pronounce your last name. I'm not going to attempt it right now, but I hope to learn. So, so in the future I can correctly pronounce it because we will probably feature more of his articles. Yeah, he's got this great article called \"Hands-On Linear Programming Optimization with Python.\" So this is a topic that's actually pretty near and dear to my heart. I've done not a massive amount of linear programming, but it's a tool that I used quite a bit when I was studying mathematics, in particular studying graph theory, which maybe we can talk about when I'm done going through the article. So linear programming is a way to take like a set of linear equations, which are things like, you know, A x plus B y equals C. That's a linear equation. You have variables that don't have any sort of like exponent on them, the x and y's, and they have some coefficients, and they're equal. Or you can have linear inequalities where that equate that expression of x and y, or however many variables you have, is like less than or equal to some number, greater than equal, but you set up the system of equations or inequalities, and it's subject to some constraints. So a good example would be, well, I'll use the example that he's got in the article. So the example he gives is a resource allocation problem, and I'll just read off a little bit here. So say that a factory produces four different products, and the daily produced amount of the first product is x1, the amount produced of the second product is x2, and then for the third and fourth, would be x3, x4. So these are your variables. Okay. And the goal is to determine the profit maximizing daily production amount for each product, so you want to know how much should I produce each day to maximize my profits. But there's some constraints. And so the constraints are, you know, for example, what the profit for each unit of each product is. So like maybe product one has a profit of twenty dollars for each unit when you sell it. Product two has twelve dollars, product three forty, product four twenty five. These are just some arbitrary values. And you know that you can only produce so many units, like in total each day. I mean, because you only have so many people that work for you, you have so much capacity. So let's say maybe that's fifty. And then each product has raw materials that are consumed when you produce that product. So you have a couple of different raw materials that are used in each to produce all four different products, and they vary in how much amount, any, you know, the amounts that you need for each product. So you have this giant system of of, uh, linear equations and these constraints and everything. And the idea is I want to find out how knowing all the all the things that I do about this can I figure out how much of each product I should produce every day to maximize my profit. So this is an optimization problem that can be solved with linear programming. Merco goes on to describe a couple of different ways that you can approach solving these kinds of problems using the SciPy library and also one called PuLP or P-U-L-P, which I've spent a little bit of time trying to figure out what the U in PuLP means and I couldn't figure it out. I mean, I think LP is for linear programming, Pu I'm not sure. Python, it's probably Python and they just like added an out of vowel to be able to pronounce it. Yeah, I'm not sure. Yeah, that's probably the. Yeah, the built-in. Yeah, it's sort of a complementary to sum. Yeah, okay. So what do you got? So speaking of math, I guess. Okay, that's my article. I've got one from, uh, Merco on the Real Python team. And Merco, next time we chat, I need to learn how to pronounce your last name. I'm not going to attempt it right now, but I hope to learn. So, so in the future I can correctly",
    "Hhm5VRbfE3k": "Welcome to the Real Python Podcast. This is episode 19. \nWould you like to clearly understand what's happening when you use the Python import keyboard? \nDo you want to use modules more effectively to structure your code, or maybe you're ready to move to the next level with your Django project by adding user management? \nThis week on the show, David Amos is back with another batch of PyCoders Weekly articles and projects. \nWe discuss a Real Python article about advanced techniques and tips for using the Python import keyword. \nDavid also talks about another recent article on the site about managing users in Django. \nWe cover several other articles and projects from the Python community, including robot programming in Python, F-strings versus dot format, the rise of Python malware, and more, so let's get started. \n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com. \n\nHey David, welcome back. \nHey, thanks for having me. \nCool, so what'd you bring us this week? What are you starting with? \nI've got an interesting article about the return of the Python print statement. Did you ever use Python 2, only in passing? \nPartly, in the process of trying to learn Python. Some of the tutorials and some of the stuff I did, and then of course, the Mac comes with it, you know, up until recently, right? \nRight, and so it was always there by default. \nYes, but I didn't study it as much. \nYeah, same. I got in early in Python 3 and never really used Python 2 except for a little bit with Zapier. \nSure, for a while, they only supported Python 2 for scripting on Zapier, so that was kind of the extent of my use of it. \nOne of the big things, I think people know the difference between Python 2 and Python 3, is the print statement from Python 2 versus the print function in Python 3. \nGuido van Rossum, earlier I guess from early June, proposed adding or bringing back the Python print statement. \nIt's funny because he talks about this and he says it's not an April Fool's joke. He's seriously proposing this, and it's a result of the new parsing expression grammar, the PEG parser. \nWe talked about that, right? I don't know, six weeks ago or something, a few weeks ago. \nYeah, he basically said, you know, I realized that it's only going to take about 20 lines of code to put this in, you know, I had a nice afternoon coding this up and wanted to get people's opinion on it. \nIt's interesting though because it's not just the print statement, and it's really kind of a different thing, although it looks like the print statement. \nAs a result of this, what it allows you to do is call a function without parentheses, and it's not just print, it's any function and any method on a class. \nFor example, the len function that returns the length of a string or of an iterable, you could type if you have the string \"abc\", you do len space and then \"abc\" in quotes, and it would return three, same for a string or a class method, you would just call the method on the class without any quotes and then the arguments separated by commas, and get the return value. \nThat was my question, was like if you could have arguments, more than just one. \nYou could, and you can even still have keyword arguments. For example, when you print multiple things, when you pass multiple arguments to the print function, there's like a sep argument that you could print like a separator between those things when it prints. \nYou could still do like print space and then one comma two comma three comma sep equals plus, and then it would print with one plus two plus three. \nHe says, you know, this is, I'm proposing this, and I just want to see what your opinion is, but he'd be happy to retractive if it's like a resounding boo hiss, this is. \nAnd right, you know, there's this response, someone said, Greg Ewing says, why is this being proposed? I think we would need a very strong reason to consider this, and so far I haven't seen any justification other than because we can, and Guido's response to Greg was there was definitely something of that. \nI was looking at the new big cursor and realized that if people wanted it, this would be easy to do, so I had a pleasant I spent pleasant hour coding it up to my satisfaction, but I was also trying to satisfy some demand when Python 3 was young. \nPrint becoming a function was one of the most frequent complaints and it's still occasionally seen on Twitter. I found at least two Stack Overflow issues about it, but the combined upvote count was less than 100. \nHe goes on to say, all in all, it's clear that there's no future for this idea, and I'll happily withdraw it. \nAnyway, it's just a funny exchange there and it seemed like when I came across it, I thought, is this just Guido reminiscing of the old the old days? \nAnyways, that's funny, yeah. \nWhat do you got next? \nThe first one I have is a follow-up from our last conversation two weeks ago talking about malware. \nIt's from a website called cyborgsecurity.com by an author, Austin Jackson, and it's an interesting kind of thing. \nYou might think, okay, when I initially started to read the headline, I thought to myself also that, oh, the idea that there's malware in packaging and you've got to be careful about what you're typing as far as pip installing stuff and you know that kind of like namespace pollution or some other kinds of things. \nNo, it's actually true malware written in Python. \nOne of the barriers to entry there is the idea that Python would have to be installed on the machine, but of course, that whole landscape is changing with things like PyInstaller or Py2exe, right? \nAnd you might say, well, oh, it's, you know, malware, one of the things that you would think about is it should probably be small, right? It should be, you know, in the kilobyte kind of range compared to the megabyte range. \nAnd you know, they give an example of how PyInstaller would create just a simple hello world and it jumps from 200 kilobytes for a hello world in like C to potentially, you know, seven megabytes or more to be an executable on Windows, but seven megabytes to the majority of people that are out there probably doesn't seem like very much these days to us programmers, it may seem like a lot. \nAnd you know, there's like image files and so forth that we're passing around the internet all the time today that are in that range. \nAnd then another thing that is another wrinkle to that is this other packaging or compiling tool, I don't know exactly what to call it, but it's called Nuitka or Nico, I don't know how to pronounce it, but it actually produces sort of the C code, sort of a C Python compiler, and it'll take something that like that example I was giving you before, like a hello world, and it'll take it down to like 450 kilobytes when you have examples of something like malware. \nAnd then the tools that look at the files that are installed on the machine or look for malware to try to prevent it coming on your machine, they very often want to be able to dive into the code to look for these kinds of things. \nAnd so this is going to make it so that, you know, you can't really tell what this thing is and what's happening. \nAnd there's actually some different packages that are out there that do this, like you might have heard of minifying CSS or JavaScript, you know, removing all the spaces and doing things like that, but there's also one called PyArmor which even does another kind of bit of binary tricks to it to kind of make it very unreadable to a human or for most machine things. \nIt's very interesting what's kind of what's happening there. \nBeyond that, there's some dangers in Python. There's the eval statement or the eval function which you can just run code, which is a little kind of scary for scripts that are out there. \nAnd so it goes through all those kinds of things and talks about that, you know this is a real thing that's happening, and then it goes in and then talks a little bit further about malware analysis tools, things that can extract a PyInstaller or unpack something like the Py2exe, uncompile, and things like that. \nIt's kind of like the flip side of some of the stuff that we talked about last week in that project of things that can kind of create these key loggers or screenshotting tools and so forth. \nAgain, our plan here of sharing this stuff with you is just to make you aware of that. \nHey, David, welcome back. \nHey, thanks for having me. \nCool, so what'd you bring us this week? What are you starting with? \nSo I've got an interesting article about the return of the Python print statement. Did you ever use Python 2, only in passing? \nPartly, in the process of trying to learn Python, some of the tutorials and some of the stuff I did, and then of course, the Mac comes with it, you know, up until recently, right? \nRight, and so it was always there by default. \nYes, but I didn't study it as much. \nYeah, same. I got in early in Python 3 and never really used Python 2 except for a little bit with Zapier. \nSure, for a while, they only supported Python 2 for scripting on Zapier, so that was kind of the extent of my use of it. \nOne of the big things, I think people know the difference between Python 2 and Python 3, is the print statement from Python 2 versus the print function in Python 3. \nGuido van Rossum, earlier I guess from early June, proposed adding or bringing back the Python print statement. \nIt's funny because he talks about this and he says it's not an April Fool's joke. He's seriously proposing this, and it's a result of the new parsing expression grammar, the PEG parser. \nWe talked about that, right? I don't know, six weeks ago or something, a few weeks ago. \nYeah, he basically said, you know, I realized that it's only going to take about 20 lines of code to put this in, you know, I had a nice afternoon coding this up and wanted to get people's opinion on it. \nIt's interesting though because it's not just the print statement, and it's really kind of a different thing, although it looks like the print statement. \nAs a result of this, what it allows you to do is call a function without parentheses, and it's not just print, it's any function and any method on a class. \nFor example, the len function that returns the length of a string or of an iterable, you could type if you have the string \"abc\", you do len space and then \"abc\" in quotes, and it would return three, same for a string or a class method, you would just call the method on the class without any quotes and then the arguments separated by commas, and get the return value. \nThat was my question, was like if you could have arguments, more than just one. \nYou could, and you can even still have keyword arguments. For example, when you print multiple things, when you pass multiple arguments to the print function, there's like a sep argument that you could print like a separator between those things when it prints. \nYou could still do like print space and then one comma two comma three comma sep equals plus, and then it would print with one plus two plus three. \nHe says, you know, this is, I'm proposing this, and I just want to see what your opinion is, but he'd be happy to retractive if it's like a resounding boo hiss, this is. \nAnd right, you know, there's this response, someone said, Greg Ewing says, why is this being proposed? I think we would need a very strong reason to consider this, and so far I haven't seen any justification other than because we can, and Guido's response to Greg was there was definitely something of that. \nI was looking at the new big cursor and realized that if people wanted it, this would be easy to do, so I had a pleasant I spent pleasant hour coding it up to my satisfaction, but I was also trying to satisfy some demand when Python 3 was young. \nPrint becoming a function was one of the most frequent complaints and it's still occasionally seen on Twitter. I found at least two Stack Overflow issues about it, but the combined upvote count was less than 100. \nHe goes on to say, all in all, it's clear that there's no future for this idea, and I'll happily withdraw it. \nAnyway, it's just a funny exchange there and it seemed like when I came across it, I thought, is this just Guido reminiscing of the old the old days? \nAnyways, that's funny, yeah. \nWhat do you got next? \nThe first one I have is a follow-up from our last conversation two weeks ago talking about malware. \nIt's from a website called cyborgsecurity.com by an author, Austin Jackson, and it's an interesting kind of thing. \nYou might think, okay, when I initially started to read the headline, I thought to myself also that, oh, the idea that there's malware in packaging and you've got to be careful about what you're typing as far as pip installing stuff and you know that kind of like namespace pollution or some other kinds of things. \nNo, it's actually true malware written in Python. \nOne of the barriers to entry there is the idea that Python would have to be installed on the machine, but of course, that whole landscape is changing with things like PyInstaller or Py2exe, right? \nAnd you might say, well, oh, it's, you know, malware, one of the things that you would think about is it should probably be small, right? It should be, you know, in the kilobyte kind of range compared to the megabyte range. \nAnd you know, they give an example of how PyInstaller would create just a simple hello world and it jumps from 200 kilobytes for a hello world in like C to potentially, you know, seven megabytes or more to be an executable on Windows, but seven megabytes to the majority of people that are out there probably doesn't seem like very much these days to us programmers, it may seem like a lot. \nAnd you know, there's like image files and so forth that we're passing around the internet all the time today that are in that range. \nAnd then another thing that is another wrinkle to that is this other packaging or compiling tool, I don't know exactly what to call it, but it's called Nuitka or Nico, I don't know how to pronounce it, but it actually produces sort of the C code, sort of a C Python compiler, and it'll take something that like that example I was giving you before, like a hello world, and it'll take it down to like 450 kilobytes when you have examples of something like malware. \nAnd then the tools that look at the files that are installed on the machine or look for malware to try to prevent it coming on your machine, they very often want to be able to dive into the code to look for these kinds of things. \nAnd so this is going to make it so that, you know, you can't really tell what this thing is and what's happening. \nAnd there's actually some different packages that are out there that do this, like you might have heard of minifying CSS or JavaScript, you know, removing all the spaces and doing things like that, but there's also one called PyArmor which even does another kind of bit of binary tricks to it to kind of make it very unreadable to a human or for most machine things. \nIt's very interesting what's kind of what's happening there. \nBeyond that, there's some dangers in Python. There's the eval statement or the eval function which you can just run code, which is a little kind of scary for scripts that are out there. \nAnd so it goes through all those kinds of things and talks about that, you know this is a real thing that's happening, and then it goes in and then talks a little bit further about malware analysis tools, things that can extract a PyInstaller or unpack something like the Py2exe, uncompile, and things like that. \nIt's kind of like the flip side of some of the stuff that we talked about last week in that project of things that can kind of create these key loggers or screenshotting tools and so forth. \nAgain, our plan here of sharing this stuff with you is just to make you aware of that. \nHey David, welcome back. \nHey, thanks for having me. \nCool, so what'd you bring us this week? What are you starting with? \nSo I've got an interesting article about the return of the Python print statement. Did you ever use Python 2, only in passing? \nPartly, in the process of trying to learn Python, some of the tutorials and some of the stuff I did, and then of course, the Mac comes with it, you know, up until recently, right? \nRight, and so it was always there by default. \nYes, but I didn't study it as much. \nYeah, same. I got in early in Python 3 and never really used Python 2 except for a little bit with Zapier. \nSure, for a while, they only supported Python 2 for scripting on Zapier, so that was kind of the extent of my use of it. \nOne of the big things, I think people know the difference between Python 2 and Python 3, is the print statement from Python 2 versus the print function in Python 3. \nGuido van Rossum, earlier I guess from early June, proposed adding or bringing back the Python print statement. \nIt's funny because he talks about this and he says it's not an April Fool's joke. He's seriously proposing this, and it's a result of the new parsing expression grammar, the PEG parser. \nWe talked about that, right? I don't know, six weeks ago or something, a few weeks ago. \nYeah, he basically said, you know, I realized that it's only going to take about 20 lines of code to put this in, you know, I had a nice afternoon coding this up and wanted to get people's opinion on it. \nIt's interesting though because it's not just the print statement, and it's really kind of a different thing, although it looks like the",
    "Ajy5gXVOj_c": "Welcome to the Real Python Podcast. This is Episode 20. Have you wanted to generate advanced reports as PDFs using Python? Maybe you want to have documents generated with tables, images, or fillable forms. This week on the show, we have Mike Driscoll to talk about his book ReportLab: PDF Processing with Python. Mike's an author of multiple books about Python and has recently rewritten his Python 101 book. He's also a member of the Real Python team and has written several articles for the site. Along with our discussion about ReportLab and PDFs, Mike talks about being a self-published author and we also talk about his favorite Python GUI framework. So let's get started.\n\n[Music]\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey Mike, welcome to the podcast. \n\nHey, thanks for having me. \n\nI wanted to talk a little bit about being an author and all the different books that you've written. I was wondering if you would want to start off and just talk a little bit about your Python 101 book. I heard you were maybe revising it, is that right? \n\nYeah, my original intention was to revise it. After looking it over, I decided that doing a rewrite was in order. So that's what I'm working on right now. \n\nWhat are the types of things that you're updating in it? \n\nWell, when I was first looking at doing the revision, I was like, well, dictionaries are now ordered and there are new types of distributing packages that weren't available five years ago. The market has changed enough in the Python packages world that it's not just pip installer and pip2ex. There's also Mutika and a couple of others like Briefcase, I think. It's come a long way. I don't have any of that coverage in the original Python 101 book, so that kind of destroys an entire section of my original book, and I was like, well, if I wanted to change that, I'm going to toss out these old modules that are no longer supported. In the original book, I was talking about ConfigObject, which maybe you haven't heard of, but it's a neat replacement for a config parser, but Michael Ford doesn't really support config objects anymore as far as I can tell. So I was like, well, I probably shouldn't be talking about that, even though I still think it's superior to ConfigParser. So, you know, it's just like and I have to chop up my book, and so I decided to just rewrite it. \n\nWow, yeah, that's hard. Are there things that you're excited about changing in that process? \n\nOh, yeah. Five years ago, Python 101 was my first book, okay? And, you know, I didn't really know what I was doing. I just kind of flew by the seat of my pants. The whole time I was doing it and now I've been writing for, well, writing books for, I guess it's been six years now, not five. Yeah, anyway, and I've improved a lot and I've worked with Real Python and I've seen how they write and I've worked with two publishers since then. I've got all this new knowledge of how to write that I didn't have before, so I was like, no, if I'm going to just do bits and pieces in the book, I might as well write the whole thing so that it's consistent in its style and tone. Yeah, it makes sense. You know, so I was excited to see how it would flow now, you know, will it look better, will it be worse, am I even going to get that kind of feedback from anyone because who's going to want to read the first edition of the second edition, you know? \n\nOh yeah, but, so yeah, I am excited because I'm adding some new chapters. Like in the first one, I only covered threading, that's when I'm covering 30 and multiprocessing. It sounds pretty deep for a 101 book. Yes, this is the thing about Python 101 that a lot of people don't understand is that I wanted to teach Python 101, which is just the first part of the book. There's another three or four parts to the book, and those other parts get into intermediate and more meatier topics because I found when I was reading all those beginner books when I first started doing Python that, oh, now I know the syntax, but I don't know what to do with it. Yeah, when I got done with the book and I'm like, well, I hated that. So I was like, I'm going to write a book that I would have wanted when I was learning Python that actually teaches you to do something beyond the basics. \n\nYeah, that I think that's exciting. That definitely would be something that I would be looking for as an intermediate developer now. So I know you have a Python 202 book, 102 or 201, sorry. So in that book, where does it take off from there? \n\n201 focuses only on intermediate and more advanced topics. So, you know, you're learning about, it goes more deep into multiprocessing and threading. It talks about descriptors, decorators, okay, topics that, you know, you don't normally need to use every day, but that you'll eventually use once you've mastered the basics. In Python 101, basically does that have a similar ending section there where you get into more project kind of stuff? It should, and I might end up doing that, but right now it does not. It just kind of covers stuff that, like the collections module and, and okay and other modules that I thought would help people like Hydra tools, stuff like that, and it just helps kind of shine a spotlight on, hey, these are more advanced, or at least intermediate level stuff that I was told by the Python community, these are intermediate levels. So this is what should be covered, and so I just included those. \n\nYou seem to be into creating graphical user interfaces, and you have a couple books and then you have several articles on Real Python now. One we talked about last week or a couple weeks ago on the podcast was your PySimpleGUI article, but then I'm in the process of creating a video course for your wxPython, which is taking me a little while since I've got some new responsibilities there at Real Python. And then another one on Qivi, um, do you have a favorite GUI framework? Um, my favorite is still wxPython, I think.\n\nOkay. What is it that you like about it? \n\nWell, when I was first looking into doing GUI in Python, I was trying to translate a VBA app into Python, basically. Okay, yeah. Oh, you know, VBA for applications, it was based on adding a GUI to your Excel spreadsheet or to Microsoft Access, and my boss didn't want to keep paying Microsoft to break our code every time we upgraded, all right. So he wanted us to translate the Python, and I looked and I looked and Tk, Tkinter, Decanter, whatever they call it, yeah. I didn't have the widgets that you need to make it look like Microsoft, okay, to be like kind of look like it would sit next to the other applications and not be this really strange looking, yes. You know, it didn't have a very good notebook solution, it didn't have a good table solution, okay, I ain't notebooks are better, I might be mistaken there, but I know I didn't have a good table solution or a good list where they kind of a what I call a list control, I didn't like their list control solution very much, so I evaluated DeBeix Python and PyQt, and PyQt had a really big cost to it, the time, it's for commercial stuff, yeah. It seems like it really jumps into that very quickly, yeah, and my boss was like, nope, so I went with Python, and yeah, it worked really good, and the community was crazy welcoming and very helpful, and so that's so that's kind of why I stuck with it. The only downside to DeBeix Python is it's basically like three guys, maybe who work on it, so yeah, uh, the bus factor is unfortunately high on that one. The what factor, sorry, the bus factor, you know, somebody might, if somebody quits the project or gets hit by a bus, they won't let's die, you know, wow, I haven't heard that term, I've got a different term for bus ideas, which is this idea of, and you can use it for other things, but I knew a friend who worked at a music store, and she had this concept of this idea that we're all on a bus together and we're traveling through time, some people get off in 1975, and that's their music they got off the bus, yeah, and you know the rest of us are keep kind of keep going, and so forth, but I feel that is that way with technology sometimes too, right, where people just like, you know, I knew this guy, you know, speaking about Microsoft and Visual Basic and, you know, he created these applications, and, you know, all his stuff was at this point of all being sunset and so forth, he's like, whatever, I got off the bus, you know, yeah, and didn't want to keep moving forward, which is kind of hard with Python too in some ways, it just keeps moving, you know, against all the changes you have to add to your 101 book, and keep it updated with that, and I would imagine that with GUIs is kind of the same thing with oh my gosh, just like what they're changing the Mac interface again, yeah, well, the nice thing about DeBeix Python is that it wraps the native widgets, so, oh good, yeah, you know, it does not, and the library itself doesn't have a huge bunch of changes all the time, so, you know, stuff that I've written even 10 years ago, all I've had to do is upgrade it for Python 3 and it works, you know, so, yeah, good. \n\nI have a question about that and then it's relation to PySimpleGUI, it seemed as though PySimpleGUI can sort of sit on top of some of these other frameworks and provide sort of an abstraction layer to that, is that right? \n\nYeah, that's correct. \n\nOkay, um, have you used it with the wxPython then? \n\nI know it kind of defaults to Tkinter if that's right. \n\nCorrect. So, um, I haven't tried it with wx. I think I played with it with Qt because I, so the guy who created it, who I've talked to a few times, he said that the idea is to wrap other frameworks so that he can, you can use the same, you know, possible GUI interface, but you get the widget sets of the other, right, the other frameworks. So he has completely wrapped Tkinter, he has only partially wrapped Kivy because it's so big, right, okay, he's only wrapped, you know, a handful of the widgets there so far, and I think he's got a pretty good wrapping of the core widgets of PyQt, so if I was going to use it, I'd probably use it with Qt first because it's just better wrapped right now, it's more, has more coverage or where you want to call it as far as the types of widgets and things that you might end up using, correct, okay, cool. \n\nIn your day-to-day work, how often are you building things with wxPython? \n\nUnfortunately, not all that often, um, I sometimes will do it for like a hackathon for my work, but it's more just hobby stuff right now, whereas, you know, my previous role, I did write a fair bit of Debeix Python applications for my company, okay. \n\nWhat is, what's the more common Python tasks that you're doing at your work now? \n\nWell, right now, they call me an automated test engineer, so I'm in charge of our custom-made, uh, Python test framework for a C++ embedded application, okay, and so those are like embedded hardware, is that right? \n\nYes, so we just, we design, um, a basically a tractor control system that maps, you know, as you see plant spray and all that good stuff, it shows it on screen, and so I write test software to test all the different configurations and all the buttons and widgets that are on screen, okay, cool. I guess you're in the right place, uh, living in Iowa then, yeah, I have, uh, extended family, my wife's family's from, from Iowa also from a little town called Cherokee, if you're familiar with that, I've heard of that, yeah, it's very small, tooled around there, and you know, when all the different, you know, farmlands and very interesting to see that get, you know, technology added to all those things, to tractors and stuff like that, that's pretty cool, yeah, I didn't realize how much tech went into the tractors and farming in general. \n\nSo you recently restarted your YouTube channel, how's that going? \n\nPart of me is like, I'm really excited about it, another part of me is like, wow, this is kind of a slow, slow burn is what I want to say, yeah. \n\nAre there things that you find challenging in trying to make video content? \n\nWell, it took me a long time to find the right mic setup, okay, so it would actually record, correctly, and I finally figured out that I needed an arm for my desk so that I could position, like a boom kind of thing, yeah, so I can position my mic where I needed it, because before I would, I just couldn't seem to find the right distance from my face to get that unit to record correctly, and once that that was solved, it's been a lot easier, oh yeah, yeah, it's weird, like, like a mic stand sitting on or a little, you know, tiny one sitting on your desk and then it picks up all the sound of you typing and clicking and or it's like in the way of the screen, yeah, that I still think I picked up too much of my typing, so I try to use Jupyter Notebook when I can to do the presentation of the code because then it's just me hitting spacebar basically, yeah, I think that's interesting presentation technique, I definitely see that being used in a lot of the conferences again probably partly because of the amount of time that you're going to have to show these concepts but you can still sort of have it run the code to see it sort of you know translate into something, yeah, it works for cert for the Python 101 stuff that I've been doing, uh, lately and it works really good for um the Jupyter Notebook presentations I've been doing, yeah, but you know if I want to I've done a couple of wxPython tutorials and you can't use it with that obviously so those are more you know working in an editor and then showing the output type thing, yeah, definitely you're gonna have to change it up for that. \n\nOne of the things I wanted to have you talk about was your book about ReportLab, when did you put that one out? \n\nUm, I believe that came out in the summer of 2018. \n\nOkay, who did you see as the audience for that book? \n\nWell, so I watch the statistics for my blog and I see that an article I wrote, I think almost 10 years ago, about is the ReportLab tutorial kind of a step-by-step one, and it has been like my top article for years, oh wow, and I was like dude, I think it's still in my top five, even now, and other ReportLab-ish or just PDF related articles have been for long periods of time in my top ten, I think I have two or three right now that are still PDF related that are in my top ten, and I was like there's obviously a market for learning about how to use PDFs with Python, yeah, definitely, and ReportLab has been the most comprehensive way to create PDFs that I've ever seen in Python. I wanted to focus on ReportLab because there is no other book, I don't even think it's hardly mentioned in any other books on that topic, and then the other libraries, PyPDF2 and PDFRW, also weren't covered very well in books. So to me, I was like I'm just going to try it, I'll see if the Kickstarter works, and if it does then I will continue writing, if it doesn't then I'm not sure what I'll do, but I might continue writing, but in the end, everyone was, there was enough interest that I went ahead and wrote it all out. \n\nIn general, you've used Kickstarter a couple of times now, is that right? \n\nYeah, I use it for my self-published books mostly to check and see kind of get a reading of the audience, is there enough interest that this is worth pursuing, is it kind of a tepid interest, sometimes I, I already have in my mind, I'm like, oh, if it fails, I'm going to write it anyway because I'm interested in writing it, but, sure, so do you set the goal maybe a touch lower in that case to make sure that it creates or do you have a strategy? \n\nMy strategy is to make enough that I can pay what I've already spent. So like getting the artwork done is not cheap and okay, so I make sure that I cover my artwork, and I make sure that I",
    "XyGg8AZHGGw": "Welcome to the Real Python Podcast. This is episode 21. Do you want to learn how and when to implement k-means clustering in Python? Would you like to practice your pandas skills with a real-world project? This week on the show, David Amos is back with another batch of PyCoder's Weekly articles and projects. David talks about a Real Python article on how to perform k-means clustering in Python. We also talk about a new project-based article on the site about how to create a gradebook using pandas, where you'll practice skills like importing, merging, and calculating across groups of data. We cover several other articles and projects from the Python community, including JPEG image decoding, object-oriented development with interfaces and mixins, sparking joy with Python, five package picks from Real Python authors, and more. So let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with the community of experts at realpython.com.\n\nHey, David. Good to talk to you again.\n\nYeah, great to be back. I wanted to start off this week and talk about an article that is diving into kind of a topic I've been interested in for a while, which is JPEG and JPEG compression. It's by Yasub Khalid on his blog called \"Understanding and Decoding a JPEG Image Using Python.\" I'm a photographer, and I've taken professional photos for a few different eras of my life. I did some stuff for music magazines like Mix Magazine. I don't even know if they're still around, but I did some photography for them. Then used to do other things on the side. I was always intrigued by it and always wondered how the compression worked. This article goes deep into it and gives you tools in Python to decode a JPEG compressed image and see what's going on in there. It goes into the whole process of what's happening when something is being encoded and the whole kind of lossiness of JPEGs. One of the first things that's really interesting is that the JPEG color space is YCrCb, which stands for luminance, chrominance red, and chrominance blue. This changes the overall look of the image from RGB into this other space. They can kind of get into this whole idea of what a human can tell as far as differences. There's a lot of information that can get simplified to reduce file size. They break everything into these 8x8 pixel chunks and then apply this thing called DCT, which stands for Discrete Cosine Transform. It looks at the overall balance of all those YCrCb images, and there's an overall initial upper left corner that is saying basically one or a zero, kind of like an overall black or white, which they call DC. All the other ones are kind of alternating very cosine-shaped waves of where the pixels kind of overlap. Each one of these, as it goes along this 8x8 thing, is determining how complex of a combination of all these cosine shapes make up this pattern inside the 8x8. It's really fascinating to me how they could do that and how it translates. There's a really good YouTube video that shows you how that works. After that's done, it goes through a zigzag pattern of determining from that upper left corner of the overall dark-light to these other values. It goes through and basically creates a pattern across the 64 squares of how much of this information is going to be used. From there, it can be quantized, and there are quantization tables saved for rounding down things because the levels are going to start to approach zero near the end. One of the things you can do with that to reduce data is this type of compression, and there are three of them that can happen: run-length, delta encoding, and Huffman encoding. This is where they include another link to another video that explains Huffman encoding. In the 50s, David Huffman figured out a way to compress language down using binary trees and doing a similar idea with colors here. There's a lot of information that gets stored into the compressed file with tables of that information, like what the Huffman tree looks like to re-encode or decode this, and the same thing with how the thing was quantized. That's why JPEG images can fail pretty spectacularly if one of those pieces of information is wrong or one or two bits of that information. You start to have disastrous results in decoding it. The Python part of it goes into this whole idea of going through the reverse of that, and all the data is in the file. It goes through showing you the zigzag pattern of reassembling it, reading from the Huffman tables, reading from the quantization tables. It's just a really neat exercise, and if you're interested in images and images in Python, I think it's a really cool way to dive in and learn a little bit more about not only JPEGs but image encoding and how that might be translated through a Python library. \n\nThe next article I've got is a Real Python one myself. It's a pandas project called \"Make a Grade Book with Python and Pandas\" by Brian Weber. In this project, you get a quick demo of what you're going to be building, but the overall idea is if you are interested in how to aggregate data, merge data, combine data, and use pandas for this whole process. It takes you through the whole idea in this case, the example is truly doing actual grades. You kind of initially explore the data and then you need to go through the process of using pandas to load in the information. It involves like a roster and then unique IDs to connect to different homework files, exam files, and then quiz files. Then you start merging and you start merging based on different indexes, filling in NaN values, the sort of numpy stuff there. Eventually getting into calculating grades and creating formulas to do that stuff. It's pretty slick. I went through the whole thing kind of playing around with it and I decided to use a Jupiter notebook in this case just to be able to keep looking at some of the data as I work through it. You know, maybe suggest that as a way of kind of playing with it yourself as you continue to build this project up. Then get into plotting at the very end, summary statistics, and do a little additional data science stuff right. They're kind of doing a little bit of calculations and figuring out means and kind of grade overall grade curves. \n\nThe next one I've got is an article from Real Python by an author that we just, this is his first article written for Real Python and I think he'll be doing a lot more for us. His name is Kevin Arvey or Arve. This article is called \"K-means Clustering in Python: A Practical Guide\" and this is for the data science folks. It's about clustering algorithms for classification and particularly this article is about the K-means clustering algorithm. It talks about what K-means clustering is, when you would use K-means clustering to analyze your data, how you can implement it using the scikit-learn package in Python, and then also some tips and tricks to help you optimize the algorithm and select a meaningful number of clusters in it. A couple of things I like about the article is he kind of puts this K-means clustering idea into context and compares it to a couple of different types of clustering algorithms. So he talks about partitional clustering, hierarchical clustering, and density-based clustering, and how the K-means sort of fits into all these different types of clustering algorithms. Basically, the idea behind K-means is that you've got a bunch of data points and you're trying to assign some labels to the different points in the data set to categorize them somewhat. It's categorizing them as something, and so it could be anything. Maybe your points represent some kind of label, some sort of animal or something, or it could be maybe a type of cancer, maybe it's like you've got a bunch of data points from a cell biopsy or something, and you're trying to label certain data points as cancerous cells or non-cancers or maybe even identify the type of cancer. There's all sorts of applications, but the cancer one comes up in the article, which is why I'm talking about that. The idea is you've got these groups of data points that you can plot out and you can start to kind of group them together and calculate what would be considered the centroid of a group. You can iterate on this process to get a tighter fit of like, here's all the points that are kind of close to this centroid and all the points that are close to this centroid and all the points, and that would help you then label the different data points with whatever you're trying to label them as. He walks you through setting up an entire scikit-learn pipeline, an end-to-end pipeline that trains a model on a data set, tests it and everything, and then gives you the final model that you can use to run the K-means algorithm. Yes, it's a really in-depth, lots of great examples. In fact, he's even got a great example of where K-means can go wrong and where it isn't the right tool for that particular data set. So there's just a lot of great information here to help you understand what that algorithm is, how you use it, how to apply it, and how to build it in Python. I played around with this in scikit-learn and a little bit of K-means stuff, and so I learned about the elbow and trying to figure out what's an actual good number of groups to divide things in because it becomes less meaningful going beyond or above a certain amount. It was the information I was playing around with was shopping information, okay, and so it was kind of more like a retail environment and",
    "mawkudDRh7I": "Welcome to the Real Python Podcast. This is Episode 23. Have you wondered what Python wheels are and how they are used to package Python code? Does Python use pass by value or pass by reference? This week on the show, David Amos is here to help answer these questions, and he's brought another batch of PyCoders Weekly articles and projects. We cover an article called \"What are Python wheels and why should you care?\" David talks about a Real Python article about pass by reference in Python. We cover several other articles and projects from the Python community, including transcribing speech to text, powerful features Python is still missing, 10 awesome Pythonic one-liners, and more options for packaging your Python code. So let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey David, welcome back. Hey, thanks for having me again. So what are you starting off with this week?\n\nWell, this week I've got an article called \"Four Powerful Features Python is Still Missing\" by Serdar Jaegerlop. This is on InfoWorld, and this talks about these four features that are maybe common in some other languages that aren't in Python. He uses this word \"missing.\" They're still missing in Python. What I think is interesting about reading this article is asking yourself whether or not you actually think they're really missing. Maybe there's a reason they're not in Python, or maybe they're not needed. So we'll just go through the four here.\n\nSure. The first one that he talks about is true constants. This is a big one, and I know if you come from a statically typed language, if you come from Java, C++, even JavaScript has constants, values that once you assign them, they cannot change for the lifetime of your program, or in a similar manner, maybe like an argument to a function, or maybe I should use the word parameter, like you've got a parameter on a function that anything gets passed into that should be treated as a constant for the lifetime of that function. So these are things that don't quite exist in Python. I say don't quite because in new versions of Python, there's actually a little bit of a workaround. So we'll get to that in a second. Python is a dynamic language, and it's also not compiled. People say, is Python interpreted or is it compiled? And the answer is yes. This joke goes, it is compiled to bytecode, and then the bytecode is interpreted by the interpreter. But unlike a language like C++, or something that's getting compiled to machine code, that's what's running. Python doesn't work like that. There's no way to guarantee that the value of some variable is going to stay the same value for the entire lifetime of the program. It can be changed, and that goes for all sorts of things, like in the math module, there's mathematical constants, right? Like pi. Pi is a mathematical constant, but you can change pi in Python. You can import pi from math and then set it to whatever value you want. If you're an engineer and want to call pi 3.14, then go for it. I mean, I guess pi already is rounded off in any computer language, so it's not like it's the true value of pi, which is irrational. But yeah, constants don't exist in Python, and they're never going to exist. I don't think it's really a missing feature. The next feature he talks about is true overloading, and this is the concept of overloading a function. So if I have a function, I don't know, add x and y, it takes two parameters, x and y, and if they're numbers, like if they're of an integer type, I want them to be added the same way you would add any other number. But if they're strings, I want them to be concatenated. So it's got these two different behaviors depending on the type of the argument. Another reason you might overload something would be maybe the number of arguments that get passed to it, or in the order that they're entered. So there might be lots of reasons you might want to overload a function, keep the same function name, but it has different behavior based on how it gets called. So this is not something that you can really do in Python. There are some sort of hacky ways to sort of deal with this if you really, really need to. But I think for most Python developers, this is sort of, like, maybe rename your function so that it's telling you what it's doing. That might be more Pythonic or more in the spirit of Python. The other thing is you can dispatch within the function call. You can say, \"Well, you can use is instance to check the type of a variable and use an if statement to have different behavior based on the type of variable it is.\" So there are ways to kind of do it. It's not that it's not real overloading, though. Now what's interesting is back in 2007, there was a PEP introduced, 3124, for overloading generic functions, interfaces, and adaptation. That's the title of the PEP. Its status is deferred. So it wasn't rejected. It's been deferred. I guess maybe someday we'll see something like that in Python. Again, I would argue this is not necessarily a missing feature, though. I think that being a dynamic language and not being statically typed makes true overloading difficult and also kind of unnecessary. I mean, maybe rename your function so that it's telling you what type it's expecting or something like that. The next feature, tail recursion optimizations. So if you've written a recursive function in Python, you probably have seen this. I can't remember the exact name of the error, but there's a recursion limit that you reach in Python. And it's pretty low. It's a few thousand iterations or recursions. I think what tail recursion optimization does is helps guarantee that you're using as little of the stack, like the call stack as needed, when you're getting into these recursive functions. So it helps optimize things like memory",
    "a3NL30-WeAk": "Welcome to the Real Python Podcast. This is Episode 25. Wouldn't it be nice to use a form of version control for data, something that would allow you to track and version your data sets and models? Well, that's what the tool called DVC is designed to do. This week on the show, David Amos is here and he's brought another batch of PyCoder's Weekly articles and projects. David starts with a Real Python article titled \"Data Version Control with Python and DVC.\" \n\nWe also cover several other articles and projects from the Python community, including where to get exposure to well-written code, delegation, composition, and inheritance. Good Python project ideas for high school students, never running Python in your downloads folder, and more. We also have a special guest this week. I talked to Sadie Parker, who recently joined the Real Python team to help create and edit transcripts for all the Real Python video courses. \n\nWe talk about how you can take advantage of all the features this new resource provides. Sadie also discusses how she uses Python to speed up and simplify the editing process. The transcripts and closed captions are now live on the website for all new courses, and we're working our way through the back catalog. \n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with the community of experts at realpython.com. \n\nHey, David, welcome back. \nHey, good to be back. \nAlright, so you cool with starting off this week with your first topic? \nYeah, let's do it. \n\nSo I've got a Real Python article by Christiane Evanczyk, hopefully pronounced his name correctly. Christiane has done a couple of articles. I'm not sure if there's a second article or third article for us now, but he had about a year or so since the last one. He's come back and written this excellent article for us on data version control with Python and DVC. \n\nIt's a really cool project, this DVC, which stands for data version control. Data version control is a concept, right? Controlling version control for your data. DVC is the project name. It's written in Python. It's sort of like Git for data, and it's really, really cool. I think it solves a really interesting problem that I think a lot of people run into. I think it's not uncommon for people, data scientists, people working in academia, to have their spreadsheets and their data just kind of all over the place. You know, you have some weird version control of, you know, maybe underscore date, whatever, some number at the end of your files, and you just kind of keep track of them that way. And it's a difficult way to sort of keep track of versions of your data set. \n\nYou could use Git already to version control things, especially if you're working with text files and things that are small, right? And things that are small, yeah, if it's a small data set, then Git can kind of take care of that for you. But as you start getting into the realm of larger and larger data sets, Git becomes troublesome for that, and it can be difficult to deal with that. \n\nWhat DVC does is solve that problem. If you have a large data set that you need to keep track of, then DVC is an excellent choice for that. Christian walks you through setting up a working environment using DVC and everything, and he walks through the workflow and kind of compares it to Git. And there's a lot of crossover there. There's a lot of similarities between DVC and Git. So, for example, you can initialize a repository for DVC using `dvc init`, sort of like the `git init`, and that sets a few things up for you. So it creates a DVC folder that holds all the configuration information, so this is just like the `.git` folder that Git does, and it sets up the repository for using the DVC. \n\nYou can add data to a cache, so it works on a local cache, basically, and then you would have like a remote file storage system, and the remote could be another folder on the same machine, or it could be an S3 bucket, or it could be just anywhere, really. It's compatible with almost anything. You have some remote storage and a local cache. \n\nAgain, that's very similar to the way Git works, but you've got a DVC add command that adds things to your local cache, sort of like `git add`. It's kind of analogous to that, although it does a little bit more. It not only says, \"Hey, we need to track changes on this file,\" you add some file using `dvc add` and then file name or folder name or whatever, it says, \"Okay, we're going to track changes on this,\" but it also puts it into that local cache for you already. \n\nThat's a little bit more than what `git add` might do. Then there's a `dvc commit` command, which is like `git commit`. If you have new changes to a tracked file, you commit those to your local cache. And then there's a `dvc push` to push whatever is in your cache to the remote storage. And then on the pooling side, getting data from remote storage, you've got a `checkout` command, a `fetch` command, a `pull` command that does like a fetch and then a checkout. So there's a lot of similarities between DVC and Git. \n\nYeah, it's really targeted towards large data sets that need to have the data version controlled, and it just integrates really nicely with existing kind of Git workflows and everything. Christian walks you through this whole workflow using sort of a pet project. So you build a machine learning model. It's nothing fancy, honestly. You know, he's kind of got the code there for you. It's not the model itself is not the point of the article, so it's really not trying to do anything fancy or get great accuracy or anything like that. It's just, you know, kind of a quick and dirty thing to kind of get you going. \n\nBut you've got an actual file that you can work with and a model that you can work with. You work on training it and then evaluating the performance and then getting that model and the data into a version control. He goes through some interesting ideas on how you might work this in with a Git workflow. So, for example, when you have a machine learning model, you do a bunch of like experiments, and the experiments might use different training data or maybe a different split or maybe just, you know, different things that you want on the experiment, maybe a whole different data set. \n\nSo he talks about one way you might do this is have different branches in Git per experiment. So he kind of walks you through a way to integrate all this with your Git workflow and have something that is easy to reproduce and share with people. He takes a deep dive into something called DVC files, which are the text files that actually get committed to your Git repository, so your GitHub or GitLab or Bitbucket, whatever you're using. \n\nBut these little DVC files contain like a pointer to the remote storage for your data. So instead of having to commit that large data, you're just committing this little tiny little tiny text file that has like a hash in it and some other information. And then another really cool thing about DVC, it really goes beyond the Git analogy. You can create these reproducible pipelines with it. So you can set up like the what needs to happen for fetching the data, what needs to happen for preparing the data, what needs to happen for running the training, and then evaluating that training run. \n\nAnd you can stage all this stuff in a pipeline and use a DVC run command to run that pipeline. And then it's reproducible. The whole workflow is reproducible for everyone on your team or whoever you're sharing this with. So that's a really powerful feature that, that's really cool. The article just, yeah, it walks you through all of this. Christian is a talented writer. I think he has a gift for explaining things really well. It's just a really enjoyable article to read. If you're in the data space, I definitely recommend checking this out. I'm really kind of excited by the idea of it, especially the branching for your data. That sounds like that would be really helpful, yeah, especially, you know, with a lot of the data science kind of things where you are trying different experiments or you're shifting from training data to other data and so forth, yeah, exactly. \n\nAlright, so my first one is a Reddit thread. It's titled \"Expanding Exposure to Good Code,\" and it's sort of this idea of like, you know, where can you go out there to find well-written code and kind of learn from reading code? And this has been an ongoing topic that I've asked as a repeating question on the podcast, but this kind of goes a little bit further beyond necessarily going into reading Git repositories. It has a bunch of other resources that people suggested that kind of went in slightly different directions. Instead of saying, \"Oh, go read the Flask documentation,\" or \"Go read the source code off GitHub,\" and they mentioned some resources that are a little bit different. One is called \"Python Module of the Week,\" which I thought was kind of neat. \n\nOh, that's a good one. Yeah, yeah, it goes into depth on individual modules and kind of lets you focus your attention like, okay, this, you know, you can kind of pick and choose because it's been going on for quite a while, you know, subjects that you're interested in, and you can kind of use it as a checklist to continue to build on your learning. There's an algorithms implemented in Python GitHub repository that I think is really kind of neat too. \n\nOne that I think I've heard before mentioned on a different podcast, probably Python Bytes, but with something called Awesome Python Applications. Another GitHub repository, and this one is talking about actual applications that are out there in the world where the source code is something where you can go and read it and they're organized by the type of application. So it could be, you know, an audio player or a game or some kind of other web resource and so forth where you can kind of learn you know how did they structure this type of code for an existing thing that's out there and it's a really neat way to see not only, you know, I guess one of those awesome lists, you know of like, okay, this is created in Python, and kind of give you an idea of what's happening with it. \n\nI like how they have these examples that you can like, you know",
    "Tlf4JWiZVFA": "Welcome to the Real Python Podcast. This is episode 27. What is an effective way to prepare for a Python interview? Would you like a set of problems that increase in difficulty to practice and hone your Python skills? This week on the show we have Jim Anderson to talk about his new Real Python article, Python practice problems. Get ready for your next interview. The article provides several problems that include skeleton code, unit tests, and solutions for you to compare your work. David Amos also joins us this week and he's brought another batch of PiCoders Weekly articles and projects from the Python community. We cover these topics: structural pattern matching, common Python data structures, a tax attorney uses Python, discover the role of Python in space exploration, and five pairs of magic methods in Python that you should know. Alright, let's get started. \n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com. \n\nHey David, how's it going? \n\nSo we have a guest this week, Jim Anderson has joined us. Welcome to the show, Jim. \n\nThanks, yeah. Welcome, Jim. \n\nThank you. So we wanted to have you on partly as a Real Python team member but also to talk about an article and kind of a new format for Real Python you just created here. Do you want to talk a little bit about it? \n\nSure. We're really excited. We've got a new format that we've come up with. The article is called Python practice problems, and it's really about allowing readers to get some practice before interviews. It's a series of progressively harder problems, and the format is we give you the problem statement and then have a collapse section where we give our answer that we as a team came up with. You can kind of stop the stop reading at some point and then go off and work through your solution and see what you come up with, and then come back and compare it against what we did. It also has a testing mechanism of sort. \n\nRight now, the article is available for anybody who's a subscriber to Real Python, where you get the video courses and all that sort of stuff, and then it's going to go live this coming Monday, I believe. \n\nThat's very cool. \n\nI think it sounds like there's enough momentum, and you know, Guido is really - he's one of the authors on this, and he's a big proponent for adding this feature, so you know there's a good chance that in Python 3.10 we might see the match statement come to fruition. \n\nThat's very cool. \n\nSo my first topic is an article on Real Python, and it's actually from Dan Bader, and it's a take on his book actually. It's kind of an abstract from one of the chapters of the Python Tricks book. It's really in-depth. \n\nI want to shine a spotlight on another Real Python video course. It covers the topic we touched on during this week's episode. It's titled \"How to Implement a Python Stack.\" The course is based on a Real Python article by our guest this week, Jim Anderson. \n\nHey, David, how's it going? \n\nSo we have a guest this week, Jim Anderson has joined us. Welcome to the show, Jim. \n\nThanks, yeah. Welcome, Jim. \n\nThank you. \n\nWe're really excited. We've got a new format that we've come up with. The article is called Python practice problems, and it's really about allowing readers to get some practice before interviews. It's a series of progressively harder problems, and the format is we give you the problem statement and then have a collapse section where we give our answer that we as a team came up with. \n\nI think it's a worthy investment of your time to learn how to implement this type of data structure in Python, and like most of the video courses on Real Python, the course is broken into easily consumable sections, and you get code examples for the techniques shown. \n\nI really like that about it. It's not just like this is a dictionary fundamental stuff. It goes into a lot of the why in all these kind of alternative cases from the collections module. \n\nMy first topic is an article from Jake Edge over at lwn.net, who does a lot of Python news reporting. This one is called \"Structural Pattern Matching for Python Part Two.\" \n\nI think it's just awesome that there's people out there in the real world that are spending a little bit of time to learn some Python and then end up saving way more hours than I spent learning the language on doing these mundane things. \n\nOne of my favorite things about Python is that it's not the only language you could use for this kind of stuff, but a tax attorney is not going to learn C++ to automate things in their life, right? I mean, they're going to spend too much time just learning how to get their environment set up, and they're going to give up. \n\nIn my first programming job, I got really it was sort of the stars aligned, I guess for both parties involved. I was fresh out of graduate school and in need of a job, and the company that I went to work for was an audio-visual company that did these large installations of with lots of automation, so they were doing things like universities and hospitals and schools and things like that, so with big distributed systems, and they needed a programmer to program the control and automation for it. \n\nThis is one of my favorite things about Python. Python is not really the only language I guess that you could use for this kind of stuff, but you know, a tax attorney is not going to learn C++ to like automate things in their life, right? I mean, they're going to spend too much time just learning how to get their environment set up, and they're going to give up. \n\nThis is one of my favorite things about Python. You know, Python is not really the only language I guess that you could use for this kind of stuff, but you know, a tax attorney is not going to learn C++ to like automate things in their life, right? I mean, they're going to spend too much time just learning how to get their environment set up, and they're going to give up. \n\nI remember learning about enter and exit, and until then, I'd kind of seen some of the dunder methods and thought, \"Oh, that's kind of interesting,\" but learning about those, it's like, \"Oh, I can make my own context manager. It's not just something under the hood that the language is doing for me.\" \n\nI want to thank Jim Anderson and David Amos for coming on the show again, and I want to thank you for listening to the Real Python Podcast. Make sure you subscribe to the podcast in your favorite player, and if you like the show, leave us a 5-star rating and a review. \n\nI want to thank Jim Anderson and David Amos for coming on the show, and I want to thank you for listening to the Real Python Podcast. Make sure you subscribe to the podcast in your favorite player, and if you like the show, leave us a 5-star rating and a review. \n\nMake sure you subscribe to the podcast in your favorite player, and if you like the show, leave us a 5-star rating and a review. \n\nI've been your host, Christopher Bailey, and look forward to talking to you soon.",
    "7zEwPfm-Ar4": "Welcome to the Real Python Podcast. This is Episode 28. One of the big decisions a developer has to make is when they sit down to code, what tool do they want to use? Would you like a tool that understands Python and is there to help with suggestions, definitions, and analysis of your code? Many of the developers that I've been working with have been turning to the free tool from Microsoft called Visual Studio Code. This week on the show, we have Savannah Ostrowski, Program Manager for the Python Language Server and Python in Visual Studio. We discuss Pylance, a new language server with fast, feature-rich language support inside of Visual Studio Code. Savannah explains what a language server is and the types of features it can provide. This includes type information, code completion, automatic imports, dead code analysis, and more. We also have a discussion about type checking in Python, which leads to how Pylance leverages the static type checking tool, Pyright, and writer type stubs, those .pyi files you might have seen. Okay, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey, Savannah. Welcome to the podcast.\n\nHello, Christopher. Thanks for the invite.\n\nI thought maybe we could just talk a little bit about what you're doing at Microsoft and the team that you're working with.\n\nYeah, totally. I joined actually fairly recently in January. I actually joined as a program manager, and before that, I was working as a software engineer. This is like my first foray into the program management role, which is kind of exciting. And super exciting to be on a team that's really technical and really deep in the Python space. And so I joined as the program manager for the Python Language Server and Python in Visual Studio. And I've kind of just been working on Pylance in secret for a couple of months and then in the open since the end of June.\n\nYeah, that's one of the main reasons I wanted to talk to you. A handful of people at Real Python asking me questions about Pylance, and we're excited about it. And then I mentioned it to Russell Keith-McGee, the guy who creates Beware and Briefcase and so forth. And I mentioned that I was interested in talking to you, and he's like, \"Oh, I would listen to that episode.\" So I was like, \"Exactly.\" So yeah, there's some people that are very interested in the subject.\n\nMaybe just do a quick background of what you're working with Python.\n\nYeah, so it's actually kind of funny. I come from a non-traditional computer science background in a mixture of technical geography and computer science. So like, think satellite imagery and whatnot. Oh, cool. And so Python was actually my first programming language, gosh, like seven or eight years ago now. Very like basic scripting. And then since then, I've kind of been working on and off with Python, kind of doing everything from data engineering to full-stack development, like Flask and kind of like React type apps. So yeah, so I've kind of been all over the place with Python.\n\nI got a chance to interview Armin Ronacher about Flask. It was a fun conversation, talking about the history of it and kind of his involvement with the project. And it's been fun talking to people that are involved in these projects and these things that are kind of building up. And I'm really intrigued by what Microsoft is doing in this sort of developer space and especially Python, creating all these tools.\n\nSo you said you just recently started in January in this particular role. Were you doing other roles at Microsoft before that?\n\nNo, so I was an external hire to Microsoft in January. It's my first role at Microsoft actually.\n\nOkay, I guess maybe we could talk about the origins of the project. Were you initially working on the Visual Studio team or the Visual Studio Code team?\n\nIt's kind of interesting. So I joined up for the Python Language Server team and then Python in Visual Studio as kind of like part of my main role. But my focus has been primarily on the Language Server since I've joined. But yeah, the Language Server is kind of like, and we can get into this, I'm sure you have questions about the LSP and stuff.\n\nOh yeah, it's like a client-agnostic type piece of software. So I partner with a lot of teams, like right now very closely with Visual Studio Code and that team. But there's plans for Pylons to be incorporated into other products in the future. So another Azure offerings. So it's kind of like a very collaborative role in that way. Yeah, you get to work across a lot of different groups, probably getting a lot of feedback.\n\nYeah, it's actually really interesting too because the Python team at Microsoft has grown a lot. And so we have a lot of PMs that have very discrete focus on things like, I'm a date, like they focus on data science, Python stuff. Whereas Pylons is very much like this overarching, like I have users that are like, you know, people brand new to using Python, that have like, you know, this is their first programming language, all the way up to like where I'm a machine learning engineer or I do full stack web development. So like my users that I have to consider are really broad, which I think is like one of the most fun parts of working on Pylons is like, how do we make this approachable for everyone? Yeah, that I think is so crucial because that's one of the kind of ongoing conversations that I have with everybody. You know, me being myself, you know, fairly new to Python and wanting to learn through teaching and doing this podcast to do the same kind of thing to kind of break things down and explain them. I think that's always a great direction to kind of come from is to always sort of look at like, okay, well how are people going to use this?\n\nTotally. And I feel like any way that like we can make a product like makes Python more approachable, especially like when you're first starting to learn how to code or like learning Python, I feel like there's already so many things that are like overwhelming and like, you know, that you have to kind of grapple with. It's like, you know, finding like the wins for like our new developers I think is like something that's really empowering for me.\n\nAbsolutely. I guess we could dive right in then and just say, my first question is, okay, when I heard the term a language server, my head kind of spun a little bit. I'm like, okay, what does that mean? Like, what is a language server in that terminology?\n\nYeah, yeah. So you're not alone. I was also new to the concept of a language server when I started at Microsoft. And so like the way I like to think of a language server is kind of like a provider of all the bells and whistles of what I would consider a good developer experience for Python. So kind of like everything from like completions to signature help and doc strings and code navigation, you know, errors and warnings in your code. So like a language server is really just like a piece of software that is written in a client-agnostic kind of way in that it doesn't care who you're at what editor IDE you're using, but like, well, specifically like we're using a language server that abides by the language server protocol. So that makes it like easy to kind of plug and play into different editors and IDs. So long as they also communicate under that protocol. So that part's kind of new. The idea of making a language server have a protocol so that it can work across the landscape, that's kind of a newer development. I mean, Microsoft has been working on that for a couple years now. I think like the historically, people who are developing tools that were in the language server flavor were, you know, writing support for Python for a specific editor IDE. But now, like with the language server protocol that standardizes how servers and development tools can communicate, and so it's kind of like a win for people who are both working on like these providers, but also like the tooling vendors because it means that you can just write one application and have that kind of plug into whatever editor. Obviously, it's something that you can add to VS Code pretty easily. What are other IDs that it could be used with?\n\nSo for Pylons, Pylons is specifically made for Microsoft products. Okay. But for like, if you were writing like a your own language server, you could, you know, use the LSP, Language Server Protocol, and create a language server that could be used in something like, I don't know, Sublime or like, or Vim or something like or with them or whatever. Okay. Yeah. So it's not necessarily tied to like a Microsoft product. It's like you're creating it so that you can, I guess it's kind of like in my opinion kind of like productizing your language server. So it's kind of like, it stands alone, but it can be used with a lot of other things. Right. So it's kind of, it may be hopefully expanding the footprint of it and getting more users on board. Totally. Before Pylons, were there other tools that were using the Language Server Protocol? The original language server offering, the Microsoft Python Language Server, abided by the Language Server Protocol largely. There were areas that it did not, but with Pylons, we've been really trying to make it totally LSP compliant to save us headaches later. Yeah, that makes sense. Yeah. So to kind of go back a little bit, to talk about the things that it serves or provides, you kind of listed off a bit of a laundry list of those things. Can we go back over them one by one a little bit?\n\nYeah, totally. This is kind of, I'm glad you're asking that because I feel like when I mention that I work on a language server, people are like, \"So what is that?\" And I list out a million things or like, \"But I get those without Pylons, like why is Pylons special?\" Yeah, sure. So Pylons provides things like completions, or some people call them auto-completions. So if you're typing and you hit dot and you get the list of potential functions or, you know, variables that you could use, that's something that Pylons provides. Also, signature help. So that's kind of like, while you're typing, Pylons has the ability to kind of help, in my opinion, kind of help you write code a little easier because it basically provides you with the signature and a tooltip so that you know what parameters the function is expecting. And it also handles functions where there's like multiple overloads on that function so you can kind of toggle that tooltip. Yeah, I was looking at your video, a demonstration of that, and it kind of intrigued me because overloading is, yeah, you know, kind of a bit of an advanced topic for, you know, somebody who's getting into Python and learning just object-oriented stuff right away. And so I was like, \"Oh, that's really kind of funky that it allows you to see all the different, like, there's literally like a one, two, three up and down arrow of the different things that this, you know, function could have been overloaded to to handle these different types.\" And I'm guessing that's through, does that require annotations for that to work the way that works is kind of like, if you have, so you don't need to have like annotations or stubs to get that. It's basically like, if you've created a function that has an overload, we basically can, can find that information and then provide it to you in the tooltip. And the one thing that's kind of interesting about the signature help is that, well, you're able to like manually kind of toggle between them. To your point about like, if you're a new Python developer, you may not understand why we're showing you multiple, right? Something that I think is pretty cool is that we have the ability to kind of like, so let's say you're invoking a function that has multiple overloads and you've typed the first parameter, and you have an overload for that function that actually takes in two parameters. As soon as you start typing the second parameter, we're just going to switch over to the other signature for you. So we kind of like keep track of where you're at and infer like what signature is applicable to the function that you're trying to invoke, which path you're traveling down. Exactly. So you don't necessarily have to manually click through to find the one that's applicable to what you're trying to do. Like we do that for you. And we also keep track of like named params as well. So that's something that I think I was really excited about when we were able to ship that in Pylance. That stuff looks really cool. I think that the way the definitions sort of show up is different, like the that layout looked really different to me. How it's kind of like, kind of like a split window. Are you talking about the when it's providing hints and then providing the, I'm going to say the wrong word, but the descriptions of the functions and the arguments and everything kind of like almost kind of formatted like a code formatter. Yeah, whereas something, yeah, it's different. Yeah. So the difference is that we have docstrings. So what you're saying, the top part of that tooltip, if you're invoking a function and you get completions and you see on the right hand side, the bigger tooltip, we prioritize the signature in that tooltip. And I think the difference that we're also trying to figure out the best, if there's additional improvements we want to make here for readability, especially for kind of beefier functions. But like we show the types of each parameter in the, the signature, which if you don't use types in Python, maybe you don't care about, but I still think that it's kind of valuable, especially if you're like, I don't know, invoking something like read CSV from pandas and there's like 50 parameters that it could possibly take in, you're like, which one is this? Yeah. So yeah, that's a huge one. Yes, it's like that's like the, the best example. So yeah, so we, we have the, the signature at the top with the types, the parameter types and the return type. And then if possible, we get the docstring. So that's kind of like the, the general, our like hierarchy that we have now. But definitely open to user feedback. If there's ways that people think that the readability there could be improved. Yeah. So that kind of covered two things, like the code hints for like when you're hitting dot and getting the code completion and then you're getting the docstrings and the types of parameters and so forth that it can accept. If we kind of continue on the list, what else was there? Yeah, yeah. Yeah. So we also have like all the code nav stuff. So like go to definition. Something pylance handles right now. We show you both the definition of that function, but we can also show you the the signature in the type stub, which is something that is interesting if you're into types in Python. And then also diagnostics. So that's you know, any like any error or warning that appears in your code. We have different levels of diagnostics that we can provide depending on the type checking mode that you select. Okay. So by default, type checking is off as types are kind of this newish construct in Python. So by default, you're going to get errors and warnings for things like unresolved variables or unresolved imports. And then if you enable basic mode, you're going to get, you know, basic set of type checking rules. And then strict mode, you're going to get even more type checking rules at the highest level of severity. So they're going to appear as errors. Yeah. So that brings me to want to ask a little more about type checking and if you could just to talk a little bit about the different ways that the types can be sort of defined in your in your Python files. You know, there's right now there's like a couple different approaches, right? There's like, you know, actually annotating your code, right? But then you also have things like type stubs, which act as separate files, you know, that are what I kind of describe as pseudo Python because it's, you know, just function signatures and return types. Yeah, those are really funky. Like that's something I wasn't that familiar with. And, you know, these .pyi files, I guess kind of introduced with PEP 561. Yeah. So I can kind of reference that, but like you're saying they're almost like just the definitions, these kinds of things that, you know, something a tool like Pylance would really love to have to be able to provide you more information about the code that you're writing. So these kind of sit alongside your other files. From what I'm reading and trying to do my research, it looks like, you know, it would read that .pyi file first before it goes into the .py file. And inside of it, it would have, you know, the same way you start off, you're defining your function, but then you would have the annotations right there with it, with the return value, the, you know, the little sort of pseudo arrow and return type, and then a dot, dot, dot, basically saying, you know, implemented somewhere else, you know. Yeah, and so that really intrigues me and I'm always like, you know, I really want to see some examples of these things. And I was, you know, kind of stumped then because I, you know, I kind of started my research a little late into, get into this conversation. And I'm like, okay, well, what are examples of that in the wild? Like where can I find these .pyi files and being used and to kind of get like a good example of what's happening? If you have a good example. So Pylance is shipped with a bundle of type stubs for popular modules from a repository, an open source repo called Type Shed. Okay, and so you can go into Type Shed and Type Shed has, you can see .pyi files for some mostly Python 3 but also some Python 2 modules, which is kind of interesting. And we also, like, if you're interested, Pylance also has the ability to provide you with code actions. So if you're in the strictest type checking mode, there's actually a code action that you can generate your own type stub from. It's really bare bones, and there's definitely some manual intervention needed to get it to be like totally accurate. But if you're just looking for like a skeleton of like what that structure looks like, I think that those are two resources you could check out. Okay, I think there's also some good documentation somewhere. I can't remember what website",
    "uZtVq2Isy5o": "Welcome to the Real Python Podcast. This is episode 29. If you use Python, then you probably have used pip to install additional packages from the Python Package Index. Part of the magic behind pip is the dependency resolver, and there's a new version of it in the latest version of pip. This week on the show, we have Sumana Hari Harshara and Georgia Bullen who have been working on the recent releases of pip. Sumina is the project manager for pip, and Georgia has been working on pip's user experience or UX resolver is how pip determines what to install and in what order based on package requirements. We talk about how you can help from updating to the latest release, testing out the new resolver with your projects, and answering surveys about your experiences. A ton of work has gone into making the updates this year. We also talk about the funding of projects like this in the open source community. All right, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with the community of experts at realpython.com. I want to welcome you both to the show. Hi, Georgia, hi, Sumana.\n\nHey there, Christopher. Thank you so much for having us. You guys kind of reached out about a month ago to talk to me about some updates in what's happening with the pip project and some of the new releases. I know another group of people were on Brian Awkin's show, Test and Code, and they were talking about a slightly earlier release in June. What's going on with pip right now that you guys wanted to come on the show and talk to us about?\n\nWell, I'm happy to go into that first. I want to give a little bit of a brief introduction to what pip is and why it's important. There might be people who are listening to the show who are very new to Python or who have been using it but haven't really thought about what it is that pip does and why it gets complicated. Now, a computer needs to know",
    "yinbvCCitT0": "Welcome to the Real Python Podcast. This is Episode 31. The Python return statement is such a fundamental part of writing functions. Is it possible you missed some best practices when writing your own return statements? This week on the show, David Amos returns with another batch of PyCoder's weekly articles and projects. We also talk about functional programming again with an article on the Python map function and processing iterables without a loop. We cover several other articles and projects from the Python community, including interactive data visualization with PyGal, everything you need to know about named tuples PEP 638, syntactic macros, Python for kids, the new NVIDIA Jetson board, and a reinforcement learning project named football. Alright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com. Hey David, welcome back.\n\nHey Chris, yeah, it's good to be back again. We're going to dive into a variety of articles again. I was going to start off this week. I have, I think I've mentioned multiple times that I'm into data visualizations, and this one came up in PyCoder's, and I was like, \"Oh, this looks really cool.\" It's titled \"Interactive Data Visualizations in Python with PyGal,\" and I had not heard of this library. It's on the Towards Data Science medium blog. This particular one is by Sarah Metwali talking about creating these not only visualizations, but one of my favorite things, especially if anybody's looked at my Bokeh course, is I really like interactive graphs and charts, stuff where you can filter stuff out or remove parts of the data and showing it. And this library looks like it does a really good job of that, and then it has a really unique sort of feature to it that I was kind of surprised by. It exports SVGs, and I've seen SVGs, which are the scalable vector graphics, and they're great because like anything vector, the resolution can be scaled up and down, and they print really nice, and you don't get that kind of blocky raster kind of thing that you might have to deal with, especially with like computers today, everything's switching to retina-type displays, double times displays, and things like that, and the idea of something that can kind of go across that that's described by text, you know, that can be scaled into graphics is very intriguing to me. And then what I didn't know a lot about SVGs is that they can be interactive, that you can have a thing where as you hover your mouse over it, it'll highlight, maybe it's a map or an area of a graph, and can then do the hover showing values inside of it. But then also you can kind of click on different entries, say in a list of things in a graph, and so it's a neat library. One concern I have about it is that it is a little old. It looks like most of the main updates to it were done in 2016 or 2017, so I'm not sure what the status is right now of the project, but maybe this renewed focus will get some more attention on it. I like how it looks. It definitely has a lot of the standard bar charts and maps, tree maps, which I'm not that familiar with doing. The article goes into taking data, very popular at this time of COVID data, and kind of spreading it out across, in this case, counties in different states, and showing the different data. If you're interested in data visualizations and you're looking at possibly different ways that you could present it, the idea of being able to export out these SVGs and be able to embed them maybe in a Flask application or Django, or just being able to embed them within HTML is pretty powerful. I definitely think it's worth checking out. They go through everything like I was mentioning, pie charts, they do this thing called the gauge charts that are sort of a donut shape, and then lots of styling, yeah, with lots of colors, and it's definitely worth checking out as another potential graphing library. And then I'm really excited about the idea of additional ways of saving the graphs as these SVG files because I think that could help with not only the interactivity, but also just the idea that it can kind of scale to whatever kind of display or div or whatever you stick it into. Yeah, it was so unique because one of the reasons I wanted to feature this article in PyCoder's, yeah, because of this idea of these interactive SVGs, I hadn't explored at all. I was kind of surprised that you could even do it, although I mean in retrospect, it's like it's not that surprising once you sort of like peel apart the way SVG's work and everything, but yeah, it just seems like, uh, she says at the beginning of the article, you know, it just gets overlooked, this PyGal when people talk about plotting libraries, and you know, I think the fact that it hasn't been maintained in a while, I'm looking at the GitHub right now, the last push to master, I don't know about the latest release, but the last push to master was July 17, 2018. So, yeah, okay, over two years ago. Yeah, and I don't even know if that's like, you know, if that's whatever that was was in a release, the latest release that's like on PyPI might be even older. So that is one reason, you know, you may not want to use it, especially in something that heavily relies on, you know, it's like running in production and relies on code that's going to be secure and well maintained and everything. Yeah, it makes me think about all the things coming out with Python 3.9 and right, also the idea of making your code maintainable and updated and so forth. But it looks like a really cool library and maybe, you know, someone will be inspired to maybe help out and see if it's worth, you know, kind of dusting off and getting back up to speed. I like how it looks. It definitely has a lot of the, you know, all the standard bar charts and maps, tree maps, which I'm not that familiar with doing. The article goes into taking data, very popular at this time of COVID data and kind of spreading it out across, in this case, counties in different states and showing the different data. If you're interested in data visualizations and you're looking at possibly different ways that you could present it, the idea of being able to export out these SVGs and be able to embed them maybe in a Flask application or Django or just being able to embed them just within HTML is pretty powerful. I definitely think it's worth checking out. They go through everything like I was mentioning, pie charts, they do this thing called the gauge charts that are sort of a donut shape and then lots of styling, yeah, with lots of colors. And it's definitely worth checking out as another potential graphing library. And then I'm really excited about the idea of additional ways of saving the graphs as these SVG files because I think that could help with not only the interactivity, but also just the idea that it can kind of scale to whatever kind of display or div or whatever you stick it into. Yeah, it was so unique because one of the reasons I wanted to feature this article and PyCoder's, yeah, because of this idea of these interactive SVGs, I hadn't explored at all. I was kind of surprised that you could even do it. Although, I mean, in retrospect, it's like it's not that surprising once you sort of like peel apart the way SVG's work and everything, but yeah, it just seems like, uh, she says at the beginning of the article, you know, it just gets overlooked, this PyGal when people talk about plotting libraries and you know, I think the fact that it hasn't been maintained in a while, I'm looking at the GitHub right now, the last push to master, I don't know about the latest release, but the last push to master was July 17, 2018. So, yeah, okay, over two years ago. And I don't even know if that's like, you know, if that's whatever that was was in a release, the latest release that's like on PyPI might be even older. So that is one reason, you know, you may not want to use it, especially in something that heavily relies on, you know, it's like running in production and relies on code that's going to be secure and well maintained and everything. Yeah, it makes me think about all the things coming out with Python 3.9 and right, also the idea of making your code maintainable and updated and so forth. But it looks like a really cool library, and maybe, you know, someone will be inspired to maybe help out and see if it's worth dusting off and getting back up to speed.\n\nOne of the things I really like about this article is that it has a whole section on the differences between named tuples and data classes, which I think is really, you know, if you're going to have a complete article on named tuples, you have to include this because there's, I guess the sentiment I've seen, coming from some people on Twitter and some comments that I've seen on articles, is that they kind of feel like, with the introduction of data classes in 3.7, named tuples are obsolete. And that is absolutely not the case. There's a very big difference between named tuples and data classes, and that is immutable structure versus mutable structure, right? And it kind of comes down to the difference between like a tuple and a dictionary in a lot of ways. So, I don't think that named tuples are obsolete at all. In fact, the whole tuple versus dictionary thing is actually a very relevant comparison in my mind because you know you don't say that tuples are obsolete because we have dictionaries, right? So, they're serving kind of different purposes. And I think, you know, the fact that you get an immutable and hashable data structure out of a named tuple is really advantageous in certain situations. The fact that they have a smaller memory footprint, they're based on code written in C instead of your Python, right? So, the speed thing again, yeah. So there's like some speed advantages which, you know, on an individual basis isn't, it's not like you're getting mega differences between those two things, right? But if you're having to process millions of items, right, that's always what it comes to, right? It could, you know, it could mean quite a large difference in the performance of your program. So, yeah, it's just something to keep in mind that, you know, think about if you're using a data class, which I think in many instances you should, you might want to consider using a named tuple instead if you need some of the advantages that named tuples provide. So, and that hashing and immutability kind of being the key thing there, right?\n\nSo, this week I've got, it's not a very new project as far as I can tell, it's like a year and a quarter hold me, a year and a few months, okay? But I just heard about it, it's from Google, it's called Google Research Football, and I was, it came up as like, I think one of the trending projects, Python projects on GitHub, and so I just was like, what is, what is this, I'll look into it. It's really cool, it's all about reinforcement learning, and reinforcement learning is used to train, like, AI, they can interact with like an environment, it can solve complex tasks, and it can work with real-world applications like robotics, like self-driving cars, uses that's like all reinforcement learning, they've been used to do things like learn to play console games, learn to play Go, chess, you know, all these things, and you know, get good enough that they can actually beat some of the best masters we have of these types of games. So, this is a research environment for reinforcement learning that is based on the world's most popular sport, football, or soccer if you're American, the football where you actually use your foot, that's right. It's modeled after like, I mean, it looks like the FIFA game you would play on like Xbox or something, it's a very complex 3D environment, it provides this whole engine for you to use to train agents to learn to play football, and it's just incredible, I mean, it's beautiful graphics. Yeah, it looks like it uses Pygame and SDL, it's, yeah, it's all written in Python, and you know, I'm looking at, so there's the GitHub repo that's got a bunch of information, and then at the top of their readme they've got links to things like the game server and a blog post that's actually got like pictures and stuff within it, but yeah, they're using Pygame, OpenCV, and SciPy, and something called Gym, huh, I've never heard of Gym before. Gym, yeah, a toolkit for developing and comparing reinforcement learning algorithms, there you go, yeah, so it's, I think it's, is it 100% Python, what's on the side here, 72.7% Python, 25.5% Jupyter Notebook, so it's like basically all Python, which is kind of crazy because if you look at the pictures and from the blog post, I mean, this is, it's just like, I've never seen a Pygame game look like that, it's really good, so really cool. So, if you like soccer and are interested in reinforcement learning, this looks like a really cool way to kind of combine those two interests and have a lot of fun working with that, nice. Yeah, it kind of ties in a whole bunch of stuff there, and then I haven't talked about gaming a whole lot in the last several months, but I'm intrigued to kind of dive back into that, and I have some guests in mind that hopefully I could get onto the show, that'd be fun. On the show, dive a little bit deeper into that, and this would be kind of a cool project to explore. Yeah, well, that's great, thanks for coming on the show and bringing all those articles again. Yeah, thanks for having me, all right, talk to you soon, David, see ya.",
    "jDXGlyNHDCc": "Welcome to the Real Python Podcast. This is Episode 32. Do you have gaps in your Python learning path? If you're like me, you may have followed a completely random route to learn Python. This week on the show, David Amos is here to talk about the release of the Real Python book Python Basics: A Practical Introduction to Python 3. The book is designed not only to get beginners up to speed but also to help fill in the gaps many intermediate learners may still have. David's been working on the book for the last two years, and we dive into all the resources that come with it. These include code challenges, quizzes, and multiple projects that are designed to help you cement your learning. We also discuss the people and processes involved in creating, reviewing, and updating the book. All right, let's get started.\n\n[Music]\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com. Hey, David. Hey, Chris. Welcome back to the show. It's kind of a slightly different format this week. Instead of bringing a bunch of topics, you brought some actually really cool news about the book you've been working on forever. Definitely, yeah. So we're moving from the early access release of the Python Basics book. What's going on? Well, I've been working on this book with Dan Bader and Joanna Jablonski, the executive editor, for over two years now. Wow, and it's been in early access for over a year. I can't remember the exact date that we set that up for early access, but yeah, it's the Python Basics, and it covers the introduction to programming. It doesn't assume that you've had any experience whatsoever, and it's kind of a rewrite, if you will, of the existing book from what's known as the Real Python course bundle, which is Book One of that. We've just been expanding on it and updating it, and we've now reached a point where we can actually take it out of early access and call it done. So it's pretty exciting. That's cool. During the early access phase, you've had the ability to get lots of feedback and input from readers checking it out. How's that shaped what you've been doing? That's been a really, really good experience. It was very different. We kind of got it to a point where we felt comfortable letting people look at it, and then they gave us their feedback. So we've been able to kind of course correct on a few things and change the scope in some cases, or go into more detail, less detail. I mean, we got tons of feedback from people that really helped us gauge how it was working for them. You know, were they comprehending? Were they understanding? What did they still find confusing? So we were able to go in and kind of tweak that. Yeah, I found it enormously helpful. I was also very pleasantly surprised that, you know, the vast majority of the feedback was positive and constructive criticism. There was not really any negativity. So that was really nice, not to say that it was perfect, and we definitely had people say, \"I don't understand this,\" but yeah, everything was very constructive and enormously helpful. So I'm very grateful to all the early access readers. In some ways, you kind of mentioned who the intended audience is. In this case, I guess we could kind of expand on it a little bit. Is it a different group of people potentially from the original version? Possibly. I think it's a little bit more focused. So the original version, I think, was, it made some assumptions that, so for example, it assumed you knew how to use the terminal. It assumed you were familiar with maybe like, you know, how a file system worked and things like that. So it was, I think, geared more towards, it wanted to include as many beginners as possible, but also kind of be more for the people that, \"Hey, if you're coming from Java or C++, or some other language, then this would also help get you up to speed without sort of wasting your time on these things that you probably already know.\" Okay, so with Python Basics, we still try to keep it interesting enough that if you are coming from another language, you could use it to get up to speed with Python, but we really wanted something that would also, you know, if you had no experience programming whatsoever, you could get started with this book. So it doesn't assume that you know what a terminal is or even how to open it or how to type commands into it. It doesn't assume that you have any kind of sophisticated understanding of the file system or anything like that, or like, you know, things like character encoding or all this kind of stuff that I think sometimes gets taken for granted and can be a point of contention for people or confusion. Yeah, we really tried to hold people's hands through that and make it accessible to folks that are, this is the first time they've ever programmed a computer. What I think of is that would be really useful, and I'm not sure I haven't really gone through a lot of the book yet, is this whole just the installation process. I've had multiple situations where I've moved from one platform to another, or like, in some cases, I'm sure a lot of people are dealing with this year, of going from an office computer to then setting it up on a personal home computer and getting Python configured. Maybe it's the first time they're using Windows or a Mac or Linux, or they're shifting between these. Is that part of what's in the book too? Yeah, so the very first chapter is about installing Python, and we cover it for Windows, MacOS, and Ubuntu Linux, which are kind of the three most popular operating systems that we see among our readers. And I think, you know, the book walks you through that process. For Windows and MacOS, we use the official python.org installers. And there were some things to consider there that we felt like, say, for example, for Windows, you know, you can install from the app store, which, right, honestly, for a total beginner might be the right way to do it, but you end up with not necessarily the kind of environment you would want for professional development if you do it that way. There are a few limitations from installing from the app store that you don't get really if you're going to install, I think, for, you know, for a professional Python development environment on Windows, you want to install from the python.org installer. Okay, we made that decision there, which if you read, we've got a Python installation and setup guide article on the website. If you read that, it suggests using the app store installation for beginners. So that is one, I guess, little difference there. But for MacOS, we walk you through using the python.org installer, which I halfway through the book. It's kind of a funny story. I don't know about halfway through, but at some point, I was mainly using a Linux distribution, using Ubuntu on an old Lenovo laptop. The laptop died and I didn't have a work machine anymore at home. So I kind of on a whim decided I'm going to switch to MacOS and switch to MacOS and got a MacBook. I followed the instructions to get Python installed with homebrew, which was, I guess, so it seemed like that was kind of the recommended way to install on MacOS when I was looking at things. Even on Real Python, we had in that installation guide, and I started running into all sorts of problems with IDLE and with Tkinter when I did that and was like, man, what is going on? I had none of these issues on Linux. I'd use Python on Windows, had none of those issues. So I discovered that, you know, there were some serious limitations to that, which was great because the original installation instructions for MacOS in what became the Python Basics book was to use homebrew. So I was able to get that all corrected, you know, get a nice solid development environment set up using the python.org installer. I'd have to agree with that, like, you know, being a Mac user for a long time, mainly because I do a lot of video and audio stuff, again, I think this is something that was really common four or five years ago. You know, the suggestion was to use homebrew, but I had a really kind of awkward experience with it. It had some really strange things written inside of homebrew as far as like how it was like doing version numbers. It's something I discussed, I think, last week about, you know, like it was doing greater than, less than kind of things with certain version numbers and all these kind of weird, weird kind of things. It wasn't super clean. You know, and also just the way and where it installed it, whereas the installation from Python, like I had to redo my entire iMac recently and anyway, so downloading from Python was the best way to do it. In my experience, it was been super clean and I've actually been able to install a couple different versions of Python and switch between them pretty easily, you know, without having to like dive into Docker and other kinds of things. Right, seems to work pretty smoothly. Yeah. I think the Kindle library works in a similar way. So yeah. Yeah. And we've had folks reading it on, you know, all three of those formats and using, you know, ePub readers that I've never even heard of and all sorts of stuff. So yeah, it's kind of been battle tested. It's a vast world. Yeah. I guess kind of a related topic would be to think of it in a digital form. You don't think about it this much, but in a printed form, like what does this translate into like a page count? Like how big is this book? It's not super small. Okay. It's not a small book. I mean, there's some things to consider there though. I'm looking at the, I've got like a test version that we printed, yeah, a while ago, and it has changed quite a bit since this test print I've got in my hand. Yeah. For example, the original installation instructions for Mac OS in what became the Python Basics book was to use Homebrew. So I was able to get that all corrected, you know, get a nice solid development environment set up using the python.org installer. I'd have to agree with that, like, you know, being a Mac user for a long time, mainly because I do a lot of video and audio stuff, again, I think this is something that was really common four or five years ago. You know, the suggestion was to use Homebrew, but I had a really kind of awkward experience with it. It had some really strange things written inside of Homebrew. As far as like how it was like doing version numbers. It's something I discussed, I think, last week about, you know, like it was doing greater than, less than kind of things with certain version numbers. And all these kind of weird, weird kind of things. It wasn't super clean, you know. And also just the way and where it installed it, whereas the installation from Python, like I had to redo my entire iMac recently and anyway, so downloading from Python was the best way to do it. In my experience, it was been super clean and I've actually been able to install a couple different versions of Python and switch between them pretty easily, you know, without having to like dive into Docker and other kinds of things. Right. Seems to work pretty smoothly. Yeah. Yeah. And we've had folks reading it on, you know, all three of those formats and using, you know, ePub readers that I've never even heard of and all sorts of stuff. So yeah, it's kind of been battle tested. It's a vast world. Yeah. I guess kind of a related topic would be to think of it in a digital form. You don't think about it this much, but in a printed form, like what does this translate into like a page count? How big is this book? It's not super small. Okay. It's not a small book. I mean, there's some things to consider there though. I'm looking at the, I've got like a test version that we printed, yeah, a while ago, and it has changed quite a bit since this test print I've got in my hand. Yeah. For example, the original installation instructions for Mac OS in what became the Python Basics book was to use Homebrew. So I was able to get that all corrected, you know, get a nice solid development environment set up using the python.org installer. I'd have to agree with that, like, you know, being a Mac user for a long time, mainly because I do a lot of video and audio stuff, again, I think this is something that was really common four or five years ago. You know, the suggestion was to use Homebrew, but I had a really kind of awkward experience with it. It had some really strange things written inside of Homebrew. As far as like how it was like doing version numbers. It's something I discussed, I think, last week about, you know, like it was doing greater than, less than kind of things with certain version numbers. And all these kind of weird, weird kind of things. It wasn't super clean, you know, and also just the way and where it installed it, whereas the installation from Python, like I had to redo my entire iMac recently and anyway, so downloading from Python was the best way to do it. In my experience, it was been super clean and I've actually been able to install a couple different versions of Python and switch between them pretty easily, you know, without having to like dive into Docker and other kinds of things. Right. Seems to work pretty smoothly. Yeah. Yeah. And we've had folks reading it on, you know, all three of those formats and using, you know, ePub readers that I've never even heard of and all sorts of stuff. So yeah, it's kind of been battle tested. It's a vast world. Yeah. I guess kind of a related topic would be to think of it in a digital form. You don't think about it this much, but in a printed form, like what does this translate into like a page count? Like how big is this book? It's not super small. Okay. It's not a small book. I mean, there's some things to consider there though. I'm looking at the, I've got like a test version that we printed, yeah, a while ago, and it has changed quite a bit since this test print I've got in my hand. Yeah. For example, the original installation instructions for Mac OS in what became the Python Basics book was to use Homebrew. So I was able to get that all corrected, you know, get a nice solid development environment set up using the python.org installer. I'd have to agree with that, like, you know, being a Mac user for a long time, mainly because I do a lot of video and audio stuff, again, I think this is something that was really common four or five years ago. You know, the suggestion was to use Homebrew, but I had a really kind of awkward experience with it. It had some really strange things written inside of Homebrew. As far as like how it was like doing version numbers. It's something I discussed, I think, last week about, you know, like it was doing greater than, less than kind of things with certain version numbers. And all these kind of weird, weird kind of things. It wasn't super clean, you know, and also just the way and where it installed it, whereas the installation from Python, like I had to redo my entire iMac recently and anyway, so downloading from Python was the best way to do it. In my experience, it was been super clean and I've actually been able to install a couple different versions of Python and switch between them pretty easily, you know, without having to like dive into Docker and other kinds of things. Right. Seems to work pretty smoothly. Yeah. Yeah. And we've had folks reading it on, you know, all three of those formats and using, you know, ePub readers that I've never even heard of and all sorts of stuff. So yeah, it's kind of been battle tested. It's a vast world. Yeah. I guess kind of a related topic would be to think of it in a digital form. You don't think about it this much, but in a printed form, like what does this translate into like a page count? How big is this book? It's not super small. Okay. It's not a small book. I mean, there's some things to consider there though. I'm looking at the, I've got like a test version that we printed, yeah, a while ago, and it has changed quite a bit since this test print I've got in my hand. Yeah. For example, the original installation instructions for Mac OS in what became the Python Basics book was to use Homebrew. So I was able to get that all corrected, you know, get a nice solid development environment set up using the python.org installer. I'd have to agree with that, like, you know, being a Mac user for a long time, mainly because I do a lot of video and audio stuff, again, I think this is something that was really common four or five years ago. You know, the suggestion was to use Homebrew, but I had a really kind of awkward experience with it. It had some really strange things written inside of Homebrew. As far as like how it was like doing version numbers. It's something I discussed, I think, last week about, you know, like it was doing greater than, less than kind of things with certain version numbers. And all these kind of weird, weird kind of things. It wasn't super clean, you know, and also just the way and where it installed it, whereas the installation from Python, like I had to redo my entire iMac recently and anyway, so downloading from Python was the best way to do it. In my experience, it was been super clean and I've actually been able to install a couple different versions of Python and switch between them pretty easily, you know, without having to like dive into Docker and other kinds of things. Right. Seems to work pretty smoothly. Yeah. Yeah. And we've had folks reading it on, you know, all three of those formats and using, you know, ePub readers that I've never even heard of and all sorts of stuff. So yeah, it's kind of been battle tested. It's a vast world. Yeah. I guess kind of a related topic would be to think of it in a digital form. You don't think about it this much, but in a printed form, like what does this translate into like a page count? How big is this book? It's not super small. Okay. It's not a small book. I mean, there's some things to consider there though. I'm looking at the, I've got like a test version that we printed, yeah, a while ago, and it has changed quite a bit since this test print I",
    "VSqq6VxgbOk": "Welcome to the Real Python Podcast. This is episode 34. Are you ready to move beyond flat files for your data in Python? Maybe you're not sure where to start with databases and SQL. This week on the show, David Amos returns with another batch of PyCoder's Weekly articles and projects. We cover a Real Python article about managing data with SQLite and SQLAlchemy. David explores the intricacies of using the modulo operator. We also cover several other articles and projects from the Python community, including how to shoot yourself in the foot with Python, exploring fractals on a cloud computer, the DMCA takedown request for youtube-dl, Python for feature film, an online multiplayer text-based game framework, and a sorting algorithms visualizer.\n\nThis episode is brought to you by the Tech Meme Ride Home Podcast, Silicon Valley's favorite daily podcast. Alright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com.\n\nHey David, welcome back to the show.\n\nHey, thanks a lot. Good to be back.\n\nAlright, so what have you brought us to start with here?\n\nMy first one this week is called \"How to Shoot Yourself in the Foot with Python Part One\" by Miguel Brito. It's sort of a fun and whimsical look at some of the things. I'm assuming these are things that have affected Miguel personally. Some of them may look familiar to listeners, some of them look familiar to me when I was first starting out with Python. It just catalogs five different things that you might run into that sort of make you stop and go, \"What in the world is going on here?\" And I'm just gonna go through and list the five things, and you know, I won't go into all the details so that there's still something fun to read in the article. But he talks about implicit string concatenation. This is one that maybe not so much of a gotcha, or maybe it depends on how it comes up, but it's something that for me, it was just the first time I saw it, I was like, \"Wait a second, that's valid, like that's real syntax.\" It looked kind of odd to me. So the premise here is that if you have two strings and you want to concatenate them, usually the most basic way to do that would be to put a plus sign, use the concatenation operator between those two strings. Yeah, you concatenate them and you get a single string back with all the characters from those two strings. Well, you can remove that concatenation operator and just have two strings side by side with the space between them, and that will implicitly concatenate to a single string. So this works like if you want to split a long string up. It's a technique I actually have used some on my own where you put a bunch of strings inside of parentheses, not like a tuple, you don't have commas between them, but you put an open parenthesis in the first string and then hit enter. On the next line, you put the second string and then hit enter after that, put another string, and so on until you have your long string that you want split up, and then close the parentheses. So I guess this is something he ran into and just wasn't clear, like wait a second, what's going on here? There's not even an operator, how is this working? So there's that implicit string concatenation. Something interesting that he found with the walrus operator, which was new in 3.8, is that you might expect some people might expect it to work similarly to an assignment where like you can assign multiple values on the same line. So you have like a comma b equals two comma three, and then when you inspect a, it's equal to two, and the variable b is equal to three. So there's something going on there called tuple unpacking, which is what works in that case. But you might say, huh, can you do the same thing with the walrus operator, like could I do a comma b, and then you know, colon equals 16, comma 19, and that gives potentially some unexpected results. So if you run it in the same session that you ran where you signed a to two and b to three, when you do this a comma b walrus operator, 16 comma 19, you end up with a three tuple of two comma 16 comma 19, and it just looks like, wait a second, what in the world just happened? How did I get this three tuple out of it? So he talks about why that happens, and I'm not going to mention why, I'll leave that to those of you that want to read the article. And then some other weird things that could happen if you didn't have values already set there. So the moral of that story is don't assume that an operator that looks like another one sort of behaves the same way. In that case, the next gotcha he talks about is to be careful when using the plus equals, this assignment augmented assignment operator with lists. This one doesn't have so much to do with the operator itself as it is just the way that these operators work with different data types. So for example, if you have a list of integers and say one, two, three, four, and you make a copy, let's call that a, and you make a copy of that list and you do b equals a, and then you do a plus equals five, six. So you've got this list of numbers now, one, two, three, four, five, six. That also affected b because when you assigned a to b, what you did was assign a new name to the same list in memory. It's just pointing to the same list as before. So you can contrast this to the way that this augmented assignment works with say something like an integer. So if you have the variable a, you assign it the value one, and you have set b equal to a, then if you increment a, a plus equals one, then a is equal to two, but b is still equal to one because they're not, you get a new copy of that integer when you assign when you assign a to b, which doesn't happen with lists because lists are mutable. The moral of that story is just to don't assume that similar looking operators or same looking operators work the same way on different data types. Yeah, that's another thing that can get you, another gotcha is mutable defaults. This one I think a lot of people maybe have seen before if you've seen a lot of these kinds of gotchas, but that's if you have like a default argument in a function that takes the defaults to like a list. So if you don't pass anything into that parameter, then it just gets it gets assigned a new list. This can this can cause problems because that default argument is always pointing to that same that same list the first time it gets it gets called. Yeah, or really not even when it gets called, it's probably when it happens when it gets compiled to bytecode. It's creating that default argument, that empty list, and then every time you call that function, if you don't pass something to that parameter, then it's just going to use that same list over and over again. So there's some weird things that can can happen there. And then another one is, he calls it chained operations gone wrong. This is when you have things like these like chained expressions like 25 is greater than x is greater than or equal to 10. So you like you, you want to verify that some value, a value is between, you know, in some range. So what happens here is, if you're not careful with parentheses or if you don't understand necessarily everything about what's inside of those parentheses, you can run into some some funny issues. So he's got an example where you have some variable x and say you do this, um, I'm not sure what value he's assigned to it here, but okay, x is equal to 10. So you have a variable x, it's assigned value 10, and you have this expression 20 equals equals x equals equals zero. No parentheses or anything. You look at this, you're like, well, clearly that's false because 20 is not equal to x and x is not equal to zero. So that should be false. Now, if you put parentheses around the left side of that, so the 20 equals equals x, now you've got parentheses 20 equals equals x. That part in parentheses and then the result of that equals equals zero, that evaluates to true. And that might throw some people off because what's happening there is you've got the 20 equals equals x is being evaluated to false, right? False. Yeah, it's returning false. And then you're saying, is false equal to zero? And in Python, the boolean true and false are subclasses of the int class of the data type. So true is one and false is zero. So false really is equal to zero. And you can verify that in your in the in the command line in the Python shell if you want, but by putting that parenthesis there, you actually changed, you might not expect it to change the value, but it actually does change the return value. So when you're when you're doing these kinds of comparisons, again, when I look at this, I don't think it's so much about the parentheses as much as it is just when you're doing these kinds of comparisons, it's good to know like what you're actually comparing, right? Like not just what what the value is, but or you know, and what type it is, but what type that might be subclassed from or so you know, having a full understanding, right? Or it's going to evaluate you and yeah, what it what it's going to you know how it affects the evaluation and everything. So so anyways, there's the five gotchas. It's labeled part one. So my guess is there's going to be more in the future, some more in the future. And what I like about it is that, you know, it's, you know, he's sort of Miguel's sort of being vulnerable here. He's saying, look, these are some weird things that I, I, I came across while I'm, you know, learning Python and programming in Python. And this, you know, it made me stop and go, what in the world? And, you know, I'm trying to explain it. He has some explanations in here. And I thought he did something interesting. So he has some explanations that some commenters pointed out as, hey, that's actually not the correct explanation for why that happens. And rather than, you know, deleting that and updating it, he just, like, crossed through it. So you can still see, like, his old reasoning and then says, you know, thanks to so and so who kindly corrected me and everything. So it's sort of this living document he's put together that I assume, you know, he's learning a lot about the way Python works by doing all this. So it's a really good example of why it's good to write these kinds of things down and document these parts of your journey. And, you know, if you have it in you, you know, be a little bit vulnerable and put it out there and let people correct you. And, you know, the internet can be harsh, but yeah. But he's, you know, I had a lot of, you know, nice people that have just given them some sort of gentle criticism and haven't been like, oh, you know, you're, you're, you're, you're stupid or something like that. They're just, hey, actually, that's not the way it works. But, um, you know, check this out. This is actually what's going on. So, really cool article, Miguel. Thanks for putting it out there. I enjoyed reading it. Yeah, cool. What do you got?\n\nSo my next one is a Real Python article. This one's from Doug Farrell, who's a previous guest on the show. And yeah, he came on to talk about APIs. And Doug has a lot of background in creating APIs and dealing with SQLAlchemy. And so this is kind of a dive deeper into the area of SQL and SQLite. There's so many ways that I've heard this pronounced. SQLite or SQL light or SQL light. So I may interchange them. I'm sorry. It's another one of those words I don't know how you like to pronounce it. But it's called \"Data Management with Python SQLite and SQLAlchemy.\" It starts off with the idea, okay, you have data and you're going to be working with potentially where a lot of people start, which is kind of going back to last week's episode with Al Swaggart talking about automating the boring stuff and doing stuff inside of Excel or doing stuff in these other situations. When you have a flat file of data, CSV or what have you, there's certain advantages to that. There's certain ways that you kind of work with that kind of information. Probably the biggest advantage is there's sort of built-in things in Python for reading it and then there's really popular libraries like things like pandas for working with it and manipulating that data and so forth. But as a storage medium, it's got a lot of kind of problems. It's very hard to update the data in it. Also, you potentially, if you're sharing your work with multiple people, it's not really a shared source and so you're walking around with files or emailing files and potentially dealing with multiple versions of things. The records themselves are just individual rows and then you're having to have tons and tons of columns if you're adding attributes about these things and it kind of starts to feel like, well, maybe there should be a central thing like a database that can contain all these items. And that's where this structure of one of the simplest databases that I've worked with is this SQLite and SQLite is a file, which is kind of nice. It's an individual file that can be hosted, can be hosted in a shared kind of thing, or it could be, you know, something that's up on the web, you know, an API endpoint or what have you. And what's nice about it is it doesn't require a whole lot of additional structural stuff about it. You know, it's literally just this file with the extension .db. So he talks about creating that, creating the structure. It's sort of a bit of a primer on SQL. If you've never done anything with SQL, so you're learning some of the basic commands behind it. And I've probably mentioned this, I don't know how many times, but that's my background where I kind of got really back into programming and so it was like, oh yes, it's pretty neat. And so, and then it kind of gets into this, they call them ERD, which are these relational diagrams that you kind of create to decide, okay, if I'm going to take this thing in this example, it's a set of books, how do you decide how this data should be related to each other? In the case of a book, there's an author, but there's also a publisher. And so those things, you know, one author could write multiple books potentially and a publisher might publish multiple books and so there's also this relationship where then, okay, this author might work with multiple publishers and so forth. And so you kind of need to decide, well, how do you want to divide these things up? And creating those tables. And so it goes into that. And I think it's really kind of neat to kind of just see that background. If you've maybe you've never delved into this area and thought about what's happening there. And so advantages there is that when you go to update things, you're updating a single place. You can update with a single command and it's going to go and adjust all the records, which",
    "qIMwi83SdWE": "Welcome to the Real Python Podcast. This is episode 35. You built a web application in Python, now how are you going to authorize users? Security goes beyond authentication; it gets into who gets to do what, where, and when. This week on the show, we have Sam Scott, Chief Technology Officer from Oso. Oso is an open-source policy engine for authorization that you embed in your Python application. Sam talks about the typical security and authorization challenges developers face. He discusses building an engine on top of your existing Flask or Django app and covers the concepts of policies, business logic, and some common paradigms. \n\nThis episode is brought to you by the Techmeme Ride Home Podcast. Silicon Valley's favorite daily podcast. Let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com. \n\nHey, Sam. Welcome to the show. Thanks for having me. Excited to be here.\n\nTo get a little background on Oso and your project, can you just tell us a little bit about what your project's doing and the origins of it?\n\nYeah, so, prior to this, I was doing a PhD in cryptography. We actually used a fair bit of Python through Sage early on, doing a bunch of fun elliptic curve things using Sage. That was really nice, and I was kind of having a lot of fun there. I came out of that PhD looking to do something more practical in the real world. The interesting thing I saw was that there were all these problems out there in the real world that, from the academic view, were these solved problems. I was like, \"Wait, why are people still struggling with them?\" It's kind of because the tooling out there was so impossibly hard for everyone to use that you had to have a PhD in cryptography to be able to work out what to do. \n\nThis was almost three years ago now. I was coming out and speaking to a bunch of people, understanding the space better. About six months into that, I met up with my now co-founder, Graham. He was coming from this developer background, previously at MongoDB, and we just had this incredible conversation over coffee about the state of the world of security and for developers. Two years ago now, we just clicked on this idea that security shouldn't be so hard for developers. That's basically what we're asked to do. The very high level of what Oso is all about is putting the security into the hands of developers.\n\nJust to take you back a little bit, I'm not that familiar with Sage. Can you tell me a little bit about what that was?\n\nSage is this math package built entirely on top of Python with a few overloads. I actually don't know exactly the internals of it, but it has a Python repo, for example. Some of the syntax is overloaded so you can do math operations like exponentiation easier. It's very much like using Python to do math. You can add and multiply matrices together using the syntax you expect in Python. It's just a very deep open-source math package. It's actually my entry point into open source. I dug it up from like 19 years ago. It was my first open-source contribution, and it was this little piece of functionality in Sage math.\n\nWhat are some of the first steps you guys made in getting Oso started?\n\nThe first thing we did is just went out and spoke to as many developers and security teams as possible and really just open to hearing about the things they were struggling with. A lot of where we started out was around how people think about managing secrets. I think that was very appealing to me from a cryptography background, like okay, encryption is one thing and you know post-quantum and all this stuff, but what do you do with the key? Where do you put that stuff? There's a bunch of products out there that help you manage those, but that's still something very painful for people to this day. We kind of spoke to people, heard about the struggles they had with doing things like encryption, authentication, authorization, and auditing. The one that kept up time and time again was that people have been reinventing from scratch pretty much consistently. We've seen people building from scratch their own authorization and permission systems.\n\nCan you give an overview of the kind of authorization that Oso can represent?\n\nAbsolutely. There are two main types of authorization people normally think about: roles and attribute-based access control. The idea of roles is the classic paradigm where you group both users and permissions into some kind of simple, easy-to-understand notion of what someone can do. You're the owner of a repository; that means you can do a certain set of actions. You have a collaborator with some other kind of set of meanings. Then there's this idea of attribute-based access control, which is like if the repository is public, anyone can see it. If it's private, then depending on something else. In reality, no implementation is ever that simple. There are always these weird edge cases where you know you have repository roles, but you also have third-party plugins that need to be able to do stuff across multiple repositories, and they're not really a collaborator. They're just some additional functionality, and they have different permissions.\n\nWhat are the common security concerns that developers face?\n\nThere are an overwhelming number of concerns when it comes to security. One common concern is managing secret keys, which developers often need pretty early on when deploying apps into production. SQL injection is another common security issue where user input can lead to arbitrary SQL requests, potentially exposing data or causing other problems. Authorization is also a significant concern, making sure that users can only access the data and perform actions that they are authorized to do. \n\nUsers don't want to have to spend a ton of time understanding internal permission structures just to use an app. Security breaches are also a major worry for users, as no one wants their data stolen. Overall, security is a complex and multifaceted issue that developers and users both need to be aware of and actively address.\n\nWhat are some of the worst security issues you have found in a Python app?\n\nOne security issue that comes to mind is a case where authorization was not properly implemented on an endpoint that allowed users to delete a user account. This oversight meant that users could delete other people's accounts, leading to a significant security breach. It's crucial to ensure that all endpoints and actions in an application are properly secured and authorized to prevent unauthorized access and potential data breaches.\n\nWhat are common gotchas that happen in developing applications around authorization?\n\nOne common issue developers face is the complexity of managing custom roles and permissions within an application. As organizations grow and require more granular control over user access, it can be challenging to implement and maintain a system that accommodates these custom roles while also ensuring security and scalability. Role hierarchies and role inheritance are common patterns used to manage roles and permissions effectively, but they can also introduce complexity and potential vulnerabilities if not implemented correctly.\n\nAnother challenge is the proliferation of authorization logic throughout an application, leading to a tangled web of permissions and access controls that are difficult to manage and maintain. By separating authorization logic into a centralized policy engine like Oso, developers can streamline the authorization process and ensure consistent and secure access control across their applications.\n\nWhat are other ways that authorization gets complicated?\n\nAuthorization can become complicated when developers rely on ad-hoc solutions or custom implementations that lack scalability and maintainability. As applications evolve and new features are added, the complexity of managing roles and permissions can increase, leading to a tangled mess of authorization rules and exceptions. By adopting a centralized policy engine like Oso, developers can simplify the authorization process and ensure consistent and secure access control across their applications.\n\nIn addition to role hierarchies and role inheritance, developers can also leverage attribute-based access control to define more granular access rules based on specific attributes or properties of users and resources. By structuring authorization logic in a logical and coherent manner, developers can avoid common pitfalls and ensure that access control remains robust and manageable as their applications grow and evolve.\n\nWhat's something you're excited about that's happening in the world of Python?\n\nI'm excited to see the growing interoperability between different languages and platforms, as well as the increasing adoption of tools like WebAssembly for cross-language development. By leveraging technologies like Rust and WebAssembly, developers can build more efficient and scalable applications that seamlessly integrate with Python and other languages. I'm also looking forward to exploring new frameworks like FastAPI and their potential for enhancing the development process and improving performance in Python applications.",
    "qnLdC9zuJpg": "Welcome to the Real Python Podcast. This is Episode 36. Are you interested in learning more about natural language processing? Have you heard of sentiment analysis? This week on the show, Kyle Stratus returns to talk about his new article titled \"Use Sentiment Analysis with Python to Classify Movie Reviews.\" David Amos is also here, and all of us cover another batch of PyCoder's Weekly articles and projects. Kyle discusses an article about distance metrics for machine learning. David shares a Real Python article about Python signal processing and Fourier transforms with SciPy FFT. We also cover several other articles and projects from the Python community, including stimulating real-world processes in Python with Senpai, working with Microsoft Excel using Python and OpenPyXL, why running code during import is a bad idea, what I wish I knew as a junior dev, the Raspberry Pi 400 personal computer, and dynamic sky replacement in videos with Sky AR. This week's sponsor is Linode. Simplify your infrastructure and cut your cloud bills in half with Linode's Linux virtual machines. Try Linode today with $100 in free credit for Real Python listeners. Visit linode.com/realpython. All right, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com. Hey, David, welcome back.\n\nGood to be here, Chris. So we have a guest this week. We have Kyle Stratus back on the show. He was on Episode 10. Hi, everyone. Welcome, Kyle. Good to be here. We were talking back then about Python job hunting in a pandemic, and I think I followed it up in the next week that you had found a new position. Do you want to talk a little bit about that?\n\nYeah, I ended up becoming the second engineering hire at Visit Labs, which is a young startup here in Boston that basically is trying to create AI focus groups so we can test images against these audiences that we build and we can tell you how much of an impact and engagement they can drive. We do a lot of work with larger e-commerce and consumer goods brands to help them optimize their images and tell them where people's eyes are being drawn to and which other images out of their whole digital shelf look best and would perform the best.\n\nCool, and the name again is Visit, V-I-C-I-T, yeah. Awesome. Well, I brought you on to talk about some articles and partly why I wanted to have you on was to talk about your most recent article for Real Python. It's called \"Use Sentiment Analysis with Python to Classify Movie Reviews.\"\n\nYeah, it's a great little project. I think it was a lot of fun for me to do. I'd say about two-thirds of it is really learning about what natural language processing is and what techniques are kind of wrapped up in that concept and how you use that along with machine learning tools to do things like understand what's being communicated in the text. So in this case, we're looking at how to know whether some text has a positive or negative emotion and detecting that in movie reviews where there's usually some kind of obvious or maybe sometimes less obvious positive or negative sentiment towards what the review is saying. That's a topic that I think's come up a few times on the show so far of people talking about getting into natural language processing.\n\nWhat are the tools that you're using in it? So with this article, we use primarily spaCy, which is a great NLP package that has a lot of features built in. Another major one that a lot of people use in Python is the Natural Language Toolkit or NLTK. That one's a bit more advanced. It gives you a lot more power, but it just takes a lot longer, I think, to get comfortable with it, where spaCy has a really great, more beginner-friendly interface. It doesn't require you to kind of tweak a bunch of knobs to get it working right. And so I chose spaCy so it'd be a really good introduction to NLP without having to worry so much about the tooling, and it has built-in classifiers that you can train as well, so it has kind of the whole package all in one. I've used it before, and I really like it for that reason. It's really simple to use for anyone who doesn't need a PhD in machine learning or anything like that. We go over kind of the tool itself, the concepts behind it, and then the last part is a project where you kind of build your own sentiment analyzer, and I step through all the parts of it from vetting your text corpus or your data set and ingesting it, doing the NLP techniques to it, training a model, and actually setting it up so that you can pass in any sort of text and get the sentiment out based on these movie reviews, and it kind of stops at a place that makes it really nice to take it to the next step.\n\nYeah, I liked this article a lot because I think it highlights to how this is one of the things that if you take a college algebra class or something at one point or if when else would it come up maybe in like a pre-calculus or and then you're going to use it all the time. This notion of Euclidean distance, you're going to use it all the time if you ever had to take like a calculus three class or anything like that or linear algebra in school. And I think there's a sense when you sort of learn these things that it's like these only apply to like, you know, you think of the term distance and it's like, well, I'm measuring the distance between two physical points in space and there's a sense that if I'm not doing anything that none of this stuff really applies. And it turns out that like these kinds of this idea of like measuring distance is so applicable to just so many different things and it sort of lies at the foundation of like these categorization techniques in machine learning like how similar are two things, right? So you take your data and you have some sort of vector representation of that and you want to know are two of these things similar, well, if the distance quote-unquote between those two things is very small, then whatever small means in your problem, then yeah, then we can say those two things are the same or they're similar enough to be labeled with the same kind of category. It's just fun to see that like these very sort of basic notions come up in what might be surprising ways to some folks.\n\nYeah, I think this article does call out some of the more foundational or more basic machine learning algorithms like k-nearest neighbors and k-means clustering, things like that as applications for these distance measures. And I think the illustration of the Euclidean distance and how they explain it in terms of k-nearest neighbors makes it so easy to understand. It's so much clearer than, I think, the first couple of times I learned about it, right?\n\nYeah, I agree. What side is this on?\n\nSo this comes from aigence.co. I was written by Jamie Zornoza. Hopefully I'm pronouncing that right. But they did a great job with this one.\n\nSimplify your infrastructure and cut your cloud bills in half with Linode's Linux virtual machines. Develop, deploy, and scale your modern applications faster and easier with 24/7/365 human support with no tiers or handoffs, regardless of your plan size. Whether you're developing a personal project or managing larger workloads, you deserve simple, affordable, and accessible cloud computing solutions. Get started with Linode today. Visit linode.com/realpython. Click on the Create Free Account button and get $100 in free credit. Try Linode now.\n\nI want to thank you guys both for coming on. I know we've had some interesting audio issues today. David's on assignment and so he's got slightly different audio setup too. But thanks for coming on the show again.\n\nThanks for having me.\n\nAnd yeah, thanks for coming back, Kyle. It was really great to talk to you again.\n\nThanks for having me. I had a blast. Thanks a lot.",
    "ENqja_2okC0": "Welcome to the Real Python Podcast. This is Episode 37. One of the best ways to learn something well is to teach it. This week on the show, we have Kelly Schuster Paredes and Sean Tibor from the Teaching Python Podcast. Sean and Kelly teach middle school students Python and share their art and science of teaching Python on their podcast. They wanted to come on the show and talk about the Real Python articles, quizzes, and other resources they use when teaching their students.\n\nWe also talk about teaching students how to research topics and use things like advanced search with Google. We discussed using cloud-based tools like collaborative notebooks and some of the core Python concepts students need for a solid foundation. Kelly and Sean also talk about how the changes to teaching over the past year have had some unexpected benefits. They also talk about a few recent guests and topics covered on their show. This week's sponsor is Linode. Simplify your infrastructure and cut your cloud bills in half with Linode's Linux virtual machines. Try Linode today with $100 in free credit for Real Python listeners. Visit linode.com/realpython. Alright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHi Sean and Kelly, welcome to the show.\nHi Chris, it's great to be here.\nHey Chris, it was really fun being on your show back. It seems like ages ago this year. So I was a little worried because I didn't put any other episodes after I was on. [Laughter] It was that COVID thing. Yeah, kind of a little crazy. Well, on the plus side, your episode got a lot of downloads because we... Yeah, is there a Saturday invite so for a while. Yeah, you got a lot of episode downloads because yours was the only one there for a couple of months. Yeah.\nAlright, so I wanted to start by talking about why did you guys pick to use Python as the curriculum for your classes?\nWell, you want me to start that one Sean?\nYeah, well you were actually there for that conversation Kelly. I was. That was before I started teaching. Yeah, so we've always had a computer science program at our school K-12, and we have the kids in the lower school going through the Scratch programming language and they're pretty solid in it. And in seventh grade, it was kind of a hodgepodge of stuff, you know a little bit of Swift, a little bit of Legos, and everything. And then in the high school, they were working with JavaScript and Java. Correction, Java. I don't know in the higher levels, I don't teach up there. Yeah, the AP courses are all taught in Java in the upper school. Okay, so our boss called me in and we had a good conversation and I was pushing for JavaScript just because that was one of the languages I kind of knew. And we started researching a lot and we noticed that Python was like this up-and-coming language and there was so much to do with it and we heard about the BBC Microbit and the Python MicroPython modules and that. And my boss was like, \"We're teaching Python.\" Cool, do it or not well. And so, right after that conversation was when I came in as well. So I was hired in to teach computer science in the middle school alongside Kelly and they said to me okay, well we're going to be teaching Python in the middle school and they asked me do you know any of it and I said well no in fact it's been a few years since I've been in a developer role. I've been in more you know marketing and technology and things like that that were less hands-on or detailed so I said no but I'm willing to learn and that was kind of how we got started.\nIs the BBC Microbit still a central part of your curriculum?\nIt's part of our sixth-grade curriculum. We spend about three to four weeks on it and we've also introduced it into our robotics curriculum this year more in-depth, I should say. Sean's been doing a lot of work with coding and putting together a lot of the pieces, the ultrasonic sensor and everything with the Microbit. But as we progress up the grades, it's a little bit of a hodgepodge. We sometimes get into the Circuit Pies, playground, and Sean brings in all kinds of cool things. He can tell you more about those. Yeah, so in the upper grades in middle school, so we're talking like 12, 13-year-old kids, we really start to get into the idea of more advanced coding concepts. We get into some of the Circuit Python-based hardware when students are into that. And what we're really trying to do is match their interests with what Python can do. So we'll survey a lot of the different third-party libraries and popular tools. Matplotlib comes out quite a bit, Pygame, they love turtle. Even as eighth graders, they love making circles and spirographs and things like that. And then I've had a number of students this year that have really gotten into a lot of the math capabilities of Python and using it to validate and check their math homework in the process.\nAre you using a particular IDE or teaching environment and coding environment?\nWe always start with my sixth grade, so we all we love Mu in sixth grade. We use that a lot, the interface is easy, the kids have the big buttons are big, it's not scary, and it's just something easy to jump into. We often fall back to Replit because if you know a child has a loner tech or laptop, we can just get on Replit and code right away so those are the two that we use in sixth grade and then seventh grade we like to introduce them to the Collab notebooks just because the importing of the libraries is a lot easier for us and then Sean does a little bit more in the eighth grade. Yep, so by the time they get to eighth grade they've seen a couple of different editors and this is the first chance where we kind of introduce them to a modern Python programming environment so they might download an IDE like PyCharm or Visual Studio Code and then also install their own interpreter locally you know where Mu comes bundled with its own interpreter or Collab that's built-in and running on the Google servers. This is their first chance where they're installing their own interpreter and getting used to how do I use the command line a little bit to make some of this happen and use IDEs to make my code editing a little bit easier more flexible based on what my needs are as a student.\nI was wondering about that. I haven't been teaching in a school system. I taught in a school for recording engineers and we were just at the beginning of maybe what Google was offering with like cloud-based documents and things like that and I know a lot of educational systems are using Google Docs and things like that. So I kind of wondered about these sort of cloud options and so you mentioned a couple. Is it helpful in the sense that you can they can move keep their projects, move them around from home and back and forth, especially with how schooling is right now with some in-person and some not?\nFor sure. I mean the nice thing about it is they're already used to the paradigm of the Google Doc, right? So because we've been at Google School and they've used it for several years whether it's on a Chromebook or on their own laptop when I go to introduce the Google Collab notebook which is just Jupyter running on Google servers all I have to do is tell them it's like a Google Doc but you can also run Python code in it and they kind of like oh okay well that's no problem and then we move on. So the paradigm is already there and they get a lot of the benefits of the sharing of the documents and being able to collaborate on it. It's not quite as real-time as I'd like but you know you can definitely see when someone's editing your document and making changes to it.\nAnd maybe like way down the road would be like something where you teach them something like Git or something like that at this point the Collab is sufficient for you know working and sharing?\nAnd it has its own you know version control in there so we can at least talk to them about the concept of it's always being saved and you can go back in time and revisit your progress and everything so it gives us some of those precursors to a Git-style version control environment.\nThat's cool. I think like for us in education, for teaching with the Collab notebook, you know kids always forget to save and it's like oh no I've lost my my code but it saves automatically and it is nice when you know we're working in a version and the kids start adding in a whole bunch of things and they get a little bit confused we always tell them you can go back to the day before when the code was working and have a look at that and it's such a nice feature you could do that side-by-side comparison and Sean's used to we've used a lot for me when I've got lost in someone else's code on the student's code and trying to understand where they've made up an error as 300 lines in and it's just nice to see it.\nAlright, let's move on to the next section. Kelly, what's something that you're excited about right now in the world of Python?\nI just learned about Beware. Yeah, Russell's great. I just made my first mobile tutorial app. I followed along and had \"Hello Kelly\" and we had Ali a couple of weeks ago. Yeah, Spittle. She got me into Django Girls tutorial so I've been stumbling through that which she's got some great videos. I don't know her name from Django Girls but her videos are great. Sean, who else do we have? Oh, we had Eric Mathis on an upcoming episode. So we had him back to talk about making projects happen in school and what makes a good project for learning right and getting students engaged and interested. So, that one's coming up probably as soon as I can get it edited later today. And we've just been having a really good conversation about all the changes with the way we're teaching this year, the things that we've been able to do with remote learning that have actually enhanced the learning experience for our students.\nI was wondering about that. Yeah, it's interesting because I think programming in general can be such a demanding subject in that you have to be able to focus and think through the problems that you're trying to solve and in a normal classroom it can often be fairly distracting when there's a lot of other kids moving around and you know there's always noises and sounds and things like that. So our students that are at home have often pulled ahead of their peers in the classroom because they can hit the mute button on the classroom and focus in on what they're trying to learn and create this environment where they can really think and I believe that that's something that we don't often create for our students is the space to think and have some time to really delve into a problem in a way that is meaningful and relevant and so if there's been a silver lining to all this distance learning it's the ability to show them that space and help them think through a problem in a deep and meaningful way.\nI think when people ask us how did we handle COVID and I think Sean and I both were we said oh it was great you know I got so far with the teaching I saw a seventh grader one of my seventh graders this year who had me fourth quarter last year the kid is a coding superstar and I guess when they were locked up he was also the one that was asking Sean about the numbers and complex numbers. Sure, I'm like did I teach you last year? It's amazing and but they just had so much time during the summer and by themselves they weren't allowed to go out and I think computer science and as long as you have someone to mentor you and you have the resources available to you I think it's one of those subject areas where I mean we've all learned most of us have learned on our own anyways but it's one of those areas where kids can just go and thrive you point them in the right direction here's this tutorial here's this editor and just go and they are really feeling successful I think so it's kind of nice.\nThat's cool. Are you hosting it yourself or does the school provide you space or you set that up yourself to host this Django thing?\nJust on myself right now. I haven't gotten very far. Everything's locally. I'm actually working in a Collab notebook right now because every time I go in I have I've been on a personal fight between whether I'm going to use PyCharm or Visual Studio for sure so I was getting used to Visual Studio with the LEGO programming but I don't know I liked PyCharm and then I don't know the whole V-E-N-V I don't know how you guys pronounce it V-E-N-V is a lot for a new person yeah and you get kind of lost and I was also doing terminal so learning all about terminal and kept ad that's great in his book.\nI was yelling at Russell saying why terminal in our last episode. I have to listen to that and he yeah he explained it really well and I was because I was just like why do I have to install Beware through terminal when I could just go into my finder and make my own folder and I think there's the things that happen with newbies you know we do stuff because that's the way the programmers had always learned how to do stuff so it's one of those things that you have to be cognizant of when you're teaching someone who's never coded before.\nWe always change we try not to change too much during the year yeah but in the end we always do because we get you know we get bored we're gonna do the card game or we'll do something else and I think just being able to make and show them more examples they end up producing other things for us so I don't know we we're making all kinds of things Sean's made all kinds of crazy hardware stuff in the classroom and you know you name it we've we've tried it so it's uh I need somebody to give me those assignments here and I just like have not been making the time I've been you know getting all these other things going so we decided to ditch the the Microbit kits where they already have the robot designed and you know there's a whole bunch of different kits out there for the Microbit robots and we're making our own and we're piecemealing it. We've made up these little ziplock bags for all the students and we've given them ultrasonic sensors and deep boards breakout boards and breadboards and jumper cables and wires so we'll send you some of that stuff and you can uh you can compete with us we're going to do battlebots all right.\nThat sounds funny. What were things that you were happy about the change from switching from teaching potentially teaching JavaScript to now teaching Python? What changes about teaching those different languages that you enjoy that has made that easier for you I guess?\nI think for me working with Python versus the other codes and I guess I should say more like looking into Swift because we also looked into using that. I just think it's something more tangible. I feel like you can easily jump in. We take kids that have never coded before in a language maybe a little bit of scratch and in nine weeks we have them coding 200-300 lines of code and making up their own apps. They've made mad labs, they've done designs with turtle and these are things that aren't like box they're not finding it off the web and copying and pasting it. They're actually coding their own stuff so I think that's that's the one thing I really love about Python. I can guarantee and I say this to all the parents when they're freaking out that their child is stressed out the first two weeks. I'm like I've done this 28 times in three and a half years I promise you that by the end of the nine weeks your kid is going to be begging to come back to class and it and it's happened maybe one or two kids that has and I know that sounds a little bit egotistical but it's not because of me it's because of the language. You know Python is just something that's so awesome that if you know the kids want to build an app I can give them that if they want to draw with Python or turtle I can give them that if they want to use hardware I can give them that and I just think that it's one of those languages that is accessible and that's kind of why I love it.\nThat's awesome. Well, I really want to thank you guys for coming on the show and it was so much fun talking to you again. Thank you so much. I mean we love what you guys do and you're such a great resource for us at school that we just wanted to say thank you.\nAlright, take care Christopher. Bye Kelly. Bye.\nThanks, Chris.",
    "mmXU2xAWPOk": "Welcome to the Real Python Podcast. This is Episode 38. If you're coming to Python from a different language, you may not know about a useful tool for working with loops: Python's built-in enumerate function. This week on the show, David Amos is here and he's brought another batch of PyCoder's Weekly articles and projects along with the mentioned Real Python article covering the details of the enumerate function. We also talk about another article about constructing Python graphical user interface elements. In PyCute, David shares a couple of resources for data scientists, including an article about skills not taught in data science boot camps and a project for creating synthetic data. We also cover several other articles and projects from the Python community, including an update about YouTube DL hunting for malicious packages on PyPI, using Python's bisect module, 73 examples to help you master f-strings, and game programming in Jupyter notebooks. This episode is brought to you in part by Scout APM. Scout APM is application performance monitoring designed to help developers quickly find and fix performance issues without having to deal with the overhead of enterprise platform feature bloat. Alright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey David, welcome back.\nHey Chris, good to be back.\n\nSo I wanted to start off with a follow-up. This is actually going to seem a little while ago now, but we talked about YouTube DL and I'm sure most people know that it was pulled off briefly from GitHub and it was reinstated about a week ago, maybe two weeks ago now depending on when this comes out. There's this really great Reddit thread that I think tells a story better than anything that we covered. It includes links that start with a letter, basically showing you what the types of things that the RIAA was arguing was why the DMCA takedown should happen and the EFF, the Electronic Frontier Foundation, wrote this really elaborate letter that explains why it doesn't apply in this case and they worked with GitHub and GitHub now wrote also their own letter explaining what's going on. I think they're both really good reads in this day and age of open source software and kind of understanding why all this sort of happened. GitHub now has this new process in place which I think is good that's been now defined and they have this developer-focused approach to the DMCA. This whole letter explains what they were changing and then the EFF letter really goes well into what happened there behind the scenes as far as the legal arguments and it's really well written for somebody who's not a lawyer. Anyway, I won't spend a ton of time on it but I thought it was really kind of neat. I think it's GitHub also set up what's called the Developer Defense Fund, which is really cool. Yeah, yeah, I had a feeling that the whole situation was getting resolved somehow in YouTube DL's favor, but I didn't expect all the other things that came out of that as well. I thought that was those are some cool developments in the world of open source.\n\nWe mentioned that there were some specific things that were in their tests and right, they explained why they were, you know, arguing one way or the other why they shouldn't be included. Anyway, they were removed, but if you're interested to see like what was included there, it's a good read to kind of not only see all the parties that are involved in what's at stake there, but also it's a nice result for open source, right, and for people that want and need these tools for other uses than what people assume is this malicious intent, which isn't always what's happening there. So what's your first story? The first one I got is a Real Python article by Brian Webber, who I think we've featured on the show before. If not, then congrats, Brian, for your first feature. But I'm pretty sure I can't remember. But his latest article is called \"Python Enumerate: Simplify Looping with Counters.\" This is one of those things that I think is a beloved feature of Python that Python programmers really enjoy. It's one of these \"batteries included\" features that you hear talked about. Enumerate is a function that is a built-in function to Python that you can use to loop over some iterable, a list or a tuple or even a dictionary or just anything that you can loop over while also looping over the indices or indexes that are associated with each item. If you need the index, which you don't often need it but if you do, then this is a really handy way to do that without having to keep track of an additional variable. If you're familiar with other languages, a lot of times you end up having to do is initialize some index variable, I call it i equal to zero and then at each step of the loop you have to increment it to keep track of where you are with whatever you're iterating over. Enumerate gets rid of that for you and just pops off the index with the item at each step. So it saves you some work and it looks nice. The article dives into how it works, so it goes over how iterating with for loops works in Python as a quick refresher and then talks about using the enumerate function and how that works. But it dives into a couple of other things so you get some interesting examples in a section called practicing with Python enumerates. You just see like how this could be used in practice with different few different examples. It also takes a peek under the hood by giving kind of the Python equivalent of how you could write your own enumerate function if you wanted to. So you get to see like how does the enumerator actually work, like what's going on there. It's not exactly the way it works because the enumerator being a built-in is not actually written in Python, but you get some kind of equivalent there. So yeah, it just walks you through how enumerate works, some really practical examples and then a peek under the hood and then a couple of more advanced items at the end for folks looking for a little bit more that they can do with it. Overall, just a great article. If you're not familiar with enumerate, it's a great place to learn about it, yeah. I think a lot of people coming over from something like JavaScript and using that for something like a for loop or what have you, it's a nice quick way to switch over. I know that initially I was coming from other languages and using these other techniques for looping and I was like, \"Oh my gosh, this is a great built-in thing. It's so much cleaner.\" Yeah, and understands what you're iterating through, which is really slick. And the count is a very helpful thing that is often needed as an index. It's a nice tool. Absolutely. So my first one is going back a little bit into a topic you covered a handful of times, but last time that you were on with me, we talked about not having code running during import. Oh yeah. And this is kind of related to that. It's called \"Hunting for Malicious Packages on PyPI.\" It's by Jordan Wright, who's a security researcher and open source developer. And he went through and installed every package on PyPI to look for malicious content because that's always been a bit of a worry, and we've discussed that idea, is there malware out there, is there sort of name squatting and sort of pollution there that could happen that if you slightly misspell something, could you be downloading a package that potentially could be malicious and have odd code in it? And it talks about being a security researcher and what would be involved in doing this whole project, and it's pretty elaborate things that he goes into. Definitely starts by talking about what are the things that run in the setup.py file that's part of setting up a package and getting it all running there. It goes into trying to find these malicious libraries, and that dives right into this idea of one of the more malicious things that could happen is a system call where a program is talking to your system and saying create this file or copy this resource or go to this URL or what have you. What's interesting about that is those system calls can be tracked. There's this tracing that you can do to look at that, and he uses a thing called sysdig, by using that he created this elaborate setup. Basically, one of the first things he needed to do was like create a script to get all of the Python packages and luckily, PyPI has a fairly simple API, he explains in the article, and pretty quickly, he had links to 268,000-odd packages and it doesn't go back in time, so these are like current listings, he didn't want to delve into that project of looking at older versions of packages, which I can understand that could get even exponentially larger, yeah. So the process involves a lot of AWS overhead, he created 15 Elastic Compute 2 content instances, these EC2 instances, about 15 of them, and then he needed this large S3 set of buckets to dump everything into. So, step one is that the sysdig is started and then records all the system calls that are going to be made inside of a Docker container, and that's where it is doing the pip install of each one of these individual packages. And then, meanwhile, there's a TCP dump container that's kind of the side of that that's created to monitor the network traffic going on in and out of that and ignoring specifically traffic to and from PyPI. If this package is calling for additional packages or what have you, that traffic's ignored, but if it's going to some other odd third-party things, that stuff that he wants to know about and track. So then a container's created that just as it installs those packages like I said, the sysdig is looking at that and then the TCP dump is happening. So he created about a terabyte of data that's dumped into this S3 bucket and then he ended up merging that into these JSON files. Okay, there's like a metadata and then outputs of DNS, a category for files, a category for connections, and a category for commands. And it was interesting the things that he found. I was expecting him to find more things, but he found two what looked like proof of concepts more than anything. You should be aware of what's happening here. And literally the first one's called \"I Am Malicious.\" Yeah, I am -malicious. And it is in a way because it's going to create files on your system and it pulls them from a GitHub gist, a Python file and adds this \"I am here\" message, like \"I was here on your computer\" kind of thing where you're like, \"Oh, okay, that's interesting.\" Yeah. And then the second one he found was another package, literally called \"Malicious Package,\" no spaces. It was very similar. And then the one that he found that was more of an eyebrow-raising, \"Okay, what are they doing?\" It was called \"Easy IO CTL.\" And that one's really hard to really tell what's going on. There's a lambda function that fetches, in this particular case, it's kind of hiding some of the activity that's doing in system-wise and it looks kind of sketchy what it's trying to do. And so, anyway, it's a really interesting article, but also it could be a project if you're interested in it. He has created a lambda function that keeps looking at all the latest packages that come along. He's basically got it pointed at the PyPI RSS feed, so you can put basically anything new that's coming into PyPI through the same process, and if you want to analyze the data, the terabyte of stuff that came through, he's got a link provided for that and you can kind of learn more what's going on. But this is a really neat deep dive and if you were going to analyze what is happening and where you should be looking and definitely system calls makes sense and there's this great little cartoon that he shares that's part of it too that explains what system calls are and yeah, it's just really well done. Yeah, it is a good article.\n\nDid you mention that it's not specific to PyPI, that he's going to do the same thing for npm? Yeah, you know, definitely this is the same kind of research that you'd want to do on any kind of package index. Yeah, yeah, you know, it definitely explains that idea of these are some funky things that can happen during setup.py. You're allowing it to run in your case, often uninspected code by simply running pip install. Yeah, and that's just to kind of bring up, you know, there's been a movement away from setup.py in recent years and that's one of the reasons you hear people talk about is there's this code execution that takes place, you know, it can be executing anything and if it has access to the whole system, it can really wreck some havoc if you get someone that really wants to do some damage in there. So we're starting to see more momentum behind like the PyProject.toml and these other concepts to get us away from the setup that Py files. So it's, you know, there's still a lot of projects using it out there because that's just the way it was done for so long. So yeah, it's a kind of slow adoption but but I see more and more that that happening. We'll be moving away. Eventually, I could see a world where these kinds of issues are no longer a problem but it could be really far away. It might take a little more. It might take some time. Yeah.\n\nScout APM is application performance monitoring designed to help developers quickly find and fix performance issues without having to deal with the overhead of enterprise platform feature bloat. With a developer-centric UI, interesting logic that ties bottlenecks to source code, Scout helps you quickly pinpoint and resolve performance abnormalities like N+1 queries, memory bloat, and more so you can spend less time debugging and more time building a great product. And with Scout's real-time alerting and weekly digest emails, you can rest easy knowing Scout's on watch to help you resolve performance issues before your customers ever see them. Give Scout APM a try today with a free 14-day trial and experience firsthand why developers worldwide call Scout their best friend. As an added bonus for real Python podcast listeners, Scout APM will donate $5 to the open source project of your choice when you deploy. Learn more at scoutapm.com/realpython. Thanks to David Amos again for joining me and I want to thank you for listening to the Real Python Podcast. Make sure you subscribe to the podcast in your favorite player and if you like the show leave us a five-star rating and a review. You can find show notes with links to all the topics we spoke about inside your podcast player or at realpython.com/podcast. And while you're there you can leave us a question or a topic idea. I've been your host Christopher Bailey and look forward to talking to you soon. See you Chris. Thanks again to Scout APM. Don't forget the added bonus for real Python listeners. Scout APM will donate $5 to the open source project of your choice when you deploy. Learn more at scoutapm.com/realpython.",
    "IP2SjhIkAUU": "Welcome to the Real Python Podcast. This is Episode 40. Have you wondered how Python manages memory? How are your variables stored in memory and when do they get deleted? This week on the show, David Amos is here and he's brought another batch of PyCoders Weekly articles and projects along with the Real Python article on Python memory management. We cover another article about creating even and non-even space to raise in Python with np.linspace. We share an article titled \"The Unholy Way of Using Virtual Environments.\" This leads to a discussion on how to structure the directories around a virtual environment. We also cover several other articles and projects from the Python community, including storing a list in an int, why you should use an ORM, unraveling \"not\" in Python, an open-source Python fuzzer, and Python static website generators.\n\nOkay, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey David, welcome back to the show.\n\nHey Chris, thanks for having me back. Do you want to start off this week talking about your first article?\n\nSure, yeah. So the first one I've got on my list is a Real Python article called \"np.linspace Creates Evenly or Non-Evenly Spaced Arrays.\" This one comes to us from Steven Gruffetta, who is one of the newest authors on the Real Python team. It's about the np.linspace function, which is used to create, most people think of it as creating evenly spaced arrays of numbers. If you want to create something that starts with zero and goes up to 100 and is taking steps of like 10 between each consecutive number in the array, you do something like linspace. It stands for linear space, right? They're spaced linearly. It doesn't have to be evenly spaced, so you can use one space to create something that's not exactly an evenly spaced array of numbers. So this article is very comprehensive. It goes through all of the parameters for the linspace function, how to control things, you know, have finer control over the types of the values, setting your endpoints, things like that. It gets into some interesting examples of it. So he has an example where you kind of go through and model like a food production conveyor belt, okay? And you use these arrays to help you model that kind of a situation. He also talks about how you can use arrays like this to represent mathematical functions discretely. So if you have a continuous function like a polynomial, and I mean you could say create a function, Python function that takes like, you know, some number x and returns the value of that polynomial evaluated at x, and then you could, you can use this to create like an array or something, you know, but that function is just like it's... Well, you get the input and the output, but what if you want to like graph that function or you want to use the values of that function as sort of input into some other algorithm? Well, you need a way to represent not just the function, I guess as like a where you take an input and give an output, but you need a way to represent the function as like a collection of data. And you can use the linspace function and the arrays that it produces to do that. So he talks about that, which is helpful in a lot of situations, you know, obviously in things like scientific computing and data science and things like that, but also getting into graphics and just modeling and stuff like that can crop up in a lot of different ways. So that's a kind of a cool application, but yeah, there's just a lot of good stuff in it. It's incredibly comprehensive, lots of great plots and things to look at. So fantastic job, Steven, on the article.\n\nTo take a step back there, so the np is standing for numpy, right?\n\nOh yeah, thank you. Good to point that out. Yes, it does stand for... This comes from the numpy package. So this is the linspace function in that, and it returns a numpy array, and those are advantageous for a lot of data situations because of the... It's more of a C implementation, and so they're a little bit smaller and, right, yeah.\n\nOkay, yep. There's a lot of advantages of using numpy arrays over something like just a Python list or Python even has an array data structure. There's an array module with an array class in it, and those are good if you want like a pure Python implementation, but they're still not quite as speedy and efficient and everything as the numpy arrays. So awesome. So my first one, it's a really interesting one. I was, when I saw the list of articles on PyCoders, I was like, okay, well, this looks kind of fascinating, and it's titled \"The Unholy Way of Using Virtual Environments.\" And it's by Bupesh Varshney. It's on his development blog. And you've probably heard us talk about virtual environments before on the show, and we're definitely both proponents of using them. And I typically use the built-in tools that come with Python, the venv command, and use that for building my virtual environments. But there are different ways of schools of thoughts here. And this definitely has a very unique one. So, yeah, he starts out with these three different ways, and the first one is he considers the moral way, or maybe would be considered a very common way, and that you start a project folder, and as you're setting it up, you create a virtual environment inside of that directory. At that point, if you say, start creating a git in it inside there, you have to be aware of the idea that, okay, I need to make sure that I have a git ignore file that is not going to include this virtual environment, and to make sure I don't back up this entire coding environment and all of the stuff that goes with it there. And I'm guessing that's the struggle that this author has had with virtual environments, is that the idea of, like, accidentally putting them into there. And it might be just in, I don't know, naming conventions or other kinds of things. Anyway, so the pros to this, he calls it the moral way, is that it's portable, it's easy to remove and create new environments. It's been a pretty common technique for me, just create a directory, have the v and v in there, and then just making sure that if you're using git and you're committing your stuff, that you just want to make sure it has an ignore file that ignores all that stuff inside there, right? So, you know, the cons that he mentions there is accidentally committing your v and v, and that could be because you're doing something interesting as far as naming on the constructions of your v and v, so here's the second way, which he calls it the holy approach. Holy being like, you know, h-o-l-y, and in this one, it's creating a directory structure first, and then inside of that, having a project folder and a vnv folder separate, and so in that case, the project folder is embedded separately, and that's where you're doing your git commit, and you're actually, or you're initializing your git, and so it's not gonna grab any of that stuff outside there. You don't need to add it to your git ignore, and you can easily still swap environments, like you can with the other one, and you can use custom names if you wanted to for things like that. The problem is it can be a little bit confusing in navigating. It's something that I've noticed often in something like a Django project where you might have an outer folder like that, and then all of the applications that are inside of it, you end up with kind of this duplicate naming, and you kind of just have to be aware of what you're doing, yeah, inside of that. I don't typically do that one as much, but I can see the structure, and again, it might be kind of just an organizational thing. So here's the one that's really weird, is he calls it the unholy way, and this is to go ahead and create the virtual environment, and then start building your project inside of the virtual environment, folders in directory, and his reasoning is that you can't accidentally commit this V and V. You don't need to bother with a git ignore, because it's already sort of embedded in this lower level directory that's inside the structure, you know, sitting alongside the other areas of the different things that are inside the virtual environment. The cons are, I think, are huge on this one. It's really not portable, yeah, and it can really cause some issues. He has a whole list of ways that he's created to implement this, shell scripts and things like that to automate the process, and I just, I don't, I don't see the need to do it, but I think there is a reply that's at the bottom of this article, this blog post, that really covers my opinion really well, the idea that the environment really should be this ephemeral thing that can be recreated on, you know, different people's platforms and so forth. Yeah, and then something that we focused on a lot in other episodes where we've been talking about, you know, the portability of code, and also the idea of there's different uses for the code, there's the, there's the environment that a developer is going to need, and even, you know, somebody's like helping on, like, an open source project, they would also maybe need certain libraries for including testing and things like that. So like this sort of shared development sort of thing where that environment may be slightly different, or it could be a thing where, again, you have like a testing and a production or what have you, and then, you know, again, if it's an open source thing, there's this whole other type, which is like an end user is going to need a very different type of environment there, and so like it should, in my opinion, be an ephemeral thing, you know. So the next one I've got is another really interesting and sort of off the wall kind of article. All right, it's called \"Storing a List in an Int.\" This immediately piqued my interest, and I was like, I've got to check this out. Like, this is totally up my alley. And the concept here is that Python's integer type, unlike C or Rust or Go or something, a lot of these other languages, the integers in Python have arbitrary precision or I'm sorry, well, arbitrary unlimited precision, which means that there is no, there's no like maximum integer. You can just keep going until you're until you, your memory runs out. So like the largest integer that you can store in Python with on your computer depends on your memory, okay? And that's it, whereas in, in a lot of other languages and especially like in C, you have like different sizes and they have different ranges and are they signed or unsigned, like there's all this stuff about it, and there's like, you know, very hard limits until like, like that's the biggest integer that you can store in this kind of integer type and you just don't have that in Python. It's all handled for you behind the scenes. So you have this unlimited precision, unlimited here is kind of like in air quotes, right? Like it's sort of like, sure, I mean, in theory, it's unlimited, but it's limited, it's limited by your hardware and not by like the language or anything itself. It kind of goes back to the idea that I've had a couple of people on talking about pandas and ways to, you know, make, again",
    "dgxbdy-21jE": "Welcome to the Real Python Podcast. This is Episode 41. It's been quite the year for the Real Python team. We've written, edited, curated, illustrated, and produced a mountain of Python articles. We've also upgraded the site and membership with office hours, transcripts, this podcast, and much more. This week, we're joined by two members of the Real Python team, David Amos and Joanna Jablonski. We wanted to share a year-end wrap-up with a collection of articles showcasing the diversity of Python topics and the quality of our team's work this year. Joanna and David helped shepherd articles through the multi-stage editing process, ensuring they impart crucial Python knowledge and provide a thorough didactic experience. We hope you enjoy this review. As a programming note, there won't be an episode next week, but we will be back the following week with a year full of great guests, topics, projects, and articles.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us to learn real-world Python skills with a community of experts at realpython.com. Hey David, welcome back.\n\nHey Chris, good to be here. We have a special guest this week, another member of the Real Python team, Joanna Jablonski is helping us out with this episode.\n\nHi guys, hey, welcome, thank you.\n\nWe're considering this sort of a year-end wrap-up for the Real Python podcast. We're not going to have an episode next week, so this will be kind of our end of the year spectacular. Joanna is really a great person to bring on board, along with David. Both of you guys are super involved in helping carry all those articles to the site that everybody enjoys every week. I want to talk a little bit about Joanna. I mentioned you're involved in that process way back in episode one with Gorana, and then I think I talked to David about it a little bit and talked about the kinds of roles that you have. Do you want to just go over your background a little bit with Real Python and what you're currently doing? \n\nI came on board early 2018. I guess the broadest way to describe what I do is I just run written content at Real Python. We take our articles through a pretty extensive review process, and we're really proud of how that's going. I'm really happy with the content that's been put together and just the community that's grown up around it. It seems like a really positive place to learn, which is useful for me too because I don't really have a traditional CS background. When I started, it was basically a way for me to just read and write tutorials all day. So I basically get to be paid to learn to a large extent, and that's been really cool. I think people could probably tell that's sort of my background with Real Python too. I was super excited to come on board and use these resources as a way to learn. By teaching the tutorials and now the podcast has been really fantastic to kind of broaden that even a little bit more to ask lots of basic questions of people, and hopefully people have those same questions that they want answered.\n\nPartly what we're going to do here is go over a collection of articles that we feel really highlight not only what Real Python provides as this resource, but also kind of standout stuff from the year. A lot of these we've talked about on the podcast, so we'll mention the episode that they came on. We're not going to do super deep dives on them, but we want to talk about key takeaways, things that we thought were really great about these articles, why you may be interested in them if you're interested in a particular learning path, and just to provide you a good resource like, hey, if you missed this, you should check these out this year if you want to take some time over the end of the holidays here to enjoy them. Alright, let's get started.\n\n[Music]\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us to learn real-world Python skills with a community of experts at realpython.com. Hey David, welcome back.\n\nHey Chris, good to be here. So we have a special guest this week, another member of the Real Python team, Joanna Jabonsky is helping us out with this episode.\n\nHi guys, hey, welcome, thank you. We're considering this sort of a year-end wrap-up for the Real Python podcast. We're not going to have an episode next week, so this will be kind of our end of the year spectacular, and Joanna is really a great person to bring on board, along with David. Both of you guys are super involved in helping carry all those articles to the site that everybody enjoys every week. I want to talk a little bit about Joanna. I mentioned you're involved in that process way back in episode one with Gorana, and then I think I talked to David about it a little bit and talked about the kinds of roles that you have. Do you want to just go over your background a little bit with Real Python and what you're currently doing?\n\nI came on board early 2018. I guess the broadest way to describe what I do is I just run written content at Real Python. We take our articles through a pretty extensive review process, and we're really proud of how that's going. I'm really happy with the content that's been put together and just the community that's grown up around it. It seems like a really positive place to learn, which is useful for me too because I don't really have a traditional CS background. When I started, it was basically a way for me to just read and write tutorials all day. So I basically get to be paid to learn to a large extent, and that's been really cool. I think people could probably tell that's sort of my background with Real Python too. I was super excited to come on board and use these resources as a way to learn. By teaching the tutorials and now the podcast has been really fantastic to kind of broaden that even a little bit more to ask lots of basic questions of people, and hopefully people have those same questions that they want answered.\n\nPartly what we're going to do here is go over a collection of articles that we feel really highlight not only what Real Python provides as this resource, but also kind of standout stuff from the year. A lot of these we've talked about on the podcast, so we'll mention the episode that they came on. We're not going to do super deep dives on them, but we want to talk about key takeaways, things that we thought were really great about these articles, why you may be interested in them if you're interested in a particular learning path, and just to provide you a good resource like, hey, if you missed this, you should check these out this year if you want to take some time over the end of the holidays here to enjoy them. Alright, let's get started.\n\n[Music]\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us to learn real-world Python skills with a community of experts at realpython.com. Hey David, welcome back.\n\nHey Chris, good to be here. So we have a special guest this week, another member of the Real Python team, Joanna Jabonsky is helping us out with this episode.\n\nHi guys, hey, welcome, thank you. We're considering this sort of a year-end wrap-up for the Real Python podcast. We're not going to have an episode next week, so this will be kind of our end of the year spectacular, and Joanna is really a great person to bring on board, along with David. Both of you guys are super involved in helping carry all those articles to the site that everybody enjoys every week. I want to talk a little bit about Joanna. I mentioned you're involved in that process way back in episode one with Gorana, and then I think I talked to David about it a little bit and talked about the kinds of roles that you have. Do you want to just go over your background a little bit with Real Python and what you're currently doing?\n\nI came on board early 2018. I guess the broadest way to describe what I do is I just run written content at Real Python. We take our articles through a pretty extensive review process, and we're really proud of how that's going. I'm really happy with the content that's been put together and just the community that's grown up around it. It seems like a really positive place to learn, which is useful for me too because I don't really have a traditional CS background. When I started, it was basically a way for me to just read and write tutorials all day. So I basically get to be paid to learn to a large extent, and that's been really cool. I think people could probably tell that's sort of my background with Real Python too. I was super excited to come on board and use these resources as a way to learn. By teaching the tutorials and now the podcast has been really fantastic to kind of broaden that even a little bit more to ask lots of basic questions of people, and hopefully people have those same questions that they want answered.\n\nPartly what we're going to do here is go over a collection of articles that we feel really highlight not only what Real Python provides as this resource, but also kind of standout stuff from the year. A lot of these we've talked about on the podcast, so we'll mention the episode that they came on. We're not going to do super deep dives on them, but we want to talk about key takeaways, things that we thought were really great about these articles, why you may be interested in them if you're interested in a particular learning path, and just to provide you a good resource like, hey, if you missed this, you should check these out this year if you want to take some time over the end of the holidays here to enjoy them. Alright, let's get started.\n\n[Music]\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us to learn real-world Python skills with a community of experts at realpython.com. Hey David, welcome back.\n\nHey Chris, good to be here. So we have a special guest this week, another member of the Real Python team, Joanna Jabonsky is helping us out with this episode.\n\nHi guys, hey, welcome, thank you. We're considering this sort of a year-end wrap-up for the Real Python podcast. We're not going to have an episode next week, so this will be kind of our end of the year spectacular, and Joanna is really a great person to bring on board, along with David. Both of you guys are super involved in helping carry all those articles to the site that everybody enjoys every week. I want to talk a little bit about Joanna. I mentioned you're involved in that process way back in episode one with Gorana, and then I think I talked to David about it a little bit and talked about the kinds of roles that you have. Do you want to just go over your background a little bit with Real Python and what you're currently doing?\n\nI came on board early 2018. I guess the broadest way to describe what I do is I just run written content at Real Python. We take our articles through a pretty extensive review process, and we're really proud of how that's going. I'm really happy with the content that's been put together and just the community that's grown up around it. It seems like a really positive place to learn, which is useful for me too because I don't really have a traditional CS background. When I started, it was basically a way for me to just read and write tutorials all day. So I basically get to be paid to learn to a large extent, and that's been really cool. I think people could probably tell that's sort of my background with Real Python too. I was super excited to come on board and use these resources as a way to learn. By teaching the tutorials and now the podcast has been really fantastic to kind of broaden that even a little bit more to ask lots of basic questions of people, and hopefully people have those same questions that they want answered.\n\nPartly what we're going to do here is go over a collection of articles that we feel really highlight not only what Real Python provides as this resource, but also kind of standout stuff from the year. A lot of these we've talked about on the podcast, so we'll mention the episode that they came on. We're not going to do super deep dives on them, but we want to talk about key takeaways, things that we thought were really great about these articles, why you may be interested in them if you're interested in a particular learning path, and just to provide you a good resource like, hey, if you missed this, you should check these out this year if you want to take some time over the end of the holidays here to enjoy them. Alright, let's get started.\n\n[Music]\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us to learn real-world Python skills with a community of experts at realpython.com. Hey David, welcome back.\n\nHey Chris, good to be here. So we have a special guest this week, another member of the Real Python team, Joanna Jabonsky is helping us out with this episode.\n\nHi guys, hey, welcome, thank you. We're considering this sort of a year-end wrap-up for the Real Python podcast. We're not going to have an episode next week, so this will be kind of our end of the year spectacular, and Joanna is really a great person to bring on board, along with David. Both of you guys are super involved in helping carry all those articles to the site that everybody enjoys every week. I want to talk a little bit about Joanna. I mentioned you're involved in that process way back in episode one with Gorana, and then I think I talked to David about it a little bit and talked about the kinds of roles that you have. Do you want to just go over your background a little bit with Real Python and what you're currently doing?\n\nI came on board early 2018. I guess the broadest way to describe what I do is I just run written content at Real Python. We take our articles through a pretty extensive review process, and we're really proud of how that's going. I'm really happy with the content that's been put together and just the community that's grown up around it. It seems like a really positive place to learn, which is useful for me too because I don't really have a traditional CS background. When I started, it was basically a way for me to just read and write tutorials all day. So I basically get to be paid to learn to a large extent, and that's been really cool. I think people could probably tell that's sort of my background with Real Python too. I was super excited to come on board and use these resources as a way to learn. By teaching the tutorials and now the podcast has been really fantastic to kind of broaden that even a little bit more to ask lots of basic questions of people, and hopefully people have those same questions that they want answered.\n\nPartly what we're going to do here is go over a collection of articles that we feel really highlight not only what Real Python provides as this resource, but also kind of standout stuff from the year. A lot of these we've talked about on the podcast, so we'll mention the episode that they came on. We're not going to do super deep dives on them, but we want to talk about key takeaways, things that we thought were really great about these articles, why you may be interested in them if you're interested in a particular learning path, and just to provide you a good resource like, hey, if you missed this, you should check these out this year if you want to take some time over the end of the holidays here to enjoy them. Alright, let's get started.\n\n[Music]\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us to learn real-world Python skills with a community of experts at realpython.com. Hey David, welcome back.\n\nHey Chris, good to be here. So we have a special guest this week, another member of the Real Python team, Joanna Jabonsky is helping us out with this episode.\n\nHi guys, hey, welcome, thank you. We're considering this sort of a year-end wrap-up for the Real Python podcast. We're not going to have an episode next week, so this will be kind of our end of the year spectacular, and Joanna is really a great person to bring on board, along with David. Both of you guys are super involved in helping carry all those articles to the site that everybody enjoys every week. I want to talk a little bit about Joanna. I mentioned you're involved in that process way back in episode one with Gorana, and then I think I talked to David about it a little bit and talked about the kinds of roles that you have. Do you want to just go over your background a little bit with Real Python and what you're currently doing?\n\nI came on board early 2018. I guess the broadest way to describe what I do is I just run written content at Real Python. We take our articles through a pretty extensive review process, and we're really proud of how that's going. I'm really happy with the content that's been put together and just the community that's grown up around it. It seems like a really positive place to learn, which is useful for me too because I don't really have a traditional CS background. When I started, it was basically a way for me to just read and write tutorials all day. So I basically get to be paid to learn to a large extent, and that's been really cool. I think people could probably tell that's sort of my background with Real Python too. I was super excited to come on board and use these resources as a way to learn. By teaching the tutorials and now the podcast has been really fantastic to kind of broaden that even a little bit more to ask lots of basic questions of people, and hopefully people have those same questions that they want answered.\n\nPartly what we're going to do here is go over a collection of articles that we feel really highlight not only what Real Python provides as this resource, but also kind of standout stuff from the year. A lot of these we've talked about on the podcast, so we'll mention the episode that they came on. We're not going to do super deep dives on them",
    "yB7wmMH6h08": "Welcome to the Real Python Podcast. This is Episode 42.\n\nAre you familiar with the role data engineers play in the modern landscape of data science and Python? Data engineering is a sub-discipline that focuses on the transportation, transformation, and storage of data. \n\nThis week on the show, David Amos is back and he's brought another batch of PyCoder's Weekly articles and projects, along with the Real Python article on data engineering. We talk about a project where researchers downloaded 10 million Jupyter notebooks from GitHub to gather insights about the current state of data science technology.\n\nWe also discussed an article about validating data in Python with the package Cerberus, and this led us to a conversation about a set of coding challenges from Advent of Code. We also cover several other articles and projects from the Python community, including building your own chess engine, the visual guide to NumPy, a free and open-source alternative to SAP, a library for working with STL files and 3D objects, and is Python really a bottleneck? Okay, let's get started.\n\n[Music]\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey, David, welcome back. Hey, Chris, thanks for having me back. It's a new year, got a new set of articles and projects to talk about this week. Got a fun batch of stuff. Yeah, so I want to start off talking about a Real Python article. This is by our guest who joined us a few weeks ago, Kyle Stratus. Kyle was also on an early episode talking about finding another job during the pandemic. He has a real background in this. I saw him posting on Twitter recently about being a generalist, and I thought, \"Oh my gosh, that's really a good definition of what I am. I am such a generalist in so many different areas.\" He had this book talking about it, so I'll include a link for that. But his article is about... It's less pure Python and more describing roles for jobs and so forth in our industry, and it's titled, \"What is Data Engineering and is it Right for You?\" The article really goes into describing the whole discipline of what data engineering is. People maybe have heard of managing data or databases and so forth, and it feels like a term that needs to be defined a little bit compared to what a data scientist is and what's happening there. He goes into the article and really dives deep into what does a data engineer do. One of the main things that they're in charge of is this idea of a data pipeline. Data that's coming into an organization can be so varied. It can be sensor data from vehicles, sensor data like in the healthcare industry. It can be coming in at various tempos and could be very sporadic and coming out of different resources and inputs. And then the one I'm most familiar with is financial data coming from lots of different systems, kind of coming in internally or externally and so forth. You've got to know where the data is coming from and sort of the cadence of it. He goes in and talks a little bit about this idea that a lot of programmers might have heard of a model view controller setup or MVC. Where this sort of fits in is that the data engineer's job is to really build this model of the data to organize it and shape it into a usable thing so somebody like a business intelligence person or somebody who does visualizations on top of that needs that organized data and hopefully it won't be just their job to gather and clean everything and make it all ready to go. So yeah, that model of data and organizing it is really where this data engineer role kind of fits in. And then it goes into diving into talking about what are the customers that you will be working with and those are mostly internal customers. I think you would think about within your organization, but there can also be outside customers if you're serving data as some sort of service in another way. And then it goes through the data flow. There's a lot of terms that are acronyms that people throw around. If you look at people's resumes or job listings, they might mention something called ETL, which stands for extract, transform, and load. That's part of that whole data flow. The extracting is bringing in all the data from these different sources and wrangling it in a certain way, and then transforming it involves potentially the whole thing of normalizing it, like maybe it's removing duplicates, it's going to possibly be transforming it in making sense, and maybe it's date information and it's incomplete and it needs to be in your specific format for that. So it might be a form of cleaning or optimizing, missing fields, errors, or potentially corrupt data. And the last is then to load it up and put it into whatever the format of the database that's in there. So it goes really deep into all that stuff, which I think is really cool. I did a lot of this. I worked in a couple of different roles. I know I've talked about the marketing role that I had, but the role I had before that was called credit risk. And so we were bringing in and analyzing all the different loans that are being processed through the system, and everything from auto loans to mortgages to credit cards and so forth. We needed to make sure that data was clean and prepared. For whatever reason, in the process of doing that, I was mostly the person reporting on it, but we had become a part of the wheel in the cog where this whole machine where my job was to make sure that all these things were appropriately formatted. And so you'd find we had all these reports I'd write at the top of the month to basically make sure everything was correctly inputted and find weird formatted things or something's put in as text that it's supposed to be in an integer. Yeah. And I wasn't using anything advanced. It would have been awesome to have much more automated tools and use Python, which is what really is a great tool for doing a lot of this. But I'm familiar with all the concepts and what needs to happen before you can ever report on what you have here. And then he talks a lot about the common data engineering skills. Do you need general programming types of skills? Everything from object-oriented, the idea that you're kind of creating this structural language that the data needs to fit into with data structures and then being familiar with the database technologies and they could be the ones that we've talked about on the show a lot, the SQL-based ones with relational databases, but also there's popular ones for other types of data that comes in like the NoSQL type that are more sort of document-based and not really table-based type of relationships that you have. And then there's a variety of other ones that are interesting for speeding up and creating indexes and things like Redis and tools like that. And then you also need to be familiar with some of the other technology that's out there, like cloud engineering. Probably most importantly at the very end of it, he talks about what isn't data engineering. And it really isn't data science. You know, that's something that really sort of happens after the fact, after the data is in this format that is ready to be consumed. Right now you're going to be trying to figure out and create your models and build stuff on top of it or business intelligence, which I talked a little bit about with the visualizations and charting the data or even machine learning. And so it's such a crucial part of the whole flow. And it actually kind of lends itself to somebody who is a generalist in a way. Somebody who has a background in some of these other areas that knows what these other teams are going to need. I was working at that same bank where I was working in the credit risk area, and I had worked in mortgages before that, and they were building a data warehouse, this separate team, and they were constantly asking us questions because they were the ones trying to model this stuff, but they didn't ever have to work with it. And so they didn't understand how it should be laid out or organized or what makes sense, what sort of cadence should be stored, and they were trying to data warehouses very often can pre-bake attributes and things inside of there to make it easier and aggregate things so you're not having to do raw searches all the time. And the problem is they really had no idea what kinds of things that we would want to report on. So there's always this communication between teams, and having a generalist can really be useful there. It's definitely what Kyle's kind of slid into as this role over the last several years coming out of academia. Yeah, I'm really glad to see this topic being discussed on Real Python because I read an article a while ago. In fact, it may have even been like pre-2020, like in 2018. 2019, where they were talking about there were all these people that data science had become super popular and there are all these people going to data science boot camps or getting data science master's degrees or things like that, and it was all very focused on machine learning, deep learning, neural networks, and you know all that stuff. And when they were going out into the workforce, you had all these companies that were like, \"Oh, I want to hire a data scientist because look at all the insights and you know some of these big companies are getting from this.\" And so I want that for my company too. And they'd hire one of these people fresh out of school or something, and the realization was that the company that hired them was not in any position to be doing any machine learning or they couldn't really get any insights from the data because it hadn't been normalized, it hadn't, right, and the whole process hadn't been done. So you found these data scientists that were sort of thrown into a role where they really needed to be a data engineer, but they didn't have the right background or anything. Because one of the things that Kyle talks about in his article is that you know data engineering relies a lot on software engineering best practices. And so you take full advantage of things like version control and things like that. So there was this real disconnect between what companies wanted and what they actually needed. Yeah, definitely. And the people, you know, to fill those roles. So but it's such a crucial part of it. Even if you're not doing any like real machine learning, I think just to even get to the point where you can trust the kinds of insights that you get from your data, you just, you have to start from data engineering. It's the absolute like first step to all of that. So anyways, yes, I'm just excited to see that. I think there's going to be more stuff coming out on that topic as well, where it actually gets into examples and showing you how to actually do some of this stuff because this article is very, I mean, I don't think there's even a single Python code block in it. It's just describing what data engineering is, what it isn't, and things like that. But yeah, really good stuff. Yeah, I'm excited to see the kinds of things that you could add on top of it and just even the practice of cleaning data and so forth. Very often the data that is presented in tutorials is always so pure, right? You know, even the stuff that comes from like different challenges and things on the net, the data sources are all pre-organized, which is, yeah, it's such an interesting skill. You come to these companies that have like, you know, 10, 15 years of history. Oh yeah, you know, the difference between, yeah, it's like that's crazy. It can be pretty overwhelming. But that's the reality. So what do you got? We got first here. My first article is called Building My Own Chess Engine, and it's not mine. It's written by Andrew Healy. It's about creating his own chess engine, playing to play chess using Python. So he says he's been learning chess again and he decided how to learn how to program a chess engine for the first time. And I wonder if it's related to the Queen's Gambit. I think that's, yeah, I know it's such a popular thing right now. Yeah. And I saw someone post like, I think it was like a Google Trends thing where like chess is basically just shot up after that movie came out and everything. But you can't buy a kit. It's like the same kind of idea like you couldn't buy a microphone or a lighting rig for all the video and audio cameras for computers are impossible to get to, right? Right. Yeah. It's funny. He says that, uh, after skimming some introductory text, he was convinced that building a simple chess engine, one that would put up a fair fight against a casual player would take no more than a few days. But he was wrong. I think this is going to be kind of a series that he's going to, you know, kind of continue to talk about this. But he basically, in this, in this article, he just talks about, like, kind of his general approach to it. Yeah. It was way more difficult than I expected it to be. For example, chess is such a beautiful and classic example of something called a combinatorial explosion. There's actually a very famous number associated with chess called the Shannon number. There's a mathematician named Claude Shannon who calculated that there's about 10 to the 120 possible games of chess. So it's, it's one of those things that's weird. Like chess is finite. Like there's only, there's only so many combinations that you can get out of these pieces and moves, which means that at some point there's only a finite number of, like, games that can happen. It's not like, um, it's a huge number though. I mean, 10 to the 120 is absolutely massive, right? But you know, dealing with this thing, like he, the author, Andrew, when he was thinking about, like, okay, how do I search for optimal moves and things like that, he started to realize that, okay, after, for the first move, there's something, I think it's like a few hundred possible moves for the first move. So it's, that's a pretty quick search when you're trying to find, like, of those 400 possible moves, what's the optimal one, right? Like, if your opponent's already moved, then after that, it starts getting into the thousands. And then by the third one, it's already up into the millions. And it just is like exploding. And so by the time you get like a few, just, you know, a half a dozen or so moves into the game, the time that it",
    "wlKulcJ6Op0": "Welcome to the Real Python Podcast. This is Episode 43. What's it like to design a Python library for three different audiences? This week on the show, we have Nir Adas, creator of Jupylet. His new library is designed for researchers in deep reinforcement learning, musicians interested in live music coding, and kids interested in learning to program. Everything is designed to run inside of a Jupiter notebook. Nir's initial goal was to create a framework for his own study of deep reinforcement learning, and this led to building a framework for 2D and 3D games and graphics. As he continues the development, he realized that this interactive environment could be useful for learning Python. \n\nWe also talk about how he got interested in live music coding and the advanced mathematics of sound synthesis. Nir also shares some resources for finding graphical assets and tools for creating 3D models. \n\nAs a programming note, our connection had some sound issues. We worked hard to try to clean it up for you, but you'll still hear some of those artifacts. \n\nThis episode is brought to you in part by DigitalOcean's App Platform. So let's get started. \n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real world Python skills with the community of experts at realpython.com. \n\nHi, Nir. Welcome to the program. \n\nThank you for inviting me. \n\nA couple weeks ago, we had mentioned Jupyter, which I had been calling You Pilot, and you said you weren't too concerned about the pronunciation, but Jupyter sounds more appropriate. I got so fascinated with the program and again you sent me an email which I mentioned that you had updated the MIDI drivers and I was having a lot of fun playing with that. Thanks for sending me that email. \n\nYeah, I said, \"Well, why don't you come on the show?\" I know you were a little nervous initially. Thanks for coming on. \n\nGreat, thank you. Maybe I could start off first just talking a little bit about why or actually when did you start this project? \n\nWell, I started it about one year ago. While I was trying to learn reinforcement learning, I was having trouble customizing the game environment I was trying to use for training. \n\nWhat is deep reinforcement learning? Is that something you mentioned early on in the documents but I'm not familiar with it that well. \n\nDeep reinforcement learning is like a modern evolution or phase of reinforcement learning. It's a field that goes back all the way to the '50s. It's a framework that is conceptualizing the way agents interact intelligently with an environment. It can also be applied to biology. There are links between biology and the way it is applied in computer science. \n\nYou can see it sometimes in articles and papers with DeepMind. They sometimes open their papers by stating their inspiration from biological systems. They think it's also in the other direction sometimes. It's also a set of algorithms for developing agents that perform well in this context. \n\nLater in the documentation, you show sort of a DeepMind model learning a video game, I think it's Breakout. Is that the types of things that you were interested in exploring? \n\nThat model was kind of the splash moment for DeepMind and caught the attention of the world. It was the first time, I think, that the model played some of these games at a superhuman performance level. \n\nIt's interesting to see from this video how it learns and you can kind of look at what it's doing. I think about it like as if it's an intelligent being playing the game when it does what. \n\nAre there ways that you've tried to implement that in Jupylet? \n\nThe first big moment for DeepMind, I think shortly after that, Google bought them and they advanced very far ahead since then. I think they're leading the entire domain. Teaching the agents to play such historic games is being like a basic thing you want to do and start planning it yourself. \n\nThat's what I've been trying to do with the game of Pong, which is actually implemented in Jupylet. I was trying to get the model to play it using the classic Atari game simulator. \n\nSo you had to create this, you had to do quite a bit of work to get the game engine built and so forth. I was looking through the setup.py file just to kind of see like, okay, what are the different tools that you're using to create this whole framework if you will on top of it. And I noticed that you're using a few different sort of graphic libraries GL, modern GL, and Pi GLM. How are you using those? \n\nThese are kind of tools that you want to use to the basis for what you're doing on top of them. Modern GL is the wrapper for the OpenGL API, which is a very complex massive API in standard and kind of difficult to wrap your hair around. It was developed by hardware engineers back in the '90s. \n\nModern GL does a very good job of making it accessible to Python. It's very performance and it also adds some abstractions that make it a little more platonic and nice to work with. It's really a nice project. It's hard to think sometimes of the Python and 3D gaming together and this project really kind of makes it appear possible. \n\nThat's why I really appreciated that about it, that the GL API one of the advantages is that it's itself is cross-platform right across multiple operating systems and so like I was able to run Jupylet on my Mac and so that's kind of nice that you don't have to build all that we've been talking about graphical user interfaces and the advantage to a variety of them is that they do some of the underlying work of making it run on Windows and Linux and Mac. Is that true of modern GL? \n\nYeah, it runs on Mac and Linux and Windows. And by the way, there's an amazing developer who is called they now firstly for sales and was very helpful is also always very responsive. He's got his Discord channel and all the guys are there asking questions and he's always there to help. And without him, I can't imagine all this. \n\nThat's really cool. I can imagine and I guess that NumPy I'm sure it's a pretty complex project because of all the underlying c code that's involved and making sure it compiles properly on all those platforms as they progress, right? \n\nOkay. As we were talking earlier, we also talked a little bit about the need for assets. The things that you would use in this case you have a variety of them. We go back to the game programming stuff. Do you have some suggestions or resources that you think are useful for finding different graphic assets? \n\nThe one you mentioned can is an amazing website with a lot of good stuff for 3D, you basically need many textures and sometimes even models and HDR. \n\nIt's very good resources and there are also other, other the internet is full reducer so it depends on what you want to do. Because for example, for Jupylet, I wanted to include only such assets that where I could include them legally, so it took a while to find these. \n\nThat's always a challenge, huh, finding things that allow for some kind of open license but if you're using it for just for creating personal stuff than you probably have a lot more options on the internet. \n\nYeah, the moon by the way the texture of the moon is directly from school. It's an actual accurate picture for the moon also for its normal. It's called the normal map it's the one that creates the effects of the shadow on the line where they become light. \n\nThis is because it is made of a finite sequence of harmonics and when you play that one, it sounds nice. This is kind of advice I sometimes get from people. \n\nThat's great. Yeah, that's fascinating. That's cool. That's kind of it's been a bit of your introduction not really being like we talked earlier a little bit about I'd ask you if you were a musician but this is kind of an interesting way into that you know the whole sound production and the yeah that's one of the things I think why I enjoyed music and math and kind of the combination of them is they're very much related and so you're kind of going back into that a little bit about the synthesis side of things you're doing a lot of the math using either pure python but you're also in some cases using NumPy. \n\nI use the NumPy massively for that purpose. NumPy is like a very basic library for data science in Python and it's very efficient for manipulating arrays of numbers, tensors. I used it for doing all the computations all the sound processing because pure python is just too slow for that. \n\nIt's actually that's the natural way to go because sound processing is a form of computational graph. This is what inspired me to use the way PyTorch is designed to build the deep learning models. \n\nThis is what inspired me, it's actually suddenly occurred to me that there isn't much difference between the computational graphs deep learning and the computational graph you build when you actually assemble a sound synthesizer from all kinds of components that are each applied on one another and until you get the sound you want. This is also a computational graph. \n\nWell, it's really just starting because the release of the way it looks now, it's a release from last month, like one month ago. It was the first time it really came together as a project with the documentation and sound synthesis and 3D graphics. As a programming note, our connection had some sound issues. We worked hard to try to clean it up for you, but you'll still hear some of those artifacts. \n\nThis episode is brought to you by DigitalOcean's App Platform. \n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real world Python skills with the community of experts at realpython.com. \n\nDon't forget you can get started on DigitalOcean's App Platform for free at do.co/realpython. Thank you for listening to the Real Python Podcast. Make sure you subscribe to the podcast in your favorite player, and if you like the show, leave us a 5-star rating and a review. \n\nThank you for coming on the show and talking to me. Thank you for inviting me. \n\nI have a question on that as far as interactivity. One of the things that Jupyter can allow in certain circumstances is sort of like cloud kind of stuff, and I don't know if like having more than one person interacting with the code is that possible with Jupylet? I don't know that multiple people can use the same notebook in the same simultaneously. \n\nI haven't thought about it. Maybe it's but and even if it's not implemented in Jupyter now it should be technically possible in the future. \n\nIf you're not using it for just for your personal for creating personal stuff then you probably have a lot more options on the internet. That's true. \n\nI think it's amazing that you're building on top of just the GL libraries themselves and not having to structure everything on top of an existing library. Is that something that you have to fight often or things that you have to think about in the process of building a library like this? \n\nThe only problem that's happened so far was surprisingly a bug related to NumPy. Actually, two different bugs, one Windows and another one another problem on Mac machines. \n\nWhen you started to work on the project, what were the features that you were most interested in including? \n\nWhen I started, it was about making it possible to create two simple 2D games interactively in the notebook and to be able to run them effectively and efficiently. For machine learning, it was important that it should be possible to render like thousands of frames per second for the model to train. It was important for me to be able to customize the environment easily. That was the main points as I was starting. Along with that, what were features that you felt like you really had to understand? \n\nMaybe because it's as I said it started when I was trying to learn reinforcement planning and I figured that it would make perfect sense to be able to create those game environments directly in Python and interactively in a Jupiter notebook. So it started but soon after it's like kind of a ship that is sailing and it's changing course. Yeah, it's good to me that it's just a perfect, it could be it might be a perfect environment for kids to learn programming just like I had when I was a kid. I had the Commodore 64, which was simply an amazing experience as a kid growing up. I kind of wanted to recreate this experience in Jupiter for kids because there's a limit to what you can do without graphics. Jupiter is an amazing tool for teaching stuff but you can show kids how you can use it as a calculator or make a simple loop that prints strings like their name or hello world. But after a while, it's like you can run out a little bit of what will they show them next like the people not too serious. It's kind of you need something to grab their attention and I figured out that gaming graphics and music would be a very good combination together with Jupiter. \n\nI appreciate you taking all this time to talk to me and I love the project. I'll see what I can do as far as contributing to it because I want to see it keep going. \n\nThank you for inviting me. \n\nThank you for coming on the show and talking to me. Thank you for inviting me. \n\nThank you for listening to the Real Python Podcast. Make sure you subscribe to the podcast in your favorite player and if you like the show, leave us a 5-star rating and a review. \n\nThank you for coming on the show and talking to me. Thank you for inviting me. \n\nThank you for listening to the Real Python Podcast. Make sure you subscribe to the podcast in your favorite player and if you like the show, leave us a 5-star rating and a review. \n\nThank you for coming on the show and talking to me. Thank you for inviting me. \n\nThank you for listening to the Real Python Podcast. Make sure you subscribe to the podcast in your favorite player and if you like the show, leave us a 5-star rating and a review. \n\nThank you for coming on the show and talking to me. Thank you for inviting me. \n\nThank you for listening to the Real Python Podcast. Make sure you subscribe to the podcast in your favorite player and if you like the show, leave us a 5-star rating and a review. \n\nThank you for coming on the show and talking to me. Thank you for inviting me. \n\nThank you for listening to the Real Python Podcast. Make sure you subscribe to the podcast in your favorite player and if you like the show, leave us a 5-star rating and a review. \n\nThank you for coming on the show and talking to me. Thank you for inviting me. \n\nThank you for listening to the Real Python Podcast. Make sure you subscribe to the podcast in your favorite player and if you like the show, leave us a 5-star rating and a review. \n\nThank you for coming on the show and talking to me. Thank you for inviting me. \n\nThank you for listening to the Real Python Podcast. Make sure you subscribe to the podcast in your favorite player and if you like the show, leave us a 5-star rating and a review. \n\nThank you for coming on the show and talking to me. Thank you for inviting me. \n\nThank you for listening to the Real Python Podcast. Make sure you subscribe to the podcast in your favorite player and if you like the show, leave us a 5-star rating and a review. \n\nThank you for coming on the show and talking to me. Thank you for inviting me. \n\nThank you for listening to the Real Python Podcast. Make sure you subscribe to the podcast in your favorite player and if you like the show, leave us a 5-star rating and a review. \n\nThank you for coming on the show and talking to me. Thank you for inviting me. \n\nThank you for listening to the Real Python Podcast. Make sure you subscribe to the podcast in your favorite player and if you like the show, leave us a 5-star rating and a review. \n\nThank you for coming on the show and talking to me. Thank you for inviting me. \n\nThank you for listening to the Real Python Podcast. Make sure you subscribe to the podcast in your favorite player and if you like the show, leave us a 5-star rating and a review. \n\nThank you for coming on the show and talking to me. Thank you for inviting me. \n\nThank you for listening to the Real Python Podcast. Make sure you subscribe to the podcast in your favorite player and if you like the show, leave us a 5-star rating and a review. \n\nThank you for coming on the show and talking to me. Thank you for inviting me. \n\nThank you for listening to the Real Python Podcast. Make sure you subscribe to the podcast in your favorite player and if you like the show, leave us a 5-star rating and a review. \n\nThank you for coming on the show and talking to me. Thank you for inviting me. \n\nThank you for",
    "iNvWE78UwMg": "Welcome to the Real Python Podcast. This is episode 44. How do you create a virtual conference that retains the interactivity of an in-person event, and what are the tools needed for talk submissions, ticketing, and live hosting? Can those tools be written in Python? This week on the show, we have several of the organizers of the PyCascades 2021 conference. They share the process of restructuring a Python conference to meet those challenges.\n\nMy guests are Nina Zakarenko and Seb Vetter, who are the co-chairs, and Asha Zawaduk, who is the conference program chair. PyCascades will be held online from February 19th through the 21st with a day of virtual social events, one of live-streamed talks, and another of mentored sprints. We discuss ways to recreate the elusive feel of the hallway track virtually. They share advice about submitting a talk proposal and ways that you can volunteer for conferences. Tickets are available now, and PyCascades is looking for additional sponsors. If you work for an organization that can help, get in contact with them.\n\nThis episode is brought to you by PyCharm. Do you want to get work done? Use PyCharm, the Python IDE for professional developers. All right, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHi, welcome everybody. This week, I have a group of people from PyCascades, the organizers, and I'll kind of just introduce you one by one. So first, we have Nina. Why don't you tell us a little bit about what you do for PyCascades, Nina?\n\nYeah, so I'm Nina Zakarenko, and this year for PyCascades, I'm a co-organizer. I believe that is my official role, which there is no prescriptive set of things that I've been doing, so just kind of trying to be the glue that sticks everything together.\n\nGreat, and we also have Seb. What do you do for the PyCascades, Seb?\n\nI am the second co-chair this year. I've been with PyCascades since its inauguration, so I've been having or carrying a lot of institutional knowledge around paperwork, admin, finances, budgeting, so I get a lot of the questions that are logistical internally. And then like Nina as well, we kind of split up the wrangling work of the things that need to be done and trying to stick to timelines that we have, make decisions around how to move forward, stuff like that.\n\nAnd we also have Asha. Yeah, so I, this year, am the program chair. I started volunteering with PyCascades as a talk reviewer, and yeah, this year, program chairs, I put together the program from doing the organizing, the talk reviews team, and essentially the schedule with the support of Nina and Seb. All right, great.\n\nI mentioned in the intro a little bit about the dates and, you know, where people can find more information, but does somebody want to talk about the schedule a little bit, like what you guys are including this year in PyCascades?\n\nI can talk about the overall vision, and then I think Asha can fill us in on the details. So traditionally, PyCascades has been a single-track conference. It's been two days, and that format works really well for in-person because that means that each speaker has everybody's undivided attention. Unfortunately, in the after times, our attention is very divided. So yeah, we decided to switch things up because we're going virtual. We kind of made this decision early on that we didn't have to copy and paste our format for how things were in person. So we decided to do one day, two tracks, and kind of really take advantage of people's time at home. You know, people have other responsibilities now. There are a lot of online conferences going on, and to kind of help be respectful of people's time.\n\nSo we're going a more traditional route with some talks from speakers that went through a traditional CFP process that were accepted by a committee where it's kind of a structured talk. We've asked folks to pre-record this part of the event because I think we've all been to a lot of online conferences where things have gone wonky or somebody's connection has been dropped off. Sure, yeah, totally. So that's kind of our standard track, and then for the second track, we decided to do something really fun and interesting. I probably shouldn't be sharing this, but I'll tell you our working title. Which was the Chaos Track. Okay, good chaos. So this track is going to be, yeah, good chaos, chaotic good. And this is going to be the track where we have live panels and demos and interactive discussions where we're kind of expecting folks to maybe have technical issues or maybe something will go wrong. These are going to be interactive sessions where there's some more Q&A and a little bit more dynamic. There aren't slides. And so we're kind of hoping to have the best of both worlds.\n\nYeah, we really wanted to kind of approach it in a really different way because, you know, when you're in person, it's not just about the talks. And the talks are obviously the highlights, but it's also you get a lot of connection, you get a lot of engagement. You get a lot of conversations that, you know, there's a whole way, a whole hallway track that people are really excited about generally. And it's very difficult to kind of recreate that in a virtual environment. So, you know, we really wanted to find a way to still connect, engage, and that's kind of where the whole idea for this more interactive track came from, a way to be able to connect with people who have been a part of the community to have, you know, more conversations with them around topics to see what they're working on, and yeah, to have a little bit of balance between being and listening to more of a listening and watching to more of a passive talk as well as more kind of active discussion and to balance that.\n\nIs there new types of technology that you're using or are there is there a model of something that you've seen and you're like, oh, this would be kind of a way that we could maybe include it in this version of PyCascades.\n\nOkay, yeah, I think from our perspective, this has been a very new experience going virtual because obviously there is a lot of new and different tools that come into play for this. I think one of the things that we've always benefited from, not just us as PyCascades but as a larger Python community, is that we have a lot of people that have different areas of expertise that we can draw from, and especially the organizers community within the Python community has experience, has worked out some of these things throughout 2020 or has figured out this works well, this doesn't work as well. So we drew from a lot of knowledge from other people that we're connected to. We look towards PyCon Australia, for example, regarding their experience, regarding their tools and ways of bringing talks into the online space. So we basically took a lot of their learnings and reached out to other people to inform our decision around that.\n\nBut there was a lot of research and comparing and talking about what are options that we have to kind of make this become a reality. Yeah, there was definitely a lot of testing in terms of trying out different platforms, hopping on many different types of global events and smaller events and seeing how other events are kind of doing virtual conferences and to be able to just see what the experience was in a live format and be able to kind of bring that knowledge back. So we definitely had a lot of people just jumping in and looking at other conferences definitely and getting inspired by them. But I also want to mention too that, you know, their tools do make a difference, but I think we're really trying to focus on what's between the lines, you know, how it is, can you know you can connect in so many different ways and so many different tools and we want to make sure that some of that fun engagement aspect is there no matter what tool we're planning to use.\n\nThat sounds great. I'm excited to check out what you guys are creating. So we ended up selecting pre-tix, T-A-L-X, pre-tix, and then Venulis for the platform. And to my understanding, those are tools that are built in Python and have been used for other Python conferences successfully in the past, like PyCon Australia. So to back up a little bit, that's the tool for ticket sales, the tool for the CFP, the call for proposals, as well as the hosting platform for the videos on the day of the event. And for us, all those things are now going to link together and they're built by the same team. So we're really excited about that because we've definitely had issues in the past with platforms like PaperCall for CFPs, which is a good platform but unfortunately, I don't know who they've angered, but their acceptance emails go into some people's spam folders automatically. And so in the past, we've had a lot of issues with telling speakers that they've been accepted and them having no idea and then confusion. Wow, the systems that we've selected have worked really great so far and we've been happy with our decision.\n\nI know you guys are still kind of working out some of that. How would the hallway track sort of fit into what you're creating there?\n\nSo I think we've kind of took it apart in little pieces essentially. So for example, even though all of the talks are on the pre-recorded track, we are actually including an intro and a thank you at the end. So we're adding an extra five minutes to each talk just so to be able to engage in person and for the speaker to actually say hello to everybody and then thank yous for listening in a more interactive way. And so it's really kind of a collection of those small little things to be able to provide chats and be able to provide, for example, an inch more interactive Q&A. So PyCascades is typically never done live Q&A for any of the talks. We've always just let people approach the speakers after the talk is over so they can have a conversation there. And so we've kind of tried to recreate the same kind of way into the platform where we actually stream the talk, say hello, stream the pre-recorded talk, and then essentially kind of shuffle people over into a video chat channel and a platform where they can kind of continue that conversation in a smaller group. So that's something that would be kind of really similar to like, you know, a part of the hallway track almost in a way. And so it's really kind of a collection of small things like that that we're trying to recreate. We did want to provide some kind of social events because we particularly done that in PyCascades before because it gives a chance for people to meet each other. And we've always had like a pre-registration that you could register the evening before. So we wanted to have something similar. So I think a lot of times is creating more opportunities for conversations to happen is really where the hallway kind of track is about and so being able to create some of those moments more explicitly.\n\nYeah, so on Friday, the 19th, right? Yes, is that give you a chance with that sort of initial gathering to test out a lot of this technology with a larger audience and check out how it's going to work for the next day in some ways.\n\nWe have a tech check scheduled for a week before. Oh, okay, yeah, we got a fantastic recommendation from PyCon Australia for an AV vendor that they used. His name is Ryan and his company is Next Day Video. And he has been our lifesaver as we transition into this online-only new brave new world. So he has checklists and guides and a portal where our speakers can upload their talks and everything is taken care of. He's also going to be helping us release the videos on YouTube after the event for folks who were not able to attend in person. And so yeah, we should be doing a tech check a week before and hopefully by the time the party starts, we can all relax and hang out with the attendees and not be super stressed out. That's great. Yeah, it sounds much better.\n\nYeah, one of the added benefits of having this little social gathering from again from a more technical or more tool-oriented perspective is that attendees can",
    "pGIcrMonEuo": "Welcome to the Real Python Podcast. This is episode 45. Are you interested in processing images in Python? Do you need to load and modify images for your Flask or Django website or CMS? Then most likely you'll be working with Pillow, the friendly fork of PIL, the Python Imaging Library. This week on the show, we have Mike Driscoll, who's writing a new book about image processing in Python. We dive deep into the types of processing Pillow provides. Mike talks about creating Python GUI applications to take advantage of all the library has to offer. We also talk about his PyDev of the Week series and his Python Interviews book. This episode is brought to you by Scout APM. Scout APM is application performance monitoring designed to help developers quickly find and fix performance issues without dealing with the headache or overhead of enterprise platform feature bloat. Alright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with the community of experts at realpython.com.\n\nHi Mike, welcome back to the show. Thanks for having me again. So when we last talked, you were doing a lot of work getting the Python 101 book sort of into revision 2. How's that going and has it already come out? It actually got finished up over the summer and I released it in August. How's the reaction been? I'm pretty positive. I've gotten some really good reviews on Amazon, and I think I had one guy who said that somebody I've never heard of on YouTube covers everything in my book, so why would you buy it? That's interesting. You know, most people are super positive. Like he takes some chapter by chapter or something like that.\n\nThat's weird, or just the topic, I don't know. I've never heard, okay. I think I can't believe somebody on YouTube has covered every single topic in Python 101 because this book is massive with like over 500 pages. So yeah, and we talked all about all the additional stuff that you have in there for getting like projects and stuff kind of getting people a taste of what to do with it once they get going. All that stuff with PDFs and so forth kind of getting going. So that's interesting, yeah. It's very different because it covers the basic syntax in like the first 10, 20 chapters, and then the rest are like, here's how you can use Python with Microsoft Excel, how to create a PDF, how to create a GUI with WxPython, stuff like that. I just can't imagine someone being that wide-ranging on YouTube right now, although I know there are some that specialize in machine learning.\n\nYeah, it's pretty rare, partly why I wanted you to come on the show is you are working on another book project, and this one is about the Pillow library. Do you want to talk about what's going on there? Oh, sure. Pillow is the friendly fork of the Python Imaging Library, which came out many, many years ago. I think Pillow itself is over 10 years old, and basically, it lets you edit photos with Python. You can, it works with Python 2 and 3, although I don't know why you'd still be on Python 2, but right, right, I mean I was stuck on it until March of last year, but some people get stuck on it, and it's really cool that it has always worked for so long, but you can do all kinds of different things with Pillow and images. Yeah, we'll probably dive into that more like some of your other books. You're doing this as initially to get things going as a Kickstarter. Yes, I am using Kickstarter for this particular project as well. So what are some of the reasons that you use Kickstarter? So I use Kickstarter more as a way to gauge interest in a book, not necessarily to get funds, but the funds definitely help, sure. I know you mentioned something about getting the ISBN numbers and kind of securing all those for the different formats that you put out. Yes, if I apply as BN numbers for everything that can be kind of expensive, although a lot of like Amazon will provide a free one now, oh nice, if you don't mind them having their name attached to your book. You know if I just want myself attached to it, then I have to pay for my own ISBN. Okay, anyway, when did you start the Kickstarter and how long does it last till? I started it on January 4th and it lasts for 30 days. Okay, so to the top of February here. Okay, I think February 4th, February 3rd, somewhere in there. Okay, it looked like you already met your goal, which is great. So it looks like you have a good interest started. Yes, yeah, the book has gotten positive feedback already. This one I started out by giving it to a few people that I trust to do beta reading, and I also have two technical reviewers who are giving me feedback on it and helping me keep the book focused and well written. Great. So as you're laying out the chapters, what are the types of things that you're gonna dive into in the book? I have your sort of sneak preview version of the book, so yeah, and it had the first sort of three chapters laid out. So like it starts out with Pillow Basics and then gets into colors and then image data, which I want to dive into a little bit more. What can we expect for the other parts? Yeah, so the rest of the book is going to cover like the internals of the Pillow, like what you can do with it beyond that. So, you know, getting XF data is great, but Pillow comes with an image filter module you can use to apply filters to your images. It allows you to crop, rotate, and resize images. Image Enhance is kind of like image filters, it does some similar things and some different things like image enhanced can do brightness and contrast, but it also does some blurring that the image filters do as well. Okay, then I look at combining images so you can combine images in different ways by concatenating images or you can blend them together using a mask or using a compositing function that kind of is, it's kind of hard to describe the difference between the two but one uses the alpha channel more than the other. And then later on in the book, I'm going to talk about drawing with Pillow so you can draw shapes on your images kind of like how people like to take Instagram and draw funny shapes on their photos and whatnot. I would think that might be useful in a way to do something like if you have to do a lot of teaching and explaining and so a common thing would be to do like a screenshot and then have like arrows pointing at things or circle things or put squares around things. Yeah, would that be something that you could do there? Yeah, you could do that too with it. Yeah, oh cool. There's also like two specialized modules that aren't talked about very much in my opinion when it comes to Pillow. One is Image Chops and one is Image Ops. So personally, I use Image Chops at my job to do image comparison testing and Image Ops I've actually not used very much at all so I'm really interested to see what all I can do with that particular module. So that's spelled Chops like C-H-O-P-S. Yeah, it is, okay. And the idea behind it is a bit of comparison, like looking at differences between images. Is that the main idea? I mean, that's what I use it for. I think it has other operations. So I haven't looked at this one super close. It looks like it has some of the same things that the Image object itself does. So Image object lets you paste and blend. It looks like Image Chops also has a blend function. So I don't really know. Does it use the same thing underneath that the Image object does? I haven't dived into that code to see how these things work exactly yet. So when I think of channels, I think of the color channels, potentially like red, green, blue levels. Is that kind of what they're talking about there or is it some other form of channels? According to the documentation, it's an arithmetical image operation called channel operations, used for special effects, image compositions, algorithmic painting, and more. It sounds fun. Yeah, I don't know. I don't know how deep I'll get into this because some of it might even be over my head, but I'm going to cover the parts that make that I've used personally and anything that I think my readers will find helpful to use with that module. To go back to how you're using it, what's your use in day to day? Yeah, so at my workplace, I'm an automated test engineer and so I test this GUI that's written in C++ using Python and one of the things that we do is I need to take a screenshot of some state on the app and then I reload the app and see that the state stays. When you use Image Chops, I think it's the diff function in it. It will take the two images, yeah, difference is what it is. I take the two images and it'll return a pixel by pixel difference as an image object that I didn't save off and if that image object is completely black with no white in it then the images are exactly the same. If there's any white in it, it'll be in that little black image that it returned. You can actually see what the difference is most of the time and you'll know, oh my X, Y or Z is off by a couple of pixels and something isn't translating correctly. You know, does the map transfer from one app to the other app because we also support running these apps in parallel and creating multiple vehicles and so they need to all update the same way and draw the map the same way. That's cool. So this has been a reliable way for you to confirm those differences in your testing. Yeah, it's worked really well for the vast majority of cases. I've had a couple of weird times where I've had to enhance the RGB values so that they kind of blow them out so that they can see the differences better. Yeah, or actually so it'll capture so I can see the differences better because the computer could see them. Yeah, it still looks black to me and it's like there's a difference here and I'm like, I don't see any difference. What are you talking about? So before I make the comparison, I blow it out just to make sure that I can see what the difference is so I know what's wrong. Yeah, kind of like enhance it for human vision if you will. Yeah, that's cool. And then the other one you haven't worked with as much, the one called Ops, is that right? Yes, that's correct. And what's that one do? It is ready-made for image processing operations and it has some interesting things in it like auto-contrast, it can do colorizing of grayscale images, okay, deform an image stuff like that. I think of the as a person who's played in Photoshop for a couple of decades just kind of messing around in it, there's always this sort of, I don't want to say generic, but there's because I've used it so long, it feels generic because there's like this list of uh, sort of standard filters that are in there and they would be like emboss and and and things like that that maybe the algorithm or the arithmetic involved has become somewhat standardized in the image processing world that they could included in this library pretty you know as a fairly standard inclusion. Does that feel the same way to you? I would think so. So there actually is an emboss filter in the image filter module, yeah, and it has a few other ones like blur detail, edge enhance and smoothing and sharpening filters. So it has those kind of filters but you're not going to have like the really cool filters like you do with HDR or like replace the background and fancy stuff like that, yeah. Stuff like that, it's not going to have. So when you go into something like let's say sharpening, it still provides a couple of parameters that you can adjust inside of that, yeah, and it's so the way that the filters work is it has a enhancement factor okay between zero and pretty much infinity but logically if you look at it, it's like zero to like five or ten and it's a float okay so you can it has a fairly decent amount of scalability of what you can do but yeah since it's not like interactive, it's not like a GUI, you can't always see what it's doing until you like reopen the output again or you call show and it'll show it to you but then you have to open up the original so you have it side by side.\n\nScout APM is application performance monitoring designed to help developers quickly find and fix performance issues without dealing with the headache or overhead of enterprise platform feature bloat. With a developer-centric UI and tracing logic that ties bottlenecks to source code, Scout pinpoints and resolves performance abnormalities like N+1 queries, memory bloat, and more so you can spend less time debugging and more time building a great product. And with Scout's real-time alerting and weekly digest emails, you can rest easy knowing Scout's on watch to help you resolve performance issues before your customers ever see them. Better yet, at only $39 a month, Scout provides the insights you need in less than four minutes. Start your 14-day trial today and as an added bonus for Real Python listeners, Scout APM will donate $5 to the open-source project of your choice when you deploy. Go to scoutapm.com/realpython.\n\nSo one of the things that you're looking at doing inside of the book is taking people not only through all these different parts of Pillow and talking about like simply opening images and saving images and things like that, which you should probably talk about what image formats it works with, but your goal is to get them to a point of building kind of an application, a simple GUI application that they can apply some of these techniques to. What's that going to look like? What's the framework you're using for the GUI and what are the kinds of things you're thinking of including? So when I originally started the book, I was using WxPython because I'm really familiar with it and have been using it for over a decade. After launching the Kickstarter, I had a couple of people mentioning, \"Hey, you could shorten these examples and make them more readable if you use Python GUI instead.\" Okay, and I was like, \"That's a really neat idea. I tried it out and the example code you end up with is about 50% less than the WxPython equivalent and since you're not using object-oriented programming with PySimpleGUI, it is easier to explain what's going on to some degree. So I went ahead and switched to that and I kind of like it so far.\" So back to your question of how I'm going to do it with what I'm going to show the user or the reader. I mean, each chapter will have a GUI that lets them use, lets them apply something that they learned in the chapter. So like the image filter chapter, you'll get to create a GUI that can apply any of the filters that you used in the chapter to an image and you can see how it applies in real time, so to speak, in your GUI. Nice. And you had written an article about PySimpleGUI, is that right? Yes, I've written one for Real Python and before that I even had one on my own blog. Yeah, so we'll link to those and people can learn a little bit more there. It's kind of nice that it helps to even abstract the GUI even a little bit more, which is, it's great that that's going to save you code for something like a book, cutting out a lot of that boilerplate is going to be great. Yeah, I mean, the cool thing about PySimpleGUI is it has Pillow built in, so you don't even have to import Pillow. Oh, it just does it magically underneath, whereas you have to use it in PySimpleGUI, but that's okay because the code's shorter and easier to understand. So there's those trade-offs, yeah. Are there other ways that you're using Pillow or have been using Pillow in the past? I have used Pillow a little bit for like checking for colors in an image. Again, this was with my testing background. We would test to see, you know, does the map that I'm loading have a certain color on it that's not supposed to be there, like an air conditioner, you know, because when it's an error, we have a different color. And so that color's in the screenshot, then we know something bad happened. So you can get all the colors that are in an image and then search for those RGB values in the list. So again, this is in a testing situation, yes, where it can alert you across a variety of machines that there's an error on one of those machines, yes, without you having to visually go and look through every one of them. That's cool. Yeah, so but I could totally see myself, so I used to take a lot of photos and that's kind of my hobby when I'm not programming or writing and I could totally see myself using Pillow to do like a batch process after I do some photos outside where I need to like add a watermark so that people notice my image. Or I could use it to crop them all a certain way or you know enhance them, you know, brighten them up a little bit, that sort of thing. Yeah, I think of that, you know, having dabbled in a variety of web frameworks, things like Django and Flask, I think that's the most common place that I've seen Pillow kind of being used is inside of some CMS sort of system in the background helping you gather the images or even just simply be able to bring them in and open them and yeah and kind of do really simple like just okay I need to be able to open up these objects and so forth but yeah I mean that's such a common thing for for photographers or people that work in web situations where they want an automated system to make sure all these images are resized and potentially cropped to something that makes sense and then things with so many image formats are compressed to be able to choose like a level of compression is that something you can do in there we didn't get I was going to come back to this right of like the formats like what are the file formats it can do and then maybe we could talk about compression in that too. So yeah, it works with all the standard formats TIFF, JPEG, PNG, GIF or JIF, okay. Yeah, I'm trying to and it allows you to convert between the two between any of them as far as I can tell, yeah. Okay, I didn't check to see how it works with compression though, that's that is a good question that's something that we can find out more about. In the case of something like a PNG it'll that allows you to have alpha channel, you know where it can you can have transparency, yeah, uh does it support that still too I believe so yes, and and and I recently learned you can do animated PNGs and animated GIFs",
    "wj5wRjqXct0": "Welcome to the Real Python Podcast. This is episode 46. Are you interested in building interactive dashboards with Python? How about a project that takes a flat data file all the way to being web-hosted and interactive? This week on the show, David Amos is back and he's brought another batch of PyCoder's Weekly articles and projects, along with the Real Python article about data visualizations using Dash.\n\nDavid covers an article designed to help Python developers understand the fundamentals of C. We discussed a couple of articles about Excel and using Python with Microsoft Office. We also cover several other articles and projects from the Python community, including out-of-memory crashes in Python, updating all packages with pip, reviewing data science notebooks for teams, and a command-line tool for looking up colors, shades, and palettes.\n\nAlright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey David, welcome back.\n\nHey Chris, thanks for having me back. There's kind of a bit of an announcement with Real Python. We have a bunch of topics today that are very data science driven and actually a lot that are around C in Python. Some news related to that is the announcement that the C Python internals book is out of preview and should be available for purchase. The printed version should be available soon too, right?\n\nYeah, we should have the printed version relatively soon. I think we're still collecting some feedback, kind of left over, and we're working on the final tweaks to all that to make it look really good in print. But yeah, that book is now out of preview. It's written by Anthony Shaw, who's a Real Python author and a previous guest. He also just announced recently that he's switching jobs to take a developer advocate role at Microsoft, which is pretty exciting. But yeah, the C Python book is kind of for the more advanced crowd, I would say. But it covers the subtitle, \"Your Guide to the Python 3 Interpreter.\" So if you ever wondered how the C Python interpreter works, then this walks you through the whole thing and you learn a lot about how Python works under the hood.\n\nYeah, it's gonna dovetail really well into the episode I have next week where I talk to Brett Cannon, where we talk a lot about all the internal workings of the different functions inside of Python and kind of almost sort of unravel them is his title for his series. So I'm excited to share that episode with everybody next week.\n\nYeah, that'll be awesome. And you know, one of the things that you need to kind of get through the book C Python internals is a working understanding of the C programming language. Real Python's own Jim Anderson has written an article that we released a little while ago called \"C for Python Programmers.\" It's actually the appendix from the C Python internals book, so that'll be included there for reference if you get the book and read that. But it's also available on realpython.com. It's a real gentle introduction to see if you've never seen it before. And it's not a long introduction, so it's not going into a whole lot of depth and all this stuff. It's really just like your quick start guide to understanding C so that you can follow along with the C Python internals book. Yeah, I'm excited to check out the book. All this initially was making me a little nervous about diving deeper into it. I've done a little bit in C. I had learned some of it because I was interested in programming for iOS, and that's the language actually I had learned way back when I was in college. I had dealt with C a little bit and Fortran, and so I had to kind of pick it back up, and then Objective-C, and then they quickly shifted everything to Swift right about the same time I got interested into it. So that was an interesting transition and kind of following, you know, such a common thing for developers today to have to move across different languages and understand the different structural changes in there and how they can kind of relate and talk to each other. And in the case of Python, what's sort of happening underneath this, underneath all of all that in the interpreter. So it's pretty cool, and that'll be kind of a bit of a theme today in a few of our things. We'll be talking about some of the underlying stuff that happens inside of all of our programs.\n\nMy first topic here is from another previous guest we have about three guests in a row here because Jim was on the show recently, and this is from Edomar Turner Trowering. His blog is Python Speed, and he was on episode 24. We talked a lot about packaging Python applications. After some further discussions and one of his other articles kind of came up on one of our topics, so we brought him on the show. And this one is called \"Dying Fast and Slow.\" The subtitle is \"Out of Memory Crashes in Python.\" It's kind of funny because it's a bit dark. The terminology uses a lot about death, and it kind of goes a little bit further. Hopefully you can take that with a little bit of a grain of salt and think about it, but it really is trying to show you the different ways that memory issues can manifest and so that you can kind of look back at what happened and how they happened and so that you can go back and debug and hopefully fix them. Edomar works a lot with this and has been a focus for his blog, and he's also created some tools, which I'll mention in this also that can help you with this process. The first one he talks about is a slow death, and the slow death is typically characterized by swapping, which is taking the data that you're working with and you're running out of RAM memory, and it could be from lots of different things. It could be you're running multiple processes. You know, everybody's picking on Chrome lately, but maybe you got a lot of Chrome tabs open and it's eating up a lot of your RAM, and then you're trying to run your instances or you're trying to run your application. And so suddenly it's out of physical RAM chips, memory, and it's going to go and grab space from your hard drive and swap back and forth between that, and that can be really slow depending on the age of your machine and the technology behind there, and it can really seem to be this sort of strange thing where everything's sort of slowing down suddenly because it's grabbing and pushing things around. And then eventually, depending on how the swap file is allocated and the space that's been allocated in your storage system for that, that can run out also, and then suddenly then you're completely stopped. And so it kind of is like this winding down, as he described it as a slow death. Then the next one is an obvious death, which I characterize as a nice death, question mark, because in this case, you're having a memory error, and Python has identified it in the interpreter as it's allocating and the API fails to allocate. Hopefully at that point you're going to get this memory error exception, and you'll get the error up here and you can see what happens. So like it's a lot easier for the individual to diagnose what happened. You know, it's obvious and you can kind of see what's happened and hopefully troubleshoot where things went wrong in your application and troubleshoot it quickly. The next one is a little harder to find, which is a corrupted death. And this is actually going back to C. So there's something called a seg fault in your C code, and it's in a case where the code has been written, and again, there's a lot of interesting stuff with C libraries or if you're being adventurous in your data science and you're trying to figure out ways to harness the advantages and speed of using C, if you're not really good at the concepts of memory allocation and planning for potential errors, there's this thing where a memory address can be allocated for this chunk of memory, but if the allocation is too large and it fails, like it's been given this memory ID, this location that in this case it was too large to find a space to be able to store that huge amount, it would return a zero or basically a null address. And if it tries to run with that, then it's going to crash. And so it's one of these things that you may not know what's going on, and it's again leads to this whole level of like corruption where you're like, where is this error happening? And that's where like a program like his tool, it's a memory profiler called \"Fill\", I think it's pronounced \"Fill\", and that can actually help you or using something like a debugger and GDB, these kind of tools go through and look at the of where this potentially could be happening, and again, it's kind of diving deeper into the C code itself and looking for potential problems.\n\nI was just going to say, when I was in college, I took an operating systems class that used C as the programming language for that, and the segmentation faults were like the most common thing that any of us ran into during that. Yeah, it's something that again, without needing to worry too much about memory allocation inside of Python, it's something that's pretty foreign for most of us to think about it. And again, a lot of data science people are not really coming from the computer science side of things, and so again, they may not really kind of see where all that's happening and understand what's happening with it. So having some additional resources, and he's updated the tool since I talked to him back in episode 24 to be able to work on Jupyter notebooks, and it's a really nice open-source tool, so something to check out. The last one is kind of a funny one. He calls it \"Death by Assassination\", and I mean, again, joking in this sense, the thing that's doing the killing here is the operating system itself. And the operating system can, especially modern ones like Mac OS or Linux, can actually go and see this process is getting out of hand and the operating system can just shut it off and just say, \"Alright, this thing's using too much memory, I'm going to kill it.\" This happens even on like, you know, again, like an iPhone or other tools like that. You might have seen something like that happen where an application just suddenly has been killed by the OS. It used to be that your entire machine would lock up, right? And so it's nice in some ways that the operating system can decide these things and say, \"Okay, this process is getting out of hand.\" But it's hard for you to know what happened in that case. You have to know the operating system's sort of underlying tools, and the article goes into that to help you kind of say, \"Well, here's where those logs are, here's where you can kind of find more information.\" And again, something like a memory profiler might help. So it's a really great tool if you're having these kinds of things, or maybe in the past you've had a history of working with these large, very memory-intensive processes, and you want to look at it, or memory is one of those expensive resources when you look at virtual machines, or you know, you're looking at cloud things, and so it's one of those things that having an idea of where these bottlenecks and problems could happen with memory might help you avoid a lot of problems or potentially a lot of headaches with your cloud instances and things like that.\n\nAnd potentially a lot of money. Yeah, exactly.\n\nYeah, yeah. What do you got next?\n\nMy next topic is switching gears a little bit into the data science space a little. Well, this one is not so much data science as it is, I guess, more like business tasks and automation. It comes from the blog Practical Business Python by Chris Moffitt, which is a really cool blog if you're into the business space and automation. Chris has got a ton of great resources on there. But this article is called a case study automating Excel file creation and distribution with pandas and Outlook. And it actually comes from one of his readers that sent him a note saying that he had a business need that arose where he needed to send out emails with Excel attachments to about 500 users. And it was going to be a really kind of arduous manual task because they had a master Excel file with all the user data. And they had to split that Excel file per user and just send each user their portion of that file as an Excel spreadsheet. You can imagine having to do that manual task for like 500 users, it's going to take a lot of time. But they were able to use Python and pandas to automate it all for them as well as sending out all the emails and everything. And save themselves a lot of time. So it's a really cool example of how just knowing a little bit of Python and being comfortable with that can really bring a lot of value to a business and to you as a job holder in that business. It can be seen as a good skill that you have. And they walk through solving the problem and show how they use pandas to read the Excel file, sort through it, and split everything up based on the customer. They make a nice use of the pandas group by method on the data frame object, which we've got some good resources on real Python about group by. And then how they separate all that out, write it to individual Excel workbooks, and then integrate with Microsoft Outlook to send all the emails. So it's not a super long article, but it does have all the code in there and kind of walks you through it.\n\nYeah, it's just a really great example of this kind of Python superpower thing that we've talked about before. So I thought that was a neat article and a cool case study.\n\nYeah, I like that blog a lot. I've actually, when I was in my job at the bank, I was always looking at those because it was very much combining a lot of the office tools, which are usually Microsoft type of tools, right? And combining them. And so like if you have Outlook and you have Excel and you want to do more of that great automating the boring stuff kind of stuff, it is a really good resource. And so that's nice that he's getting people submitting additional stuff to him to kind of build on top of it. It's great. Yeah, I really enjoy Chris's blog. I mean, as someone who also used to be working for a business, you know, I do appreciate seeing these kinds of use cases. And it's interesting to me as well. Like, I think that, you know, when I was working for a business and having to use like Office 365 and everything, there wasn't a lot of Python support for that. Yeah. And I think that's growing. So I think there's actually kind of a movement in Microsoft as well to start like, I think you can now do some scripting with Office with Python as opposed to like solely having to use their like a VBA or even like a C-sharp. There's a big sigh for me on that one. Yeah. Yeah. The same VBA is so clunky. I've spent a lot of time way more time than I ever would have liked debugging VBA code. So yeah. Yeah. Yeah. Fun stuff. But yeah. So it just be interesting. You can watch that space and see how Python grows there because now Microsoft has a lot of big players in the Python space working for them. They absolutely do. Yeah. I hope they can integrate it more because that, you know, we've talked about several industries now, be it, you know, we were talking about, you know, 3D printing and 3D modeling for you, not only manufacturing, but also the space of creating for visual effects and things like that. And I've actually learned just a few different music programs that are trying to do that, you know, like create additional plugins or other kind of structural stuff with, well, I've seen one that has used as Python, but then there's a few that actually use JavaScript, which I thought was kind of interesting too. So, you know, the idea of like kind of using some of these more larger audience languages to potentially open up what you can do inside there, I think is really great if they can do it and, you know, make the tooling be open like that.\n\nWhat do you got next?\n\nMy next one is from a website called Stack Abuse, and it actually just says \"anonymous,\" the person who submitted it, which I thought was interesting, guest contributor.\n\nYeah, guest contributor. It's a tool called Pip Review, and this is basically just kind of going over the things that are inside of it, and it allows you to update packages. So imagine you have a virtual environment. I do this a lot with Real Python because I review a lot of the video courses before we put them on the site, so I want to test the code and go through step by step to make sure everything's working. So I might come back to a virtual environment and a whole sort of code session that I've left on my drive as something I might want to repeat and look back at. So I decided, well, let me try this thing out, and it's from this other set of tools called Pip Tools, which has a lot of other additional powerful things, so they've kind of extracted this specific tool called Pip Review. What it will do is look at what's been installed on your virtual environment and see what the status is. You can actually like just run it and it'll actually give you a nice little report and tell you, \"Okay, you have scikit-learn installed, and this is the version you have, and this is the version that's available.\" And maybe it's like, you know, one version sub-number off or something like that. But it'll go through all the things that are in the virtual environment and that have been pip installed, which is pretty slick. And then there's a whole bunch of tools. It's actually a very readable command line tool where you can say, \"Hey, just update them all,\" which is nice instead of having to know, you know, which ones are which and go through them. And then there's an interactive version of that, which is really nice, where it can actually ask you as you go along, and you can say, \"Upgrade now,\" or \"No,\" and \"Yes\" or \"No,\" or you can just again, hit all and do them all. Then there's also a constraint file kind of feature that you can put in there where you can say, \"I want to leave things within these particular constraints,\" and you know, what version you're willing to go up to. So, it's a really simple article, goes through just all these kind of simple steps and started getting going with the tool. And I was excited by how simple and easy it is to get going with it, especially if you work with virtual environments and work on lots of different projects. You can kind of look at the status of what's happening very quickly in a readable, very organized way, work through what you want to review or update in your environments.\n\nYeah, it's interesting. So I started looking a little bit at kind of the",
    "3JruhMhjdLI": "Welcome to the Real Python Podcast. This is Episode 48. The initial steps to get your Python script hosted on the web may have been built with Flask, but how do you stand it up so you can share it with others? This week on the show, we have previous guest Martin Bryce. Martin shares his recent article titled \"Python Web Applications: Deploy Your Script as a Flask App.\" And David Amos is back, and he's brought another batch of PyCoder's Weekly articles and projects. David shares a recent mathematical Real Python article about the stochastic gradient descent algorithm with Python. Stochastic gradient descent is an optimization algorithm often used in machine learning applications to find ideal model parameters. \n\nWe also cover several other articles and projects from the Python community, including property-based testing with Hypothesis, Python's tug-of-war between beginner-friendly features and support for advanced users, how Python integers work, the steering console accepts PEP 634, a magical full stack framework for Django named Django Unicorn, and a visual programming environment called Math Inspector. \n\nThis episode is brought to you by Scout APM. Scout APM is application performance monitoring designed to help developers quickly find and fix performance issues without dealing with the headache or overhead of enterprise platform feature bloat. Alright, let's get started. \n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com. \n\nHey David, welcome back to the show. \n\nHey Chris, thanks for having me back. \n\nAll right, this week we've got a good set of stuff. I'm gonna do kind of a follow-up with Martin Bryce because he has a new article that just came out on Real Python titled \"Python Web Applications: Deploy Your Script as a Flask App.\" It comes from an older Real Python article which was kind of doing the same thing, but it's updating all the inner workings that have changed over the years. \n\nDo you know the initial steps to get your Python script hosted on the web? You may have built something with Flask, but how would you stand it up so that you can share it with others? This week on the show, we have previous guest Martin Bryce. Martin shares his recent article titled \"Python Web Applications: Deploy Your Script as a Flask App.\" And David Amos is back, and he's brought another batch of PyCoder's Weekly articles and projects. David shares a recent mathematical Real Python article about the stochastic gradient descent algorithm with Python. Stochastic gradient descent is an optimization algorithm often used in machine learning applications to find ideal model parameters. \n\nWe also cover several other articles and projects from the Python community, including property-based testing with Hypothesis, Python's tug-of-war between beginner-friendly features and support for advanced users, how Python integers work, the steering console accepts PEP 634, a magical full stack framework for Django named Django Unicorn, and a visual programming environment called Math Inspector. \n\nThis episode is brought to you by Scout APM. Scout APM is application performance monitoring designed to help developers quickly find and fix performance issues without dealing with the headache or overhead of enterprise platform feature bloat. Alright, let's get started. \n\nSo the Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com. \n\nHey David, welcome back to the show. \n\nHey Chris, thanks for having me back. \n\nAll right, this week we've got a good set of stuff. I'm gonna do kind of a follow-up with Martin Bryce because he has a new article that just came out on Real Python titled \"Python Web Applications: Deploy Your Script as a Flask App.\" It comes from an older Real Python article which was kind of doing the same thing, but it's updating all the inner workings that have changed over the years. \n\nDo you know the initial steps to get your Python script hosted on the web? You may have built something with Flask, but how would you stand it up so that you can share it with others? This week on the show, we have previous guest Martin Bryce. Martin shares his recent article titled \"Python Web Applications: Deploy Your Script as a Flask App.\" And David Amos is back, and he's brought another batch of PyCoder's Weekly articles and projects. David shares a recent mathematical Real Python article about the stochastic gradient descent algorithm with Python. Stochastic gradient descent is an optimization algorithm often used in machine learning applications to find ideal model parameters. \n\nWe also cover several other articles and projects from the Python community, including property-based testing with Hypothesis, Python's tug-of-war between beginner-friendly features and support for advanced users, how Python integers work, the steering console accepts PEP 634, a magical full stack framework for Django named Django Unicorn, and a visual programming environment called Math Inspector. \n\nThis episode is brought to you by Scout APM. Scout APM is application performance monitoring designed to help developers quickly find and fix performance issues without dealing with the headache or overhead of enterprise platform feature bloat.\n\nAlright, let's get started. \n\nSo the Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com. \n\nHey David, welcome back to the show. \n\nHey Chris, thanks for having me back. \n\nAll right, this week we've got a good set of stuff. I'm gonna do kind of a follow-up with Martin Bryce because he has a new article that just came out on Real Python titled \"Python Web Applications: Deploy Your Script as a Flask App.\" It comes from an older Real Python article which was kind of doing the same thing, but it's updating all the inner workings that have changed over the years. \n\nDo you know the initial steps to get your Python script hosted on the web? You may have built something with Flask, but how would you stand it up so that you can share it with others? This week on the show, we have previous guest Martin Bryce. Martin shares his recent article titled \"Python Web Applications: Deploy Your Script as a Flask App.\" And David Amos is back, and he's brought another batch of PyCoder's Weekly articles and projects. David shares a recent mathematical Real Python article about the stochastic gradient descent algorithm with Python. Stochastic gradient descent is an optimization algorithm often used in machine learning applications to find ideal model parameters. \n\nWe also cover several other articles and projects from the Python community, including property-based testing with Hypothesis, Python's tug-of-war between beginner-friendly features and support for advanced users, how Python integers work, the steering console accepts PEP 634, a magical full stack framework for Django named Django Unicorn, and a visual programming environment called Math Inspector. \n\nThis episode is brought to you by Scout APM. Scout APM is application performance monitoring designed to help developers quickly find and fix performance issues without dealing with the headache or overhead of enterprise platform feature bloat. Alright, let's get started. \n\nSo the Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com. \n\nHey David, welcome back to the show. \n\nHey Chris, thanks for having me back. \n\nAll right, this week we've got a good set of stuff. I'm gonna do kind of a follow-up with Martin Bryce because he has a new article that just came out on Real Python titled \"Python Web Applications: Deploy Your Script as a Flask App.\" It comes from an older Real Python article which was kind of doing the same thing, but it's updating all the inner workings that have changed over the years. \n\nDo you know the initial steps to get your Python script hosted on the web? You may have built something with Flask, but how would you stand it up so that you can share it with others? This week on the show, we have previous guest Martin Bryce. Martin shares his recent article titled \"Python Web Applications: Deploy Your Script as a Flask App.\" And David Amos is back, and he's brought another batch of PyCoder's Weekly articles and projects. David shares a recent mathematical Real Python article about the stochastic gradient descent algorithm with Python. Stochastic gradient descent is an optimization algorithm often used in",
    "lqhz2WNRJE4": "Welcome to the Real Python Podcast. This is episode 49. What's the difference between writing code for yourself and developing for others? What new considerations do you need to take into account as a professional Python developer? This week on the show, we talked to Dane Hillard about his book, \"Practices of the Python Pro.\" Dane discusses his philosophy on the design principles that go into writing code. We talk about namespaces, object-oriented design, and how to keep your code extensible. We also consider the how and when of code optimization.\n\nThis episode is brought to you by PyCharm. Do you want to get your work done faster? Use PyCharm, the Python IDE for professional developers. Let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHi Dane, welcome to the show.\n\nHey, thanks. Yeah, we've been talking for the last nine months about trying to figure out a time to get you on the show and talk about your book. We were just talking offline before we started, your book came out just about a year ago at the time of this recording.\n\nYeah, that's right. I think right around January 20th. So that's tomorrow.\n\nWell, how's the response been?\n\nIt's been pretty good. You know, with these things and especially being my first book, I guess I didn't really know what to expect. I think I got a lot more activity and engagement from people than I expected. And, you know, it's being translated currently into Chinese and Korean as well.\n\nOh, cool. And I think the Korean one, I think, is close to done because I just got an email about getting a copy of it. So I'm pretty excited about that and to sort of think that it's spreading to other countries. I think was, you know, big enough achievement, but other continents is kind of, kind of more than I would have expected of anything.\n\nThat's the publisher that's helping with all that, localization, language stuff?\n\nSo Manning actually doesn't do translations. They typically will partner with another publisher who's interested in doing the translation. So it kind of goes through a whole new set of contracts and advances and all that stuff. So still getting to that point where it's going to start selling copies in China and Korea and seeing how the response is there. Yeah, cool. I mean, Python is definitely a global phenomenon as we've mentioned many times on the show.\n\nSo many times on the show. This is the first book you've written, is that right?\n\nThat is right, yep. What was the process like?\n\nThe whole thing started, I guess, when Manning reached out to me, which I don't know if it's always typical, but they do have people on staff who sort of see who on the internet is already writing and might be interested in writing a book. So I'd been doing some blogging online for a time, and so someone reached out and said, \"Have you ever thought of writing a book?\" And I don't know that I had at the time, often then. But, you know, it had been something I was enjoying, and I very much like sharing my experiences with people if they can be helpful. So I figured it would be a good idea. And I think that Manning's process actually has a lot of the same things that I've seen with the Real Python editorial process.\n\nThat's really good. So they have a big focus on sort of optimizing for the right level of reader and making sure everything you're doing is speaking to that intended audience and just really trying to drive home the learning, which just kind of makes everyone involved successful. So they sort of pair you with an editor throughout the process, sort of a development editor, learning editor, and then each of your chapters gets reviewed by a technical editor. And then sort of at the end of the book, they do the production copy editing and typesetting and all that stuff. Yeah, I found it pretty smooth for the most part and pretty enjoyable. My editor was great.\n\nSo I talked to a couple different authors who've written in a format where there was like an early release of chapters as they kind of went along, and then, you know, the final sort of version was released on a specific date. Was that your experience with this book?\n\nIt was, yeah. Manning has the Manning Early Access Program, or MEAP is usually how they stylize that. So I enjoyed that quite a bit too. I think getting early and frequent feedback from people is the best way to make sure you're kind of maintaining your trajectory and not, you know, totally off course, I guess, in either what you're teaching or how you're teaching it.\n\nYeah, that makes sense. Yeah. How long was the overall process?\n\nOh gosh, it was a little longer than I expected. I think I hoped it might be around a year or a little less than that. It went a bit longer than a year, I think.\n\nOkay. I want to say that, and I guess part of it wasn't just me, you know, there's other phases, I guess that people have to go through.\n\nYeah, yeah. The editing process and the, I'm guessing the feedback loop is gonna add time into all those steps.\n\nExactly. So I think it was something like 16 months or something from sort of contact to printed book. Okay.\n\nOne of the things I thought that's different, you know, with the title, is the focus and sort of the intended developer who did you feel like was the intended Python developer for your book?\n\nThat's a good question and one I like to clarify sometimes because I think there's a pretty, maybe broad, not broad definition, but definitely opposing views on sort of what a pro is in programming. And I come very much from a place that if you're making money doing something, you're technically a professional. Okay. The title is meant to convey sort of that if you plan to be doing this full-time, here are some interesting things to think about. That's kind of what I'm trying to say. So I think that the audience is anyone who's kind of new to programming or new to Python or, you know, especially switching into the industry from some other place. You know, there's a lot of people joining software development from, maybe still even technical fields, but sort of less day-to-day programming like data analysis or stats or something like that, right? Getting those folks on board and talking about, you know, software can be written to work, but then what do you do with it after that in terms of design and testing and making sure that things will last a long time. So that's the idea. Yeah, I think of that in a way. Like I don't know, we were talking about this generalism thing before, the idea of having lots of different backgrounds, but I have done photography in situations where I've been paid, right? It's not my everyday thing, but technically I've had clients I've had to work around certain specific events. I've done photography for races, you know, for like a marathon, and I've had to do them for like graduations and other things like that. And so technically, yeah, you know, that kind of moves me into this other category of being a professional photographer. And so there's like these other kind of unique demands that that system's going to look at and sort of a level of it's not necessarily always the things of that people think of like I need to be able to deliver a consistent product to somebody, you know, and that they're going to be willing to say yes, you know, we're going to keep hiring this person. Does this analogy kind of fit in some ways?\n\nIt doesn't. I actually understand exactly where you're coming from because I have done some professional photography too. And so with this analogy, right, this book would kind of be like, now that you're starting to do this more often and maybe looking to do it all the time, you might want to start thinking about how you book clients on a regular basis or how you, you know, what to look out for, what to avoid when booking weddings or what to do, right? Like, you know, those kinds of things where it's like, if you do it once in a while, even if you do it wrong or some way that you don't enjoy, you only have to deal with it every so often. But then once you're doing it every day, you don't want to have to deal with those same pains all the time.\n\nYeah, okay. So that's kind of the focus is this idea of, okay, so you're going to take this thing seriously, right? You're actually going to look for a job in this in this field, and this is going to be the tool that you're going to use for it. Here, here are the things that you may not have thought about. Is that part of it?\n\nYep. Okay, because even in, even in sort of the quote-unquote traditional software background, like going to a university with a four-year degree in computer science, not some of these subjects still aren't even touched on there either. Yeah. You know, getting some sort of hands-on experience or first-hand look at what some of these things are, a lot of which come kind of from maybe some open source community ideas, collaboration, and looking at what needs to be in place to consider code kind of ready for production, those kinds of things, I think aren't as rigorously touched on in school either. So kind of giving folks a handle on here's what a lot of teams are doing in organizations in the real world is the focus. Yeah, that makes sense. Did you have some of those experiences yourself potentially coming out of school and getting into professional development? Yeah, I think even in my first job out of school at the time, I was doing C and C++ development and a bit of MATLAB, which actually drived very well with my school curriculum at the time. But I hadn't really done any testing. Okay. Aside from, aside from, you know, submitting code to an autograder, and this first job right out the gates had a full test harness, and it was pretty rigorously tested and had coverage thresholds and all that stuff. And so I kind of had to get up to speed pretty quickly on that stuff because you can't, you can't necessarily be productive in that environment without following some of those rules that have been put in place usually for good reason. So that makes sense. How was the organization as far as getting you up to speed? Were there ways that they helped you with that, or was it very sink or swim?\n\nThe people were good and willing to help on that kind of stuff. I don't know that I recall getting sort of an onboarding, if you will, into it. Sure. Of course, this has to vary from organization to organization, right? But some test suites will be somewhat self-explanatory, and when they fail, they tell you why and they tell you where to look and all that stuff. And some, I'm sure, don't give you that kind of help, right? So getting some kind of conceptual foundation about what all these things are, I think just ends up being some tools in your belt for feeling more comfortable exploring into the areas that you have less experience or exposure to.\n\nAs you shifted to doing testing inside of Python, what were your thoughts about the tools and how are you using the tools now?\n\nFor a long time, I was using nose, okay? And I try to remember if there was a time where I kind of just relied on unit tests as the built-in thing that was available. I think I pretty quickly got onto nose, and then nose sort of fell by the wayside, and I'm a pretty big proponent of Pytest these days. I think that it matches the mental model for me that is similar to when I'm actually writing executable code. And I like a lot of the integrations that it has for testing Django apps and running under tox and all that stuff. Not that unit tests can't do those same things, but I think anything that sort of enhances the ergonomics of a system tends to be where I gravitate. So Pytest lets you parameterize functions, test functions that is. It lets you pretty quickly monkey patch things instead of mocking things and writing a lot less boilerplate code is all good stuff to me. And it seems to have such a wide audience of people using it, and therefore there's a lot of contributions. Like you were mentioning, the sort of the inclusions of stuff for inside of Django and I'm guessing a lot of other frameworks. So that hopefully some of the initial legwork has been taken care of for you.\n\nYeah, exactly. When did you feel like you were becoming a Python pro? When did you feel like that?\n\nMaybe so. I was just talking about ergonomics, and maybe it's kind of in that space where when you have enough of a handle on what it is you're working on on a day-to-day basis enough to kind of say, \"Hey, now that I understand this as well as I do, I see that there are some things we could improve about it that would make everyone's lives a lot easier.\" To me, that's in my earlier statement, right? That you're a pro if you're getting paid to do it, right? But I think both of those are true, but like when I kind of internalized it for myself was when I was like, \"Whoa, maybe I could inject some of my experience and help make things better for people.\" Okay, so when you kind of start to move into mentoring potentially other people, yeah. And that, you know, maybe I would say maybe like professionalism is kind of a milestone achievement in that sense, right? Like you're a pro if you're getting paid, you're a pro at many points along the way, and I don't think it makes sense to keep anyone in that sense, right? It's not necessarily an endpoint, you know, exactly. There's always, as everything is constantly evolving and growing around all of us, that we're all going to have to keep learning and learning from each other. Exactly.\n\nDon't waste your time configuring your IDE for your Python project. Get everything out of the box with PyCharm Pro. You get expert Python assistance, including smart refactorings, code completion, and an integrated debugger. Web development support for popular frameworks such as Django and Flask. Get your project up and running with three free months of PyCharm Professional Edition. Click on the PyCharm banner in the episode description and use the Real Python 21, that's all caps, R-E-A-L-P-Y-T-H-O-N-2-1, coupon code at checkout. The offer ends on March 31st.\n\nWhen you're getting into creating the book, what was the topic that you were like, \"Okay, I'm super eager to share.\"\n\nYou know, I think it's interesting because I originally had this pretty grandiose plan, I think, for this book that touched on a lot more around sort of formal design patterns and things like that, and maybe a little bit more of the process of software development as a whole. And I think it was ambitious, but I think some of the things that I originally intended to bring in that did make it in were still around design. So talking about extensibility in code, and I guess this idea of loose coupling generally, and how to think about loose coupling between different parts of your code were two that kind of excited me. And maybe it's also because that is a place that's pretty hard to reach any kind of end point on, too, right? Like you can always think of ways to make your code easier to work with and make sure that when you're touching this area of code that this area over there doesn't break or change. So I think the fact that I'm still probably very much in the middle of that experience made it an exciting thing to try and teach others about.\n\nOkay, to kind of go into a couple of those ideas that you're mentioning there. You start off pretty early on in the book just sort of describing what the book's about and kind of your approach, and then you dive pretty deep into design. Like you said, what is it about design that you think is sometimes missing when somebody starts creating code? That there are, or maybe even an organization, they make missteps in that place?\n\nI think it ties back a little bit to that idea of ergonomics because you can make code work, and that may be perfectly sufficient depending where you're at, right? Like if you are an early stage startup or something and you're just trying to ship things out the door, you know, getting working code is the most valuable thing. But there's, you know, inflection points there as you mature. And at some point, maintaining that code and making sure you don't go down are more important than shipping new features, right? So design is kind of this idea of taking what works and making sure that it's easy for others to use it the way it's intended and to have kind of, kind of guardrails, if you will, or some sort of guidance that leads you to the right way of doing things, right? Just kind of like writing the class and hoping it ends up where you want to go.\n\nYeah, when I was thinking about you talking about that design process, it kind of started to unfold into this idea of like, okay, the code needs to be usable. There's this, depending on you know, if it's something that's for public consumption or if the audience is like inside of a company and they're your co-workers, but they're going to be using your tools, and then there's the design so that you can keep maintaining it, and then potentially the people behind you or others on your team can maintain it. And so there's like all these kind of layers of, I don't know, communication that need to be within your code to you know, make sure through that whole process that it's designed that each one of those is accessible.\n\nYeah, I think all of those have slightly different and nuanced considerations, right? Any audience you might intend to serve, you kind of have to think about what their goals are and what is the most important thing to them and try to accommodate as much as you can while still being in some kind of sustainable model, right?\n\nYeah, and so you start out kind of diving into that a little bit with namespaces, which I thought was an interesting sort of topic to kind of dive into, but it's funny how that seems to be a theme throughout Python that I think people still kind of struggle with a little bit. You know, why did you want to focus on that?\n\nSo it can act as this kind of, I mentioned earlier, kind of a guidance towards doing things a particular way. I think namespaces can reflect back some sort of mental model about, you know, if I'm using some package, if there's a particular set of namespaces in that package, it might really help me understand how that code is organized and like how the author intended for it to be used. Some are more obvious when there's a namespace called \"deprecation\" or something like that, where it's like, \"Okay, maybe this code is going to go away someday.\" And some",
    "A4RyQ7SvA8Q": "Welcome to the Real Python Podcast. This is Episode 50. Have you wanted to get your Python code to consume data from web-based APIs? Maybe you've dabbled with the request package but you don't know what steps to take next. This week on the show, David Amos is back and he's brought another batch of PyCoder's Weekly articles and projects. We discussed an article titled \"Python APIs: A Winning Combo for Reading Public Data,\" and David shares another Real Python article about creating microservices using Google Remote Procedure Calls (gRPC). We also cover several other articles and projects from the Python community, including making a difficult data analysis question easy with Pandas, efficiently cleaning text with Pandas, the tricky bits of Python concurrency, building rich terminal dashboards, making better assertions for Python tests, and building and managing real-life data science projects with Metaflow. Let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey David, welcome back to the show.\n\nHey Chris, thanks for having me back.\n\nWe've got a couple really great Real Python topics that we want to start off right off the bat, and what's very cool is they're related in many ways. I'm very excited to talk about them today, and then we're actually going to dive pretty deep into data science. So what's your first one?\n\nThe first one I've got today comes from Dan Hichman. It's an article called \"Python Microservices with gRPC.\" This is a pretty extensive article, so it falls into that category of almost a bookacle. They've been called that in the past. That's the terminology. I think it was Mike Kennedy that started calling them that with these super long, okay, very thorough articles that we've got. But this one is all about an introduction to what microservices are and what that design style entails. It also covers how you would create a microservice using the gRPC style of creating an API. This is different from a RESTful API. gRPC is Google Remote Procedure Call, and it's a very different kind of take on what an API is. It walks you through why you would maybe want to consider the microservice design style, what micro actually means, and the trade-offs between monolith versus microservice idea. It gives you some examples of microservices that you use through the article. It gets into defining the structure of these microservices using something called protocol buffers, which is a language that allows you to define what the API is, similar to something like the OpenAPI spec where you can define the structure of your API and what kinds of parameters different endpoints take. Then it gets into what really is this remote procedure call, how it differs from a RESTful API, and the main difference is that rather than using these HTTP verbs like GET, POST, and DELETE, it's more focused on calling a function. So there's a function that does something, and you call that function to do something. It's a little bit of a different idea there. It walks you through this large example of how to set all this up and how to create clients. One of the advantages of using these protocol buffers is that you can automatically generate clients and automatically generate the server. So you sort of define your API in this single file, and then using a Python library, you can automatically generate a client library and automatically generate a server library as well, which is something you can also get in a RESTful API. We've actually got a series of articles by Doug Farrell talking about using this connection framework with Flask. It's a similar idea where you're automatically generating some things, and then there are libraries out there to generate client libraries automatically as well based on this OpenAPI specification. Once you've got the client and the server going, it talks about getting it production ready, talks about things like Docker and networking, using Docker Compose, how to test these things, and finally how to deploy it to a Kubernetes cluster, and then also monitoring your microservices with things called interceptors, and then a discussion on some best practices around all of this. It's a pretty thorough discussion on this whole topic and a really neat look into gRPC and how to use it in Python. Pretty good stuff.\n\nThese deep dives are fantastic for anybody wanting just to get into these concepts and see multiple sides of what they're going to have to work with. I love that he's including the best practices and all these other kinds of things like monitoring and care and grooming of them, which is really cool.\n\nYeah, it is neat because there's a lot of tutorials out there and this isn't necessarily a bad thing, but you build some sort of API or something and then it maybe shows you how to deploy it. Maybe a cloud service or something and then it's like, \"And then you're done.\" It's like, \"Well, you're never done, right? Now you have to be like, is it still working? Is it working properly in production? How do I even tell that this thing is doing what it's supposed to do or how do I monitor for failed requests, like all that kind of stuff?\" So it is neat to see all that being discussed as well in one article.\n\nMy first one is from Pedro Gregorio and it's called Python and APIs: A Winning Combo for Reading Public Data. When I initially looked at it, I was like, \"Oh, okay, it's another one kind of talking about APIs.\" And then I'm like, \"Oh, you know, consuming them, which is actually a really popular concept, right? You know, for beginners who want to get into playing around in Python, it's like, \"Okay, well, what kinds of things could I build and what kinds of things can I use here?\" And I had created a course. It was one of the very first courses I ever made for Real Python about an article about the request package. And so that was something I wanted to learn very early on. I was like, \"This seems like something I'm going to use.\" And kind of dive into. And what's interesting is, I feel like a lot of people get confused very early on as to the concept of, like, what request is trying to do. They think it's primarily just to consume any kind of web data. But really, request, the idea behind it is that you're going to point it at a very specific API. And whereas some people might be confused and they're thinking, \"Oh, I actually want to scrape a website or I want to pull data from a website in the raw out of the raw HTML or, you know, whatever different techniques that you have out there.\" And we've covered that before with talks about Beautiful Soup and we've covered a few other kinds of tools that can help with like dynamically generated websites. But what can be a much more efficient way is to actually go directly to an API. And be able to go to that endpoint and then query and pull very specific information. So this article starts in kind of a nice historical way, like we were just talking about SOAP and REST and then also the newer one to the bunch, which is GraphQL. And I have to admit, I was not that familiar with GraphQL. I had a few people come on and talk briefly about it, but I didn't dive very deep into it myself. And I was a little confused as to what it provided. But it's a newer query language for working with APIs. It's developed by Facebook. And I think it's something if you're interested in this and want to kind of see the future of where we can go, it might be another offshoot of the idea of remote procedure calls, the idea of like calling functions. This is similar in the sense that you can kind of request multiple things. And the idea that some of the information might be unpacked by the client and not having to like grab so much data all the time, like pull like all of it and then have to sort of sort through it. You might be able to specify more specific things. And again, I'm still on the cutting edge of like just trying to learn what it's about, but I'm kind of intrigued by it and what it can do. But I think this is a great follow-up for somebody who was like, \"Oh, okay, I kind of understand what requests can do. This article really goes deep into doing it. And there's lots of examples, lots of really kind of fun APIs that Pedro gives you to play with and kind of bounce against. There's this really kind of fun one that's sort of like a dog API. And so you're asking questions about breeds and kind of pulling back different information. And you're learning about query strings and then it kind of really covers those really important API-related concepts about all right, how do I structure it? What's a response code? Looking at the different information that comes back. And then like I said, I really like that it has lots of these public APIs for you to kind of play with, to kind of learn about what's happening and the different styles of APIs that are out there and the different formats that they can kind of come in. And then it goes into more advanced stuff. It talks about authentication, which is kind of the next level of things that you might run into. And then beyond that, it's really deep and a lot of information. It talks about pagination. So like there's lots of pages of information that are coming back to help you with that. But then also something we talked about when talking about scraping, how you might be a good consumer of data and how you may want to work with rate limiting and figuring out like, you know, what sort of rates are allowed and what's happening. And then what's fun is at the very end of it, there's several practical examples. One is searching and fetching for GIFs or GIFs, however you want to pronounce it. There's one, a more serious topic of getting COVID-19 confirmed cases per country. And then related to what you're talking about before, there's one, searching through Google Books and their extensive API. We started off with talking about, you know, building some APIs and building endpoints of places you can kind of pull data from. And we've had lots of those on Real Python, but this is again a nice beginner/intermediate introduction into really consuming APIs. And in this case, you're working very directly with a request package and diving pretty deep. So if you're wondering, what's my next step if I've learned sort of the basics of requests, I think this would be a great article for you to kind of build up off of. \n\nThe next article I've got is from Data Science Is The Blog. The title of the article is \"Making A Difficult Data Analysis Question Easy.\" And the difficulty of the data analysis question that he shows in the article is a little bit up for debate, whether you would actually say that's truly difficult or not. But what I really liked about the article was that it highlights kind of a problem-solving technique that is very powerful and can be very useful when analyzing data. So to kind of set the scene, he's taking a look at a data set that's looking at temperatures, minimum and maximum temperatures for different cities around the world based on each year. So like there'll be a row for the year 1995, and then you've got a column of, for example, the city, Abijan_max, and it's got the maximum temperature for that year, and then another column, Abijan_min, and it's got the minimum temperature for that year. Let's not say what the units of temperature are here, which is interesting but kind of irrelevant to the analysis that he's going to do. So you've got a whole bunch of these columns like city_max, city_name_min, and then the rows are different years. And the question is or what you're trying to get is the temperature range for each city. So it's not that hard. I mean, you just subtract the maximum, I'm sorry, subtract the minimum from the maximum for each year, and it kind of gives you the what the range was. So the range is like a single value, like it was a 26 degree range that year. So I guess you're looking for like cities where the temperature doesn't fluctuate a whole lot, and other cities where the temperature fluctuates a lot, like it does in my city, which we've had an insane range of temperatures. Yeah, same here. We got into the single digits. Yeah. Yeah. And we were deep in the negatives recently. So yeah, yeah, which is unique. I had lived in Hawaii and you could look at the temperature and it would be like, you know, it didn't matter. It would just be the same, right? Yeah. Continue on and on and right. Right. Now that sounds kind of nice. Yeah. Yeah. For sure. I'm in Houston, Texas and we got down, I think, to like eight or nine degrees last week at the low point of this cold front we had. And then literally this week, we were back up in the 70s. Very wide range. Yeah. But anyway, so you've got this data set and you want to compute this range for all these different cities. But what makes it kind of challenging is that is the format of the data. So you kind of have to like go through and it's like, okay, for each city. Well, the city is like encoded in the column names. And each city has these two different columns for it. And you end up having to do a lot of kind of manual work to sort of get the data that you need in a format that you want to be able to present it in. And so that's the challenge. It's not that the analysis is necessarily hard. It's that the format of the data makes it kind of difficult to work with. And so he goes through two different solutions of this. One where you just stick with the original format of the data set and kind of use a little bit of elbow grease and some manual work to kind of get what you need out of it, which is fine. You know, one of the things you learn when you ever have to do any sort of data wrangling for a company that has a long history of data is that sometimes you just have to do some manual work. That's just the nature of it. But once he goes through that solution, he then talks about a second option, which is, hey, you could reshape the data to then make it really easy to answer this question and get it in a nice format. So he talks about a strategy doing that where you reshape the original data frame. This is all using pandas and pandas data frames. You reshape the data frame using the melt function on the data frame and a little bit of additional work there to get it into basically instead of having a data frame with two columns for each city, and I don't know how many cities there are in this, like 50 or 70 cities or something like that, you have a so you've got a ton of columns, right? You've got over 100 columns. Yeah, you instead turn that into a data frame with four columns where you have a column for the year, a column for the city, and a column for the maximum temperature, and a column for the minimum temperature. And then your solution basically is just you have to like subtract these two columns from each other, the minimum column from the maximum column, and now you've got everything you need in each row. So that's what I thought was really neat about this article was just showing how when you're confronted with data that has a complex format, you know, and think about the problem that you're trying to solve, reshaping the data might be a good first step to get it into a form that makes it very easy to then solve the problem that you're trying to solve. I thought that was really good.\n\nYeah, that sounds like a really useful tool built on top of a few other things that we've been talking about. Async and await and these other tools that have been added to Python. But very often there isn't the why. You know, you know, it could be included there and you know, there's definitely in a lot of these industries, especially data science where it's like, well, there's actually a big why that could be answered. So that's cool.\n\nWell, and what I loved about it, so I love good examples. Good examples are extremely difficult to come up with. And the example here is, has to be credited to David Beasley, but this is, to me, is just a beautiful example of a very minimal server that accepts the connection and also has a very expensive CPU-bound function that it's that it's calling. So everything is wrapped up in this one really simple and very easy to understand example, which is just absolutely beautiful. So, yeah, that was enjoyable from that perspective as well.\n\nNice. Mine builds on top of a few other things that we've been talking about. It's using a library that I was not familiar with called Rich. There's actually quite a few of these libraries that are out there that can kind of help make the terminal a lot nicer looking and can add some additional functionality. The title of it is Building Rich Terminal Dashboards. So the idea of like a lot of people think of dashboards like the dashboards we were talking about before of, you know, hosting on a website and showing lots of data. But sometimes you may want something just locally on your machine to pop up in a terminal and show some ongoing information. And keep going. And so some people have taken the creator of Rich, Will McGugin, and he got a tweet from some people who took his library and modified it and said, \"Hey, check out what you could do with this.\" And had created this multi-window version of it, and they had hacked the library to kind of do that. So he said, \"Well, they don't need to do that anymore. I've added it to the library.\" And he updated the library to do this stuff. And they had created this thing called GHtop that showed a real-time stream of events from the GitHub platform. And it looked really good. He was like, \"Oh my gosh, I see this potential and how this could be a really handy thing to keep writing.\" And again, being that it's a command line interface and very much just text-based, and I hadn't heard this term. I guess it's common, but I hadn't heard of it, a TUI, a text user interface. And so this allows you to really kind of take advantage and really build a more elaborate TUI. And so in this really short article, it's showing you how to build a five-section layout with a header, a footer, two sort of stacked boxes on the left-hand side that are sort of half height, half width, and then a right side full height, like main box. And with, it's like, I don't know, 20 lines of code. It's really short. And then if you want it to be able to actively resize, he created a sort of a loop that can kind of pay attention to that. So I built it up and created it in VS Code and now it would resize no matter what size I made the terminal window, which is really slick. It's",
    "xOyw_n_Vz28": "Welcome to the Real Python Podcast. This is episode 51. What goes into the decision of how to host your Python code or application in the cloud? Which technology stack is the right size for your project?\n\nThis week on the show, we have Calvin Hendricks Parker. Calvin talks about cloud hosting options, infrastructure choices, and deployment tools. Calvin is the co-founder and CTO of Six Feet Up and co-organizer of the Python Web Conference.\n\nWe talk about finding the right tools for his clients, and he discusses the platform they created for hosting a virtual conference. We also discuss how to host your own personal portfolio projects, and that conversation leads to a question of what types of skills you can showcase through creating a hosted project.\n\nThis episode is sponsored by Scout APM. Scout APM is leading-edge application performance monitoring designed to help developers quickly find and fix performance issues.\n\nAlright, let's get started.\n\n[Music]\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at real",
    "ytaDmw01NQs": "Welcome to the Real Python Podcast. This is Episode 52. Have you heard about NoSQL databases or wondered how to use one with Python? How does MongoDB store information, and what packages can you use to connect this type of database to your Python project?\n\nThis week on the show, David Amos is back, and he's brought another batch of PyCoder's Weekly articles and projects. David talks about a recent Real Python video course about managing namespaces in Python. We also take a look at a few recent stories about the Python packaging ecosystem. We cover several other articles and projects from the Python community, including generating customizable PDF reports with Python, how semantic versioning will not save you, PEP 621 is final, a user hits the Python community with 4,000 fake modules, making a synth with Python, and what is running on the Mars helicopter.\n\nThis episode is brought to you by DigitalOcean's App Platform. Alright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey David, welcome back to the show.\n\nHey Chris, thanks for having me back again.\n\nAlright, we've got a whole bunch of interesting PyCoder stuff.\n\nYeah, this kind of combines a few things that we've talked about in the past. I had Mike Driscoll on to talk about PDFs and ReportLab, and we've talked about Leodinis's entire massive PyQt learning path that dives super deep into it. But this article combines them together in a really fun way, and in my opinion, it makes a very useful tool. I've mentioned several times about talking with small businesses and creating tools for them, and this, like in a small amount of code, you're making a customizable PDF report builder with Python and PyQt. It uses all those things, and it also uses something else we've talked about before, which is PDFRW, which is a very nice tool in Python for working with PDFs. It's by Martin Fitzpatrick from learnpyqt.com. Basically, you go through this process of starting out with a template PDF so that if you have, I don't know, say a letterhead or a certain kind of look and feel for an existing form that you want to have generatively filled out, either by someone going in and filling out the form field by field via a PyQt layout, it can do that, or you can have it generate it based upon a set of fields coming in from something like an Excel file or a CSV file. They show you both, and it's pretty slick. So it kind of goes through the whole process of building up not only where the forms will lay out inside their PyQt fields, how to kind of create this thing called a generator inside of that. And then it's, I don't know, it's really slick. I was impressed with the code. I got it running on my machine pretty easily, and I could see customizing it pretty quickly into a solution for, again, some of these small businesses. That was a really common thing for me to do is build fillable forms for them, and this would even take it to another level of having it run on here. I could see maybe even combining it with something like Beware, and I know that yeah, Russell had an announcement, and I guess Beware's working on M1 Macs, which is cool too. It's a new version of Beware out there. Yeah, so check it out. It's a neat little article kind of diving into customizing PDF reports and combines all these little technologies that we've talked about. Very readable, very easy to get up and running. And it seems like a neat site again if you want to dive even deeper into learning PyQt, learnpyqt.com looks like it's got lots of other interesting resources for free to check out too.\n\nOne cool thing about this article too is all of the code examples have little tabs at the top of them. Yeah, versions, yeah, yeah, to switch between like the code using PyQt 5, PyQt 6, or PySide 6. He's got the different implementations there for each.\n\nYeah, each one, which is pretty cool. There's a fun little joke in the whole thing. I don't know if I should spoil it or not.\n\nYeah, of what you're creating. So hopefully you'll find that as a fun little surprise for those of us who've seen that movie. So we're going to dive into a pretty intense topic next that we're going to hit from multiple sides. So I guess we'll have you start with your first article. Yeah, it's kind of, we got a little packaging theme going on.\n\nYeah, and the first article that I've got is by Hynek. It's called Semantic Versioning Will Not Save You. This first popped onto my radar, well, not this particular article, but there was a lot of chatter on Twitter about a pretty emotional GitHub thread. That's actually Hynek's words that he uses in his article, and it's very accurate. There was a lot of high emotions involved, but the Python package cryptography changed their build system to use Rust for low-level code. Yeah, and this was a pretty big change in the build system. It's important to remember this is the build system. This is not, like when you pip install cryptography, you're installing from a wheel. It's already been built, and so there's no like Rust dependency for using cryptography or anything like that. But this change in the build system caused quite a stir, and the way that Hynek describes this, he says enthusiasts of 32-bit hardware from the 1990s aside, there was a vocal faction that stipulated adherence to semantic versioning from the maintainers, claiming it would have prevented all of the grief. And there was a lot of pushback to that. There was also a lot of people saying, yeah, they broke semantic versioning. And this article does, it kind of doesn't take a side on whether or not semantic versioning was actually broken, although it kind of does in a footnote. But the point of the article was not whether or not this actually broke semantic versioning. The point was that even if it had broken or had not broken, this reliance on semantic versioning to sort of save you from any breaking changes is not necessarily a good mindset to have. And so kind of if you're not familiar with, I guess, for listeners that aren't familiar with semantic versioning.\n\nYeah, so it's pretty common. It might be the most widely used way of expressing versions of packages. I don't know that for a fact, but it just seems like you see it all over the place. Yeah, what it is is you have a version number, say something like 1.10.0, right? So the first number in that triple is the major version, so version one. The second number is the minor version, so that would be minor version 10. And the last number is called the patch version or the micro version. And so in this case, it would be zero, like 1.10.0. And the idea, so semantic version is supposed to come with like, okay, not only do I have this version number that describes this sort of breaks it down into like this major minor and patch version, but there's also supposed to be kind of this promise that as long as the major version doesn't change, I'm guaranteeing no backwards incompatibility or no breaking changes. So that if you had version 1.9.0 installed and you upgrade it to 1.10, in theory it should just work. There wouldn't be, it wouldn't cause any issues, right? I mean, this is all theoretical though. I mean, there's nothing about semantic versioning that actually guarantees this. It's up to the maintainers of packages. You can use it however you want, right? You can use it however you want, right? Yeah, exactly. But right, it kind of goes back to that zero verb thing I've heard people say too. It's like there's these people that hung on to like 0.75.1, you know, or whatever, you know, where the zero verb goes on forever, right? Yeah, but you're right there. That's not, it's not those aren't rules. These are just guidelines. It's, it's an idea, it's a guideline. It's sort of like how it's quote unquote supposed to work, but yeah. And this, the whole zero verb thing is like your major version is zero. So it's sort of like this, this, uh, offshoot of semantic versioning where you're, you keep your major version at zero and the idea is that until you get your major version to one, it's kind of anything goes. It's beta, it's, it's, it's exactly. It's like it's a beta type, type thing. So, so that's what semantic versioning is. And he talks about in the article this Hyrum's law, which basically states with a sufficient number of users of an API, it does not matter what you promise in the contract. All observable behaviors of your system will be depended on by somebody. So even if you have, say, a bug, yeah, and someone is utilizing this bug in some way that they're relying on it, then when that bug gets fixed for them, that's a breaking change, right? I mean, basically it's impossible to predict like how a change is going to affect all of your users. If you have a wide enough user base. And the point of this article is just that, you know, the responsibility for packages falls on both ends. There's the package maintainers that have a contract and are supposed to follow that, but as a user of a package, it's your responsibility to not assume that just because there wasn't a bump in the major version that everything is going to work fine. You need to test it. You need to take some responsibility yourself, right? And not just blindly expect that this contract wasn't broken. And if it was, I mean, you know, to alert the maintainers in a constructive manner and be a good citizen and help them with that. He lists some things that I want to just kind of rattle them off for a second, because I think it's, you know, if for readers, for listeners that don't read the article, it's important stuff to keep in mind. And one is have tests with good coverage, pin your dependencies to exact versions, and regularly try to update your dependencies to their latest versions. And if your tests pass, then you can pin to the new versions. So this is kind of a framework for when a new version is released, you know, how you can go about upgrading. And the wrong way to do it is to say, oh, they released a new version, so, you know, I'm going to go into my requirements file and pin it at the new version and then push it out and, you know, everything's going to be okay. And nothing, you know, nothing bad is going to happen. Well, I think about the pinning technique of using like the greater than kind of thing potentially could be problematic there too. It could, you know, you're, you're, you're going to, you got to think about how you're going to pin, like from here down or probably preferably equal equals, you know, this is the version that we're, we're, you know, we've tested on and it works on. So, right. Yeah, there's this, there's kind of this mindset. I've heard where, you know, if you're writing a library, you should pin your, your dependencies. If you're writing a, an application, you can kind of fudge it a little bit and use the, the greater than and less than or, you know, those kinds of version specifiers. I tend to just pin everything just because I know, hey, I've got it working. Yeah, and you know, upgrading a dependency can be a hassle because, especially if that dependency has several other dependencies, right? But, you know, if you pin it, then, then you know it's going to work when it gets distributed, whether it's an application or a, or a library. So, you know, take that how you will. If you're listening in, but, but anyways, it's just a really, I thought it was a really good article with really good advice on how you should approach upgrading your dependencies and where responsibility falls with all this. And I'll just read what he has at the end here of the article. He just says, so please use version numbers only for ordering releases, take responsibility for your builds, and don't harass maintainers to provide you with even more free labor that has only marginal upsides for you at best. So basically, be a good citizen. Yeah, especially if you're depending on the system that I think that were having a problem were like you said like really they're pretty archaic was at least commented on the Twitter thread. Yeah, I mean, they're specific old hardware, you know, I met on breaking change with hardware this week of upgrading to a Mac, M1, you know, processor and my expectation that a 20 year old MIDI interface that has a USB port on it, why shouldn't it work? You know, that that's kind of a little, you know, you know, steep, you know, for for even me to get upset about it, but I see people get upset online, you know, I've read those forum posts myself. So, you know, it's one of these things and I, I can understand there's like, there's, you know, there's limits to the hardware and software and also open source, there's gonna be limits. So, yeah, but yeah, it's, you know, especially if you're approaching it with good faith, you would hope. Episode is brought to you by DigitalOcean's App Platform. DigitalOcean's App Platform is a new platform as a service solution to build modern cloud native apps. With App Platform, you can build, deploy, and scale apps and static websites quickly and easily. Simply point your GitHub repository and let App Platform do all the heavy lifting related to infrastructure. Get started on DigitalOcean's App Platform for free at do.co/realpython. That's d-o-dot-c-o/realpython.\n\nThe next one is about a new PEP that's been in the works for a little while. It's PEP 621, and it's sort of the announcement that PEP 621 is final. It's a PEP from, well, Brett Cannon's one of the lead people on it, and he sort of spoke about this really briefly on our episode together, and I may have him come back and talk a little bit about it because he's really a champion on packaging, kind of going back down this packaging thing. And the note is that in the near future, you'll be able to store project metadata in pyproject.toml files, and Toml is another sort of markdown style file. It actually stands for Tom's Obvious Minimal Language, which is kind of a funny name. And I guess that's by Tom Preston-Werner and Pratien Gedem. What might be good for people to do, and I'll include links for this, is there is a post from last March, almost a year ago exactly, from Brett Cannon that's titled, \"What the Heck is pyproject.toml?\" Yeah, and it goes back to PEP 518 and PEP 518, and pyproject.toml changed. Now, a tool like pip can read the pyproject.toml and see what build tools are specified at it and install those in a virtual environment to build your project. That means you can rely on specific versions of setup tools and wheel if you want. Heck, you can even build with a tool other than setup tools if you want. Those are other tools that can rely on the same file called Flit or Poetry. You might have heard of these. Yeah, but since these are other tools require pyproject.toml and their users are already familiar with that. The key point is, assumptions no longer need to be made about what is necessary to build your project, which frees up packaging ecosystems to experiment and grow. Okay, so things that are in this pyproject.toml file can communicate with PyPI for uploading and sort of standardizes those names and the fields, things like the name of the project. And you know, that's necessary for the file name, the version, going back to what we were talking about of like potentially how you want to do your versioning number, the description, which is sometimes described as a short description. And then an actual readme, and then requires, which goes back to pinning and the idea of like, you know, what are the things that are needed to build this thing, the other dependencies that are in there. A license, the authors and maintainers, and that would include like not only authors names, but also their email addresses and ways to contact them, keywords and classifiers, and then URLs, which are a whole set of URLs that could be, you know, where the docs are, where the project's hosted, and all that kind of stuff. So it's really just sort of standardizing a lot of that. A Toml file feels a lot almost like a JSON file, the way that it's sort of organized. It's very much in sort of a dictionary sort of style. It's something that's hard to describe over audio, but I'll include links not only to the post about PEP 621 being final, but again, the blog post from Brett Cannon, and then there's some other information I'll include there that is the discussion going kind of behind it and then finally kind of coming to consensus. A lot of consensus lately, which is great, great to hear, yeah. Kind of early in the development of the next version of Python. And again, anything to make this stuff be more standardized, I think is great. Standardizing the tools, I think that's a bit of a complaint people have had about the Python ecosystem is sort of packaging in general, and we've been touching on it a lot, you know, like what are wheels, what are SDIs, what are these other kinds of things, and this is one of these things that's going to help try to, I don't know, narrow the landscape a little bit, make it a little more easier to understand and describe. Again, this is really tools for people that are maintaining packages and sort of describing the recipe that, you know, not only created this thing, but also all the ways to rebuild it and can be read by these other tools to make it much simpler, yeah. So then we got another packaging story, yeah. And speaking of packaging and I guess making it even easier to package, you know, with more power comes more responsibility and exactly there is an example of misuse of or some irresponsibility, I guess, recently in, yeah, with the Python Package Index. And this is, I guess it was a couple of weeks ago, but it just kind of came across my radar within the last week or so. And this user uploaded somewhere around 4,000 fake packages basically to PyPI in a very short amount of",
    "rWmjuruiO1Y": "Welcome to the Real Python Podcast. This is Episode 54. Do you know how a neural network functions and what goes into building one from scratch using Python? This week on the show, David Amos is back and he's brought another batch of PyCoder's Weekly articles and projects. David talks about a recent Real Python article titled \"Python AI: How to Build a Neural Network and Make Predictions.\" This article covers how to train a neural network and create a linear regression model. \n\nWe also cover several articles about testing in Python, including writing unit tests, testing code in Jupyter notebooks, and a testing style guide. We cover several other articles and projects from the Python community, including how to build an asteroids game with Python and Pygame, a five-point framework for Python performance management, how it helps to know a Python programmer if you want a vaccination appointment, a Flask mega tutorial, and the new release of SQLAlchemy. \n\nThis episode is sponsored by Scout APM, leading-edge application performance monitoring designed to help developers quickly find and fix performance issues. Alright, let's get started. \n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with the community of experts at realpython.com. \n\nHey David, welcome back to the show. \n\nHey Chris, thanks for having me. Alright, so we've got a couple of Real Python articles to start off with this week. One that I haven't really talked about much since last year when I had John Fincher on the second episode. We talked about games and Pygame. There's a new article on Real Python called \"Build an Asteroids Game with Python and Pygame\" by Aval Fertig. \n\nIt's really cool. It's kind of a fun one. I recently updated my Mac to Big Sur and I was having a little bit of trouble when I was doing my own course about Pygame with versions of Pygame and getting it to behave well. They were in the middle of, I think, getting Pygame 2.0 kind of solid. Well, it's pretty solid now. It works pretty well on Mac, at least. I set up a virtual environment, installed it, ran the demo, and it was good to go, which was really nice. \n\nIt was a neat project. It dives pretty deep into it. I focused on this a little bit in my interview with John about the idea that games are not only a great way to learn Python and programming, but as far as learning object-oriented programming, they're fantastic for that. You really are learning this idea of creating different types of objects and spawning them. In this case, they change the name, which I think is kind of funny, to space rocks. Don't want to have a copyright complaint there. \n\nIt goes into setting up Pygame, creating the project. I liked how it was set up a little more in a project sort of form where the initial code is going to be separate from the game launcher, which I think is really kind of neat and kind of focuses on that idea of using the \"if name equals main\" kind of loop to work with it as far as importing those types of materials. Pretty quickly, it gets into input handling, movement, and dealing with images. You can be working with the different objects and figuring out behavior. \n\nIt dives a little bit into geometry and the geometry of these objects and the whole idea of these game objects. Then, there's one of these interesting things with Pygame is that if you don't initially set up a clock to control the frame rate, it goes at the fastest speed possible, which can be a little too fast with a lot of modern computers. So you can kind of control it back down and get it to like 60 frames or cycles per second.\n\nYou build the spaceship, talk about okay, rotating it, and accelerating. A very interesting thing about asteroids is the idea of wrapping around the screen. If you go to the top edge, it'll appear on the bottom edge. How you do that, what's the math involved there, and all the way up to creating the interactions with the bullets and interesting unique things that are to the asteroids type game where you're splitting them up into smaller objects and then working with sounds and kind of ending the game. They don't want to go on forever, so there are things that are really nice jumping off points to polish it more, the idea of scoring right, really controlling the speed a little bit more. If you remember Asteroids Deluxe, I believe that was the one that actually had a shield, sort of shield buttons. That might be something fun to do, controlling with the joystick instead of using the keyboard, though I guess the keyboard is very much like the arcade cabinet would be as far as the individual buttons. \n\nBut anyways, it's a really neat project. It's very detailed. I enjoyed playing around in the code and working with it. It's a really good way to get into Python and playing around in Pygame. \n\nYeah, I'm excited by all this. Updates to creating more step-by-step stuff. I really feel like it's giving people an opportunity to build on top of it, give you enough of a framework. Of course, right as we always mention, you can get the code from the GitHub repository if you need that to kind of help you keep going with it. So what's your first one? \n\nI've got another Real Python article. This one comes from a brand new team member, Deborah Mosquita. It's called \"Python AI: How to Build a Neural Network and Make Predictions.\" This is a cool article because it walks you through building a neural network from scratch. Not using any pre-built thing like from Psychit or PyTorch or anything like that, which is not something I think when you're working in the real world, you wouldn't build something like this from scratch. \n\nBut if you're trying to learn about neural networks and understand how they work, then doing something like this is a great way to do that because you really get to see how everything is tied together and how it works from the inside out. This is going to be part of a new learning path that we're putting together on neural networks. So this will kind of be your introduction to how neural networks work, what the main concepts are, and then getting some practice actually building one so that you can implement the concepts that you're learning. \n\nAnd yeah, she walks you through kind of an overview of what artificial intelligence is and kind of what it isn't, and then the different kinds of artificial intelligence, and then how neural networks fit into that, some of the main concepts around neural networks and the process of training them, things like linear regression and how that fits into it. And then yeah, you start building your first neural network. \n\nAnd then at the end, you actually train it and use it to come up with a prediction. It's a really, I hate to use the word simple, but it's a simple neural network. I think it only has one layer, so if you're familiar with neural networks, they have these different layers. This one just has a single layer, and it really guides you through how all this works, a little bit of the math involved. It doesn't get too much into the math, but it's linked to a whole bunch of resources if you want to dive deeper into the math. You can, but yeah, it's just a really great introduction. \n\nI did the technical review for this. I really enjoyed it. I'm excited to have Deborah on the team and excited to see what else she comes out with here for us. \n\nYeah, I'm excited by a lot of new data science stuff that we're kind of adding as we go. I have a course that's coming through that's about NLP. It's actually kind of a neat one. It kind of goes into the Keras framework, and he does a bit of sentiment analysis, which we had Kyle on the show to talk about. His article, that was another one that was about sentiment analysis also. \n\nSo it's kind of fun. We're kind of diving a little further into that, and I was doing the review on it, so I learned a lot more about the process there. That one, again, kind of is there's so much depth as far as learning something like creating the neural network and then building layers and all these different steps that are in there. So yeah, anything to kind of get you in and then giving you additional resources, I think is fantastic to get you on a path where like, okay, if you want to dive further in, here's where you can kind of go. There's only so much you're going to fit in one article without it becoming a book, as we've mentioned before. \n\nRight, yeah, exactly. \n\n[Music]\n\nScout APM is leading edge application performance monitoring designed to help developers quickly find and fix performance issues. At only $39 a month, Scout APM pinpoints and resolves performance abnormalities like N plus one queries, memory bloat, and more, so you can spend less time debugging and more time building a great product. With a developer-centric UI and tracing logic that ties bottlenecks to source code, get the insights you need in less than four minutes without dealing with the headache or overhead of enterprise platform feature bloat. \n\nAnd with Scout APM's real-time alerting and weekly digest emails, you can rest easy knowing Scout's on watch to help you resolve performance issues before your customers ever see them. Start your free 14-day trial today, and as an added bonus for Real Python listeners, Scout APM will donate $5 to the open source project of your choice when you deploy. Check it out at scoutapm.com/realpython. \n\n[Music]\n\nAt this point, we're going to kind of dive into a fairly deep topic on testing, and it's kind of neat because I've actually recorded an episode in advance here. A new episode will be coming out soon with the team from sorcery.ai, and it's all about refactoring. \n\nIn that process of refactoring, that's really important that you've set up all this sort of testing in advance so that you know that if you're going to change your code that you haven't changed it in a way that's broken it, and having tests and unit tests and things like in place to make sure that that goes smoothly is really critical. Inside of PyCoder's this week, there were like three or four different resources all about testing and one was from Miguel Grinberg. \n\nIf you're not familiar with him, he created his Flask mega tutorial which is pretty famous in our community. We'll talk a little more about that later. He's got started a series and it's called \"How to Write Unit Tests in Python\" and it's part one. He took a very common interview type question, he keeps calling it a game, which I think is interesting. \n\nHe calls it \"The FizzBuzz Game.\" If you're not familiar with it, you're presented in an interview fairly often with this idea like okay, if you have a set up a range of numbers from 1 to 100, have it print them out, but whenever there's something that's divisible by 3, it should print fizz. If it's divisible by 5, it should print buzz. If it's divisible by both or by 15 or some kind of iteration of that, then it should be fizz buzz. And otherwise, it would print the actual number. \n\nSo it's kind of a neat thing to create a test around. It's very, it's something you could hold in your head, which is something also we talk a lot about when we're diving into this idea of refactoring and the idea of like okay, you know can you think about this, how complex is it, and so forth. Yeah, it starts with like \"build and\" and then something that you're building. So it walks you through literally step by step. \n\nExactly, yeah. So I think that's a really neat format, and you know, I think a lot of people appreciate taking the concepts they've learned from our more educational type articles and really building something with it. And this one is really fun. As you said, it's got some really cool graphics and stuff that come with it, and I think even has sounds, yep, with it as well. And it was something that Apollo actually approached us with. He had used it, so he's kind of reusing something he'd already built before that he'd done. I guess he'd given some talks at some PyLadies meetups over in, I think he's in Germany, yeah. \n\nSo it's a really fun project. It's another example of the step-by-step project format, which I'm excited to have more of these come out, and we've got more of them in the pipeline. If you like these style of tutorials, then there's more coming. Yeah, I just noticed on his personal page here, not only that he's living in Berlin, but he has a game development sort of company. I'm gonna... Oh, does he? I didn't know that. Try it here, Miss Miskatonic Studio is what it's called, and there's a link for it, and there's two projects in there. One called \"Intrepid\" and another one that's using Godot or Gdeto depending on where you want to pronounce it, open adventure template, which is something that actually John mentioned also, which is kind of cool. \n\nYeah, it's kind of cool. Yeah, again, a neat way to kind of dive into that and check it out. I'll include links to his stuff there, but you can get to it from the article too. Yeah, I'm excited by all this, you know, updates to creating more step-by-step stuff, and I really feel like it's giving people an opportunity to build on top of it, you know, give you enough of a framework, and you know, of course, right as we always mentioned that you can get the code from the GitHub repository if you need that to kind of help you keep going with it. \n\nSo what's your first one? \n\nI've got another Real Python article. This one comes from a brand new team member, Deborah Mosquita. It's called \"Python AI: How to Build a Neural Network and Make Predictions.\" This is a cool article because it walks you through building a neural network from scratch. Not using any pre-built thing like from Psychit or PyTorch or anything like that, which is not something I think when you're working in the real world you wouldn't build something like this from scratch. \n\nBut if you're trying to learn about neural networks and understand how they work, then doing something like this is a great way to do that because you really get to see how everything is tied together and how it works from the inside out. This is going to be part of a new learning path that we're putting together on neural networks. So this will kind of be your introduction to how neural networks work, what kind of the main concepts are, and then getting some practice actually building one so that you can implement the concepts that you're learning. And yeah, she walks you through kind of an overview of what artificial intelligence is and kind of what it isn't, and then the different kinds of artificial intelligence, and then how neural networks fit into that, some of the main concepts around neural networks and the process of training them, things like linear regression and how that fits into it. And then yeah, you start building your first neural network. And then at the end, you actually train it and use it to come up with a prediction. It's a really, I hate to use the word simple, but it's simple as in the opposite of complex, I guess here. It really is a simple, I think it only has one layer, so if you're familiar with neural networks, they have these different layers, to them this one just has a single layer, and it really guides you through how all this works, a little bit of the math involved. It doesn't get too much into the math, but it's linked to a whole bunch of resources if you want to dive deeper into the math. You can, but yeah, it's just a really great introduction. I did the technical review for this. I really enjoyed it. I'm excited to have Deborah on the team and excited to see what else she comes out with here for us. \n\nYeah, I'm excited by a lot of new data science stuff that we're kind of adding as we go. I have a course that's coming through that's about NLP. It's actually kind of a neat one. It kind of goes into the Keras framework, and he does a bit of sentiment analysis, which we had Kyle on the show to talk about. His article, that was another one that was about sentiment analysis also. \n\nSo it's kind of fun. We're kind of diving a little further into that, and I was doing the review on it, so I learned a lot more about the process there. That one, again, kind of is there's so much depth as far as learning something like creating the neural network and then building layers and all these different steps that are in there. So yeah, anything to kind of get you in and then giving you additional resources, I think is fantastic to get you on a path where like, okay, if you want to dive further in, here's where you can kind of go. There's only so much you're going to fit in one article without it becoming a book, as we've mentioned before. \n\nRight, yeah, exactly. \n\n[Music]\n\nScout APM is leading edge application performance monitoring designed to help developers quickly find and fix performance issues. At only $39 a month, Scout APM pinpoints and resolves performance abnormalities like N plus one queries, memory bloat, and more, so you can spend less time debugging and more time building a great product. With a developer-centric UI and tracing logic that ties bottlenecks to source code, get the insights you need in less than four minutes without dealing with the headache or overhead of enterprise platform feature bloat. \n\nAnd with Scout APM's real-time alerting and weekly digest emails, you can rest easy knowing Scout's on watch to help you resolve performance issues before your customers ever see them. Start your free 14-day trial today, and as an added bonus for Real Python listeners, Scout APM will donate $5 to the open source project of your choice when you deploy. Check it out at scoutapm.com/realpython. \n\n[Music]\n\nAt this point, we're going to kind of dive into a fairly deep topic on testing, and it's kind of neat because I've actually recorded an episode in advance here. A new episode will be coming out soon with the team from sorcery.ai, and it's all about refactoring. \n\nIn that process of refactoring, that's really important that you've set up all this sort of testing in advance so that you know that if you're going to change your code that you haven't changed it in a way that's broken it, and having tests and unit tests and things like in place to make sure that that goes smoothly is really critical. Inside of PyCoder's this week, there were like three or four different resources all about testing and one was from Miguel Grinberg. \n\nIf you're not familiar with",
    "-DpVFah8E4M": "Welcome to the Real Python Podcast. This is episode 55. Do you think it's time to refactor your Python code? What should you think about before starting this task? This week on the show, we have Brendan McGinnis and Nick Vapin from Sorcery. Sorcery is an automated refactoring tool that integrates into your IDE and suggests improvements to your code. Nick and Brendan provide advice on how to start refactoring and setting achievable code objectives. We discuss setting up unit testing and building confidence that you aren't changing your code's fundamental meaning. We also talk about technical debt and how it can creep into your organization's projects. This episode is brought to you by DigitalOcean's App Platform. Alright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey Nick and Brendan, welcome to the show.\nHey, thanks for having us. Hello there.\n\nToday we're here talking about refactoring and I kind of wanted to go just a little bit into a little background on really what is that and so maybe I can just ask somebody specifically here, so Nick, do you mind starting off and just kind of giving like a bird's eye view of what you see as refactoring?\nI guess it's the process of improving the quality of code without changing what it does. Often when you're writing code, you might hack together a solution and it works, it does what you want to do, but it's not very readable or maintainable. So you might sort of clean it up and improve the structure before you actually commit it. So this is kind of the process of improving code, I'd say.\n\nYeah, Brendan, do you have stuff to add to that?\nYeah, so there's also other times that refactoring can be done. It's not just when you're writing code for the first time. If you're coming to add new features to code, then maybe you need to change it at that point. And often a good time to do refactoring is at that point. Okay, make the code easier to work with so you can add those features more easily as well.\n\nI wondered about that. I did like a little dive into to kind of read up about like sort of what people have written about it and they had like kind of three factors that I thought of which would be: ones that you were mentioning Nick of the readability of the code and making sure that it's understandable and making it presentable in a way that others hopefully can join in on the project and make heads their tails of what's happening. And sort of potentially reducing maybe complexity might be part of that too, which kind of starts to lean into what you're saying Brendan. But then also I think what you're saying Brendan is this other one which is sort of the idea if this project needs to grow and this is a term that I spent some time talking with Dane Hillard about this idea of extensibility, the idea that okay this code needs to be able to work with other code and so maybe that might be part of the issue you're running into. Did I get that right?\nAbsolutely. The first time you write code, you may have some very simple requirements and you don't need a huge amount of structure and design to it. You can write a relatively simple solution, but as more functionality is required, more structure is often required to make everything clear, readable, and understandable. Like you say, extend and look, and so this is often the time to understand how the code needs to change, and that's when you do the refactoring. Okay, you make it clearer and easier, more extendable. It's kind of the best way of writing code as well. So if you start with a skeleton that works and then you iterate on it and then add new features, you don't write whole screens of things you're never going to need, and you kind of understand what you're doing as you're doing it. Okay, in that process are there outside of these software tools that we're going to talk about a little bit more that can help with the process, what would be techniques or maybe a I don't even want to call them tools but like, you know, sort of methodologies that people look at for doing this?\nYeah, I guess some unit testing is a very important part of the puzzle because often you don't want to be refactoring code if you're worried you're going to break it. That's kind of the worst thing. And when I do a manual refactor, often I will break the tests. Okay, you know then the chest will pop up red. I fix them. They're green again and then you can refactor again. It's kind of this cycle you go through. I think people call it red-green refactor sometimes. They're like, first make sure it's tested and then you have the confidence to be able to change the code structure because if it's not tested, you haven't got that confidence. Then it's kind of this first company we worked in had a massive code base and you were very no unit tests. You were very nervous you went and made the littlest change possible. Yeah.\n\nI worked for a bank for a while and in that circumstance we had large amounts of data. It was mortgages and so not only did I really think of the data was like kind of the most important sort of part of the formula in the sense that they had this entire staging environment. Not only like a playground development environment but then you know obviously the production kind of environment is, is that similar in the sense of like if you're working on something where you have code set up where you would be kind of refactoring inside of that sort of staging area?\nYeah, it's a confidence thing really okay you when refactoring you need to be confident that you're not changing the meaning of the code. That's the key thing and one excellent way for that is having these tests that tell you okay this is what the code did before. Once I change the structure of it, it still needs to pass all those tests. So we know it's doing exactly the same as it was before and if you, if you've got that safety net, you can be confident to do completely wild refactorings, whatever you like to do you can try things out and you know at the end of the day if all the tests are still passing the functionality is the same so however you want to structure if you think that's how the code is going to be best going forward you can go and make those changes if you don't have that safety net you have to be very, very cautious about what you do and you're unlikely to be able to find the best final outcome for the code you can only take both I mean you might be able to make some improvements to the code but anything that's a bit bigger than that you just don't have the confidence to go ahead and try it out.\n\nYes, we've chatted to some people who are working on this code base with that test and they will only do refactoring sort of the you can do through the ID or through a tool so they need to have that confidence they haven't made a manual typing error yeah if there's no unit tests, okay. So if you were let's say consulting a company and they're looking at doing this kind of project of refactoring and you pretty quickly notice that they haven't added tests like what how deep does that go like how many tests are needed like is there like some sort of metric that you would use to say okay we have the proper amount of tests in place before we can start moving into red light green light kind of mode?\nI think you can probably go bottom up like just pick a place start writing tests for it. Okay once you've got 100 code coverage on you know your function or your your your class you don't start doing some refactoring. Um you need to kind of go through the whole system writing all the tests which would be a very kind of maybe a very long project before you can start. Yeah, also the important bit is which part of the code base is going to change there's no point refactoring apart, the code base that works perfectly and has no change in future requirements. It's where are we going to be adding the new functionality and then the important bit is actually to test that functionality because it's not actually necessary to test every line of code as long as we're testing what we, we expect the outcome of the programs to be okay so as long as we've got that completely locked down and tested then we can do that restructuring as we need to and the best place to do it is obviously the place where we're not is going to be making changes to the system or where there's going to be a lot of changes upcoming because we get the most return on our investment right in those tests takes time so we need to get the value for them.\n\nDo you see that people sometimes get into sort of a spring cleaning mode or whatever you want to call it and they say okay we're going to refactor everything and then sort of end up spinning their wheels in areas that are not like things that you're ready for implementing change or that you were planning for is that something you've seen happen?\nWell too often I'd say I mean um because people are often they need like a reason well either refactoring is part of your normal workflow as in every time you make a change you tidy up a bit after yourself okay I think that's kind of the ideal or if it's like a case of you're going in and you're like okay we've got some technical debt we need to fix it often it's sort of like okay as Brendan said I'll find these these modules that we keep working on they're really difficult and we'll refactor those and concentrate there okay we're gonna say Brendan yeah I was gonna say that the first first aspect that Nick was talking about of always refactoring the code it's like this boy scout rule of leave the code better than when you first found it yeah absolutely okay if you if you can build that up as a team then the code's always improving the quality gets better it's always nicely tested it's always the whole code base is really easy to work with so that's the ultimate sort of idea working in an environment where everyone is always improving the quality of the code the code is a joy it's easy to work with but obviously there's many places where that's not the case or technical debt has built up despite those aspects and refactoring is still required at certain times so I've heard that term a lot and I mean you guys both have used it a couple times already now so this idea of technical debt is there a fairly easy explanation or I guess maybe we could think of a an example of common technical debt that you see in organizations code yes you can kind of think of it in terms of time and it's often sort of I'm going to save time writing this new bit of feature new feature I'm not gonna do it nicely it's gonna be this ugly bit of code so you've you've saved some time it's gonna cost extra time every time you come in and want to fix a bug in that code or or maintain it so it's like you've saved a bit of time but then you're paying the interest on that every time you need to change it and so paying off the technical debt is be how much time will it take for me to clean up that code and make it lovely and beautiful again okay it's kind of one way of thinking about it the i don't know the sort of project management constraints triangle you've really stretched the shape of the triangle and now you're gonna have to hammer it back into place um be able to to get a better uh payoff you know whatever ratio you want to call it um so that you you can work it back in what are common causes of technical debt that you you've seen you mentioned um just you know kind of doing something in a hurry are there other yeah yeah I mean like you say the first one is deadlines like you don't have enough time to really think it out or write the code and then do refactoring before it's all fully committed but then there's also lack of experience you may you may not know how to design this in a way that's nice and extendable going for forwards and then the third possibility is the requirements change for a project okay or for a certain area of the project and suddenly what seemed like a good design that was extendable in a certain direction is no longer or it doesn't extend in the new direction that uh the users need and so there needs to be a refactoring there to allow it to take that new functionality nice and easily I think of um remodeling shows you know you're watching uh somebody taking apart a house and saying oh we just wanted to add on this little room over here and then they open it up and you know the rafters are rotted or whatever and and so now you're you're not only spending a lot more money but you're spending time to even think about how it could support any of that additional code yeah itself and that person is yourself that you think like you think you understand the code perfectly and you come back in a few weeks and like like who write this right I don't get blame or what have you kind of thing where you start to recognize oh yeah okay that that was me from it was definitely it kind of made me think about another thing kind of related to that the idea of the mythical man month or whatever that you can't really throw that many bodies at something in the sense that if these are people that are new to this thing and truly the problem is the code is somewhat undocumented and un indecipherable every single one of those people is going to have to get up to speed on it and understanding it whereas it may make more sense to spend the time of you know like one person really fixing the documentation of like and understanding that code before really introducing anybody else because it seems so wasteful for everybody to have to learn it again and again and you know be throwing their hands up for sure I think when someone on board's on a team it's actually a really good time to work on the documentation and because they're looking at the code for the very first time I mean this is if the documentation is not already written yeah then it's a good time to catch up because they all have a lot of questions that may seem obvious to people who have been there for a year or more but at that point in time it's like I don't understand how this bit works and yeah the next five people that come on to the team are going to ask exactly the same questions so documenting at that time is a really good opportunity it's kind of funny I thought of two things with that one is the idea you know I've been in organizations that let's just say nobody ever asked questions and it was really very scary to me and I was never I'm fairly new to the development world in general and and I was you know brought up in kind of a different era of of people that were doing this sort of thing like I did computer engineering you know a long time ago in the late 80s and then kind of have come back and and gotten more and more into it with a big break and with in whole other sets of industries in between and so like I'm super anxious and ready to ask questions and I feel kind of emboldened to do that and you know I don't care if it makes me look dumb or whatever I just want I I need to know and I feel like it's important but I was in a culture and this may be just this particular you know set of organizations where they I think they were brought up not to ask questions um and it was really kind of strange to me and they would just go back and sort of just you know they might go on the side and ask somebody the question did you understand this or whatever you know and it's like you know completely inefficient and then I the one on top of that was I was thinking about the way you just mentioned it is sort of like a reverse code review is having that person come on board and in that process you know like look at this code and generate a bunch of questions for me about it if you feel like this isn't making sense and so forth and then you know having hopefully a healthy enough organization that they'd be welcome to that sort of reverse code review yeah it's a great way to think about it yeah you get so j like yeah you get so used to things when you're working on them forever that you just don't realize that you know it's so difficult to understand you've already put in that time this episode is brought to you by digitalocean's app platform digitalocean's app platform is a new platform as a service solution to build modern cloud native apps with that platform you can build deploy and scale apps and static websites quickly and easily simply point to your github repository and let app platform do all",
    "Zs4WWCl1RdA": "Welcome to the Real Python Podcast. This is Episode 56. Are you looking for a bit of order when working with dictionaries in Python? Are you aware that the Python dict has changed over the last several versions and now keeps items in order? Could you learn more about object-oriented programming in Python by comparing it to another language? This week on the show, David Amos is back and he's brought another batch of PyCoder's Weekly articles and projects. David covers a Real Python article about the differences between the OrderedDict versus a standard dictionary in Python. We discuss a recent video course about how object-oriented programming in Python compares with Java, and we cover several other articles and projects from the Python community, including what is Workzig building, a full-text search engine in 150 lines of Python code, loading SQL data into Pandas without running out of memory, how to beat the Berlin rental market with a Python script, replacing print with ice cream, and the new version of CircuitPython and Mu. This episode is brought to you by DigitalOcean's App Platform. Alright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey David, welcome back to the show.\n\nHey Chris, good to be back.\n\nSo this week we've got a real mix of things.\n\nYeah, I'm kind of excited about a lot of them, a potpourri.\n\nExactly. We've got a few different project kind of things, of course a couple Real Python articles. What do you got first?\n\nThe first one I've got is by Leodanes Poso Ramos, who is one of our premier authors at this point. He's pumping out a bunch of good stuff. People hear his name a lot here. This article is called \"OrderedDict versus Standard Dictionary in Python: The Right Tool for the Job.\" I was really happy to see this article come out because it's one of these things that a lot of people get confused by. If you've even heard of OrderedDict, so first of all, I think there's probably listeners out there who don't know what OrderedDict is. You have this built-in dictionary type in Python, which is sort of like dictionaries are just everywhere in Python, and it's like a key-value table in a sense, right? So you have keys and then they are tied to values, and the advantage is that you get really fast look up of values by their key, so you can access that key and it'll spit back the value that's there, and it's basically constant time performance. Up until Python 3.6, dictionaries didn't have any order. If you were to use, for example, there's this method on a dictionary called pop item, which allows you to just remove an item from the dictionary and it spits back a tuple with the key and the value in it and removes it from the dictionary, so you can kind of destroy the dictionary with this pop item and get items out of it, and it would just return like a random key-value pair. There was no order to it. When you would iterate over a dictionary, there was no order to how things were iterated. So there was nothing about the dictionary involved any kind of order at all. In 3.6, that changed. Well, I guess I should back up and say that if you needed a dictionary with an order, then you would use this OrderedDict type, which is available in the collections module, and that always kept a last-in, first-out kind of ordering, right? So basically, insertion order. And then if you needed to pop things out, then you would get, by default, you would get the first thing that you put in. When you iterated, it would go off of the insertion order. But then you also had the option of sort of shuffling things around, and you could pop items from the last thing that got inserted into the dictionary, or you could move things to the end. If order was important, then you would use this OrderedDict. If order was not important, then you would just use the standard built-in dictionary type, and all those methods were built in with that particular type. Exactly, yeah. And OrderedDict is actually a subclass of the dict type, so it has essentially the same API, but then adds a couple of things onto it to handle the ordering. Well, in Python 3.6, they did kind of a massive overhaul of the dictionary type in Python, and it was not a specified consequence, or what's the right way to say this? Happy accident, yeah. Kind of like a happy accident, was that in the process of optimizing a lot of things about the dictionary, they ended up maintaining insertion order. Now, in 3.6, they said like, none of this is a guarantee, you know, it's kind of just this unintended consequence, you know, don't rely on it. But so many people loved it that in Python 3.7, they decided to guarantee this last-in, first-out ordering for dictionaries. The built-in dictionary type. So then the question is, okay, well, if dictionaries now are ordered, then why should I even care about this OrderedDict type? Like, does it just cancel it out? Like, what's the difference? And why should I even use it? So that's the goal of this article is to explain what the differences are and why there are times that you would want to use the an OrderedDict versus just a standard dictionary. And just to kind of summarize why the answer is yes, that you still need an OrderedDict is that one is, you know, it signals intent, you know, it by using OrderedDict, you're making it very clear that the order is important here. OrderedDict also provides you some measure of control over the order. It's got a move to end method that can move items to like the end of the dictionary. It's got this modified pop item method that can pop from either end, and it's optimized for that. So you get fast removal either from the beginning of the dictionary or the end. And then also equality test behavior. So even though dictionaries, the built-in dictionary type is ordered, if you compare two dictionaries that have the same keys and values, but they were inserted in a different order, those will still compare as equal to each other because the order is sort of incidental. It's not like a feature necessarily of the dictionary. It's still kind of an unordered type, even though it does have this order. However, for an OrderedDict, if you have two of them that have the same keys and values, but they're in different orders, then they will not compare equal to each other. So if, again, it kind of goes back to like if that ordering is really important, then the OrderedDict is generally the right choice. Now, the article goes on to talk about how you like exploring all the different features of Python's OrderedDict type, how to merge and update using different operators, performance considerations between the two, which in general, the built-in dict type is usually faster, you know, for kind of the basic operations, and then like a kind of a handy guide for selecting the right dictionary for the job that you're doing, and then a nice little application that talks, it kind of shows you how to build like a dictionary-based queue out of this. So kind of applying OrderedDict to something you might see in the real world. It's a pretty cool article, and I think it will really help solidify people's knowledge of why these two types exist and why you would use one over the other.\n\nThat all makes a lot of sense to me. The idea that the intent is really being specified the minute you see that import statement. Yeah, you're making these constructs around something that you're going to want to always be maintaining it throughout. Something kind of going back to the refactoring conversation that I had, like this idea of showing what your intent is through how you're programming things, not just purely in documentation, but by how you're sort of setting stuff up structurally is pretty crucial. Can really explain where you're headed with these things. It makes me think a little bit about the series that Christopher Trudeau's been doing, taking this Python tricks been turned into a Real Python article that's sort of like selecting the right data structure. Yeah, he has a little bit about it there, but this sounds like a nice deep dive on it, going even further into a lot more of the why, which is great. My next one is, it's called \"What is WorkZig?\" and I always have a hard time pronouncing that word because it's German. I had the talk with Armin Ronacher way back in the show. I'll get the episode number right here in a minute, but he was talking about how when he was creating Flask, he had all of these sort of bits and pieces and tools, and he ended up calling the overall thing the Pallets project. This kind of nice conversation that we had about that and where the name comes from. Work is basically \"work\" and then \"Zig\" is like \"stuff\" and so it kind of relates to like being like tools or a toolkit, which is kind of interesting name. What it's really doing kind of underneath it is in doing this sort of heavy lifting of the HTTP functionality and not having to do all the sort of WSGI, which sometimes is pronounced \"whiskey\" Web Server Gateway Interface stuff. It does a lot of that work for you. It's of like connecting to that and setting all that up. And the article takes you through building up a little simple application in this case. It actually does have a data component where you're using Redis, which actually was able to use with Docker really easily, which was kind of nice. I didn't have to install Redis on my machine, which is very cool. It's by Patrick Kennedy. He writes on Test Driven I/O pretty often. And I just enjoyed it as an exercise of seeing the inner workings of what Flask is building on top of. It's very often you take these frameworks and you work with them at this higher level, and you don't get to see how these things integrate in what is happening kind of on the lower level. And what goes into those kind of components. So if you're interested in that, you do web development stuff, or you want to learn more about it, and you want to see kind of like, okay, what is Flask building upon? What's kind of getting handed over? It's a neat tool taking you through that. And I thought it was a good way for me to deepen my understanding of like, okay, well, what how do these Flask applications kind of tie together? And then, you know, there's this whole templating thing with Jinja templating Jinja 2, I guess it is. Yeah, anyway, I had a lot of fun kind of playing around it. And it's a well-structured project that you could work through and through the process learn actually what is WorkZig. Yeah, and I think also kind of come away with an appreciation of some of the things that Flask is doing for you. You know, you can create Flask applications so quickly. Yeah, in the case of, we've talked about visualization stuff and very often they'll use Flask as this very simple set of tools that can be set up within a handful of lines and you got this web server hosting your visualization, be it in something like Dash or what have you or Bokeh, which is pretty slick that it can do all that kind of work for you. And this is like, you know, taking you down into the inner workings of what's happening. Yeah, for sure. [Music] This episode is brought to you by DigitalOcean's App Platform. DigitalOcean's App Platform is a new platform as a service solution to build modern cloud-native apps. With that platform, you can build, deploy, and scale apps and static websites quickly and easily. Simply point to your GitHub repository and let App Platform do all the heavy lifting related to infrastructure. Get started on DigitalOcean's App Platform for free at d o dot c o slash real python. That's d o dot c o slash real python. [Music] So what do you got next? Next one I've got comes from someone named Bart DeGraff. I hope I'm pronouncing that correctly. This one is cool. It's called Building a Full-Text Search Engine in 150 Lines of Python Code. And it's true, it's like a full-text search engine. It only takes about 150 lines. One of the things that's kind of neat about it is it uses as the data set this 6.27 million article abstracts from the English Wikipedia. Wow. So it's millions and millions of documents. And you're able to search these things and get like a list of relevant documents in like milliseconds. Wow. And it talks about kind of, you know, everything that's involved in doing this. You learn kind of the basic components of a full-text search engine. That's things like, you know, indexing and searching and then how to compute the relevance. And one of the things that was that I learned and I thought was interesting was, you know, how they're actually computing that relevance. So they do this interesting thing where they they first kind of compute like the term frequency, like how often does that term appear in a document. And then also something called the inverse document frequency, which is like kind of a score of like how rare something is in the in the document. And they multiply that by the term frequency. That's kind of like their scoring mechanism. And he doesn't go into like a lot of detail of like why you do that or like what's really going on there. But he links to some really cool resources about, you know, what that is. And so we can throw those into the, into the show notes as well. So you can have a better feel for like why you're actually computing relevancy this way. But once you've kind of got all these pieces together, you've seen how to index things, you've seen how to like actually search through things and then compute the relevancy, then you tie it all together and you've got this, this full text search engine over this data set of documents. And one of the things that I really liked about this was I've come across, you know, a lot of times these articles on natural language processing. And it talks about like the basics, you've got like tokenization, lemmatization, stemming, right? And you know, for example, in the indexing part, you use this, you know, tokenization and stemming like to set things up for like the search and all that kind of stuff. But in a lot of articles, they kind of stop at these very, I use the term trivial, not as like a derogatory term, but just it's sort of like it's a minimal example to sort of show you like how something works. So I could publish it back to practically, yeah. But it doesn't give you any sense of like how do I actually use this in the real world? It's like, you know, okay, I've seen how to like tokenize some text, but like why would I do that? What's the application here? So this kind of introduces you to some of those concepts, but in the context of like building this like really useful tool. I mean, if you would be able to take this same thing and say you had, you know, a huge document library at your work that was difficult to search and it was all, you know, had a bunch of text in it, right? Then you'd be able to take this and basically take that data set and rework it using the same kind of code and build something extremely useful where you'd be able to search through those documents extremely quickly. So it's just a really cool article and I think will really help solidify people's knowledge of, you know, why these two types exist and why you would use one over the other. Yeah, that all makes a lot of sense to me. The idea that the intent is really being specified the minute you see that import statement, yeah, you're making these constructs around something that you're going to want to always be maintaining it throughout. Something kind of going back to the refactoring conversation that I had, like this idea of showing what your intent is through how you're programming things, not just purely in documentation, but by how you're sort of setting stuff up structurally is pretty crucial. Can really explain where you're headed with these things. It makes me think a little bit about the series that Christopher Trudeau's been doing, taking this Python tricks been turned into a Real Python article that's sort of like selecting the right data structure. Yeah, he has a little bit about it there, but this sounds like a nice deep dive on it, going even further into a lot more of the why, which is great. My next one is from former guest Edamur Turner-Trowling. He has a new article up on Python speed, and this one's called \"Loading SQL Data into Pandas without Running Out of Memory.\" And so, yeah, this has been an ongoing conversation that I've had and we've had that conversation even with Edamur, and how he's built this tool called Phil, it's a memory profiler tool. And I haven't had a chance to really play with it a lot, but it was neat to actually see it in this article sort of in action, if you will. You can, it gives the output multiple times to kind of show you how the thing looks at that stuff and how it kind of like creates this report kind of coming out of it. But anyway, he wanted to really talk about this problem that when you're loading in SQL, there's multiple places in memory where all that data is sort of held and has to be sort of parsed. And so there's kind of problematic ways of doing that depending on how big this query is. Like are you querying a million items and so forth. And so he has these examples. He talks about iteration number one, just load the data. A million rows. And the problem is all the data in memory. I think it's around maybe it's around 100 megabytes of raw sort of data. And by doing this multiple times, it ends up being like 400 megabytes. Again, it depends on your system. And again, we're talking example article length type stuff here. And so, but there are systems or very often we talk about resources out there on the web, cloud computing and so forth that we have to kind of plan for how much you're going to use. But, you know, the problem is, it's going to read all the memory. This SQL cursor tool is going to fetch all these rows. And then the tool, like something like SQLAlchemy, this ORM, is going to do manipulation on it. And then pandas converts it into tuples to be able to eventually do another step of converting those tuples into arrays. And at all points, all that's in memory. You know, it's not like it's sort of holding all that while those things are happening. And so it can end up being a bit of a big bottleneck. And you're getting this out of memory error. So he comes with a second iteration, which is this idea of sort of an imperfect batching of like, okay, think about these basic techniques of memory reduction. And the",
    "MfC52kb2Mqo": "Welcome to the Real Python Podcast. This is episode 58. This week's show is a bit different. We're taking a well-deserved short break, but we still wanted to share an episode with you. This rewind episode highlights clips from the many interviews over the past year or so. We also hear from many new listeners who have just discovered the show. Welcome aboard! We wanted to provide a sample of the guests, topics, and questions we feature on the show. For long-time listeners, this will be a brisk walk through past episodes and guests. We talked with so many great guests, it was hard to narrow it down to the sample provided here. We hope you enjoy this podcast rewind and we look forward to sharing a fantastic slate of upcoming guests.\n\nThis episode is brought to you by DigitalOcean's App Platform. All right, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nThis first clip is from episode three. The guest is Brett Slatkin, and we talk about his book \"Effective Python\" and how he and his team are using Python.\n\nAs you bring it up, I'm thinking about, okay, is Python a great tool for doing that sort of infrastructure work? Yeah, so I mean, I think there's like a decision tree that I have in my mind. I've written down somewhere, and it's kind of like, what language should I use for my project? You know, this is flame wars and bike sheds aside, right? I think that there's some simple things you can think about in order to make that decision. So for me, and I'm curious, you know, if you have any thoughts on this, like your view, but to me, like one of the first decisions is, is it a platform thing? So like if you're writing an iOS app, going with Swift is probably the right idea, right? It's, you know, you could try to do it with Python, but, and you know, some people try to cross compile or transpile or other things like that, and it works sometimes, but same thing Android, the number of boundaries there are going to be less, right? Yeah, yeah, you kind of want to go with the flow with a lot of the platforms. So, you know, same thing with like if you're making a game, maybe you want to use C sharp or C plus just because the platform SDKs you need to use that's what they're in. Okay, platform aside, then you get down to like these performance questions. And so to me, there's like really three kind of performance questions, which is like there's latency, there's I/O, and there's kind of memory usage. And if you really do care a lot about latency performance, like if you can't afford a GC pause, then a language like C plus plus or Rust or one of these other kind of non-garbage collected languages that's super close to the metal, that's kind of the way you want to go because you can't afford even a real-time system that's managing an airplane or something like that, you just can't afford GC pauses. Go is a bad fit, Python's a bad fit, but for I/O bound, if you're purely I/O bound and you don't care a lot about CPU overhead or latency, then like Python's like an ideal language. Oh cool. So that's my view. So like, so these systems for managing data centers are like perfect for Python because it's super flexible and you can be very effective.\n\nNext up is a clip from episode seven with Wukas Lang, and we talk about the origins of his code formatter, Black.\n\nWell, in back in 2018, it was a rather, you know, unorthodox idea. Like, you know, not to even call it kind of dumb idea to just start a new formatter for Python, right? Like, you know, Python has been around since 1990. So what makes you think like, you know, anybody needs a new formatter in 2018? And in fact, that was very much what I thought about this at the time. However, at the time I was working for Facebook, who, well, which employs a lot of people with a lot of opinions, but at the same time, like has this kind of mantra of like, hey, like we should focus on the most important thing at all times, right? You know, leave the kind of the nice to have things for later, right? And yet, I've seen code reviews be very often derailed by discussing like the dumbest things like, you know, you're missing a space, you know, after this comma or, you know, you don't have a comma at all or, you know, or you, you shouldn't have used this many blank lines here or whatever else. Like, you know, those silliest things ever. So we tried at some point to adopt a Google C app, right? You know, this project that is kind of a few years older than Black, you know, kind of, it was already stable and used by a bunch of companies and projects. So we felt like, hey, we can do this. However, we actually found out that we really cannot adopt it wholesale and that would be the only thing that would satisfy me, not to have one team at Facebook use it, but to have the entire company just kind of dive straight in and just like say, hey, we are formatting Python, right? Like this. Now we were unable to do this because the app is kind of both very configurable and has this brilliant idea that kind of backfires then to implement formatting as a dynamic programming problem. So that means is they think of every formatting problem as a problem of fitting things that you have in your virtual line, meaning if you didn't have any column size limits, a line could be just arbitrary long, right? Very often it wouldn't be because you wouldn't write while true comma and then just write more code. You would always just break the line after the colon, but some of the expressions, like I don't know, a very big dictionary, if you had, you know, no limits, you would maybe just put it in a single line, but we have limits. Maybe in your project there are 79 characters per line. Maybe they're 80 characters per line. Maybe they're 120, like, you know, whatever the number is, at some point you're going to fit a line that is too long and you're going to have to fold it. You're going to have to break it into multiple lines. So what the F is doing in this scenario is it's looking at a list of things that you as the user counted against a good formatting. You put penalty numbers in configuration saying, I don't like it. When this thing happens, I don't like it when that thing happens, you apply a number of penalty numbers in your configuration. And then the theory goes that the dynamic programming algorithm minimizes the penalty score for a given formatting. So it literally chooses the least ugly formatting possible for the given line right, conforming to this particular configuration file. So this, for the most part, works very well and actually kind of it's interesting in the sense that it's not like super consistent always, but when it's not, very often it's because you configured it not to be. Right. So that's cool. However, that makes it a very black box, right? You know, you cannot really explain to a person who is unhappy with a given formatting why a given formatting appeared, like, you know, what particular rule was used for it. You don't really know. The only thing that you know is it's tried a bunch of penalties and this combination turned out to be the minimum penalty number for this line. So what you can do in this scenario is you can go to your configuration file and instead of 48, put 49 in some particular, you know, place and maybe it will fix that particular problem that somebody came to you with. But then a bunch of other lines that used to be nicely formatted are going to be formatted differently now. So you're going to have other people coming back to you saying like, hey, like this didn't used to happen. Like why is it happening now? So it was all kind of very hidden from the end user, like what is happening. And in my particular experience, most of the time people weren't after the perfect formatting because any automatic tool that attempts this will fail. Like, you know, inevitably, like, you know, those tools don't understand symmetry. They don't understand aesthetics. They don't understand that a different file was formatted like this and this one is supposed to be formatted the same thing. It's impossible, right? Like, you know, those are very ambitious goals for a tool like this. So instead, what people would rather want to see is just some measure of consistency. Even if it's not perfect, at least you know why, right? So you can just kind of, you know, shrug your shoulders and say, you know, who cares? Like, you know, let's move on. And in fact, we've had a more ambitious kind of formatter project at Facebook for a while and that failed. So at some point, I just thought in 2018, you know, kind of I would like to have as a birthday present for myself just, just for my team and maybe a few other teams, just the simplest formatter I can ever write that just almost, it kind of looks like JSON, like, you know, does that's the same thing all over the place. Like, you know, with regardless of what bracket pair that is, it does the same thing everywhere and just run with it. Weirdly, that was the right time for this for me. That, you know, the initial alpha I pulled off in like six weeks, I think, you know, it's still in the repo history, so you can follow that. But I obviously missed my birthday because, you know, as a programmer, you're not supposed to hit your deadlines. It's just, it's the rules. I don't make the rules, but what I did actually make is Pi Day of 2018. And that was a cute date, you know, I managed to just release the first alpha then. And by the end of that day, I had like 500 stars on my repo. Wow. And I didn't understand what just happened. Like, I didn't understand why like I did have this kind of manifesto style sort of, you know, read me that actually explained why I wanted to have an opinionated formatter that makes everything look consistent and and how this makes things better.\n\nThis next clip is from episode 8 with Tanya Allard, and we're talking about using Docker for data science and how she's encouraging to use it for reproducibility of project results.\n\nSo that kind of leads to one of the things that is like a note in your like headline for your talk is the idea of reproducibility. That's correct. Yeah. I focus a lot on reproducibility. I come from a research background and we have a big problem in terms of reproducibility in research. And I think especially when dealing with machine learning, it is essential that we can actually confirm or verify that if someone is, for example, writing paper or publishing the newest research in machine learning that we can actually verify that these folks did what they said they did. And in that sense, that's where reproducibility matters because then others can build faster on those algorithms or in that research or even on an app that they're deploying somewhere else. And it also increases level of trustworthiness that people can have when you're using somebody else's work. How accepted is it in data science and machine learning space to use Docker as a tool? I think it's becoming more and more evident and we do need to have robust processes to have reproducible or deterministic environments because in so many cases people believe that if you make your code public or open source, then that makes your research or your machine learning thing reproducible. And that's not the case because you still have to be able to reproduce the environment or the data set that was used for you to get the same results. And because you can have many, many, many variations between certain dependencies, if you're using a version of Pandas versus another or Matplotlib or even different distributions of operating systems can change significantly your results.\n\nThis episode is brought to you by DigitalOcean's App Platform. DigitalOcean's App Platform is a new platform as a service solution to build modern cloud native apps. With that platform, you can build, deploy, and scale apps and static websites quickly and easily. Simply point to your GitHub repository and let App Platform do all the heavy lifting related to infrastructure. Get started on DigitalOcean's App Platform for free at d.o.co/realpython. That's d.o.co/realpython.\n\nThis next segment is from episode 11 with Anthony Shaw, where we're talking about getting advice about testing in Python.\n\nYour article as you talk a little bit about this concept of DRY, of, you know, don't repeat yourself. Yeah, so the idea with the DRY principle is that, yeah, you literally don't repeat yourself, you know, Python has lots of different ways to make your code a bit more functional so you can split things up into functions. You can extract pieces of code. It also follows the single responsibility principle. So when you're testing, if you haven't followed these principles, they'll actually make your testing harder. And that's kind of like a side effect. And it also is a bit of like what I call a code smell, which means that later down the line, if you want to refactor your code to have a new feature or like extend something or improve performance or something like that, like all these principles become a lot more important further down the line. So don't repeat yourself idea is quite simple, which is that, you know, don't have two classes or two parts of code which have more or less like the same block of code over. So don't copy and paste code between segments. Sure, yeah, I mean you can take this to an extreme like you can have pretty much like a function for everything, but like there is definitely a middle ground, which is, you know, try and remove things when you're writing tests. The don't repeat yourself thing definitely comes into play. You will probably find yourself actually repeating yourself in tests like the arrange act assert thing, you know, you'll probably copy and paste tests quite a lot. But if you're using Pytest in particular, there are some techniques you can use to basically like give it a range of inputs and run a test for each one of those. So rather than copying and pasting the test, you can actually say, run this test function with this array of inputs and it turns each one into a parameter. So that's called parameterization. And actually in this year's PyCon, Brian Auken did a talk on parameterization with Pytest, which is a really worth a watch if you're interested. Yeah, I just saw that one went up and he also wrote a pretty popular book on testing. Yeah, absolutely. I recommend the book. Yeah, I've got it. I've recommended the book. I've got it right next to me actually. I was using yesterday. Cool. Yeah. And his podcast kind of focuses on testing and test and code, though it's just like our podcast will go on a variety of topics too. So yeah, definitely. Expert is more for like tests. I think it's a lot of test professionals. Yeah. So people who are like full-time testers and there's a lot of advanced testing topics on there as well. So yeah, it's good to listen to.\n\nThis next clip is from episode 16. I talk with Hannah Stepanek about her book, Thinking in pandas. We talk about some of the steps that you might want to take as you import data into your data frames.\n\nSo one of the things I was thinking about to kind of go back to the normalizing topic is putting things into sort of NumPy type formats as opposed to just like, I don't know. I think the normal term for it is an object. Yeah, a pandas object or anything, right? Yeah, exactly. Yeah. So that's really where like you should be thinking about the types. Yeah, like the NumPy types. So you want to make sure that your types that you're using are C compatible. And a lot of times when you just rely on pandas read CSV or whatever data loader you're using, it'll spit out the types in just like objects, which are just general like Python object containers. So they could be anything, which are not C compatible and they're not performant and they're very large. So that's part of the normalization step is to kind of decide like what types you want them to be. And probably along with that like normalize your data such that it fits into that type. So like if you have any null values, for example, that's a very common problem and it's actually something that they tried to address with pandas 1.0. It's one of the major changes there is like allowing and like they built their own essentially like NAN type or null type in pandas 1.0. And they introduced, for example, like strings and boolean arrays that can have NAN values or like that that NAN is null type in them, which is a huge win for performance. Yeah, I could think so. Yeah, like normally it'd be nice to be able to not have it be like a full object just because there are some NAN numbers or NAN values in there when it when it could be just a boolean or you know or a smaller integer or something. Yeah, okay. And there are a lot of like, you know, there can be some surprises with leaving them as like an object. Like if you have a column that you expect to be a number, but it's actually an object and suddenly you have like an empty string in there, for example, and you're adding numbers together, that can definitely result in some very interesting values. Yeah, I can imagine. I remember somebody going through and let's say it's a health inspection thing, like you were talking about before, and maybe one of the columns is zip code or something like that and, you know, when you look at that data, yeah, you could potentially, oh, I could change this to an integer, but another way to look at it would be maybe to identify all the different ones that are used and sort of like classify them, yeah, which is another technique, right, to kind of simplify your data to make it a little more performant. Yeah, so there's a lot of considerations to be had there. I mean, there's also, you know, you can always like take your metadata out entirely, like, and you know, just have like a unique identifier. Pandas works a lot like databases, so if you're familiar with databases, you know, and kind of like the techniques they use there, you can absolutely apply those to your pandas data frames as well.\n\nThis next segment is from episode 18 with Armin Ronacher, the creator of Flask, and I had asked him earlier in the program about what he would",
    "2WjvRxdsp3I": "Welcome to the Real Python Podcast. This is episode 59. Are you interested in learning more about Django? Would you like to meet other professionals and learn how they're using Django? DjangoCon Europe 2021 is virtual this year, and you can join in from anywhere in the world. This week on the show, we have Miguel and David, two of the organizers of the conference. We discuss what makes DjangoCon Europe unique. David and Miguel talk about how they got involved and how the conference passes between different countries. They also cover the struggle of upending their plans for hosting the conference in Porto, Portugal last year, and how this year could use some extra support. Tickets are available now, and DjangoCon Europe is looking for additional sponsors. If you work for an organization that can help, get in contact with them. This episode is brought to you by DigitalOcean's App Platform. Alright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com. Hey Miguel and David, welcome to the show.\n\nHello, hey. So we're here to talk about DjangoCon Europe, and I wanted to get a little idea of maybe we could start off with like what you guys both do for the organization. Maybe that would be a good way to start and maybe how you got involved with DjangoCon Europe. David, do you want to start?\n\nYes, I can start. I've been a Django user since 2007. Since 2017, which was my first DjangoCon, I started to attend these conferences and got a real kick out of it. It's a really interesting conference. Eventually, from our participations, we were interested in maybe getting a DjangoCon in Portugal. We have wonderful weather, we are a relatively cheap country to travel, and in 2019 at the DjangoCon Capinaga, we were attending a meeting about the planning of the next conferences. Somebody we were already with that in mind, but somebody asked us, \"Portugal is a nice country to have DjangoCon. Why don't you apply for running DjangoCon?\" And we eventually did it and we applied for DjangoCon 2020. That's the start of our participation in terms of organizing DjangoCon. By that year, I think the Django Software Foundation had the two submissions for organizing DjangoCons. It was our submission and another one from a group in Scotland, Edinburgh. By that time, all the strange situations about Brexit, which wasn't completely closed yet and nobody really knew what it meant. By that time, help us a bit. I think they had a stronger application than ours because they were more known in the Django community. But we ended up having the concession and started to learn the DjangoCon 2020. As everybody already knows, we have COVID making a mess out of everything. Yeah, and by the time that COVID was something more real in terms of Europe and Portugal in particular, we were already with all the COVID participation active and we were already with the pretty much all the review. So we had to take some decisions. We actually decided to call for an online event to reduce all the troubles. Because at that time, there were also some major issues with the Black Lives Matter movement in the United States in the summer. Yes, and DjangoCon US was canceled by that time because between Black Lives Matter and all the COVID situations, they decided that they wouldn't have DjangoCon US in 2020. And that actually gave us an extra motivation to have a DjangoCon Europe in 2020. And that's how we ended up doing the first virtual DjangoCon Europe last year. We are very hopeful people, so we always believed that we could have an in-person event this year. Django Software Foundation was amazing. They right from the beginning, they told us that since we wouldn't have the opportunity to host DjangoCon in 2020, they will extend our submission to 2021. And we were really hopeful that we could have an in-person event because, as I said in the beginning, I think Portugal is a really marvelous country to have these technological conferences because it's not all about work. People also want to visit a nice country. We have amazing food, amazing people, great views. So it's a really nice country for traveling overall. I watched the introduction video from last year, yeah, and it was quite the travelogue kind of introduction of showing off Porto. And it totally made me want to go there. You definitely wetted my appetite for going there. And so I planned for the future to add it to one of the countries I will visit. So thanks for that.\n\nPorto is the second largest city in the country. Lisbon is the capital city, but Portuguese, I can say it's more cozy. People here are more friendly overall. We are on a hilltop, so it's not a really good city for bicycles. Yeah, we do have wonderful views of riverside. And before COVID, Porto was getting a huge number of tourists, and we are increasing very in that sense. So, Miguel, how did you get started with DjangoCon?\n\nMy first DjangoCon was in 2019 in Copenhagen. Okay. And the second one, I was already organizing it with David. So just quite a stretch for me. I loved it so much. It was a great DjangoCon, although I did not have other DjangoCon to compare to it. I know that one was really good. So I also had the idea of bringing it to Portugal and that conference happening in Porto. So when David applied, he also talked with me. And I said, why not? So we joined efforts and we started organizing the 2020 edition. Yeah, just to give you an idea, we didn't jump to organizing a conference of this level without any background. So one of the companies that allowed us to do this is a company that does live events for living. It's a company that does events in terms of real estate information. They organize, before COVID, they organized up to four events yearly events with 500 attendees at least. So we were pretty sure that in terms of organizing a conference, an in-person conference, we have all that we needed in terms of logistics to make a good conference. And that was one of the first things that really drove us to apply to the organization. And the other part, the content organization, all the other stuff. For people that know DjangoCons, and particularly the DjangoCon Europe, which is each year, it goes to a different organization in a different country. As a comparison to DjangoCon US, which has a non-profit organization that manages the DjangoCon US. In Europe, every year, the conference travels to different countries, to different sets of organizers. It's still a volunteer effort in terms of organizations. So we were pretty sure that in terms of logistics, we have the needed backgrounds, have everything that we could hope for in terms of sorting out the venue, in terms of catering, and all that part. In terms of the conference itself, we were pretty sure that we would have the necessary support from the Django community itself. And that is something that was true and is true and it will be true in the future. Typically, every organizer that has already participated in the earlier DjangoCon Europe is very willing to help the new organizers. So we have a huge amount of support from previous organizers last year and this year. A nice group of volunteers, different areas helping us with the organization. Yeah, I think it's important to mention this part that David said, in terms of passing the materials, you see, since the tips are completely different, the team from 2015 passed their material to 2016 and so on and so on. So when that material got to us, we already have four or five years of a backlog and with the notes on what to do, what not to do. So it's despite being different teams, there's a lot of information passing through to the next volunteers. So if you are thinking of applying for next year, don't be afraid and you should definitely do it. Yes, we will pass along any bit of information that we collected over these two years.\n\nThat's really cool that that's, I think it's a very interesting idea that it's a bit of a traveling conference and that the people that are interested in hosting it in their country has to sort of do their own sort of call for proposal, sort of offer up what they can organizationally for it. That's an interesting model. I haven't really heard of that before, but maybe that's a common thing with other European technological conferences. I think it has something to do with your, when you are talking about the United States, it's a single country. So you can have in terms of budgets and in terms of others, other things, you have a common policy. In Europe, each country has its own rules, even though there are some rules that are similar. For example, ticketing, invoicing will be specific to each country. So having a single organization that works over all the countries in Europe, it's really hard. And I think that has something to do with why some of the technological conferences in Europe work this way to some degree. I think, for example, EuroPython is a conference committee centrally, but then each country has its own. They actually need some help locally to organize that part, the venues, all the things that need to be specific to a given country as to be done by each country by a team in the local country. Yeah, I guess if we could go to a wider picture, what makes something like a DjangoCon unique compared to say EuroPyCon?\n\nI think the biggest factor is the community. When you get to DjangoCon, you feel at home. People are very welcoming, very inclusive. I've loved Django for so long, but when I started to actually interact with the Django community, it was even better. Miguel, definitely, I completely agree. For example, one thing that I found extremely interesting was the Pac-Man rule. So imagine you are hanging out in a break and you are talking with some other attendees. There is this Pac-Man rule where you always leave a gap in the circle so other people can join in and enter your conversation. And you get to meet a lot of different people through that. That's cool. What are the types of projects and places that use Django across Europe that you can think of that are notable?\n\nWe have been working, for example, with Predix, which is a Django software that is specific for ticketing conferences. We also have been using Django Pre-Talks, which is also general software for conference participations. Okay, I think that's been used in other conferences as well. Yeah, for example, in Practice Guides, I think they were here in episode 44. They also use this stack of practice and products. So it's really some projects that have already been tested. So are there particular talks that you expect to have this year at DjangoCon?\n\nBasically, the call for participation was closed by the end of March. As we speak, we are finishing up the review stage. We hope that when this episode airs, we will have a rough schedule of the conference, which should be okay by then. This year, we have a slight drop out in terms of number of submissions, but it is kind of expected because one thing is to submit a talk for a live event where you can travel, and that's an incentive. Another thing is to submit something for an online event. And as we all know nowadays, everything is online, and the smaller events are competing with larger ones. And DjangoCon, for example, is competing with all the Python conferences at large. So it's a different landscape, I think. Yeah, so we ended up having less submissions, but from what I see, we have marvelous content. Oh, cool. Are the types of talks purely about Django?\n\nMost of the talks are related to Django. There is usually not that much space traditionally for talks that are not somehow Django related or at least related with web stack sort of speaking. So you don't chase the Flask developers out of the building. No, no, I think it's important to know the alternatives to be better at your game. We all have some space. I don't think even though I love Django and I try to use Django for everything that I do, even stuff that is not Django might not be the best tool I ended up using it. But I do believe that there are better tools for some jobs and we need to know them. And if they are useful, they can improve our work and eventually if there are other tools that develop something that Django should also have, we can be inspired by them. I think in the beginning, there was that idea of the influence between Django and Ruby on Rails, for example. Which is a bit of, for from some folks that I've spoken to, it is a bit of misconception. But in the end, there are some, I don't think that these myths come from nowhere. So I think both Django and Ruby on Rails might have influenced each other in some aspects. And it's not natural that that works like that. I see that a lot. There's, you know, not only in these web frameworks and tools that you're talking about, but also across the language, even the core development of Python. The developers are constantly looking at other languages and places and kind of techniques and tools that could be adopted into the language. So I definitely think that that kind of open mindset is crucial with how fast all this technology moves and especially web technology. You got to stay on top of where everything's kind of going. I saw some time some time ago. I revisited the origins of JSON, the JavaScript Object Notation. And the author of that told specifically that part of the syntax that we are familiar with JSON, which is very similar to Python dictionaries, yeah, it's not an accident. He actually inspired, he was inspired by Python and the nearest, in his opinion, the pattern helped to make JSON something more easily adopted. So there, there are some influences, influences, even when we are talking about different languages and different programming paradigms. So one of the things I thought was interesting is that last time you had the conference kind of over a weekend and this time you're having a lot of the conference during the week during weekdays and having sprints on the weekend. What was your reasoning for that?\n\nOkay, last year we decided to have the first online conference and we were striving to have something that allowed people, regardless of being working or not. And it was last year, it was mainly compulsory free. We offered the 500 tickets. So we decided that last year the conference would have one weekday and one weekend day. It was Friday and Saturday to allow for everybody, regardless of working or family engagements, to participate somehow in the conference. This year we started out the year hoping to have regular conference and we announced the dates and we had the venue on track, everything. And it was in one of the worst times to do this kind of announcement because Portugal at the time was really bad in terms of COVID and the results were really, really bad. We didn't expect the negative impact of that. We were a bit naive, to tell you the truth. So in the end, we kind of stick with the original dates. So it was not meant. So last year we decided specifically to have a weekday and a weekend day. This year we kind of went with the pre-selected dates and hoped that it's not a big issue for the community at large because in the end, all these talks will end up on YouTube as it is usual. And the weekend, that part, we were striving. One of the things that DjangoCon does really well is allowing people to connect and work together on some projects and sometimes bug fixing Django itself. For example, in 2019, I went to DjangoCon US and one of the Django fellows was giving a workshop on how to contribute to Django. I went to that workshop and it is really interesting to do that kind of collaboration. What we are trying to have in this year conference is allowing for people to cluster in groups of interest, having some time to collaborate on projects, as it is usual to happen in a normal conference. In terms of the week, there's also somewhat different from last year. Last year, we had one track on two days of talks. And this year, we'll have three days of talks and workshops. So we have two tracks, the main track with the talks, one keynote per day. And then on the secondary track, we'll have some workshops.\n\nWhat will the workshops be like? What kinds of things will happen inside them?\n\nSo that's a hard question because a good part of the workshops are content submitted by the speakers themselves. We also will have, and we are working on that. So it is not fully closed. We are working on having some local groups taking some of the second track space to present some content and to work on whatever they think is interesting. For example, we are working on a submission for actually, we tried to submit something for Django Girls. We are still waiting for the official reply, but if it is not the Django Girls, it will be workshops for women. We will have that content also. Okay. So they might be more instructive as opposed to like a presentation per se, like more hands-on. Exactly. It's more hands-on, but sometimes something in that vein. Okay. Yes, it's normally like that. Sometimes what you have in the in the in general workshops is really that you have a small project that somebody will guide you from beginning to end. For example, in Django Girls, it's a usual kind of work where they set up the system since the beginning to the small app working. Something like that. And who's the intended audience for the conference?\n\nI think every Django developer should at least attend one DjangoCon. And I'm pretty sure that they won't be able to stick with just one. That makes sense. They should try the first one and then they will want to go to more DjangoCons. But I think it's important to mention that although the target audience are Django developers, it's not limited to Django developers. Last year, we have speakers from Brazil talking about the design. So Python developers, web developers, web designers, everyone should at least consider attending the DjangoCon.\n\nThis week, I want to shine a spotlight on another Real Python video course. Continuing with the theme of the episode, it's about Django and it's titled Get Started with Django: Build a Portfolio App. The course is based on an article by Jasmine Finer, and this course is presented by previous guest Martin Royce. By the end of the course, you'll be able to understand what Django is and why it's a great web framework. You'll understand the architecture of a Django site and how it compares with other frameworks. You will have set up a Django project and app, and you will have built a personal portfolio website with Django. This course jumps you in and you start to learn by example. If you remember my talk with Martin back in episode four, he's a big fan of helping you work through the errors you may find along the way. Like most of the video courses on Real Python, the course is broken into easily consumable sections. You get code examples for the techniques shown, and all the courses have transcripts, including closed captions. Check out the video course. You can find a link in the show notes or you can find it using the newly enhanced search tool",
    "dBzAy9CBXtM": "Welcome to the Real Python Podcast. This is episode 60. The Python Software Foundation is hiring with the recent support of three visionary sponsors. The PSF has been able to open positions for a developer in residence and a Python packaging project manager. Real Python now has a monthly Python news article. Frequent guest of the show, David Amos, compiles and summarizes the biggest Python news from the past month. This week on the show, David's back and he's brought another batch of PyCoder's Weekly articles and projects. We discussed David's news article from the past month, and we also discuss previous guest John Fincher's new step-by-step tutorial about creating a platform game with the arcade framework. We cover other articles and projects from the Python community, including how to use IPywidgets to make your Jupyter notebooks interactive, the hidden performance overhead of Python C extensions, adding else to for loops, film simulations from scratch using Python, a gradual programming language named Hedy, and a Python ray tracer. This episode is brought to you by DigitalOcean's App Platform. Alright, let's get started. The Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com. Hey David, welcome back. Hey Chris, thanks. It's fun to be back making one of these episodes again. Yeah, so what do you got first? First one I've got is from Matt Wright, who I think we've featured at least once, maybe a couple of times before. It's called \"How to use IPywidgets to make your Jupyter Notebook interactive.\" So this is a cool little tutorial as it is just kind of a showcase of different features. It tackles a problem where you're using a Jupyter Notebook to explore some data and you've got a plot that you've made, but you need to filter the data in the plot 10 different ways. There are a number of ways you can do that. For example, you could copy and paste the code for the plot and then just change the filter for each cell. Yeah, you could modify the same cell and execute it, view the results, and then modify it again and kind of do that 10 times. Or you could parametrize the notebook using something like papermill that allows you to do these parametrized notebooks, which is a cool little project. If you do that kind of stuff, you should definitely check that out. So that would allow you to execute the entire notebook with like 10 different sets of parameters. You might do some combination of all these things. Those all solve the problem, but you might want something quicker, like a more interactive way. IPywidgets is a way that you can add these little widgets like drop-down menus, forms, sliders, and different things like that that would allow you to achieve those in a more interactive way. I think it's important just you know, say that this is not really meant to replace something like a dashboard. If you were, you know what I mean, like right? I don't think it's really for that use case. It's more for like, I've got this notebook where and we're still like analyzing data but I want you to be able to select different filters or different things like that and just be able to quickly and interactively change the data that I'm looking at. They sit between the cells. I think so. Yeah, there's a couple of screenshots. Yeah, it's like you would have kind of your own cell basically describing the widget that you want to create and then it would display below that cell once you execute the that code. Nice. He talks about a couple of different widgets like the little drop-down selector. He gives an example where like maybe you're looking at data from different areas of different regions in a state or something and you want to filter it by like zip code which we have here in the U.S. or maybe you want to sort things by like a column name so or so you could have a drop-down that you would allow you to sort data in different ways. You can also do checkboxes, multi-select list boxes where you'd be able to like select different things like maybe different column names or something and you can add buttons as well which means that you can handle events like the button click and things like that. So the little example that he gives is like a little form that you can use to sort of select different things you want from the notebook and then press like a run button and it'll execute everything using what you've selected in the form. So cool little example and I think there's a lot more that you can do with it. So this is very much just an introduction to IPywidgets and would be a good sort of jumping-off point then to go and explore the docs and and really get neck deep into all that and how you can use it. Pretty cool little tutorial. Yeah, sounds nice. It's like you said, it seems kind of in between what would be a full-on dashboard that you might hand to somebody who's just reviewing the data, right? Whereas if you want to like collaborate with somebody and then let them have a handful of controls as you're experimenting, I mean that's you know kind of what all the Jupyter notebooks in general feel like such an area for experimentation. So it kind of gives you like handles on a lot of those things which is really nice. Yeah, that's what you got. So I talked to John Fincher way back in episode two and people who listen to that might remember him describing his sort of foray into playing around with another framework not pygame but arcade and that he was interested in creating a platform game. After a really long process of getting the article done and getting it reviewed and so forth, the article came out and it's really cool. It's titled \"Build a Platform Game in Python with Arcade.\" I was expecting it to be kind of a little, you know, fairly short, but it's actually, I think, a bit longer than the previous one that was about pygame because it really dives into a whole additional set of things that you need to do to create a platformer. And if you're not familiar with a platform game, you can think of like Mario or go back in time like Load Runner or there's some other ones that are kind of interesting, you know, the characters moving around on the screen and maybe picking up coins, like I guess Sonic would be another version of that possibly. This article uses arcade. It's not so much a deep dive on explaining the technologies of arcade, it's mainly really implementing them. It's much more of one of those that we've described as a step-by-step article. There is another article that's like that and I can give you a link for that too in the show notes to give you an idea if you want to learn like kind of the differences between pygame and arcade and get familiar with some of the basic technology of it, but you're really building this thing from scratch. He goes very deep into a topic that we've discussed a few times now of finding assets and he uses a website called KennyNL and that site, he's gotten the tiles that create the little areas that build up the map of the platform that you're working with and that can have different, oh gosh, everything from like, he's providing this sort of free tile set that has snow or dirt or grass or all these different kind of environments. So you could create lots of interesting different levels, which is neat. And then characters and enemies and things that you can pick up. In this case, it's coins. And then he kind of goes through the idea of like, okay, well, what's the structure of the game going to be? You know, sort of kind of coming up with a backstory of like how this works. And so after diving into the assets, one interesting thing that Arcade provides, which is really cool, is it has a physics engine choice and it provides like three different choices there. There's one that is actually specifically for platform games. It's built into Arcade, which is really nice. So it kind of has that sort of built-in structural gravity and things like that. And a lot of those concepts are handled for you, which is really nice. Then it dives into actually building levels, which was really fun. I enjoyed that idea of like, okay, this isn't that difficult. There's a third-party tool that is sort of freeware, sort of donationware kind of thing. It's called Tiled and it's actually a really nice design tool that allows you to import all the assets and then create this map of what the level is going to be. And you can create different layers so you can have like the actual, what would be, quote-unquote, like the ground versus like things that would be in the background versus things you interact with like objects and so forth. It goes into all of that, walks you through that whole process of working with those things, the sprites, the textures. And then as you're building and using that stuff and importing these maps, it's really fun to see, you know, a lot of tutorials like a lot of that stuff already kind of pre-built for you in this case. You're actually creating this level from scratch, which kind of gives you this kind of unique little bit of ownership over it, which is fun. And then you can kind of start to be creative like, how else would I modify this? And then it gets really into the nitty-gritty of like, okay, moving this sprite, collisions, something that's unique to a platform game is this idea that you have this map, sure, it could be, I don't know, a hundred across and maybe 50 squares high or tiles high. But your screen won't show all of that. So there's this idea of a thing called a viewport, which actually moves around as your character moves to the edge of the screen. The window moves with you and updates to that. And in this case, you're not only moving left to right, but you're moving up and down. And so there's a lot of interesting code that needs to be written to have the viewport follow you around and kind of work in there and dealing with that. Then it gets into, you know, scoring, showing that on the screen, some more advanced things like game controllers, creating intro and title screens. And then at the very end of it, after doing kind of some basic stuff, which is really a good idea to kind of make sure all that works and make sure that your character understands the environment and the player does. To it gets into then, okay, well, maybe the platforms can move, ladders, what kind of enemies there are, and how the character can interact with them and then in a whole bunch of additional directions that you may want to take this further with, you know, like numbers of lives, some other additional kind of loops, maybe a way to select levels, all these kinds of things that you could kind of see of how you could enhance this and make it your own. So it's a really great job that John did on this. I'm really impressed with it. I know it took a long time to come out, but I really am impressed with the end results and it made me excited about, okay, I feel like I could build this type of game, you know, outside of the other couple things that we've covered recently about gaming. I think this is a fun example and showed to me really the potential of Arcade engine. So, yeah, check it out. Yeah, it's really cool. It makes me want to come back and go through this tutorial myself. It was fun. I, yeah, I ended up, you know, typing almost all of it in as I went and didn't really have any big issues with it, which was cool. Awesome. Yeah, I love the little animations and stuff he's got in here too. Yeah, so you can see like what's actually going on. It looks awesome. Yeah, turned out cool. DigitalOcean's App Platform is a new platform as a service solution to build modern cloud-native apps. With App Platform, you can build, deploy, and scale apps and static websites quickly and easily. Simply point to your GitHub repository and let App Platform do all the heavy lifting related to infrastructure. Get started on DigitalOcean's App Platform for free at do.co/realpython. That's do.co/realpython. What do you got up next? Next one I've got comes from Itamar Turner-Trauring, which I think was another podcast. Yes, we've had him on the show. Got a blog called Python Speed and does a lot of stuff around working with large data sets, things like Docker, and as well as code performance. This article is called \"The Hidden Performance Overhead of Python C Extensions.\" So that's definitely on the performance side of things. He starts out by saying, you know, Python is slow, especially compared to compiled languages like Rust, C, or C++. And when your application is slow, one option is to rewrite some of your code in a compiled extension that you can then import and use in a Python program. So for example, this is the way like NumPy works. They have C extensions that and then you import those into Python and use that. But sometimes those compiled extensions can actually be slower than their equivalent Python code. And that happens for a couple of reasons. One is function call overhead, so the time it takes to actually just call a function, like not anything that the function does itself, but just calling that function has some overhead associated with it. And another thing when you work with these compiled extensions, there's a serialization and deserialization layer that adds some overhead there too. So if you need to pass arguments to functions that you're calling from the extension, then you know the way that an object works in Python is not the same way that it works in something like C++. And especially C, which isn't even an object-oriented language, so that it has to, you know, there's like a translation layer that has to be translated into something that the extension can understand. And then when the extension is done and returning a value back to the Python program, then that also has to be translated back to something that Python can understand. So that can add overhead to it as well. So he talks about these different issues and some ways that you can get around it. One thing that I thought it was kind of funny to me, I don't know if it would be funny to anyone else, but it was funny to me when I got to it in the article because it goes through like the example he's using is summing over a list of numbers. And he talks about, you know, different issues with that. And he kind of built up this solution and then he gets to the end and says, well, really the best solution is to just change your algorithm. And it kind of made me laugh because it was sort of like, I mean, I guess you could do that without the extension at all. And even mentions that in some cases just doing that you then you don't need the extension. Like you can, you can get your Python code fast enough. Of course you need to know an algorithm to be able to do that. But, yeah, that is definitely it can be the best solution. It's still a really like just interesting article. I didn't realize that there was so much overhead. For example, just calling a function from something like Cython. And it turns out it's not as slow as Python. Like if you're from Python calling a Python function, if you call a function from Python that's in Cython, it is faster, but it's not nearly as fast as like a native function call in C or C++. It's something like 30 nanoseconds for like just a, like that he has this function called do nothing which literally does nothing. The only line of code in it is pass. It takes, yeah, like around 30 nanoseconds to call that function, whereas in a compiled language you would expect something like only three nanoseconds and even faster if that function gets in line when it's compiled. So it's, it's an interesting article, something to think about if you need to write a compiled extension. Then these are things to be aware of for sure. And just, I guess one last takeaway from it, the thing that to me provided the most value when I was reading this was that, you know, this serialization and deserialization layer can really cause problems if you, if you aren't careful with that. And you have to kind of think through and the solution to there was to try to do as much of your data management inside the extension as possible. So to give you example, like NumPy, if you need to create an array of consecutive numbers, you can use like this a range function from NumPy. And what that means is when you pass, you know, you, you know, you use a range and you pass it some number and it returns a NumPy array of like, you know, zero up to, I guess, one less than that number. And the only thing that has to be serialized and deserialized there is the number that you're passing to that extension. Another way to do something similar would be to like create a list of, you know, using the range function in Python to create the same thing and then from there, create a NumPy array that's going to be way slower and actually use a lot of memory, a lot more memory than it would just passing the number to the extension. So things like that, like just kind of being aware that there's this hidden cost that you might not even be aware of and so that was to me that was kind of the biggest value that I got out of it. I",
    "EfsKDj_nEx0": "Welcome to the Real Python Podcast. This is Episode 61. Would you like to move your data science project from a laptop and scale it up to the cloud? Would you also like to have snapshots of your project along the way so that you can go back in time or share the state of your project with another team member? This week on the show, we have Seven Goyal from Netflix. Seven is the technical lead for machine learning infrastructure at Netflix. He joins us to talk about Metaflow, an open-source tool to simplify building, managing, and scaling data science projects. \n\nMetaflow addresses the needs of the numerous data scientists who work at Netflix. Machine learning is a key strength for the streaming service. They tried several existing tools to scale their own internal infrastructure and, after this experimentation, developed Metaflow. We talked about the history of the project and how someone could get started with the open-source version. Seven also contrasts the costs of infrastructure as compared to data scientists and the cost of their time. \n\nThis episode is brought to you by DigitalOcean's App Platform. All right, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with the community of experts at realpython.com.\n\nHey Seven, welcome to the show. \n\nHey, thanks for having me. It's kind of neat that you reached out after a previous episode where I was talking about the project section with David about Metaflow. I was very interested in the project and I had kind of played around with it. I'm not doing quite the scaling-type projects, but I know a lot of people who do, and I've definitely worked in those environments. So I was very interested in what Metaflow is and what it can do. \n\nYeah, so Metaflow is a data science framework that we have been building at Netflix for the last three and a half to four years. Some of the problems that you outlined around, \"Hey, here's a data science project. How do I structure it? How do I train my workflow? How do I keep track of the models that I'm generating? How do I access the data stored in the cloud, scale out my training processes, deployment experimentation?\" It's supposed to provide an opinionated view in terms of how to approach machine learning engineering, and it's available as an open-source project for both Python and R users. \n\nI've dabbled in R kind of about the same time I was working at a bank in Hawaii, and there were definitely two camps even in our small organization. There are things that I really enjoyed about R, like the tidyverse stuff. I feel like that vocabulary flows, and sometimes I had to have a cheat sheet to go back and forth between how I would do that in pandas and so forth. I know those two projects kind of steal from each other a little bit, but I can appreciate that there are people that enjoy working in one platform or another. So it's nice that the project can work across both. \n\nYes, indeed. I mean, there's this excellent project called reticulate that allows us to bridge the boundaries between Python and R. My doctor uses it behind the scenes, and Netflix has invested pretty heavily in both the Pythonic and the R ecosystem. We do have significant users who prefer to do their work in R.\n\nOne of the things that I was wondering about is your background. I feel like from the conversations I've watched online and some of the conferences I've seen you talk at, you seem to have an interesting background just by the way that you're speaking about things. Do you have a background in data science along with the infrastructure side?\n\nYeah, so it's actually interesting because when I started my career, at that point in time, I was planning to focus more on applied machine learning. I started my career at a startup where we had both data scientists and infrastructure engineers. Very quickly, I realized that to make any forward progress with any of the applied machine learning work, we had to first invest in pretty heavy-duty infrastructure. Yeah, this is almost like eight years ago, and machine learning engineering was not a phrase back then. I had these ragtag skills where I knew a little bit of data science and a little bit of infrastructure, and I found myself in the spot where I became the bridge between the infrastructure people and the data scientists. Throughout my career, that's the kind of role that I've enjoyed, essentially building infrastructure for data scientists to make them more productive.\n\nI still remember back then, Hadoop was sort of like the shiny new thing, and now people have moved on to many different architectures. The style of work has changed significantly. The contract between data scientists and engineering teams has also evolved. A lot of good things have come out, and my entire experience is just the evolution that I've seen from pretty much a front-row seat so far. \n\nI think about that as the field has gotten intensified, like the types of things that can happen inside of data science and then the machinery of the infrastructure has become in some ways democratized but in other ways allowed to scale to like kind of enormous sizes, and you've kind of been in that push and pull there right at the center of it with a company like Netflix, especially. \n\nI've been at Netflix for close to five and a half years now, and democratization is a rather interesting point. Netflix runs almost entirely on top of AWS, and what that means is if there's a brand new startup, a one-person two-person startup, they have pretty much access to the exact same sort of infrastructure that Netflix uses internally as well, and that's pretty amazing. Like 10 years ago, if somebody could have come in and said that, hey, you can get access to the same physical infrastructure that the Googles and the Facebooks and the Netflixes of the world are using, that would be a pretty big deal.\n\nYou mentioned that some of what Metaflow has built upon are some of the earlier projects that were thinking of similar solutions and then you've built on top of it and decided to contribute this open-source project out there. If someone was going to write those types of annotations, what does that look like? Are they doing that in Python in some kind of markup language or is it something specific inside of the language of Metaflow?\n\nThis is all pure Python, so we decided not to go with any specific YAML-based DSL or any JSON specification purely because it's easier for people to read and write in a pure programming language. So right now for open-source Metaflow, we have all of the integrations predominantly for the AWS cloud, and the reason for that was because Netflix is an AWS shop. We have significant experience with that. But we are seeing increased community contributions for integrations with GCP and Azure and other parts of the Kubernetes ecosystem as well.\n\nSomeone could be using some of those resources also, but the general idea of like, okay, I want this model to train with this set of resources or I want to use this particular node to do sort of the data processing part of it, those annotations are written just right in pure Python as part of the program that you've created.\n\nDigitalOcean's App Platform is a new platform as a service solution to build modern cloud-native apps. With App Platform, you can build, deploy, and scale apps and static websites quickly and easily. Simply point to your GitHub repository and let App Platform do all the heavy lifting related to infrastructure. \n\nGet started on DigitalOcean's App Platform for free at do.co/realpython. \n\nKind of building on top of that, this idea of snapshotting, which I think is totally fascinating, is how is the snapshot saved and then, I guess, how is it recalled? How does that kind of what does that workflow kind of look and feel like as far as the actual writing of files and things?\n\nThe runtime of Metaflow will take note of the entire state and it will essentially pickle it and compress it and store it in the data store. For example, you can imagine the data stored to be Amazon's S3, and we store that in a content address manner so that we can save on storage costs, even though storage is becoming cheaper and cheaper by the day. When any node executes, at that point in time, we can lazily recall any of these values when the code starts to execute on any of the instances. The snapshotting essentially helps recovering from errors quite a bit simpler and straightforward. \n\nIt also helps in some sort of like memoization, so I can go back in time, I can modify some code, I can copy over the state for my previous steps, and then I can just resume my execution as well. All of those capabilities are usually helpful when people are debugging their workflows. You can imagine that Netflix has a bunch of workflows which have super strong SLAs, so when things fail, it's rather critical for us to make sure that our users can still take the failure, but they can actually reproduce those errors so that they can reliably fix it and move forward.\n\nThe idea of handing off the project or going through an experience right now where I'm trying to take a vacation and the idea of being able to say, \"Okay, I've done all these things, I've set up all these things, all these things are scheduled, and they're supposed to happen,\" but to be able to hand this project over where it has this extra level of documentation that's happened where you've specified what hardware is supposed to do what and where, and then you've saved multiple sort of states as you've gone along. I think would allow inside of an organization somebody to be able to pick it up and potentially by watching or playing with some of these earlier versions of the project they would be able to kind of learn too. \n\nExactly, all of these can be individual nodes. Now, this concept is not a target, right? Like all workflow schedulers have a similar concept. But now what happens is our users, they declare this graph on their laptop, and now they want to execute, and very soon, what might happen is maybe the data volume is too high. Maybe you're processing say a 20 gigabyte data frame and your laptop just doesn't have the needed RAM to do that. Now, there are a bunch of different ways in which you can essentially spill to disk, be a little bit creative in terms of your data processing so that you can fit that entire computer onto your laptop. But usually it's much more easier for a data scientist in terms of the amount of time that they are going to spend if they can somehow just lift and shift that compute onto the cloud where that compute just executes on a much bigger instance. \n\nOur user in this case, they can just go in, they can just annotate that node, and they can say that, \"Hey, this just needs to run on an instance with at least 20 gigs of RAM,\" and then Metaflow will just take that compute and execute it behind the scenes for the user, and it will pipe all the logs to their laptops so to the user it would almost seem that their laptop just has more RAM at this moment. Now behind the scenes what Metaflow is doing is it will essentially take care of all the heavy lifting of like, \"Okay, what Docker image to use? How to package your code? How to actually instantiate a remote instance? Execute your code, bring back the results,\" so that you as an end user never have to think about any of those concerns. You can just keep on swapping the resource requirements that you need and Metaflow will do its work for you. \n\nLet's say you executed the first step, right? Now, the second step, you're training the model based on the features that you generated in the first step. Usually what ends up happening is that somehow the user needs to then decide how to pass data between these two steps. If everything is running locally on your laptop, then it's much easier. But then what happens if one of the steps runs on the cloud, the other step runs either on my laptop or a different instance on the cloud, and Metaflow by default will snapshot the entire state of the node and make it available to all the subsequent nodes, so that then again the user doesn't have to think about state transfer between these nodes and they can just write their code assuming that these are all class variables and are available everywhere. And that sort of like again makes them a little bit more productive given that Netflix has like significant investments in machine learning. We have many data scientists running really high-scale data pipelines, which make significant use of compute resources and GPUs don't come cheap. So, this also helps us isolate parts of our code that only need to run on expensive instances and other parts of the code can run on cheaper instances, so for example in this case where I was playing around with the data, then training a model and then storing the model somewhere, maybe only the middle step needs to execute on a GPU instance, and all the other steps can run on just the normal EC2 instances that AWS provides, which are not as expensive as the GPU-enabled instances. That also allows us to keep our cost profile significantly low.\n\nThat all totally makes sense to me, the idea that you want to take advantage of shared resources as you can. It's not going to have a bunch of idle equipment or resources out there to kind of dive into the nitty-gritty a little bit. If someone was going to write those types of annotations, what does that look like? Are they doing that in Python in some kind of markup language or is it something specific inside of the language of Metaflow?\n\nYes, so we use decorators for everything. Literally, we use decorators for everything, so you can specify resources, you can specify execution characteristics, you know, like do you want to retry this compute and so on and so forth. You can specify what sort of library dependencies do you want to use, do you want to use TensorFlow GPU, PyTorch, whatever package that gets your work done. And then given that, you know, everything is happening in the Metaflow universe, so we can essentially index and manage this metadata information and provide some stronger guarantees of repeatability. \n\nAnother point which is rather important for bigger organizations is that of collaboration and this notion of repeatability. It becomes really important in that aspect. You know, data scientists, they happen to be one of the most expensive resources, and we would ideally want them to focus on data science problems and not sort of like some of these mundane engineering chromosomes. So the goal is, can we sort of come up with an approach that builds on top of these foundational components but then smoothens all the rough edges for our end users?\n\nI think about people getting started in the industry because that's kind of the idea behind Real Python is really kind of helping people not only learn Python but learn all the tools and the different things that are available to them, and I think about infrastructure a lot. We've had a couple things where we've talked about sort of data engineering and kind of that as a sort of separate path. A lot of people I've talked to have sort of fallen into that career. It's kind of like that seemed to be what opened up for them. Do you think learning these types of tools, even at a nominal level, is something that an employer would be excited about? Seeing somebody come on board and have somewhat familiarity with not only some of the infrastructure stuff that's needed to do the data science but like this is these are some of the tools that kind of connect it together. Do you think that's a useful additional feather in somebody's hat as they go to look for a job?\n\nYeah, familiarity with the tool helps, but I think one of the bigger value propositions of anybody who is interested in this area is what are the problems that these tools are actually intending to solve. I think that's sort of the biggest value prop in terms of understanding the landscape. Many of these problems, they are hard to speculate if you have not worked in this field. So if you're brand new, if you're looking at Metaflow, then I would highly recommend just looking at it in terms of what are the problems it's solving. If Metaflow did not exist, if other comparable tools did not exist, then how would you go about solving the same set of problems? And I think that will help build real appreciation for some of the pain points, and that's always useful for employers.\n\nThat's an interesting question. On the ecosystem side of the house, I definitely really like the fact that many of the open-source projects are evolving to a point where a community is a big aspect, and the communities are also becoming more and more inviting, especially for newcomers. I mean, when I started my career, posting something on a public forum would give me anxiety because I was like, \"Okay, I'm not sure like this might be a dumb question and I'm not sure how people are going to react.\" So things have improved significantly over the last very many years and that's definitely one thing that's super exciting. We still need to make a lot of progress in terms of just making sure that people who are building the products, people who are using the products have a good representation in terms of diversity, background, diversity of thought, and there's this progress being made, but there's still a lot more that needs to be done. \n\nSo, would you like to get started with a watchmaking project next? \n\nI am pretty deep",
    "i7O1fOXFbIM": "Welcome to the Real Python Podcast. This is Episode 62. How do you know you're using the correct data structure for your Python project? There are so many built into Python and even more that are importable from the collections module. This week on the show, David Amos is back and he's brought another batch of PyCoder's Weekly articles and projects. We discuss a recent three-part video course on selecting the ideal data structure, along with comparing the types of dictionaries, data records, arrays, stacks, and more.\n\nDavid covers a recent Real Python article about the named tuple. This deep dive covers how to use the named tuple to write cleaner Python code. We also discussed new articles from previous guest Brett Cannon. He's added two posts to his Python syntactic sugar series about unraveling the pass and with statement. We cover several other articles and projects from the Python community, including async and Flask 2.0 Python projects on GitHub that are examples of best practices in good architecture.\n\nSpaceX sort of lands Starship, the new TI-84 calculator with Python, and building a Python spell checker. This episode is brought to you by DigitalOcean's App Platform. Alright, let's get started.\n\n[Music]\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com. Hey David, welcome back to the show.\n\nHey Chris, thanks for having me back. Yeah, excited to cover all these topics this week. We got a bunch of interesting stuff to dive into. Do you want to start it off?\n\nSure, okay. My first one I brought with me today is an article called \"Write Pythonic, Clean Code with Named Tuple\" by our good friend Leonidas Pozo Ramos. Total introduction and pretty thorough explanation of what named tuple is, which is probably, if I had to guess, I don't have any data to back this up, but if I had to guess, it was probably the most used data structure from the collections module. Named tuple is like a normal tuple. It's very similar API. You can put things into it. It's immutable, but you can give each slot in the tuple a name, almost like a class attribute. So it's a really great way to create a class-like experience but maintain the immutability that you get from a tuple. He talks about all the different features that it has, how to create them, converting between named tuple instances and dictionaries, and things like that.\n\nThen, a kind of a little field guide to using named tuple to write more Pythonic code. So, one of the big benefits is that you get these names of these slots in the tuple, which makes your code a lot easier to read and understand and adds a lot of context to that. He also talks about how you can use it to return multiple named values from functions. It's kind of a theme here, right? Is the idea that naming things is always a good idea. So, leaning into that feature of being able to name everything, it talks about using named tuples to reduce the number of arguments to functions and using them to read tabular data from files and databases. So, plenty of examples there to look at for ideas of how to use named tuple in your own code. He also compares named tuples to other data structures and what are the main differences. They're generally more readable, that named tuples are immutable versus mutable data structures like lists, talks about memory usage and performance, things like that. It's just a great introduction to the named tuple, which I think, you know, once you've kind of learned the basics of Python and you know all the kind of built-in data structures that you don't have to import anything to use, then I think named tuple is really one of the first next steps that you should be aware of and learn to use in Python. So, if you're at that spot, if you've never heard of named tuple before but you're familiar with all of the other built-in data structures, then this is a great next article for you to check out.\n\nWe've touched on it a couple times here on the show. I think we had another article a couple months back diving into named tuples. We touched on something that I'm going to go much further into today, which is there was an article by Dan Bader which was just about all these different forms of data structures throughout Python. That's definitely one that's covered pretty heavily there, so I'll talk about it some more there. But I think they're great. I mean, if you don't have to sort of build the whole class and write, still get the dot notation, you get all this other kind of nice functionality out of it. Named tuples are a really nice reason for importing them from the collections module to work with. Absolutely cool. Again, kind of going back in time and talking about a previous episode, Episode 47, I had Brett Cannon on the show and we talked pretty in-depth about unravelling Python syntax. He's been busy, he's been pretty busy over the last few months with the release of, well, I guess the beta release I guess you'd call it for Python 3.10 and new versions of Python 3.9 and the Python Language Summit, which meant a lot going on. We'll talk about a little more. And then this little thing that happened a little bit ago called PyCon. Brett's been pretty busy, so he hasn't been blogging a ton. But he just put up two more in the series going beyond what I spoke to him about, and this one's really kind of fun. It's just unraveling the pass statement.\n\nSo, if you're not familiar with pass, if you haven't seen it in code before, it basically is a little block of code that, if you want to define a function and then kind of as a placeholder, you can just simply put indented the word pass as a keyword in there and it does nothing. And which is fine and it's still, as far as Python, it's still readable and still works fine but it just doesn't do anything. Or if you're building out if statements or some other kinds of things, you can use it inside there. And then the pass statement, he actually unravels it and goes into the C part of it and disassembles it. And yeah, it does nothing. It has like two little steps that, you know, it returns none which kind of like the print statement does, and a lot of people don't realize that. But it's just a really kind of a uniquely Python concept. There are other languages where you throw in like an actual comment type of code inside there that's sort of formatted in a certain way to do it, and I was intrigued when I saw it the first time in Python. You can just write pass like it's like a game or something like that. I don't want to go this round. So, which is kind of cool. Yeah, so it's just a null operation. When it's executed, nothing happens. Yeah. One thing that he mentions in the article, although there's not a lot of kind of fanfare around this and I feel like it's just sort of mentioned in passing but I think a lot of people wonder like why would something like this even exist? Right? Like why would you even want to do this? And he says, you know, the reason pass exists is that you can signal that something is purposely empty. And that is the key concept. And I think that, you know, when you talk about like we were talking about named tuple and readability, this kind of goes into that readability idea. That, you know, making clear what your intentions are in the code and you know if you have a case where like nothing is supposed to happen, you could just leave that out of your big if statement. But then it's not clear like what was that a mistake or like should it be in there? Did we forget something, you know? So, putting it in there is just a way to like say like look it's not an accident like this really is not supposed to do anything. So, there are really good reasons that you want something like pass to exist. So, yeah, but I love, you know, it's the shortest. I didn't count how many words it is but I mean it's probably just like a few hundred. Yeah, yeah, which is cool.\n\nAnd just a few days ago, he released the with statement which we've talked a little bit about and you know, sort of the enclosures of the with statement and how it has kind of the special code built into it. These dunder methods of enter and exit and he goes into the details and uses a sort of a CS term that I wasn't familiar with this resource acquisition is initialization, RAII. And I'll include a link to this Wikipedia article on it but to illustrate how it goes, Rick goes into details about using that as a lock example and basically means that when you create an object, something happens and by freeing or deleting the object then something is undone and so this kind of process of width like within this enclosure, like something, you know, you're going in here, you're creating this resource, and then when that resource is done or that code is done, it basically kicks out right. And in the problem with Python is sometimes, you know, the garbage collection and the way things are allocated and stuff is kind of out of your hands and so having this statement allows you know the sort of a guaranteed cleanup, you know, kind of built into it which is kind of a neat way that this context manager can kind of do that for you. So, I won't go too deep into it but again, it's fairly short but it dives into the idea of this and then he's using it kind of as an example of like locking code for changes again if you're dealing with where you're having something be multi-threaded or some other kind of execution where you need this resource to be sort of by itself and not get changed outside of something. And so, it kind of has this sort of locking mechanic that he's kind of using to explain it. Yeah, good stuff. Yeah, I'm glad he's putting these out again. Yeah, yeah, I mean he's very succinct and I again I really like the structure of that whole series. Yeah, he also has a recent post that this is about a month ago. There was kind of a big brouhaha about open source and the idea of you know what is the responsibility as a maintainer that you have to like this entire vast world of you know right now of the users and he has a really great article. It's called \"The Social Contract of Open Source\". So, I'll include a link to that too. So, there's like three posts here. But I won't go too in-depth into it but the idea is this idea of like you know as an open source maintainer, you're basically giving something away for free and that should be a big part of the contract socially, you know. And so the way that people sometimes abuse that contract is just kind of gets out of hand and a little toxic. And so, I like his explanations that are in there and we've talked about it a little bit but this does a good job of distilling his thoughts at least. So, yeah, that is a good article. So, what's up next? What do you got next?\n\nThe next one I've got comes from Patrick Kennedy over on the Test Driven dot io website and it's called \"Async in Flask 2.0\". So, the Pallets project just released major new major versions of, I think, like every single one of their projects and Flask being one of those is now at 2.0 which is a big deal. It was released on May 11th and one of the big new features is it adds built-in support for asynchronous routes, error handlers, before and after request functions, and something called tear down callbacks. It adds all this async, excuse me, it adds all this async support and this article kind of walks you through like what the support is and how it works and you know kind of Flask's approach to handling async. One of the things that I found surprising just because I wasn't following any of this, it probably would have been surprising if I'd been following the development for a while but it does not use an async server, it still uses a traditional WSGI server and the WSGI servers are synchronous. So, there's you know a big difference between how Flask is handling this versus some of the other async frameworks. But you can read about you know what all that is and what it means and it gets into like why asyncio isn't required and everything but then it dives into you know how do you actually do this and how do you set it up. If you've done any async IO programming in Python, it's going to look very, very familiar to you. If you haven't done any async IO programming, then you're probably going to be confused just because async is not an easy thing to wrap your head around first time you take a look at it, probably even for many times you take a look at it after that. It's a very different style of programming and the logic is it can get complicated very, very quickly. But it is an important thing to be aware of and if you need the benefits that async offers then now Flask can do that for you. It talks about how to test async routes and the beautiful thing about it is that since Flask handles all of the async processing, basically nothing changes if you want to use Pytest with Flask, you can go about it using the same way to test all of your async routes as well. It's got lots of examples in it, how to do asynchronous error handling, all that kind of stuff. It's also got a section on how you can mimic Flask 2.0 async support in any version of the Flask 1.x series, which is kind of cool. So, if you want to kind of test out how it's going to work before you upgrade to 2.0 and go that route, then you can kind of mimic it and get a sense for how is this going to work with your application. There are those some differences there with how you would need to test that. So, they give some tips on using the Pytest-asyncio plugin to test async on Flask 1.x. So, it's a good article. It's not too terribly long. It gives a really good outline of what the changes are, how it works, and how you can start using it. What I was going to mention there is if somebody wants a deep dive, there's a really great async series by Lucas Langa and we talked a little bit about it. He was actually developing it way back a year ago when we were had him on the show to talk about it. But he, he's working for this new company and he dives really deep into basically all the different sort of functions. The company's called EdgeDB. The series, I know it's at least four videos, but it goes into it. Lots of good examples and he really does a good job of explaining it. Plus, he's done a few different talks and we had him talk about the async IO and music, which was really kind of cool. So, and hope to have him on the show again soon. He did this FM synthesizer thing at PyCon that was really cool. Neat to hear actual audio processing happening via Python and bringing it into like an actual digital audio workstation was pretty slick. Yeah, neat stuff. Yeah, good stuff. I'm glad he's putting these out again. Yeah. Yeah, I mean, he's very succinct. And I again, I really like the structure of that whole series. Yeah, he also has a recent post. That this is about a month ago. There was kind of a big brouhaha about open source and the idea of, you know, what is the responsibility as a maintainer that you have to this entire vast world of, you know, right now of the users. And he has a really great article. It's called \"The Social Contract of Open Source\". So, I'll include a link to that too. So there's like three posts here. But I won't go too in-depth into it, but the idea is this idea of like, you know, as an open source maintainer, you're basically giving something away for free and that should be a big part of the contract socially, you know. And so the way that people sometimes abuse that contract is just kind of gets out of hand and a little toxic. And so, I like his explanations that are in there and we've talked about it a little bit but this does a good job of distilling his thoughts at least. So, yeah, that is a good article. Yeah. So, what's up next? What do you got next?\n\nNext one I've got comes from Patrick Kennedy over on the Test Driven dot io website and it's called \"Async in Flask 2.0\". So, the Pallets project just released major new major versions of, I think, like every single one of their projects and Flask being one of those is now at 2.0 which is a big deal. It was released on May 11th and one of the big new features is it adds built-in support for asynchronous routes, error handlers, before and after request functions, and something called tear down callbacks. It adds all this async, excuse me, it adds all this async support and this article kind of walks you through like what the support is and how it works and you know kind of Flask's approach to handling async. One of the things that I found surprising just because I wasn't following any of this, it probably would have been surprising if I'd been following the development for a while but it does not use an async server, it still uses a traditional WSGI server and the WSGI servers are synchronous. So, there's you know a big difference between how Flask is handling this versus some of the other async frameworks. But you can read about you know what all that is and what it means and it gets into like why asyncio isn't required and everything but then it dives into you know how do you actually do this and how do you set it up. If you've done any async IO programming in Python, it's going to look very, very familiar to you. If you haven't done any async IO programming then you're probably going to be confused just because async is not an easy thing to wrap your head around first time you take a look at it, probably even for many times you take a look at it after that. It's a very different style of programming and the logic is it can get complicated very, very quickly. But it is an important thing to be aware of and if you need the benefits that async offers then now Flask can do that for you. It talks about how to test async routes and the beautiful thing about it is that since Flask handles all of the async processing, basically nothing changes if you want to use Pytest with Flask, you can go about it using the same way to test all of your async routes as well. It's got lots of examples in it, how to do asynchronous error handling, all that kind of stuff. It's also got a section on how you can mimic Flask 2.0 async support in any version of the Flask 1.x series, which is",
    "KcJO4XWZ0n4": "Welcome to the Real Python Podcast. This is Episode 64.\n\nAre you looking for an in-depth data science project to practice your skills on? Or perhaps you would like to add new tools to your Python web development projects instead. This week on the show, David Amos is back, and he's brought in another batch of PyCoder's Weekly articles and projects. David shares an article about how to go about detecting deforestation from satellite images. It covers how a data science team built a machine learning solution to do just that using fastai for the modeling and Streamlit to create a dashboard. \n\nWe also discuss a Real Python article about building a blog using Django, Vue.js, and GraphQL. GraphQL is a great tool to enhance your API to make it more flexible. The step-by-step project walks you through turning your Django blog data models into a GraphQL API. \n\nWe cover several other articles and projects from the Python community, including the tools and tech used to run a one-woman hardware company, visualizing data in Python using Plot.scatter, why the sad face when using black, how to iterate over data frame rows, and should you pipx. \n\nIs now a PIP PA member project and real-time lossless audio compression in Python with PyFLAC. This episode is brought to you by DigitalOcean's App Platform. All right, let's get started. \n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com. \n\nHey David, welcome back. \n\nHey Chris, thanks for having me back. \n\nAll right, we got a whole bunch of PyCoder's goodness here. Yeah, I'm going to start off mine this week talking about a Real Python article from a previous guest, Dane Hillard. Dane Hillard was on in Episode 49. He was talking about his book, \"Practices for the Python Pro,\" and kind of what makes a professional developer. Near the end of the episode, he dove into something he was interested in learning about and working with, which was GraphQL. And this is another step-by-step article on Real Python, so it's not a super deep dive into the technology like describing it in sort of research on that. It's much more of an implementation and learning how to use this and set it up and kind of get your chance to play with a lot of this technology. \n\nIt's called \"Build a Blog using Django,\" which we've covered multiple times, but then the next two commas are Vue, which is a JavaScript library kind of similar to React in some ways, and then GraphQL, which is what he was talking about briefly at the end of the episode. He was mentioning that he was interested in this query language, and I was not that familiar with it. I've learned a lot more about it, and I'll include some additional resources. There's a JavaScript-centric podcast, a web development podcast called Syntax, and they have an episode where they talk about GraphQL in a lot more detail. There's a lot of information out there. It's originally developed in the Facebook camp, and it's open source. Since 2018, it has become a pretty popular way of sharing APIs. \n\nThose of you who've maybe played around with APIs a little bit, there's sort of this problem of having to set up an endpoint for everything you kind of want to access or the reverse of it is you set up an API and then it dumps like this huge amount of data back at you. It would be nice to be able to kind of sort through that and query that and narrow it down. That's really the idea behind GraphQL. It's hard to really explain in this format. It very much looks like JSON. It's a querying is very JSON-like in the sense that you're specifying the attributes and things that you want to pull out of this information, but it's pretty neat. It allows you to move beyond like having all these separate endpoints and the pile of information you get back, and you can kind of specifically ask for what you're looking for. \n\nEventually, you're kind of building up this router, and then you're creating the separate view, what are called components, and they're very similar in my opinion to like the models and things like that. But once you kind of get it set up, there's this different sort of endpoints that you're setting up. Your server will have a slightly different port than what's happening from the Django side. So like 8000 versus 8080, and so you're kind of talking back and forth on your local machine, fetching data and pushing it back and forth. It's a really fun kind of way to explore and learn a little bit more about this stuff and see how not only how you might implement Vue but this very advanced way of working with APIs that really looks like kind of the future of how you could work with APIs in a much more elegant fashion of getting to the specific things that you want. \n\nYeah, I really like this step-by-step project format, and we've got more of these coming down the pipeline. You're right, this really isn't these styles of articles are not really about teaching you about the different technologies as much as it is showing you how to combine things you might already know about into an actual project. Right, which I think fulfills a need that goes beyond just like a tutorial on you know just Vue itself or just GraphQL. You really integrate those things and see how they all fit together in an example project, right? So yeah, it's definitely fulfilling a different need than like, you know, it kind of assumes for example, you know something about Django, you know something about Vue, maybe you know something about GraphQL. It's not really necessary because you can kind of copy and paste and follow along, and Dane does a great job of sort of showing you at each step like what your project structure should look like, like what folders and files you should have and where they are. \n\nSo anyway, eventually you're kind of building up this router, and then you're creating the separate view, what are called components, and they're very similar in my opinion to like the models and things like that. But once you kind of get it set up, there's this different sort of endpoints that you're setting up. Your server will have a slightly different port than what's happening from the Django side. So like 8000 versus 8080, and so you're kind of talking back and forth on your local machine, fetching data and pushing it back and forth. It's a really fun kind of way to explore and learn a little bit more about this stuff and see how not only how you might implement Vue but this very advanced way of working with APIs that really looks like kind of the future of how you could work with APIs in a much more elegant fashion of getting to the specific things that you want. \n\nYeah, I really like the idea of like standing stuff up and then being able to sort of poke at it, you know? So right, if you were to then go and look at other resources to learn more about Vue or to learn more about GraphQL, now you have this working project and you're now able to try those techniques out on your own services that you've set up. Yeah, and can sort of customize them, and so I think that's a nice practice for sure more than just sort of following the step-by-step, you know, which is always good to kind of get the muscle memory of typing things in. \n\nWhat's your first one you got? First one I got is called detecting deforestation from satellite images. This one comes from Andre Ferreira. It's a full-stack deep learning project, and it's sort of similar to what we just talked about with Dane's Django Vue GraphQL. It's kind of an end-to-end like we're building this project together. It's not quite the same kind of step-by-step format that we have on Real Python. This one is a Medium article on the Towards Data Science blog, yep, but it's a really good example of again like how you would approach putting together a data science machine learning project end-to-end like starting with they even start with for example like okay what data set are we going to use. \n\nThey investigate a couple of different data sets and they make a decision and they explain why they picked that particular data set. Then what model they're going to use like what package are they going to use for the model for the machine learning how are they going to present the information and the results what kind of dashboard are they going to have. It's just the whole nine yards. The article is not incredibly technical in terms of there's not a lot of code in the article, they've got links to the project repository on GitHub so you can go and you can look at all the code, but it really focuses more on the decision-making process in this and sort of like what they were thinking about. They're trying to build sort of a minimum viable product of something that could be used to detect where deforestation was occurring from satellite imagery. And they start by looking at kind of a plan for the project, it's okay what what does this thing need to do, and of course that you know is a great first step for any project. You know sit down and sort of map out like okay what is it that we actually have to get done here, what are kind of the key points. \n\nSo they talk about you know for this for this MVP, the minimum viable project, what uh, you know what what do we need to have? Well, we need to have a model that's trained and has acceptable performance on detecting deforestation, we need to have a dashboard to show the predictions on the data set, we want to have a GitHub package, we want to do some hyperparameter tuning, that is you know optimization to improve the model, and we want to have a robust data storage solution for the project. So these are kind of like the minimal goals they set out ahead of time, they talk about some like things that would be nice to have, things like what they call out of domain or distribution shift analysis, like they, you know if they have the time it'd be nice to study the model's performance on data that's different from what it was trained on to kind of see how it works there, they'd like to have tests for their package so yeah, they talk about you know kind of these nice to haves and really lay out like a roadmap for like okay this is what we want to get done for the project. \n\nSo it's really cool to see that you know the things they're thinking about what they're looking for, like I said it's really kind of a guide to like how you would approach building a project. Then they go into okay how are we going to do this like what are we, what are we going to look at, um where is our data going to come from. So they talk about you know doing a bunch of research, looking at a bunch of different data sets, and this is not, you know, exploratory data analysis, this is just like just researching what data sets are available, maybe looking at kind of the raw data just to kind of see like what's in there, what, what it might work, they narrow it down to three data sets. There's a data set of images from the Amazon from space, there's one called the WIDS Datathon 2019, which has got oil palm plantation detection in Borneo, and they've got another data set called Towards Detecting Deforestation, which is a data set for detecting coffee plantations in the Amazon rainforest. \n\nAfter they they look at this, they narrow it down to this Amazon data set, which is looking at the human footprint in the Amazon rainforest, and they decided to go with that data set for training the model. Then they get into the exploratory data analysis and data processing phase, so they they kind of talk a little bit about what they were looking for in this data set, what was available, some of the plots they were making to sort of understand what's there, things like tagging stuff like that, so they really get into how they were approaching the exploratory data analysis, and they do some of that on some of the other data sets too, and they kind of compare notes, and they sort of explain why",
    "my3sAD3aLZw": "Welcome to the Real Python Podcast. This is Episode 65. The popularity of Python is continuing to grow. Developers across the globe are embracing the language. How is Python being used in all of these different countries? And how does an organization like the Python Software Foundation work toward the goals in its mission statement for supporting and growing this international community?\n\nThis week on the show, we have Marlene Mangami, a PSF board member and part of the Diversity and Inclusion workgroup. Marlene lives in Zimbabwe on the continent of Africa. She has been organizing events not only locally in Zimbabwe but across all of Africa. She is the Chair of PyCon Africa and has given talks at PyCon US, PyCon UK, and PyCon India. She has been working locally as an organizer and educator.\n\nWe talk about the challenges of teaching technology and programming to a population of young people, and some of these students don't have access to computers. Marlene is currently pursuing a computer science degree with the University of London. As a student, she's also interning with NVIDIA and working with them on the RAPIDS project.\n\nOn a programming note, we had some initial noise with Marlene's microphone, but we did get it resolved about halfway through the episode. This episode is brought to you by DigitalOcean's App Platform. Alright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey Marlene, welcome to the show. Thank you for having me. I have a whole bunch of interesting topics I wanted to dive into with you. It was really fun running into you virtually at the tables at PyCon.\n\nYeah, it was very cool. I spotted you and a couple of other people like Ricky and Jim, I think from the Real Python team. So it's really cool to see you virtually. It's really kind of a fun setup. Yeah, I'd done something similar at PyCascades, but this was kind of an interesting way. They limited the table sizes and allowed for engaging conversations depending on what you were interested in getting into.\n\nYeah, it was very cool, and I liked the format that you could\u2014I hadn't actually like, I was at podcast kits, but I didn't do any of the interactive things. So this is kind of for me, my first experience of actually talking to people virtually, which is really nice. It's been nice to slowly come out of our shells.\n\nYeah. So the first thing I want to kind of dive into is your relationship with the PSF. You're a PSF board member, but also a vice-chair. Can you tell me a little about what those are and what you do for the PSF?\n\nThe PSF is the Python Software Foundation. It is the non-profit organization that's behind Python. Whether that's protecting Python's trademarks or organizing grants to give to communities, the PSF also runs PyCon US, and we also do a lot of things like discussing different policies on how to better serve the Python community around the world. For me, I've been on the board for almost four years now. I'm going into my fifth year on the board, which has been fun. A lot and yeah, so basically, I am the vice-chair for this year, and for the most part, I just kind of represent just an international voice in terms of trying to help the board with. I'm very interested in diversity issues and trying to make sure that we're serving the underrepresented parts of our community from different parts of the world. So I think a lot of things to do with just access and yeah, just sharing sort of my opinions is pretty much what I do.\n\nThat's cool. I'm intrigued by just the global nature of something like a language and then having an organization that's global also to kind of think about okay, what is happening with the language in different parts of the world and kind of keeping on top of it. It's so easy to be sort of focused, especially with the growth of the tech sector during the 2000s here in the US and so forth and starting to see oh, there's these huge areas of that in other parts of the world. And then with Python being such a language for so many different purposes, being for science or education and just sort of like computer literacy. I can see the importance of that and I wonder about that like how strong is the presence of Python in Africa and maybe Zimbabwe in particular?\n\nRight, yeah. Definitely, I think that Python is like, I think in the Stack Overflow survey, it's been voted several times now, I think since I've been on the board, it's always the most popular language in the world. So in terms of popularity, it's right up there. And I think Zimbabwe is definitely on that list in terms of the popularity of Python. We actually have a Zimbabwean Python community. I call us Python. I think other people also call us Python Easterners, but yeah, I don't think anyone from Zimbabwe goes on for any stress except for maybe like five of us. But like me, I know that we have a good community locally in Zimbabwe using Python. I think initially when I first joined the community and attended my first PyCon Sim, I remember hearing a lot of people mainly using it as a scripting language, but like there has been a growth of different sectors. So I think Django is being used a lot, so there's lots of Django developers locally. And yeah, I think it's really, I think it's really grown, and I would say that the community here is also quite large. It's not as active as in places like Nigeria. I think about Nigeria on the continent of Africa and how much Python is being used there, and it's definitely much bigger. But I definitely think in terms of popularity across the continent of Africa, Python is really popular.\n\nSo when you look at, you mentioned PyZimbabwe, or how was it, okay, yeah, the Python community is about, we don't actually have a name like the local community here. We just have a WhatsApp group at the moment. Okay, we used to have like a Python. Well, we actually do have a Python, but it's not, the Python was canceled. I don't think we had one last year, and I don't think we're gonna have one this year as well. Okay, but we do have a Python that's local in Zimbabwe. Yeah, well, I mean, there's across the continent, and it seemed like over the last three, four years, you've been traveling across Africa and visiting a lot of those other ones. I saw one for, ah, there's a couple different talks, right, of different ones, and Nigeria, one Nigeria, Namibia is, I've also been here quite a bit. I've been to Ghana, the Ghanaian Python community is really strong. I also was the chair of PyCon Africa for the inaugural conference, which was in 2010, which was in 2019, and then the 2021. So that's like the annual gathering of the Pan-African Python community. For all of us across the continent, it's like the one conference we have a year. And so I was really stoked to be able to be the chair of that for the past two years. That's been really, really fun. Is there one, I don't know if you can speak of it yet, uh, is there one plan for 2021? There is not one time for 2021, and I don't know if, I think we should be announcing that soon, so hopefully, I'm sure this will go out before, um, like after we've announced announced it, but I don't think we aren't going to have a Python this year for Python Africa. I think, just because it, one, I think we are really trying to figure out how to connect more with local Python communities in really tangible ways. So we're trying to create sort of an organizing body, I think that will be able to help, you know, connect with local communities and also serve those communities as well. And yeah, and I think we have decided that we want to focus on that this year. I'm not the chair this year as well. Yeah, I think last year when we ran it online, when we ran PyCon Africa online, it was a lot of work, and it was really difficult, to be honest. It was very difficult because Africa, I think, has a lot more challenges when we talk in terms of connectivity, sure. I think not everyone is able to stream a conference because that takes your internet has to be good, you have to have like, you know, either like Wi-Fi, proper Wi-Fi, or you have to have lots of data, and that's something that's a challenge to some communities. And so, it was quite difficult, I would say. Yeah, yeah, I can imagine that kind of leads me into a question I have that built on top of the idea that you're, you know, sort of changing your focus a little bit about engagement within, you know, more localized communities, and I feel like maybe that's how you started. You had gone to university, right, and then when you kind of came back to Africa, you kind of got a little more involved in Python. Maybe we could talk a little bit about that, and then, yeah, that translates into, um, what you're doing now.\n\nYeah, sure. I was in the past, you know, I don't know how many years ago now, I went to the States, and I was in Pennsylvania and Indiana as well for a bit, and I was studying molecular biology. Initially, I thought that I wanted to be a doctor, and then lots of things that happened that just changed my mind. I discovered I don't like blood. [laughs] Me too. Yeah, it's not the nicest thing to be seeing on a regular basis, and yeah, I also am not a big fan of cadavers and things like that as well, and so I came back. I remember there was a summer where I came back home to Zimbabwe, and I was really kind of thinking about what do I actually want to do with my life? What do I want to actually do? What do I enjoy doing as well? And so there were lots of different things that I just decided I wanted to explore, and so I kind of gave myself a year to just focus on trying things out. I remember I started just like, we through, oh, it was kind of a very long story, but I started a non-profit organization called ZimboPi. The purpose of that organization was to teach girls how to code in Python, and the goal of that was I wanted to do something that I felt was connected to my local community that I thought was serving my local community and kind of just, you know, giving young girls who, you know, I felt didn't have access the same access that I saw in the United States. Like, when I went to the States, I saw that, okay, wow, you know, there's so much access to education, there's so much access to knowledge, and I met so many people who are creating things, and I felt that when I was back home in Zimbabwe, that that same access was not available to Zimbabwean girls. I mean, it's also boys as well, but like I was thinking about myself and thinking like a couple of years back, you know, would I ever have known that I could code in at all? Like, did I, would I have access to that knowledge to know that I could actually do something like computer programming? And I thought that that was missing in my local community, and so, kind of focused on that, and yeah, and created this really cool non-profit with some friends of mine. So I wonder about the types of things that you would teach someone who you know, they're completely new to the idea of really even computing, and I think you mentioned this in your Real Python interview, how you know, any kind of computer classes that you had before were more focused on like general applications. Like, this is Word, this is Excel, this is a computer, yeah, it has storage, it has a peripheral, it connects to the internet, you know, like the generic, you know, like computer literacy more than like anything to do with it. So I can imagine if maybe that's the baseline that you're working with, jumping into, okay, let's create something with a programming language, right? So what are the types of things that you would teach them?\n\nYeah, so I think, you know, we got to a point where we were, you know, we were connecting with girls from sort of the high density areas in Harare, and so a lot of these girls, when they came in, they had like literally never been able to touch a computer before. And so, like everyone has phones, so they were like taking selfies with the computer, which was really kind of this weird moment for me to see. But, you know, they, oh, so a lot of it was just starting at that baseline of that same thing that I was talking about in the interview, of like teaching them this is what a computer is. You know, this is, these are sort of the basic things to get started with the computer. And then also from there, then just building those basic building blocks of then going into programming. Something that we really did to kind of introduce some basic programming concepts was to introduce hardware, okay? So we did use Raspberry Pis and things like that just to make it, I think, more engaging when we were sort of teaching and things like that.\n\nThat's something that we used as well, but mainly it was, it was really starting from the basics of, yeah, just introducing them to the world of computers. I think of the Django Girls project as a tool that a lot of communities all over the world have used as a platform of tutorials, but also as a way to kind of get kids interested because at that point they've created something that then is up on the web. You know, again, that's another limitation potentially depending on where you're geographically and the situation as far as you mentioned the disparity of potentially having internet or not having it and so forth. But if everybody has a phone, then they could kind of share their work online is something I think would be kind of exciting too. Is that something you explored also?\n\nYes, so we definitely, like the first things that we were, when we were initially introducing them to Python was the Django Girls curriculum, which is great because it's free online and it's super accessible. And I think it's presented in a format that's really easy to follow. And so, yes, we did do a lot of work with the Django Girls curriculum and just following that. And I thought that was, the girls were able to make their own websites and things like that. And I think that was something that was also very exciting. So, yeah, definitely Django Girls is fantastic.\n\nCool. The types of phones and stuff they have are completely like, they can get to the web and check out other sites and do that sort of stuff, right? It's, we definitely had, so at first we, we, so there were definitely, there were two groups of girls that we were, we, so there's one group of girls that could, you know, had Android phones. That are like coming from, you know, middle class, upper class, Zimbabwe, where they have smartphones, they do go home and they, they can, they do have internet, okay? So at home, they could, you know, play around and also upload their websites and do whatever they wanted. And just, you know, that was fantastic. But we definitely had, also another group of girls that we were working with that was in another part of the city as well. That's the, that's the group I was talking about that didn't have as much access. And they, you know, they did have like phones that had a camera and things like that, but I wouldn't say they had like a lot of access to the internet in terms of like, even when we would, we would host a club, an after school club where these girls would come. We would work with one, we worked with one of the local community centers and they would come to this community hall and we would have, like, we got some amazing donations of laptops from GitHub and from different people who just wanted to help with the program. And so the girls would come there and work on the Django Girls curriculum, work on different things at this community center. But oftentimes they would go home and, you know, they don't have internet at their houses. They don't have like, yeah, I don't think they're using data on their phones to like explore coding. I just don't think that, like,",
    "_FTO0DEayaw": "Welcome to the Real Python Podcast. This is episode 66. Are you ready to practice your Python skills some more? There's a new set of practice problems prepared for you to tackle, and this time they're based on working with CSV files. This week on the show, David Amos is back and he's brought another batch of PyCoders Weekly articles and projects. David shares an article about functional programming, with a focus on the filter function. The tutorial covers how to process an iterable and extract the items that satisfy a given condition, but also covers combining filter with other functional tools and compares it to coding with Pythonic tools like list comprehensions and generator expressions. We cover several other articles and projects from the Python community, including Excel Python and the future of data science, a Bayesian analysis of LEGO prices in Python, why comments can't appear after a line continuation character, teaching Python on the Raspberry Pi 400 at the public library, a cross-platform editor designed for writing novels built with Python and Qt, and a text user interface which uses rich as the renderer. This episode is brought to you by DigitalOcean's App Platform. Alright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com. Hey David, hey Chris. Good to have you back on the show and covering much more PyCoders Weekly stuff. Yeah, absolutely. This week, I've got a couple of Real Python things and then kind of a whole bunch of interesting stuff that's leaning towards the project area, which I'm excited about. Yeah, again, stuff we kind of keep hitting things that we've talked about before, and kind of excited about that too to kind of follow up on some topics we've touched on. So, my first one comes from the website InfoWorld. It's by Matt Assay, I think that's how you say today's last name. It's called \"Excel Python and the Future of Data Science.\" I've got to put a disclaimer out there that if you go look at this article, there are a lot of ads and pop-ups, so just be aware of that. I think they only give you like one free article a month, and then you hit a paywall. But it was a really thought-provoking article, so if you can get through all that, I do think it's worth it. The article is about Python versus Excel and what the future of data science and Python might look like. Data science in general and it starts with kind of an interesting tidbit of information that seems surprising. If someone were to ask you, Chris, what do you think the most widely used tool in data science is, what would you say off the top of your head? Well, I think we might have touched on this before, but I think it probably is still Excel. Yeah, it's also like one of the largest databases, which is crazy. It's definitely like one of the largest databases. I think though, you know, when people hear the word data science, they think like a data scientist, right? Like someone who's actually doing data science. Sure, and they're probably like their interaction with Excel is probably at this point, I mean, I don't know this for a fact, but I would venture a guess that their interaction with Excel is something like they've been sent a spreadsheet of data and they need to extract that and get it into something else. They might be using Python, they might be using R, they might be using something else. This is like a practicing data scientist, right? Sure, but Excel is being used to analyze data and gain insights from data from people who are not data scientists. In a sense, it's enabling non-technical people to do some data science-like activities. Small business owners and even large business owners that don't have a technical background, it's very easy or very maybe easing is not the right word, but it's very... I don't know, in some ways it's really available. Like it's the tool that's installed on everybody's machine. I have friends that work for a department of health, right? And that's already there, and so that's the tool that's in front of them and they make it work. You know, which is kind of amazing in some ways that... Yeah, that they can kind of twist it to do all the things that they want to do. It may not be the simplest way to do it, you know. But there's a lot of... You know, it's kind of a point and clicky kind of interface for a lot of this stuff. You can highlight a couple of columns in a worksheet and quickly generate some kind of graph or visualization or look at your data in a different way and start asking and potentially answering questions. So in that sense, you know, you can't say Excel is probably the most used tool in data science. And this article talks with kind of interviews Peter Wang from who's the CEO of Anaconda of Anaconda Python and he talks about his vision for the future of Python and the PyData ecosystem. It's not about like Python versus R or, you know, some other language like that. In his mind, it's really about taking on Excel and how can we take the power and the tools and the open source structure of the Python data ecosystem and put it in the hands of non-technical people. So, anyways, it's just a really kind of fascinating look, I thought, and kind of thought-provoking about where all this is headed and what, I guess, specifically Peter's vision for it is. I know he's not the only one that has this vision, so it is, I think, worth a read. It's not a technical article, it's not a tutorial or anything, but really was just kind of like... Yeah, I mean, it's time for Python to kind of tackle this if we want to get those tools in people's hands. You know, this is kind of the direction we need to be heading. Otherwise, it's just going to stay, even though it's, you know, it's immensely popular, the Python data ecosystem, it's going to stay only in the hands of kind of the trained data scientists and those people. We keep talking about how people inside of organizations start to develop these superpowers that other people notice them using something like Python. Yeah, like think that they have these magical skills now. Part of that is just getting that hurdle, you know, your Python basics book, like, you know, getting things set up and right going and doing your initial programs and so forth and flattening that curve is a goal of Real Python in general. Yeah, how can we get people in and using these tools and make things more approachable? And that's one big advantage of, you know, like the talk about Anaconda, the distribution of like a whole sort of ecosystem as opposed to it piecemeal. There's definitely different approaches on all that. So, yeah, yeah, cool. What do you got? So, mine is a Real Python article and it is kind of on a theme. You might remember we had Jim Anderson on in episode 27 and he was talking about preparing for an interview with Python practice problems. And he discussed the process of creating this whole thing and looking at multiple solutions. I think the main idea was we want to give you these problems and then have you think about them. So there's a whole sort of show/hide portions of the article where you can kind of decide if you want to see the answer or if you really want to go ahead and work through it before you can do your comparison with it. And this follows that structurally. In this case, he's the focus is on CSV files. And so it's Python practice problems parsing CSV files. One thing that I got a little tripped up on is I was looking for the quote-unquote CSV files, but in this case, it's focused a little differently. In the sense that you're starting with the concept of test-driven development. And if you're not familiar with that, this kind of takes you through some of it. It also provides a bunch of links to additional articles like we, I think we mentioned Dane Hillard had a really good one recently about test-driven development and using PyTest, which is kind of the tool that's being used here. And so instead of, you know, like full-on CSV files, you're sort of mocking a lot of that up with something called a PyTest fixture. And the fixtures, we might have mentioned that term also, this idea of like pre-organized data that you're going to use. And then you can kind of predict and already know the results of, you know, so that your tests can pass. So it's a very different approach on the practice problem theme, you know. Not only are you getting to work with how can I easily parse CSV files using tools that are built into Python, but then there's like four sort of scenarios that you're going to get a chance to kind of practice. That's funny because we're building off of an Excel article, right? Yeah, you can export your Excel stuff into CSV and be right along here. So, yeah, the first problem that's described is parsing football scores. This would be the world definition of football, of soccer, versus the American-centric one. And you're writing a program that's going to take the file name on a command line and then process the contents of the CSV. The program's going to determine which team had the smallest goal differential. So, like between goals that team scored versus that were scored upon it. And so those two numbers are like subtracted and they're taking kind of the overall value to see, you know, which team had the smallest one so that they were closest together, those own goals versus goals against them. So it's kind of interesting just kind of the math there isn't super complex, but you are still going to need to go through and kind of parse things line by line. And so I'm not going to spoil it because you should work through these problems. And then in there, you're getting the problem solution that the Real Python team went through. And next one is about weather data. Really popular at this moment because everything's just crazy heat wave. The two of us are still kind of on the western part of the US and we're sweltering away here. That one is about taking the average days high and low temperature and comparing them. Your program should determine which day had the highest average temperature. So that one, you're kind of working with just a slightly different set of data and kind of going through it. Then you do a refactoring, figuring out how to make all these things a little more efficient by maybe reusing a lot of the CSV parsing that you were doing, which is a, you know, structurally something you should eventually kind of think about. You might come up with a simple solution initially, but now you're going to kind of come back and then think about, okay, well, you know, how could I, I have a solution that can reuse parts across multiple other things. And then the last one is instead of using some of the built-in Python CSV tools, you're going to do CSV parsing with pandas. We've had actually a bunch of really interesting courses come out based around pandas lately. And so I'll provide links to those if you're looking for some additional skills to work on. And one was the gradebook project recently came out. And that one has a lot of really kind of fun tools that you're learning to practice and use there. Yeah. So yeah, it's another version of what we were talking about before, of let's practice your Python. And here we're giving you a bunch of things to for you to get a chance and then you can kind of reveal these solutions as you go along and check how you did. Exactly. It's a really neat format. I think it's not a tutorial. I mean, I guess you could kind of consider the solutions. Yeah, in some sense because he does Jim does explain the solutions, which is kind of funny that it's a rare thing on Real Python where the bulk of the text in this article is hidden. When you first, it looks small. First look at it, it looks small. And then you open the like the solution box and you know, it's got a full explanation in it and walks you through everything. And some of them have multiple solutions for you to look at. But yeah, it's a really, it's a really neat format and I think that you hear people talk about this idea of, you know, getting stuck in tutorials and I think that it's there's a need in general for the different kinds of content, you know, that it's, yeah. And, you know, that goes beyond the tutorial to like, okay, this is giving you a chance to, you know, here's a problem, you can practice it and then you can compare notes with one or two solutions that we've come up with that are fully explained. You're actually getting to do something yourself. So, it's, yeah, it's a really neat format. I really like it. I think Jim does a great job with these. Like he said, it's the second one he's done at this point. I think I hope that we'll have more coming down the pipeline. Yeah. It's funny. I have a question for you. Do you, when you approach a tutorial or like, maybe a book that's filled with these types of projects that they're kind of walking you through step by step, do you ever try to go off in advance and try to do the thing before you read the explanation? You ever attempt that on your own? Like if I'm actually reading a tutorial, yeah, you're like, oh, I see what they're going to try to do here. Let me, let me try to hack it out myself. You know, actually, I don't think I've ever really, really done that. Usually, if I'm following a tutorial, I'm just going through it kind of step by step and following along. And, and, and, and, and, and, and following along. And, and, and, and, and, and, and, and following along. And, and, and, and, and, and following along. And, and, and, and, and, and following along. And, and, and, and, and, and following along. And, and, and, and, and, and following along. And, and, and, and, and, and following along. And, and, and, and, and, and following along. And, and, and, and, and, and following along. And, and, and, and, and, and following along. And, and, and, and, and, and, and, and following along. And, and, and, and, and, and following along. And, and, and, and, and, and following along. And, and, and, and, and, and following along. And, and, and, and, and, and following along. And, and, and, and, and, and following along. And, and, and, and, and, and following along. And, and",
    "5CYApSEVkFU": "Welcome to the Real Python Podcast. This is Episode 68. Are you ready to expand your Python knowledge into the intermediate to advanced territory? What tools are awaiting your discovery inside Python's Funk Tools module?\n\nThis week on the show, David Amos is back and he's brought another batch of PyCoders Weekly articles and projects. We discuss an article about the Funk Tools module, which adds functionality for caching, function overloading, better definitions for decorated functions, and much more.\n\nDavid talks about a new Real Python article about working with complex numbers in Python. We also cover a tutorial about troubleshooting memory problems in Python. We cover several other articles and projects from the Python community, including DevOps interview questions, correlation analysis in Python, pivot and plot data with Pandas, how to use Python and OpenCV to play online chess with a real chess board, and generating hardware pinout diagrams as SVG images.\n\nThis episode is brought to you by Sentry, helping developers see issues that matter, solve those issues in minutes, and learn insights to keep their applications running at peak performance.\n\nAlright, let's get started.\n\n[Music]\n\nThe Real Python podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey, David. Welcome back to the show.\n\nHey, Chris. Good to be back.\n\nAlright, I want to start off today talking about a topic that's bubbled up multiple times on the show already, and it's an article that was written by Sebastian Ramirez, kind of covering all of the things that happened with FastAPI and Pydantic in the release of Python 3.10. It's titled \"The Future of FastAPI and Pydantic is Bright.\" It's a really kind of nice post-mortem to the whole scenario, and it's an article that really has a focus on typing and what this move in some ways of, okay, well, lots of frameworks really want to use static typing and type checking and tools like that to be able to kind of help with coding. And that's really the big advantage of FastAPI is it can really help you plan for things like that as you're coding. It also talks about just how popular FastAPI has gotten, and how that might bump up against, like, potential what you might have thought, or maybe these are slight, small changes in the language, and then suddenly everything breaks. So, um, but the communications are open, and, uh, as they say, the future is bright, which is cool. So, I think it's something that we don't need to dive too deep into, but I wanted to just mention it as a follow-up and include the link for everybody if you want to check it out. Yeah, it's a good read, and I think Sebastian did a good job really laying out what the issue was, like, what was going on, and, yeah, then also, like, why the future is bright. Like, it's, uh, yeah, I was just really impressed. I mean, I know there were some things with the communication could have been done better or done earlier, but ultimately, I feel like it was a huge win for just the Python developers and the community. Yeah, end of coming together to solve a problem.\n\nSo, what's your first topic?\n\nThe first one I've got comes from Bartosz Zacchinski, and it's called \"Simplify Complex Numbers with Python.\" Bartosz is one of the staff writers here at Real Python. I know we've featured some of his articles in the past, but it's nice to see another one of his come down the pipeline. This one is really neat. It's about Python's support for complex numbers, which, if you've taken an algebra class, you probably learned about, like, the number \"i,\" which is the square root of negative one, if you believe in such things. I know there's a debate on that in mathematics, but the symbol \"i,\" yeah, it's the number when you square it, you get negative one. So Python has built-in support for complex numbers, which is a little bit unusual. There's not like I wouldn't say it's a common feature in languages to have it, like, literally just like you can create a complex number literal without having to import anything. It's just built into the syntax. It talks about how you do that, and interestingly, or maybe not interestingly if you come from an engineering background, but Python instead of using \"i\" to represent the complex unit, they use \"j,\" which there's some good reasons for that and that's explained in the article why they chose to do that. The article covers all the basics, doing arithmetic with complex numbers, creating them, there's a couple of different ways that you can create them, and there's a really fun section on using complex numbers as two-dimensional vectors. So this kind of goes back to kind of the understanding of complex numbers as really a pair of real numbers with a real part and an imaginary part, and you can kind of view them as two-dimensional vectors. The complex plane, as it's called, is a two-dimensional plane, and there's this really neat use case that Bartosz lays out in the article with an example of using complex numbers to represent the cities on a map. So he uses the coordinates for cities to create a vector for Miami, one for San Juan, and one for Hamilton, which he doesn't say where those, oh, Hamilton, I guess, is a tiny island in Bermuda. Okay, yeah, I don't know whether or not I see that. San Juan is in Puerto Rico, Miami is right in Florida. Yeah, so he walks you through doing things like calculating the magnitude of these vectors, which using complex numbers is really easy because there's this absolute value function which will just give you the magnitude of that vector. So you get a lot of things for free when you do this. It's very straightforward to find the distance between two points, things like that. And then you can do all sorts of fun stuff like translating, flipping, scaling, and rotating, and you get all this stuff basically for free because of Python's built-in support. I thought that was a really fun little example of how you could use complex numbers. You're kind of abusing them in a sense, but you get a lot of this stuff for free, which is really neat. Then he goes into talking about the C math module, which is analogous to the math module in Python, but it's specific for complex numbers. So you have things in there like the complex versions of pi and tau and the NAN, not a number value, and infinity, and you've also got functions for taking square roots and all that. But they all will accept complex number values as arguments, which the math module will not. So it gets into all that and into all sorts of stuff about testing equality, how things are ordered for complex numbers because the order is not as maybe as straightforward as it is for like a real number, formatting complex numbers as strings. It's a really in-depth article, and I think it clocks in at around 10,000 words or so, maybe a little bit more intense, but it really covers a lot of stuff. At the end of the article, there's a nice example of like an application of these where you calculate the discrete Fourier transform with complex numbers. The example that he gives is not necessarily like the most efficient way to do it, but you would probably want to use something like SciPy or some other library if the efficiency is really important. But it gives you a really kind of nice look at how you can apply these, the complex number support in Python to something, and the code is really nice. I mean, the support for complex numbers makes doing something like this pretty nice. Anyways, it's a great article. I think, you know, if you're in the engineering space, if you're in the scientific computing space, if you're in maybe the graphics space and gaming space, you know, this kind of stuff, you'll get a lot of value from reading this article. And if you're just curious about like, if you didn't know that Python had support for complex numbers, just reading the first couple of sections, I think would really benefit you, just so you're aware of like, oh, that's, you know, that's how you create them, how you kind of do the arithmetic and things like that. And like I said, the section on using Python complex numbers as 2D vectors is just really, really fun. I recommend anyone interested give that a read. Nice, yeah. Yeah, it sounds like a really nice deep dive into all of that. I'm intrigued by the use of maybe gaming and some other kinds of things. Right, yeah. Exactly. My first one is covering a topic that is a little more leaning toward the intermediate to advanced area of Python. I always like to share some of these things to kind of stretch that boundary and keep pushing into it. And then if you're like myself in that intermediate and moving toward more advanced topics, this is a really nice article that kind of gives you an introduction to a lot of it. And then I'm going to supplement it with some additional resources for you. But it's titled Funk Tools: The Power of Higher Order Functions in Python. It's by Martin Hines, and it's another Towards Data Science article. When I started to learn about this one, the main one that I learned in the package of Funk Tools was the one for decorators, because I was doing my first course on decorators. And the Funk Tools wraps and the other kind of language that's inside there, which is super powerful for using with decorators. But the idea is as you create a decorator and you're basically passing a function into this other function, your original function's name, which you sat there and defined and potentially created a string for and a wrapper for to basically explain a description of it. If you don't do anything about that when it gets wrapped inside that other function, it unfortunately gets the rapper's name and so like you get sort of like a non-descriptive representation and string and so forth. And so there's this nice additional decorator you can add, Funk Tools wraps that when you do that, it basically passes through all that and then what I learned doing a little more research and going into the actual Funk Tools Python 3 documentation is that it actually is using all these additional tools in it to do that and then look at their names again. It's a whole set called update underscore wrapper and it does this whole thing partial update wrapper. It has all these other parameters of wrapped equals wrapped and assigned equals assigned and updated updated. So it kind of does all this little bit of work for you without you having to do all that background kind of stuff and learn a lot about it. You can simply apply it. Yeah. It goes further. There are a lot of other areas. There's caching, which I think is really powerful. And again, kind of a performance thing. Yeah. And it's actually been updated quite a bit. And in Python 3.9, there's a new version that's just called caching. The previous one was the LRU cache, which is a little confusing of a name. LRU means last recently used. And the idea there isn't to keep the last recently used around. It's actually to toss those ones out. The idea is like, if you are maybe it's like a website and you have a bunch of blog posts and you want to keep the ones that are really popular, you know, around that these ones have been used a lot recently and I've been looked at a lot recently and these other ones have not been paid attention to. And you can think of this again in your own programs like as far as like values and, you know, dictionaries and things like that that these are the things that are being used, I should keep these cached and and ready to go in the background. The ones that are least recently touched or used, we can go ahead and we can toss them out. So right. We have a great article on that and I'll include a link for that. A whole separate Real Python thing on LRU cache. And then there's, you know, other stuff like, uh, cache property and reduce, which is a very powerful thing where you can apply a function to an iterator and it's, you know, I want to go into depth in each one of these. But probably the other one that I think is kind of fun because we've been talking a lot about these dunder methods of like double underscore eq, which is, you know, like defining inside of or overriding inside of a class like, what does equal mean for this thing? And it's called total ordering. And what that will do, if you define what the comparison will be for something to be equal and at least one of these others like a less than or a greater than or less than equals or greater than equals, if you define equal plus one of those, it will go in and define all the rest, which is pretty slick. Yeah. So it will create all that other information and ordering of operators and comparisons and so forth. So it's a really powerful module, lots of stuff kind of hiding inside there for the intermediate developer to learn more about. Yeah. There's a lot of nice stuff in Funk Tools, and I feel like it's one of those ones that when you first come across it too early in your Python journey, you're kind of like, hey, what is all this stuff? Like, I don't know. But when you reach a certain point, you start digging in, and it's like, oh, this is going to make my life so much easier. And yeah, the caching stuff is really, really great. There's a, you can also do, like, function overloading. Yeah, there's a single dispatch decorator that you can add to functions that will allow you to basically write multiple functions with the same name that take a different type of argument and you can, you know, not have all that code for like if it's, you know, if the argument was of this type, then do this thing. And if it was of this type, then this other thing. Partial is another one that I've used quite a bit in the past. That one's really fun. And I think that we have, I think Real Python has articles on a lot of different things that are mentioned. Quite a few of them. Yeah, I'll try to try to gather as many as I can. Yeah, definitely to kind of give you highlights with some additional stuff. But yeah, this is like you said, it's a nice just tour of what's in there and what's in Funk Tools and some little examples of how you can use it. So if you're looking for learning a little more, here's an area they can kind of keep expanding your Python growth.\n\nThis episode is brought to you by Century, helping developers see issues that matter, solve those issues in minutes, and learn insights to keep their applications running at peak performance. What can you expect from Century? You get actionable insights in full context so you can fix your app's errors and optimize its performance. You get performance monitoring, engineering managers and developers now have a single tool to trace Python performance issues back to poor performing API calls, as well as surface all related code errors. And with Century's error monitoring, you can understand the important events that led to each Python exception, be it SQL queries, debug logs, network requests, or past errors. Spend less time fixing bugs and more time building features. You can learn more at century.io/for/python or you can click the link in the show notes.\n\nWhat do you got next?\n\nNext one I've got is called \"How to Pivot and Plot Data with Pandas.\" And this comes from Stephanie Mullen, who is a data scientist at Bloomberg and author of \"Hands-On Data Analysis with Pandas.\" And this is a really nice article. It's not too long, so it's a nice, kind of quick read. But it gives you an example of using real-world data using 2019 flight statistics from the U.S. Department of Transportation's Bureau of Transportation Statistics. She's got a link to the data set to analyze the top 10 most popular flight destinations in the U.S. And it's got, she mentions, it's got 321,409 rows and 41 columns. And she kind of goes through, like, how you read the CSV file and just kind of, you know, taking a look at, like, what are all the column names and kind of getting a feel for what's in there. And then kind of working your way through by changing the shape and everything and doing what's called a pivot on the data frame, on the table, to reshape things, get rid of columns that you don't need, and wind up with a nicely formatted little data set of the top 10 destinations. Then from there, it gets into plotting and making a horizontally stacked bar chart with, like, passenger totals that are colored. Each bar chart is, like, the total number of passengers that travel to a certain destination. And then within the bar, it's, like, color coded by carrier. So, like, blue is American Airlines, orange is Delta Airlines, and so on. And, yeah, the code is, like, top notch. If you're looking for",
    "eT_AQOwgdfQ": "Welcome to the Real Python Podcast. This is episode 69. Do you wonder what the future may hold for the Python language? Are there speed improvements coming soon? What if you could be in the room while the core developers discuss Python's future? This week on the show, we have Joanna Jablonski, who was invited to the Python Language Summit 2021 as a journalist to summarize and document the event. A small group of core developers from the Python community gather to work toward a healthy future for the language. Through presentations and group discussions, they share insights, ideas, and potential problems.\n\nJoanna has been the executive editor at Real Python, and she was invited to write a series of blog posts for the Python Software Foundation. We walk through the two days and discuss the topics covered. Several presentations focused on performance and speeding up CPython, along with conversations about packaging, documentation, the standard library, handling exceptions, testing, and much more.\n\nThis episode is brought to you by Sentry, helping developers see issues that matter, solve those issues in minutes, and learn insights to keep their applications running at peak performance. Alright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at RealPython.com. After the podcast, join us and learn real-world Python skills with a community of experts at RealPython.com.\n\nHey Joanna, welcome back to the show.\n\nHi Chris, thank you. Alright, so you had a really kind of a fun experience in the last couple months here of attending the Python Language Summit for 2021. Can you tell me a little bit about not only your attendance of it but the series of articles you've written about it?\n\nSure thing. I should probably start by explaining what the Python Language Summit is. It's a two-day event that happens every year in the lead-up to PyCon US. Normally, it would just be wrapped into all the events around the conference, but this year, since everything was remote again, we had it over video conference. But one perk of that was that more people were able to attend than would otherwise possibly be limited by time zones or travel, or you know, all that kind of thing. The general idea is that it's supposed to get a whole bunch of core developers from different Python implementations together, and they give presentations to each other and have discussions and generally bounce ideas around in order to help Python flourish as a language but also help the Python community flourish.\n\nIt's a closed event generally. Anyone could go, but for the Language Summit, you actually had to apply. It would be fascinating to just come and spectate. I would imagine tons of people would want to just come and sit in on this and be a fly on the wall. But the general idea is that they don't really like if you're coming, you kind of should be presenting. It might be a little bit fuzzy, but it's not just a fully open thing, which means that plenty of people probably have FOMO if they didn't get to go to the Language Summit. We want to keep Python as open source, like openness is kind of a theme, and so it's really useful just to make sure that the rest of the community still has access to what happened at this event.\n\nEvery year, the Python Software Foundation gets a journalist to attend the event and write up blog posts about all of the talks that were given and then post them on the PSF blog. If you want to check out what happened at the summit, go to the PSF blog. I posted all of the articles between May and June. Yeah, they're all there. Dig into them and just keep the conversations going because they're talking about PEPs, they're talking about ideas, they're talking about community initiatives. They're talking about all kinds of cool stuff.\n\nAnd like we want people to get involved and be leaders in the Python community. And you know, I love the Python community clearly. And this is part of what I think Python is doing fantastically well. Alright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at RealPython.com. After the podcast, join us and learn real-world Python skills with a community of experts at RealPython.com.\n\nHey Joanna, welcome back to the show.\n\nHi Chris, thank you. Alright, so you had a really kind of a fun experience in the last couple months here of attending the Python Language Summit for 2021. Can you tell me a little bit about not only your attendance of it but the series of articles you've written about it?\n\nSure thing. I should probably start by explaining what the Python Language Summit is. It's a two-day event that happens every year in the lead-up to PyCon US. Normally, it would just be wrapped into all the events around the conference, but this year, since everything was remote again, we had it over video conference. But one perk of that was that more people were able to attend than would otherwise possibly be limited by time zones or travel, or you know, all that kind of thing. The general idea is that it's supposed to get a whole bunch of core developers from different Python implementations together, and they give presentations to each other and have discussions and generally bounce ideas around in order to help Python flourish as a language but also help the Python community flourish.\n\nIt's a closed event generally. Anyone could go, but for the Language Summit, you actually had to apply. It would be fascinating to just come and spectate. I would imagine tons of people would want to just come and sit in on this and be a fly on the wall. But the general idea is that they don't really like if you're coming, you kind of should be presenting. It might be a little bit fuzzy, but it's not just a fully open thing, which means that plenty of people probably have FOMO if they didn't get to go to the Language Summit. We want to keep Python as open source, like openness is kind of a theme, and so it's really useful just to make sure that the rest of the community still has access to what happened at this event.\n\nEvery year, the Python Software Foundation gets a journalist to attend the event and write up blog posts about all of the talks that were given and then post them on the PSF blog. If you want to check out what happened at the summit, go to the PSF blog. I posted all of the articles between May and June. Yeah, they're all there. Dig into them and just keep the conversations going because they're talking about PEPs, they're talking about ideas, they're talking about community initiatives. They're talking about all kinds of cool stuff.\n\nAnd like we want people to get involved and be leaders in the Python community. And you know, I love the Python community clearly. And this is part of what I think Python is doing fantastically well. Alright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at RealPython.com. After the podcast, join us and learn real-world Python skills with a community of experts at RealPython.com.\n\nHey Joanna, welcome back to the show.\n\nHi Chris, thank you. Alright, so you had a really kind of a fun experience in the last couple months here of attending the Python Language Summit for 2021. Can you tell me a little bit about not only your attendance of it but the series of articles you've written about it?\n\nSure thing. I should probably start by explaining what the Python Language Summit is. It's a two-day event that happens every year in the lead-up to PyCon US. Normally, it would just be wrapped into all the events around the conference, but this year, since everything was remote again, we had it over video conference. But one perk of that was that more people were able to attend than would otherwise possibly be limited by time zones or travel, or you know, all that kind of thing. The general idea is that it's supposed to get a whole bunch of core developers from different Python implementations together, and they give presentations to each other and have discussions and generally bounce ideas around in order to help Python flourish as a language but also help the Python community flourish.\n\nIt's a closed event generally. Anyone could go, but for the Language Summit, you actually had to apply. It would be fascinating to just come and spectate. I would imagine tons of people would want to just come and sit in on this and be a fly on the wall. But the general idea is that they don't really like if you're coming, you kind of should be presenting. It might be a little bit fuzzy, but it's not just a fully open thing, which means that plenty of people probably have FOMO if they didn't get to go to the Language Summit. We want to keep Python as open source, like openness is kind of a theme, and so it's really useful just to make sure that the rest of the community still has access to what happened at this event.\n\nEvery year, the Python Software Foundation gets a journalist to attend the event and write up blog posts about all of the talks that were given and then post them on the PSF blog. If you want to check out what happened at the summit, go to the PSF blog. I posted all of the articles between May and June. Yeah, they're all there. Dig into them and just keep the conversations going because they're talking about PEPs, they're talking about ideas, they're talking about community initiatives. They're talking about all kinds of cool stuff.\n\nAnd like we want people to get involved and be leaders in the Python community. And you know, I love the Python community clearly. And this is part of what I think Python is doing fantastically well. Alright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at RealPython.com. After the podcast, join us and learn real-world Python skills with a community of experts at RealPython.com.\n\nHey Joanna, welcome back to the show.\n\nHi Chris, thank you. Alright, so you had a really kind of a fun experience in the last couple months here of attending the Python Language Summit for 2021. Can you tell me a little bit about not only your attendance of it but the series of articles you've written about it?\n\nSure thing. I should probably start by explaining what the Python Language Summit is. It's a two-day event that happens every year in the lead-up to PyCon US. Normally, it would just be wrapped into all the events around the conference, but this year, since everything was remote again, we had it over video conference. But one perk of that was that more people were able to attend than would otherwise possibly be limited by time zones or travel, or you know, all that kind of thing. The general idea is that it's supposed to get a whole bunch of core developers from different Python implementations together, and they give presentations to each other and have discussions and generally bounce ideas around in order to help Python flourish as a language but also help the Python community flourish.\n\nIt's a closed event generally. Anyone could go, but for the Language Summit, you actually had to apply. It would be fascinating to just come and spectate. I would imagine tons of people would want to just come and sit in on this and be a fly on the wall. But the general idea is that they don't really like if you're coming, you kind of should be presenting. It might be a little bit fuzzy, but it's not just a fully open thing, which means that plenty of people probably have FOMO if they didn't get to go to the Language Summit. We want to keep Python as open source, like openness is kind of a theme, and so it's really useful just to make sure that the rest of the community still has access to what happened at this event.\n\nEvery year, the Python Software Foundation gets a journalist to attend the event and write up blog posts about all of the talks that were given and then post them on the PSF blog. If you want to check out what happened at the summit, go to the PSF blog. I posted all of the articles between May and June. Yeah, they're all there. Dig into them and just keep the conversations going because they're talking about PEPs, they're talking about ideas, they're talking about community initiatives. They're talking about all kinds of cool stuff.\n\nAnd like we want people to get involved and be leaders in the Python community. And you know, I love the Python community clearly. And this is part of what I think Python is doing fantastically well. Alright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at RealPython.com. After the podcast, join us and learn real-world Python skills with a community of experts at RealPython.com.\n\nHey Joanna, welcome back to the show.\n\nHi Chris, thank you. Alright, so you had a really kind of a fun experience in the last couple months here of attending the Python Language Summit for 2021. Can you tell me a little bit about not only your attendance of it but the series of articles you've written about it?\n\nSure thing. I should probably start by explaining what the Python Language Summit is. It's a two-day event that happens every year in the lead-up to PyCon US. Normally, it would just be wrapped into all the events around the conference, but this year, since everything was remote again, we had it over video conference. But one perk of that was that more people were able to attend than would otherwise possibly be limited by time zones or travel, or you know, all that kind of thing. The general idea is that it's supposed to get a whole bunch of core developers from different Python implementations together, and they give presentations to each other and have discussions and generally bounce ideas around in order to help Python flourish as a language but also help the Python community flourish.\n\nIt's a closed event generally. Anyone could go, but for the Language Summit, you actually had to apply. It would be fascinating to just",
    "7W4kBJWKijQ": "Welcome to the Real Python Podcast. This is episode 70. How is Python being used today and what can you do with the language? Do you want to develop software, dive into data science and math, automate parts of your job and digital life, or work with electronics? This week on the show, David Amos is back and he's brought another batch of PyCoder's Weekly articles and projects. We talk about a Real Python article that covers the incredible variety of ways that you can use Python. David shares an article about the Pythonic way to count objects using the Counter class from the collections module. We discussed the ways it can lead to cleaner and more efficient code. We cover several other articles and projects from the Python community, including the inaugural SEA Python developer in residence, type classes in Python, GitHub Co-Pilot writes a text-based game, friendlier tracebacks in rebels, including Jupiter, 120 plus interactive interview challenges, a module that helps you build complex pipelines of batch jobs, and a tool for plotting inside the terminal.\n\nThis episode is brought to you by Sentry, helping developers see issues that matter, solve those issues in minutes, and learn insights to keep their applications running at peak performance. Alright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey David, welcome back to the show.\n\nHey Chris, good to be back.\n\nAlright, we've got some really great news to start off this episode. I wanted to mention previous guest Lucas Longa is the inaugural SEA Python developer in residence, or as people keep shortening it, DUR, which I think is kind of strange. The whole idea of the developer in residence thing, we kind of touched on this developer in residence thing a couple of times in news articles, and so forth, but it's inspired by Django's fellowship program. I didn't know that at the time, and how successful that was in helping them really make cohesive changes and improvements in Django, which is really great. Django is really moving fast lately, which is, I guess, maybe something else you can tell with that, and it adds a cohesive context, which I thought that would be one of the things that it would add. Their goal is to address the PR backlog and investigate, you know, what are the priorities of this, you know, overall project, and the initial thing we'll link to is from PSF's sort of announcement about it. Lucas wrote on his own blog about kinds of things that he's hoping he's going to be able to do, and the first was providing a steady review stream, which helps dealing with the PR backlog, triaging issues on the tracker, and dealing with the whole backlog there, being present, you know, being available for communication channels to unblock people, and that's something that I felt myself with remote work. It's sort of frustrating tossing things over the wall, or you know, weekends and other things can kind of get in the way, and so if something sits there for a long time, I know the frustration that it can have. Keep the continuous integration and test suite in a usable state, yeah, and keeping on tabs on, you know, where work is needed, being that person who can kind of direct energy. We had Joanna on last week, and there was this sort of conversation about what should I do as a SEA Python developer core developer, and I thought that was an interesting talk, and this kind of would be one of those things where he could help maybe provide guidance for that type of person who's coming in and thinking about particular issues that they're interested in, but also maybe somebody there to guide someone in the direction of, like, this needs help, things like that, so very cool. Yeah, so I'm excited for Christian. I'll try to get him on the show again. I had asked him after PyCon to come on about his FM synthesizer, but this would be kind of a neat one-two punch for an episode. Yeah, and it's just exciting news. I mean, it's like he said, he's the inaugural developer in residence, and I know this has been something that the PSF has been working towards for a very long time. Obviously, you need funding, yeah, for that, and it's just exciting that they've gotten to the point where they can actually do this and kick this off. So, yeah, congrats to Lucas and congrats to the PSF and Python for reaching this milestone. Yay, Python! Yeah, that's a big milestone. Totally awesome. So, I want to start off with my first article, and this is a Real Python one. It's actually kind of been on the site for a long time, and this is like sort of the latest revision of it. It's definitely a timeless idea, and I thought with summer maybe this would be a nice kind of idea also. There's probably people out there having a nice summer vacation or some time off, and they want to maybe play around with Python or maybe they're checking out this podcast for the first time and like, what is it that I can do with Python? And that's literally the title of the article, \"What Can I Do with Python?\" And one of the things that I love about this article, it's by Leodannis, who we've mentioned so many times on this, and he had a milestone that was a shout out last week from Joanna about. He's published now 30 articles, yeah, yeah, which is really cool. It's quite the milestone. So anyway, he helped revise this one, and there's so many links and resources in here. Even if you go, \"Oh, I know what I can do with Python,\" you may not know all the things that are kind of like, kind of under the hood. And it's just a great way in a nice narrative style to kind of just go through all this stuff. And I found this link that I was not familiar with, and it's actually a link on python.org. It's Python Success Stories. And so there's this sort of gathering of success stories, and they're in all these great areas like what's happening in VR, delivering clean and safe code, healthcare, business, education, engineering, government, scientific areas. You know, obviously software development, which we've talked about many, many times. And there's stories on all of these, and with lots of little extra. See all of the stories on those categories. It's very neat to see this sort of collection of success stories and what's happening there. There are some huge ones already. If you weren't familiar with them, that, you know, Google has been using Python from the start. You know, you think about Python being used in the real world. We had Brett Slatkin on very early on on the podcast, and he actually worked with Guido at Google, right? And talked about, you know, just his ability to work fast and do the server-side kind of stuff that is really powerful inside of Google. There and they have, you know, Dustin was on recently, and he talked a little bit about some of the tools that they have there also. Instagram, I'm sure we've mentioned that multiple times, but it's like a huge deployment of Django. Spotify, I'm gonna mention today. They use it not only for lots of data science, but other things. And then we've had a lot of fun talking about space exploration, which is, somebody here is a big fan of. We've talked about black hole research, and of course, you know, NASA and robotics and the Mars rover helicopter, things like that all. It's pretty amazing to have Python, not only in the real world, but in outer space too. So then, you know, how you can develop software with Python, and we've talked about web development, Django, Flask. One of the newest additions to the group of web development tools is FastAPI, and I'm hoping to maybe talk to Sebastian Ramirez on the show. He just had an article that came out just this last week also about using FastAPI to build Python web APIs. Yeah, and it's, you know, written by the guy who kind of developed the library himself, which is very cool, really kind of fun. And again, if you're into APIs or interested in building them, this is definitely what all the talk's been about over the last several months. And then, you know, what else can you build? Application-wise, command line stuff, GUI stuff. We've talked so much about PyGUT and everything from WXPython to, you know, the stuff you did in the Python basics books with Tkinter. Yeah, game development, I've had multiple guests to talk about that because it's something that I find that's really fun. And then, you know, then the whole data science stuff in mathematics, machine learning, scientific computing. Each one of these headings has a section with just tons of little links and additional resources for you to kind of dive in. And if you're interested in wondering about, you know, thinking about something like the data analysis and visualization section, it lists off like six of the libraries and additional resources, not only on Real Python, but out there outside of Real Python. We've talked about web scraping, and then DevOps, you know, the whole thing that is very powerful with Python is you can use it to help automate so many things in your job. And that was the title of the role I had back in Hawaii was automation engineer, and so I was building lots of those kinds of things within an organization and using this general purpose language to do that kind of stuff. Yeah, anyway, it's a really great article, you know, gets down into everything testing databases, robots, electronics, and lots of fun stuff. So check it out. Yeah, you can definitely, I think you'll find something new. Yeah, it's cool because I mean the first thing that comes to people's minds is like software development, I think in a lot of web development, yeah. And in a lot of cases, which you know, nowadays it's like, I'm not even sure that web development, software development are two separate things anymore. True, but I was surprised, one of the things I recall talking about with you on one of the episodes was, we had found, I forget if it was a single article, it might have been a series of articles, on how Python was being used in Hollywood, in the movie production space. Yeah, we did, that was fun. And you know, so there's that kind of stuff, and also I recently found out, I'm not really into animation or anything like that, but but I recently found out that the program Blender, which I know is used in a lot of animation, yeah, the 3D stuff, yeah, you can be scripted with Python. You know, so it's just like there's just so much out there where Python is being used that it's almost it at this point, it almost feels like no matter what you're doing, you might have an unknown need or it would be beneficial for you to learn a little bit of Python, yeah, because it really is, it just seems to be like applicable in so many different domains, it's really impressive. Yep, it's a bright future for sure. Yeah, totally awesome. So I want to start off with my first article, and this is a Real Python one. It's actually kind of been on the site for a long time, and this is like sort of the latest revision of it. It's definitely a timeless idea, and I thought with summer maybe this would be a nice kind of idea also. There's probably people out there having a nice summer vacation or some time off, and they want to maybe play around with Python or maybe they're checking out this podcast for the first time, and like, what is it that I can do with Python? And that's literally the title of the article, What Can I Do with Python? And one of the things that I love about this article, it's by Leodannis, who we've mentioned so many times on this, and he had a milestone that was a shout out last week from Joanna about. He's published now 30 articles, yeah, yeah, which is really cool. It's quite the milestone. So anyway, he helped revise this one, and there's so many links and resources in here. Even if you go, oh, I know what I can do with Python, you may not know all the things that are kind of like, kind of under the hood, and it's just a great way in a nice narrative style to kind of just go through all this stuff. And I found this link that I was not familiar with, and it's actually a link on python.org. It's Python Success Stories. And so there's this sort of gathering of success stories, and they're in all these great areas like what's happening in VR, delivering clean and safe code, healthcare business, education, engineering, government, scientific areas. You know, obviously software development, which we've talked about many, many times. And there's stories on all of these, and with lots of little extra. See all of the stories on those categories. It's very neat to see this sort of collection of success stories and what's happening there. There are some huge ones already. If you weren't familiar with them, that you know, Google has been using Python from the start. You know, you think about Python being used in the real world, we had Brett Slatkin on very early on on the podcast, and he actually worked with Guido at Google, right? And talked about, you know, just his ability to work fast and do the server-side kind of stuff that is really powerful inside of Google, there, and they have, you know, Dustin was on recently, and he talked a little bit about some of the tools that they have there, also Instagram, I'm sure we've mentioned that multiple times, but it's like a huge deployment of Django, Spotify, I'm gonna mention today, they use it not only for lots of data science, but other things, and then we've had a lot of fun talking about space exploration, which is, somebody here is a big fan of, we've talked about black hole research, and of course, you know, NASA and robotics and the Mars rover helicopter, things like that all. It's pretty amazing to have Python, not only in the real world, but in outer space too. So then, you know, how you can develop software with Python, and we've talked about web development, Django, Flask, one of the newest additions to the group of web development tools is FastAPI, and I'm hoping to maybe talk to Sebastian Ramirez on the show. He just had an article that came out just this last week also about using FastAPI to build Python web APIs, yeah, and it's, you know, written by the guy who kind of developed the library himself, which is very",
    "wrbJEe947L4": "Welcome to the Real Python Podcast. This is Episode 71. Are you still sprinkling print statements throughout your code while writing it? Print statements are often clunky and offer only a limited view of the state of your code. Have you thought there must be a better way? This week on the show, we have Nina Zakarenko to discuss her Python talk titled \"Goodbye Print, Hello Debugger.\" We talk about how to get started debugging your code by adding a single keyword. Nina discusses the differences between debugging on the command line versus using the tools included with an integrated development environment. She also shares tricks and best practices. If you haven't seen Nina's conference talk, it's a great starting point. We also talk about working through the last 18 months and how to recharge your creative batteries. We briefly discussed two other presentations Nina gave about Circuit Python and getting started with electronics and Python.\n\nThis episode is brought to you by Sentry, helping developers see issues that matter, solve those issues in minutes, and learn insights to keep their applications running at peak performance. Alright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey Nina, welcome back to the show. Thanks so much for having me back. Yeah, it was so fun talking to you and your whole group of people from PyCascades, and it was really fun hanging out at the conference. Yeah, I'm glad you enjoyed it. We got a lot of really good feedback from folks who said that it was their favorite online event of the year, so that was a high compliment. Oh, that's great. Yeah, I heard a lot of people are excited about it being virtual in the sense that they could attend it. Yes, and next year it's going to be virtual again. We have two new co-chairs, Madison and then Brett Gresham, who were on the chairs last year. Brett organized the volunteers, Madison was our diversity chair, so they are taking the helm and I believe their idea is to have the conference be remote but then have a handful of viewing parties across the Pacific Northwest where folks can get together and watch in person. That's a super interesting wrinkle. I think that would be fun. I think so too. Okay, cool. I wanted to talk a little bit about some of the things that you're doing with the Python Software Foundation. Yes, what's new there? I am a pretty newly elected board member. I was elected last year and I'm not sure if you know we just had elections this year and will be welcoming the new board this week. All right, yeah, super exciting. It's been wonderful and challenging and I've learned a lot. I think next year is definitely going to be pretty interesting because I'm not sure if you've heard but Eva, the executive director is stepping down. Yeah, in December we haven't talked about it on the show but yeah, that was a recent announcement and so some changes there. Yes, she is just wonderful. She has done so much for the Python community over the past 10 years. She's grown the PSF to what it is today. She's built up an amazing staff and I'm a little sad I know that it's time for her to to move on. 10 years is a long time to be doing anything. Yeah, it is but it's going to be really hard to fill her shoes. Yeah, I recently had Marlene Montgomery on. Yes, and I had Dustin Ingram on recently also. Yes, and so we were talking PSF stuff there. So, it seems to be a common theme within the guests recently, which is great. Yeah, Dustin was elected in my cohort last year as well. Oh, cool, yeah, and I mean just overall it's just such a kind compassionate group of folks. You know, we talked about this a little earlier but my mom passed away from COVID late last year and folks from the PSF banded together and they sent me flowers and a card and it was just oh wow, it was really kind and really sweet when I really needed it most. Yeah, I'm sure that's been really rough this year. Yeah, yeah, it has been uh, yeah. One of the primary things we wanted to talk about this week or I wanted to have you come on and talk about is debugging and you did a talk at PyCon 2020 but you've shared that talk in a couple other places but then I thought we could talk about a couple other additional subjects depending on on time here maybe your your passion for Circuit Python like me and then uh something that kind of fits into something we were discussing there briefly is just like of burnout and what's happening with a lot of individuals and trying to work through that over the last uh, I don't know 18 months. Yes, yes, those all sound like excellent topics. I think burnout especially probably hits home for a lot of people right now. I recently did a work training where there was just an anonymous survey of uh on a scale of one to ten how stressed out are you feeling right now and I thought you know I would see numbers from all across the board but it was really mostly a majority 8 9 10. Wow, yeah, no I feel it I feel it myself. We were talking a little bit beforehand and it's you know, it's been challenging to start a totally new creative project in a podcast um at March 2020 and and build from there you know not only finding guests but finding just the creative energy and I feel that across the board for a lot of people at Real Python also like you know taking time like maybe they have a full-time job and you know they're just their tanks are empty as far as like creativity as far as like adding additional stuff and and so I'm trying in all the ways that I can to try to provide guidance and and you know and leeway and you know and support in all the ways I can sort of managing I primarily manage the video courses and yeah and trying to keep all everybody working there and it's been rough so I'm I'm guessing you're seeing that in a lot of other areas too yeah I think the hardest thing has just been a lack of ways to recharge my batteries yeah I mean time off is one of them but that didn't help during lockdown now I think the other thing that was interesting that people posted is like oh yeah you work remote now and it should be great and it's like no it's not like remote was okay yeah let me tell you a little secret I've been full-time remote for seven years now and the past two years are nothing like what remote work actually is yeah what are differences if we want to enumerate a few well for one you know it used to be easy to go out to lunch work from a cafe you know meet a friend for coffee and just have some level of social interaction and then when you were done with work you could go outside and do things and make plans and instead during lockdown it turned into this thing where you're just trapped in the house with everybody that you live with right everybody's eating up the bandwidth and it's more like living in your office versus working from home I sleep in the little corner in the office yeah I I have this image in my head um the first couple times where I would go I don't know to a Starbucks or whatever just and them having like all the tables like taped off and like this weird kind of like remodeling kind of scenario but they weren't remodeling you know right it was just uh so weird you know those were like the places people would go and hang out and look through their code or have something else to inspire them you know being around people yeah yeah remember in person meetups yeah I just did a remote one with a local group the Py Springs and it was fun it was fun to connect with them again but I had asked them about the workspace they would use which is a co-working space and I was concerned like oh is this is it still you know happening and they they struggled through they're still there but I'm imagining a lot of co-working spots of I would guess the number would have gotten smaller yeah yeah I imagine so it might be hard to find space when all of this is over yeah I hope it all you know kind of mellows out I'm thinking about you know ways that I'm hoping to recharge I I play video games the trick is finding ones that I can complete yeah I know that sounds kind of crazy I I started one game where it never ends oh no it feels like it's one of these Ubisoft games where uh I think it's called Assassin's Creed Odyssey and they just keep throwing more things at me and I'm like okay wait this is like 50 hours or so and and you just introduced like all these new things I need to do like major goals so I broke away and I played a game called um Firewatch which you can play in an afternoon it's really kind of nice and has a good narrative and it's a you know doesn't feel like you know you're not getting your investment you know yeah you can roll credits on a game and then the other one I played was a journey which was um kind of fun and very very ambient very relaxing kind of game was fun yeah one of the ways I I recharge my batteries is spending time with friends and I moved uh pretty recently to a city where more of my friends live and I have more access to that and that's been oh that's cool I mean the",
    "7mLa2SGBAT0": "Welcome to the Real Python Podcast. This is Episode 72. Have you been hearing about the popular framework, FastAPI? An Application Programming Interface (API) is vital to make your software accessible to users across the internet, and FastAPI is a great choice for quickly creating a web API that implements best practices.\n\nThis week on the show, David Amos is back, and he's brought another batch of PyCoder's Weekly articles and projects. We share an introduction to FastAPI written by the framework's author, Sebastian Ramirez. The goal behind the article is to get you started creating production-ready APIs.\n\nDavid covers an article about the Python import system and how it remains a mystery for many Python developers. We share some additional Real Python resources on the import system and statements. We cover several other articles and projects from the Python community, including a buffet of specialized data types with Python's collections module, maps with Django using GeoDjango PostGIS and Leaflet, moving SciPy to the Meson build system, what's new in Python 3.11, a community-maintained Python framework for creating mathematical animations, and easily make PDFs with PDF Me.\n\nThis episode is brought to you by Sentry, helping developers see issues that matter, solve those issues in minutes, and learn insights to keep their applications running at peak performance. Alright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey, David, welcome back.\n\nHey, Chris, thanks for having me.\n\nAlright, so we've got a nice collection of PyCoder stuff this week.\n\nYeah, and a couple of Real Python things in there as usual.\n\nFor sure, and I'm kind of excited to get rolling. So what do you got?\n\nThe first one comes from our good friend, Leodanis Pozo Ramos. It's Python's collections: a buffet of specialized data types. We've talked about the collections module several times on the podcast. I think even recently in the last couple of times we've done a podcast together. So the collections module includes things like namedtuple, which I believe we've talked about, the defaultdict, and the Counter class, which we may have even talked about the last time that I was on or maybe the time before that. This article is really just kind of an overview of what's inside the collections module as opposed to a deep dive on individual things and kind of ties together everything that has been put out recently on these other data structures. But it also goes into some things that we don't have articles on currently, things that we haven't talked about on the podcast. It mentions the motivation behind the collections module and why you would want to learn it, learning how to write more Pythonic code and leverage the these built-in data structures that are there for you. So it gives you a quick overview and talks about things like the deque, which is a double-ended queue which is a really great one to be aware of, the defaultdict, the namedtuple. I guess I could describe what some of these things are like defaultdict is a way to associate a specific type or data structure for any key; like all keys would have kind of the same type, like a list or a set or something along those lines, and it gives you a way to like if you try to do something with a key that doesn't exist yet you've got like a default there that it'll start with, you know, some kind of empty collection of that whatever that default is or whatever the type is that you have assigned to it. And you can write some really clean code that way. It talks about that, the namedtuple, which we've mentioned, which is one of my favorites in the collections module, a way to give names to the components of a tuple like the slots in it, which is really handy and then you can access them with like the dot notation. So you could actually have a tuple, an immutable tuple data structure that not only could you access by components by index, but you could do like maybe it represents a row in a database table where you've got people and you've got first name and last name and you can actually have those names associated to that and do dot first name, dot last name to get those. Yeah, I think that's such a really powerful thing to return from a function to have all that kind of extra control. Exactly and it like so for each of these it mentions kind of like you know good examples of use cases for this and that's actually one of the ones in for the nametuples, you know as a return value for something you've maybe you've read a CSV file or read something from a database and you're going to return a record or multiple records in a list or something and you can use the namedtuple with that to give a little bit more friendlier API on what you get back from that function. I think it's into the OrderedDict which I think we've talked about some as well and the Counter, which we've talked about. Yeah, we did that one last time. Yeah, yeah and something called the ChainMap, which is like a dictionary-like class that allows treating a number of mappings as a single dictionary object so it's sort of like if you have several dictionaries you need to maybe say iterate over those dictionaries altogether you don't need to do any sort of like complicated dictionary unions or merging or things like that you can use this ChainMap to sort of chain them all together in a way and loop over that. So that's a really neat one and then also talks about some of these maybe unusual sounding classes that are in collections called UserDict, UserList, and UserString and so these are wrapper classes around the built-in dictionary list and string objects that are really meant like if you're going to create your own kind of custom dictionary rather than say subclassing from the built-in dict type you would subclass from UserDict. You can argue whether or not you would want to do something like that or you know do something more like a composition like I think we've talked about kind of the composition versus inheritance thing on here but those are I think kind of little-known features of collections or you may not even be aware that these things exist in Python at all. The article just gives you a good overview of everything that's available and kind of a quick you know quick examples of how you can use these and then we've got several articles here on Real Python that do you know deep dives into these things yeah much deeper so you can kind of continue learning by you know clicking through to those the ones that you're you're most interested in so definitely good one to check out because I think collections is one of those things that you know it really kind of takes your Python programming to the next level once you learn how to use everything that's in there yeah it kind of goes back to the test questions and that database of stuff that we found the GitHub types of interview questions and again you can kind of do it sometimes the longer way with just base Python without kind of importing you know stuff from the collections module right but then this can really speed it all up and and make it look a lot cleaner and potentially add a lot of additional methods and stuff to just really make things much more functional in a great in a kind of nice useful way yeah exactly and it like so for each of these it mentions kind of like you know good examples of use cases for this and that's actually one of the ones in for the name tuples you know as a return value for something you've maybe you've read a CSV file or read something from a database and you're going to return a record or multiple records and a list or something and you can use the name tuple with that to give a little bit more friendlier API on what you get back from that function I think it's into the ordered dict which I think we've talked about some as well and the counter which we've talked about yeah we did that one last time yeah yeah and something called the chain map which is like a dictionary like class that allows treating a number of mappings as a single dictionary object so it's sort of like if you have several dictionaries you need to maybe say iterate over those dictionaries altogether you don't need to do any sort of like complicated dictionary unions or merging or things like that you can use this chain map to sort of chain them all together in a way and then also talks about some of these maybe unusual sounding classes that are in collections called user dict user list and user string and so these are wrapper classes around the built-in dictionary list and string objects that are really meant like if you're going to create your own kind of custom dictionary rather than say subclassing from the built-in dict type you would subclass from user dict you can you can argue whether or not you would want to do something like that or you know do something more like a composition like I think we've talked about kind of the composition versus inheritance thing on here but those are I think kind of little known features of collections or you may not even be aware that these things exist in Python at all so the article just gives you a good overview of everything that's available and kind of a quick you know quick examples of how you can use these and then we've got several articles here on Real Python that do you know deep dives into these things yeah much deeper so you can kind of continue learning by you know clicking through to those the ones that you're you're most interested in so definitely good one to check out because I think collections is one of those things that you know it really kind of takes your Python programming to the next level once you learn how to use everything that's in there yeah it kind of goes back to the test questions and that database of stuff that we found the GitHub types of interview questions and again you can kind of do it sometimes the longer way with just base Python without kind of importing you know stuff from the collections module right but then this can really speed it all up and and make it look a lot cleaner and potentially add a lot of additional methods and stuff to just really make things much more functional in a great in a kind of nice useful way yeah exactly and it like so for each of these it mentions kind of like you know good examples of use cases for this and that's actually one of the ones in for the name tuples you know as a return value for something you've maybe you've read a CSV file or read something from a database and you're going to return a record or multiple records and a list or something and you can use the name tuple with that to give a little bit more friendlier API on what you get back from that function I think it's into the ordered dict which I think we've talked about some as well and the counter which we've talked about yeah we did that one last time yeah yeah and something called the chain map which is like a dictionary like class that allows treating a number of mappings as a single dictionary object so it's sort of like if you have several dictionaries you need to maybe say iterate over those dictionaries altogether you don't need to do any sort of like complicated dictionary unions or merging or things like that you can use this chain map to sort of chain them all together in a way and then also talks about some of these maybe unusual sounding classes that are in collections called user dict user list and user string and so these are wrapper classes around the built-in dictionary list and string objects that are really meant like if you're going to create your own kind of custom dictionary rather than say subclassing from the built-in dict type you would subclass from user dict you can you can argue whether or not you would want to do something like that or you know do something more like a composition like I think we've talked about kind of the composition versus inheritance thing on here but those are I think kind of little known features of collections or you may not even be aware that these things exist in Python at all so the article just gives you a good overview of everything that's available and kind of a quick you know quick examples of how you can use these and then we've got several articles here on Real Python that do you know deep dives into these things yeah much deeper so you can kind of continue learning by you know clicking through to those the ones that you're you're most interested in so definitely good one to check out because I think collections is one of those things that you know it really kind of takes your Python programming to the next level once you learn how to use everything that's in there yeah it kind of goes back to the test questions and that database of stuff that we found the GitHub types of interview questions and again you can kind of do it sometimes the longer way with just base Python without kind of importing you know stuff from the collections module right but then this can really speed it all up and and make it look a lot cleaner and potentially add a lot of additional methods and stuff to just really make things much more functional in a great in a kind of nice useful way yeah exactly and it like so for each of these it mentions kind of like you know good examples of use cases for this and that's actually one of the ones in for the name tuples you know as a return value for something you've maybe you've read a CSV file or read something from a database and you're going to return a record or multiple records in a list or something and you can use the name tuple with that to give a little bit more friendlier API on what you get back from that function I think it's into the ordered dict which I think we've talked about some as well and the counter which we've talked about yeah we did that one last time yeah yeah and something called the chain map which is like a dictionary like class that allows treating a number of mappings as a single dictionary object so it's sort of like if you have several dictionaries you need to maybe say iterate over those dictionaries altogether you don't need to do any sort of like complicated dictionary unions or merging or things like that you can use this chain map to sort of chain them all together in a way and then also talks about some of these maybe unusual sounding classes that are in collections called user dict user list and user string and so these are wrapper classes around the built-in dictionary list and string objects that are really meant like if you're going to create your own kind of custom dictionary rather than say subclassing from the built-in dict type you would subclass from user dict you can you can argue whether or not you would want to do something like that or you know do something more like a composition like I think we've talked about kind of the composition versus inheritance thing on here but those are I think kind of little known features of collections or you may not even be aware that these things exist in Python at all so the article just gives you a good overview of everything that's available and kind of a quick you know quick examples of how you can use these and then we've got several articles here on Real Python that do you know deep dives into these things yeah much deeper so you can kind of continue learning by you know clicking through to those the ones that you're you're most interested in so definitely good one to check out because I think collections is one of those things that you know it really kind of takes your Python programming to the next level once you learn how to use everything that's in there yeah it kind of goes back to the test questions and that database of stuff that we found the GitHub types of interview questions and again you can kind of do it sometimes the longer way with just base Python without kind of importing you know stuff from the collections module right but then this can really speed it all up and and make it look a lot cleaner and potentially add a lot of additional methods and stuff to just really make things much more functional in a great in a kind of nice useful way yeah exactly and it like so for each of these it mentions kind of like you know good examples of use cases for this and that's actually one of the ones in for the name tuples you know as a return value for something you've maybe you've read a CSV file or read something from a database and you're going to return a record or multiple records in a list or something and you can use the name tuple with that to give a little bit more friendlier API on what you get back from that function I think it's into the ordered dict which I think we've talked about some as well and the counter which we've talked about yeah we did that one last time yeah yeah and something called the chain map which is like a dictionary like class that allows treating a number of mappings as a single dictionary object so it's sort of like if you have several dictionaries you need to maybe say iterate over those dictionaries altogether you don't need to do any sort of like complicated dictionary unions or merging or things like that you can use this chain map to sort of chain them all together in a way and then also talks about some of these maybe unusual sounding classes that are in collections called user dict user list and user string and so these are wrapper classes around the built-in dictionary list and string objects that are really meant like if you're going to create your own kind of custom dictionary rather than say subclassing from the built-in dict type you would subclass from user dict you can you can argue whether or not you would want to do something like that or you know do something more like a composition like I think we've talked about kind of the composition versus inheritance thing on here but those are I think kind of little known features of collections or you may not even be aware that these things exist in Python at all so the article just gives you a good overview of everything that's available and kind of a quick you know quick examples of how you can use these and then we've got several articles here on Real Python that do you know deep dives into these things yeah much deeper so you can kind of continue learning by you know clicking through to those the ones that you're you're most interested in so definitely good one to check out because I think collections is one of those things that you know it really kind of takes your Python programming to the next level once you learn how to use everything that's in there yeah it kind of goes back to the test questions and that database of stuff that we found the GitHub types of interview questions and again you can kind of do it sometimes the longer way with just base Python without kind of importing you know stuff from the collections module right but then this can really speed it all up and and make it look a lot cleaner and potentially add a lot of additional methods and stuff to just really make things much more functional in a great in a kind of nice useful way yeah exactly and it like so for each of these it mentions kind of like you know good examples of use cases for this and that's actually one of the ones in for the name tuples you know as a return value for something you've maybe you've read a CSV file or read something from a database and you're going to return a record or multiple records in a list or something and you can use the name tuple with that to give a little bit more friendlier API on what you get back from that function I think it's into the ordered dict which I think we've talked about some as well and the counter which we've talked about yeah we did that one last time yeah yeah and something called the chain map which is like a dictionary like class that allows treating a number of mappings as a single dictionary object so it's sort of like if you have several dictionaries you need to maybe say iterate over those dictionaries altogether you don't need to do any sort of like complicated dictionary unions or merging or things like that you can use this chain map to sort of chain them all together in a way and then also talks about some of these maybe unusual sounding classes that are in collections called user dict user list and user string and so these are wrapper classes around the built-in dictionary list and string objects that are",
    "qzubpSKTeOY": "Welcome to the Real Python Podcast. This is episode 74. Have you started using Python's assignment expressions in your code? Maybe you've heard of them called the walrus operator. Now that the controversy over the introduction in Python 3.8 has settled down, how can you use assignment expressions effectively in your code? This week on the show, David Amos is back and he's brought another batch of PyCoder's weekly articles and projects. David shares a recent article by previous guest Brett Cannon about what to do if you botch a release to PyPI, the Python Package Index. It's a valuable resource to keep bookmarked for when things go sideways. We also talk about a recent project by Brett, a Python launcher for Unix-based operating systems.\n\nWe cover several other articles and projects from the Python community, including a Python framework with a built-in database and authorization support from Replit Decoders. Learn how to use entire libraries just from the documentation, how to use sleep to code a Python uptime bot, monitor your home's temperature and humidity with Raspberry Pi's and Prometheus, and a fast settlers of Catan Python implementation with a strong AI player. \n\nThis episode is brought to you by Gather, virtual offices for remote teams. Build a free office today at gather.town/realpython. \n\nAll right, let's get started. The Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey David, I got this notice on YouTube from somebody saying that as many times as we've had you on the show, that you should be called a co-host, and I agreed with that idea. So I'm welcoming back my co-host. Thanks, David Amos, to the Real Python Podcast. Anything you want to say?\n\nThanks, it's good to be recognized. It's been fun. I mean, it's over a year that we've been doing these PyCoder's episodes, and we've got a bunch of really good stuff this week again. I was able to play around with my electronics a little bit more. We'll get into that a little bit later. So that's been fun. \n\nWell, I'm going to start off this week talking about the podcast itself. The first guest was Guarana Yella. He was on episode one and then came back when we talked about Python 3.9 and the release there. But he's had an article in the works for quite a while. It's titled \"The Walrus Operator: Python 3.8 Assignment Expressions.\" And we've talked about the walrus operator probably several times on the show up to this point. But what I wanted to do briefly is just, I think, sometimes terminology is always one of these barriers for people. The name really explains what's happening with it better than anything. So I wanted to start out. Three terms want to get out of the way. The first is what is a statement? A statement is really just sort of a unit of code, this chunk of code that we've talked about parsing and how these things go through looking at the language itself and the peg parser and stuff like that. So we can think of statements as these individual units of code, and that term just gets thrown around a lot, and I think it's a little confusing because it's very generic as far as the programming goes.\n\nAs far as the programming goes, what is an assignment? In the Python docs, it says assignment statements are used to bind or rebind names to values and modify the attributes or items of mutable objects. So the idea is that when you say x equals 42, you're assigning that value, and x now has that value assigned to it. And what's interesting is nothing really returns out of that or anything's kind of happening with it. It's basically just sort of binding the values together, and then there's some confusion. Sometimes with the idea that you could say, \"Well, x now equals you know,\" or \"y equals x,\" and now they kind of pointed the same thing. And there's some interesting stuff there. So what's an expression? In that case, it's a sequence or combination of values, variables, operators, and function calls that produce or return a value. Yeah, so expressions are kind of the funkiest one to describe because if you were in a REPL and you had done that assignment earlier of like x equals y, if you simply typed x, that technically is an expression because it would actually return something. It would return the value that x is assigned to. In this case, it would show you know what it is. More commonly, expressions are things like comparison or doing things like equal to or greater than or equal to or something like that. But it also could be if you have seen something like a while statement, it could be just something that is standalone being evaluated. And this idea of truthy or falsey, so you could evaluate and say while x, you know, and as long as the value isn't zero, you know, it's some truthy value, then this thing's going to happen or you know none or some other kind of falsy thing. So expressions are kind of interesting to think about. So then if you tie the two together and you say an assignment expression, it's doing two things then. Yeah, there's the assignment where you're saying this value, in this case the symbol is a colon and an equals, and hence the weird symbology is then kind of the idea of like it's a walrus on its side with its tusks, right? Yeah, in that case you're going ahead and assigning that value to let's say x colon equals something. And again, it could be just a value or it could be you're evaluating something in that process too. And so what happens that's unique there is it's not just assigning that value to it, it's also returning this expression. As I look at this, is that true or is it false or you know, it's or returning a particular value. And so it is kind of a unique thing and it isn't in all languages and it was very controversial to add it to Python. Yeah, and you don't have to rehash that whole story, but I think it's a really cool thing. And there's a lot of really interesting things you can do with it. I think there's value in it and I think the hardest part is like almost like F strings like where should I use these and where shouldn't I use these and and things like that where these things get added to the language and and then you know there's compatibility issues. Like I'm was just working with the Raspberry Pi and it's basically operating at Python 3.7 and that's the you know version of Linux and Python that's kind of coming with it. And this is a feature of Python 3.8 and Guarana wrote a whole article about cool new features in Python 3.8. And then I did a course on that. And so there's some material out there we're talking about kind of the fundamentals of like you know what assignment expressions are and how to use that walrus operator. But what he's done here is gone much deeper in very Guarana style and talks about lots of different interesting uses and lots of new examples he's added. There's a really great example of like debugging. Yeah, and the idea that as you're going through a fairly complex calculation as you're moving along you can sort of set values to variables as you're evaluating them and then that value is assigned and so that variable can be reused later in the same you know definition. It's harder to explain beyond the initial stuff I tried earlier here explaining the idea of the differences between assignments and expressions and statements. But the article really gives you a good experience of like okay let's walk through lots of examples and I don't know there must be like six or seven of them in it going through them. And then also like how you could have done it and then this is how this maybe makes this better. But he also does cover the reverse talks about like where this is really probably not appropriate to use. One example I remember from an early episode of the show, I had Brett Slatkin on the show. We were talking about his book and he had used this new walrus operator to do sort of a switch case matching style. And I think now with structural pattern matching in 3.10 that will probably be you know the more preferred way because it has a lot more structures and actual um things in it to work with it. But I think if you want to get a handle on what's happening with assignment expressions and dive into them this is a really great article and it goes it goes kind of meta. He's got another example that I think is funny. You know here we are talking on the podcast about an article where he's talking about the podcast and using it as an example. Yeah, which is kind of funny in meta so recursion or something. But he's like doing this whole thing where you're like reading a feed of articles and you're pulling out specific values from that. One nice thing that you can do with it is not have to redo calculations say within the body of a function or something like that. You could. He's doing one where it's doing a line reading from a file to determine the line count, the word count, and the character count. But instead of having to recalculate each one of those as gone along or potentially read the file again. He's able to save those and evaluate as as it goes along. And I like that example. There's some examples with list comprehensions. So yeah, it's a really thorough article and I think you can get a lot out of it. Yeah, I really thought that he did a good job with the examples because one of the downsides. I think in a lot of articles I've seen about the walrus operator or visa really. I mean the walrus operator is a cool name, but I really do think that like probably we need to think of like assignment expressions because it's so much more descriptive. You know a lot of things I've seen in other articles about assignment expressions and even in the uh pep that originally proposed them you see some examples of like showing you how it works right but they're not always the most compelling examples because it's sort of like okay well I can do that with it but I could also do that this other way and it feels much more Pythonic and much more easy to understand and it's also something that like if more people are going to be comfortable with because they may have never even heard of this new thing so the examples that Guarana gives I feel like do a good job of not only showing how the assignment expressions work but also compelling examples where you look at it and you go oh yeah okay that actually does make a little bit more sense and yeah speed things up potentially right. Yeah or like you were saying about things being Pythonic and writing like make it more obvious what's happening with the code right like in the case of like he was talking about list comprehensions and sometimes you might go ahead and break that into a for loop but if there are lots of lines it's very easy for your brain to start to drift and go wait what did we do six lines ago right and here you can kind of see it all in one line and the idea that it's you know this expression being evaluated is very interesting in that it actually returns a value. Itself is interesting you know like along with the assignment so there's a lot going on in there and you're right like I think you know I've said this joke before about async IO where all the examples are just we'll we'll just make it sleep you know so that async and a wait this is we'll just wait for something to sleep and I'm like well right it's really a very fictitious thing I mean yes you would do that and we're going to talk about that more today but you know in general like you are probably going to await something actually happening you know beyond just yeah time wait so what's your first one so mine comes from the Replit blog and if you're not familiar with Replit it's it's like an online coding framework where basically it's not just for Python they've got a bunch of different languages where you can get access to like an online interpreter and they've even got like an IDE within the web browser and some hosting services so you can host apps on it and everything so you can do like all your coding on in the browser through them and they support Python and JavaScript and I think Ruby on Rails and like or I guess just Ruby Ruby on Rails is what like the web framework I don't I don't know but they support a whole bunch of different languages but they released a new web framework that is really kind of a flask extension so they have a Python package you can pip install Replit and in that Python package they've added a couple of new modules one is the db module and one is the web module or at least I believe DP's also knew I know for for a fact the web module is uh is the new one but they wrote an article announcing this and if you have a little flask app and you want to connect it to a database and also do some like user authentication and host it somewhere they have this example that is I'm kind of eyeballing this I think it's like 11 lines of code and it has a like a a route like an index you know home page basically and you have to be logged in to see that route so in this 11 lines of code you create the flask app you create the route you make sure that the user is authenticated and you also run the web app on Replit like hosted and so it it allows you to very quickly like I think you know when you run this you then you'll get like a URL basically that says hey you know go to this URL and you can see your app running and it's it's really an amazingly quick way to get something up so that you can show it to somebody and I know you know there's other ways to do this that are that are popular but just look like you know if you work a lot with flask and like flask and and maybe want to do some like prototyping just to like show maybe you're freelancer and just want to show a client or you just want to you know show it to maybe you're going to a job interview and you want",
    "aoUlxYHI7sI": "Welcome to the Real Python Podcast. This is Episode 76. How well do you know Python's math module? Maybe you've used a few of the constants or arithmetic functions, but you may be surprised by the amount of functionality hiding within this built-in library. Perhaps you don't need to reach for another additional outside library. This week on the show, David Amos is back, and he's brought another batch of PyCoder's Weekly articles and projects. We discuss a recent video course about the math module, and David shares a recent article about implementing efficient queues and stacks with Python's deque double-ended queue class. We also talk about an article that shares 25 pandas functions you may not have known to exist. We cover several other articles and projects from the Python community, including visualization and interactive dashboards in Python with HoloViz, designing a camera with Python and PyRayT, graphing data science with Python and NetworkX, and another useful Python PDF library. Runtime software verification that includes automated testing for scientific software in Python with a project named Paranoid Scientist.\n\nThis podcast episode is brought to you by DataStax Astra DB, built on Apache Cassandra, now made easy in the cloud. Get 40 gigabytes of storage free every month at astra.dev/python. All right, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com. Hey David, welcome back to the show.\n\nHey Chris, thanks for having me back. All right, looks like you're starting off with another article by Leo Donis.\n\nYes, Leo Donis is on a roll. This one is called \"Python's deque: Implement Efficient Queues and Stacks.\" If you haven't heard of deque before, it's a double-ended queue, which can be a very useful data structure when you need efficient operations of appending things. You can think of it as like a list in a sense, but it allows you to do operations like appending and removing things from either side of the list very efficiently. Yeah, it's spelled as D-E-Q-U-E. It is, which is confusing. I think some people probably look at it and pronounce it D-Q. Yeah, and I think that also makes a lot of sense. But if you read the documentation, the official Python docs, they do mention that it's meant to be pronounced DEQ, like D-E-C-K, like a deck of cards or whatever, right? And I guess, for comparison, you know, a list you can efficiently pop items from a list. The list has a pop method by default. It's going to take it off of the very end of the list. Like the last item in the list will come off. And the same thing, if you append to a list using the append method, then it's going to append it to the end, like after the last item of the list. Now you can pass an argument to pop. Like you could call pop(0) where 0 is the index that you want to pop, and it's going to pop off the first item. But it's not very efficient because what happens is it'll pull that first item off the list, and then it has to shift everything down. So it actually ends up having a higher complexity. You can use a list efficiently as a last-in-first-out kind of queue. People call these LIFO queues. But if you need to pull things off the front of the list, then it's not the best choice. And that's kind of where this deck thing comes in. So this whole article talks about deck data structure, deck module. So you have to import deck in order to use it. And it gets into all the basics, you know, what, why is it different from a list? How is it implemented? And whether or not it's thread-safe, which it is, and the memory efficiency, things like that. And then it gets into just all the different operations. So how you pop and append items from it, how you can access random items from inside of a deck, and then a couple of sort of applications, you know, how to build efficient queues using deck. So a deck is a sequence, which a sequence is anything in Python that you can access things by numeric index, right? So like anything where you can put the little square brackets with an integer inside of it would be considered a sequence. So things like tuples and lists, even strings are sequences. A deck is a sequence type as well. So the article explores what that means and kind of the different things you can do with that, things like counting the number of a certain value that appears in it, getting the index of a value, reversing the deck, and all that kind of stuff. So it really goes into a lot of detail on all that and then takes a look at putting it into action and actually giving you kind of an example where you would use this and how it might look in your code. Definitely a good read. I guess just to clarify for example, one of the examples that Leo Donis looks at is emulating the tail command on a Unix, where you can take a file path, pass it to this tail command and look at the last few lines in a file, and you can tweak it to look at any number of lines. So he talks about how to implement something like that using a deck. Really great read, very in-depth, lots of good info in there for sure. If you're looking at learning some more data structures and you want to see how you would do this in Python, it's there. You don't have to build these things from scratch like you would in some other languages.\n\nWe've focused on a lot of these data structures. Going back to previous conversations, we've talked about the collections module and all the different kinds of tools in there. So this is a nice another tool that's hiding inside there for people to kind of play with.\n\nYeah, it's definitely one of those things. You know, I think if you're just getting started with Python, you probably don't want to, well, if you're just getting started with Python and also new to programming, you probably don't want to really worry about these kinds of things yet. And I think that, you know, from a design perspective, just the plain old Python list covers so many of the most common use cases and does it really well. You can go a long way without ever even knowing that you need something different. But yeah, once you kind of get beyond that, you know, take it to the next level, this is definitely a good one to be aware of.\n\nAnd it might even come up in some interviews. So yeah, definitely.\n\nMy first one is from the Towards Data Science Medium blog, which we've mentioned multiple times. This one is from Sofia Yang, and Sofia is a senior data scientist at Anaconda. It's really a short love letter to this really powerful visualization and interactive dashboard tool called HoloViz. HoloViz is definitely a powerful package. It includes so many of the libraries you might have already heard us talk about, things like Bokeh, Matplotlib, Datashader, Plotly. It even goes much further than that and sort of combines them all into this overall overarching package that you can work in lots of different situations. It could be generally... We've talked about data visualization inside of notebooks or inside of Python files, but often, as a person who is creating data visualizations for other people in dashboards for people, one of the other things you might do commonly is create reports and PDFs or individual graphs coming out of these things or making like a server that serves those things out. This is another tool that could fit inside that. A couple things about it. This is a real short read. It really is just kind of giving you an idea of some of the things that are available in it and things that you can do with it. It's truly, in my opinion, a thing that works best in Anaconda or Miniconda. It seems to be much the preferred method for getting this all set up. I'm not saying you can't in other ways, but the way that it's sort of packaged and sort of distributed, it feels much more like that seems like a plan. And it's pretty big when you install it, like the footprint that I got after installing HoloViz was around 2 gigabytes for kind of everything that came with it, which is pretty big for a library. But again, it includes so many other libraries inside of it. And I will include links to the HoloViz documentation, which talks about the libraries that are inside of it. It mentions seven of them: Panel, HoloViews, GeoViews, DataShader, Param, ColorSet, and HPPlot. All the views. GeoViews is a great library if you want to do stuff with maps. DataShader takes the shading elements that you may want to do in some of your data visualization and actually amps it up quite a bit, which is nice. An area called \"param\" like parameter, and then ColorSet. And I just, you know, if you're interested in diving deeper into data visualizations and data science, I would say this is a good one-stop shop for all of that. And the tutorial is pretty intense. It takes not two gigabytes to get the tutorial file set up and running on a machine. And they open up inside of a Jupyter Notebook and kind of walk you through everything. Definitely, if I was doing a lot more in the data science world, I could see having a machine all set up and writing all this stuff because it kind of combines all of them together and is kind of maintaining some of those libraries underneath it and it builds on top of that whole SciPy, PyData, and they call it the PyViz ecosystem.\n\nYeah, in her article, the short article about it, she talks directly about her workflow and has kind of a starting out with a pandas data frame and then figuring out where that she would want to plot it. And it's dividing time in between this thing called HV Plot or if it's geographic data into Geo Views. And then if you're dealing with lots and lots of data, you might be looking at things like the data shader to be able to kind of give you another dimension for that. At the very end of it, building up the panel, which is the interactive dashboard or application for it. And she provides a nice little example, which uses Bokeh. It kind of creates some controls and within like, I don't know, it's like seven, eight, nine lines of code, you've created a whole dashboard set up inside there. And Bokeh is really nice. I did a whole tutorial on it. And not only is it give you a lot of interactive controls where people can kind of play with it in that dashboard sense, but there's like little save buttons to save what you've done. If you've done any kind of navigating of the data, you can kind of save out images from it, which is really nice. And to be able to set those things up, it's also nice because you can just output that whole thing as an HTML file, which has all the data and everything in it. It's like just a static file that you could host somewhere. Just pretty slick. So yeah, you should check it out. I think what I liked about this, you know, is that it kind of, you know, it starts with the pandas data frame, which is where a lot of data analysis starts. And then, you know, from there, it's kind of like, okay, well, if you want to have some sort of data visualization pipeline, typically you would go looking for these different projects, right? And try to kind of like build something that works for you, whereas, you know, if you're at that point of like, I just need to get something that works, you know, this can save you a lot of time. I mean, it's the whole sort of pipeline there for you. Obviously, opinionated, but it does look like it's pretty customizable. So yeah, I think, you know, if you have existing workflows and things, you know, Holoviz might not be something that you're going to fit into that, but if you're just getting started and you need to move quickly, it looks like this has got everything to get you up and running from end to end. Yeah, definitely. We've talked about a lot of these data structures. Um, yeah, kind of going back to previous conversations. We've talked about the collections modules and all the different kinds of tools in there. So this is a nice, another tool that's hiding inside there for people to kind of play with.\n\nYeah, it's definitely, I mean, it's one of those things, you know, I think if you're just getting started with Python, you probably don't want to, well, if you're just getting started with Python and also new to programming, you probably don't want to really worry about these kinds of things yet. And I think that, you know, from a design perspective, just the plain old Python list covers so many of the like, most common use cases and does it really well. You can go a long way without ever even knowing that you need something different. But yeah, once you kind of get beyond that, you know, take it to the next level, this is definitely a good one to be aware of.\n\nAnd it might even come up in some interviews. So yeah, definitely. My first one is from the Towards Data Science Medium blog, which we've mentioned multiple times. This one is from Sofia Yang, and Sofia is a senior data scientist at Anaconda. It's really a short love letter to this really powerful visualization and interactive dashboard tool called HoloViz. HoloViz is definitely a powerful package. It includes so many of the libraries you might have already heard us talk about, things like Bokeh, Matplotlib, Datashader, Plotly. It even goes much further than that and sort of combines them all into this overall overarching package that you can learn to work in lots of these different situations. It could be generally. We've talked about data visualization inside of notebooks or inside of Python files, but often, as a person who is creating data visualizations for other people in dashboards for people, one of the other things you might do commonly is create reports and PDFs or individual graphs coming out of these things or making like a server that serves those things out. This is another tool that could fit inside that. A couple things about it. This is a real short read. It really is just kind of giving you an idea of some of the things that are available in it and things that you can do with it. It's truly, in my opinion, a thing that works best in Anaconda or Miniconda. It seems to be much the preferred method for getting this all set up. I'm not saying you can't in other ways, but the way that it's sort of packaged and sort of distributed, it feels much more like that seems like a plan. And it's pretty big when you install it, like the footprint that I got after installing HoloViz was around 2 gigabytes for kind of everything that came with it, which is pretty big for a library. But again, it includes so many other libraries inside of it. And I will include links to the HoloViz documentation, which talks about the libraries that are inside of it. It mentions seven of them: Panel, HoloViews, GeoViews, DataShader, Param, ColorSet, and HPPlot. All the views. GeoViews is a great library if you want to do stuff with maps. DataShader takes the shading elements that you may want to do in some of your data visualization and actually amps it up quite a bit, which is nice. An area called \"param\" like parameter, and then ColorSet. And I just, you know, if you're interested in diving deeper into data visualizations and data science, I would say this is a good one-stop shop for all of that. And the tutorial is pretty intense. It takes not two gigabytes to get the tutorial file set up and running on a machine. And they open up inside of a Jupyter Notebook and kind of walk you through everything. Definitely, if I was doing a lot more in the data science world, I could see having a machine all set up and writing all this stuff because it kind of combines all of them together and is kind of maintaining some of those libraries underneath it and it builds on top of that whole SciPy, PyData, and they call it the PyViz ecosystem.\n\nYeah, in her article, the short article about it, she talks directly about her workflow and has kind of a starting out with a pandas data frame and then figuring out where that she would want to plot it. And it's dividing time in between this thing called HV Plot or if it's geographic data into Geo Views. And then if you're dealing with lots and lots of data, you might be looking at things like the data shader to be able to kind of give you another dimension for that. At the very end of it, building up the panel, which is the interactive dashboard or application for it. And she provides a nice little example, which uses Bokeh. It kind of creates some controls and within like, I don't know, it's like seven, eight, nine lines of code, you've created a whole dashboard set up inside there. And Bokeh is really nice. I did a whole tutorial on it. And not only is it give you a lot of interactive controls where people can kind of play with it in that dashboard sense, but there's like little save buttons to save what you've done. If you've done any kind of navigating of the data, you can kind of save out images from it, which is really nice. And to be able to set those things up, it's also nice because you can just output that whole thing as an HTML file, which has all the data and everything in it. It's like just a static file that you could host somewhere. Just pretty slick. So yeah, you should check it out. I think what I liked about this, you know, is that it kind of, you know, it starts with the pandas data frame, which is where a lot of data analysis starts. And then, you know, from there, it's kind of like, okay, well, if you want to have some sort of data visualization pipeline, typically you would go looking for these different projects, right? And try to kind of like build something that works for you, whereas, you know, if you're at that point of like, I just need to get something that works, you know, this can save you a lot of time. I mean, it's the whole sort of pipeline there for you. Obviously, opinionated, but it does look like it's pretty customizable. So yeah, I think, you know, if you have existing workflows and things, you know, Holoviz might not be something that you're going to fit into that, but if you're just getting started and you need to move quickly, it looks like this has got everything to get you up and running from end to end. Yeah, definitely. We've focused on a lot of these data structures. Um, yeah, kind of going back to previous conversations, we",
    "q8N3GaN0H4A": "Welcome to the Real Python Podcast. This is Episode 77. Are you a beginner or intermediate Python programmer who's made it through some of the fundamentals? Have you tried to tackle a big project but got stuck and frustrated? Completing some small projects might be the answer. This week on the show, we have author Al Swigert to talk about his new book, \"The Big Book of Small Python Projects.\" We discuss the advantages of sometimes thinking small in terms of Python programs. We talk about completing projects and the benefits of manually copying code by typing it in yourself. I'll also have suggestions about tools for beginners and intermediate developers.\n\nThis episode is sponsored by Rev AI, the most trusted way to build global speech-to-text to insights products and workflows. All right, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com. Hey Al, welcome back to the show.\n\nHey, it's great to be back on here again. Yeah, you've been busy. You've been making books all throughout this wonderful time. Yeah, that's been pretty cool. That's what I would like people to think. Yes, I've been very busy and productive and not just sort of staring at the wall during the pandemic. Well, it seems that way from the outside.\n\nI really like the format for your new book, \"The Big Book of Small Python Projects.\" So I have a bunch of questions about that generally, but I thought maybe we could start off talking about you were on a panel with a bunch of other Python authors at PyCascades, and I thought I could include a link for that. I think it's really interesting some of the stuff you guys got into there. It was basically everything, a very lofty title, \"Everything You Need to Know About Writing Technical Python Books.\" I saw that title, and I was like, I think we're going to need more than 45 minutes. So what were the kinds of things you covered in the talk? Um, mostly that it was, of course, a lot more work than I realized and just talking about the general",
    "oMSk9t_eI9I": "Welcome to the Real Python Podcast. This is episode 78.\n\nAre you a visual learner? Does it help to have programming concepts shared with concrete examples and images? Would you like to see if your child might be interested in programming? This week on the show, we talk with author Sherry Eskinus about her books, \"A Day in Code Python: Learn to Code in Python Through an Illustrated Story\" and \"Learn Python Through Nursery Rhymes and Fairy Tales.\"\n\nWe talk about the books and what inspired her to bring programming to picture books. Sherry discusses her goal of providing a fun way for beginners to experience learning to code. Sherry is also an electrical engineer with multiple patents and the founder of Sunday Electronics. We talk briefly about Sound Break, which is an audio device that alerts headphone users to outside sounds. Sherry's programming background is primarily in C, and we cover her path to Python. We also discuss how she's using Python and the Raspberry Pi to prototype new projects.\n\nThis podcast episode is brought to you by DataStax AstraDB, built on Apache Cassandra, now made easy in the cloud. Get 40 gigabytes of storage free every month at astra.dev/python.\n\nAlright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com.\n\nAfter the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey Sherry, hey Christopher, and welcome to the show. It's been fun going back and forth and talking to you and learning about the projects you're doing.\n\nYeah, thank you so much for having me on.\n\nYeah, so I guess maybe we should start right there and talk about you as an author. You started with a couple of books, and they're geared towards children. Maybe we could start with the first one, and then we can dive into the ones that are a little more Python-specific.\n\nYeah, sure. My first Python book is called \"A Day in Code Python.\" It tells the story of a fun day using Python code and teaches Python basics in the process. It follows from my first book, which is called \"A Day in Code,\" which is in the C language. So this Python book is a picture book that uses Python programs to describe situations in a story about two kids seizing the day. Each Python program acts as a code example, which is explained on the same page, and there's a full-page illustration next to it that shows the scene that's being described in code. For example, there's a program where the kids are flying kites, and each kite is represented with a Python dictionary that specifies its shape and color. There's a list of all the kites available from a rental booth, and then after the kids rent their kites, the kites they chose are removed from the list, and you see the kites they chose in the illustration. So it usually shows the event that the code is describing. It's not just a collection of random code examples that describe everyday things, but it's a story because it's a continuous progression of their day, with them sleeping, waking up, having an extravagant breakfast, going to the beach, having a great pizza lunch. You know, what a perfect day. So I wanted it to be really colorful and have the feel of a picture book. And the code itself is also colorful with syntax highlighting, which makes the code explanation below it easier to read.\n\nYeah, that really pops out to me. I noticed that, and I really like the illustrations. You've got a good partnership going on with that illustrator.\n\nThank you. I say that I have no artistic ability. I'm at the level of I can't draw stick figures, but I have artistic visions, and I work with a really talented artist who takes my rough sketches and ideas and brings them to life. So it's like, I'll say, in this drawing, show an open donut box on their towel on the beach, and two seagulls flying in the air with donuts in their mouths, and show the kids building a sandcastle and not noticing. So I'll communicate that. Besides using words, I'll use stock photos or illustration examples to show what I have in mind in terms of the rough appearance and positions of things in the drawings. And I guess there's actually a lot of back and forth and revisions, and there's a lot of effort that goes into each of the detailed drawings in the book.\n\nYeah, that's cool. Thanks. It's like I'll communicate that to the artist, and the drawings show an open donut box on their towel on the beach, and two seagulls flying in the air with donuts in their mouths. And show the kids building a sandcastle and not noticing. So I'll communicate that. Besides using words, I'll use stock photos or illustration examples to show what I have in mind in terms of the rough appearance and positions of things in the drawings. And I guess there's actually a lot of back and forth and revisions, and there's a lot of effort that goes into each of the detailed drawings in the book.\n\nYeah, it's pretty comprehensive in the beginner Python concepts that it covers. It packs it all in there into these programs. It's everything from the very basics with variables and operators to conditional statements and loops to functions and classes. I noticed that some beginner books, particularly for kids, don't even cover the topic of classes. And so I wanted to include that.\n\nWell, besides seeing that it wasn't mentioned in a bunch of beginner books that I looked at, I thought it was important for Python because I saw classes being used even for the Raspberry Pi, for example, which is geared towards kids and students and hobbyists. So yeah, I thought it was important for that to be familiar.\n\nYeah, I totally agree with you. The idea that the language is so, everything is an object in the language. And speaking about the Raspberry Pi and electronics, I was just talking to Scott Shawcroft about CircuitPython and how that's such a common thing. Like you're bringing in literally these objects like, okay, there's this thing that is the touch sensor and being able to address it in kind of a different way and that it has its own methods and things. Those are crucial, sort of fundamental concepts that people could need to maybe get introduced early.\n\nYeah, definitely. The program that introduces classes actually involves a futuristic salad bar concept. And it's about modeling creating a salad with a class. It's like, as the illustration shows, it's this touchless salad bar in which you select an ingredient you want, presumably with a proximity sensor detecting your hand. And then, I just randomly came up with this, the ingredient, let's say tomatoes, flows down the chute into your salad bowl. And there's a row of labeled shoots for the different ingredients and all you can eat salad bar. And so, I'm not sure if I'm the first to have thought of that, but I'm throwing the idea out there for someone else to implement.\n\nThat's a cool idea, the limitless salad bar restaurant. Although that would be fun to do, but yeah, it would take a lot of time and funding. So that's my free idea I'm just getting out there.\n\nYeah, I'm gonna toss it out there. Yeah, see if that becomes reality. There used to be all these great salad bar sort of concept restaurants and they kind of have, I haven't seen them as much. I don't know, Sweet Tomatoes is still even around.\n\nOh my gosh, actually, so I know the story of the Sweet Tomatoes. Apparently, yeah, I hadn't heard of that name because apparently in California, it was, past tense, known as Sweet Plantation. Oh yeah, okay. In other states it's like Red Tomato and Sweet, okay. And like the pandemic started, they just went out immediately basically. So they should maybe they can do this now. Yeah, there you go. This is like touchless and just set it all up. I think of the robot, you know, this is a more adult thing, but the robot bar in Vegas, I saw where you could basically punch in the drink and the robots, all unfortunately replacing jobs that bartenders would have, but it seemed like such an interesting idea.\n\nYeah, like you always need people for the maintenance though.\n\nOh yeah, absolutely. And running things and yeah, in the design and everything.\n\nTotally, yeah.\n\nBesides the classes area, what were some of the other concepts in Python that you were excited to cover in the book?\n\nA big part of it is conditional statements and loops because describing things logically, it often just comes down to an if-else statement or if-elif-else. And so a lot of the programs involve conditional statements. Like I think I covered practically all the major beginner topics. So it's just describing the logic of an event with the code. I also include one program that has class inheritance where they're eating dessert and the cake that they're eating is a child class of the dessert parent class. So that's kind of like the most advanced concept I think that I have in there. So it kind of starts off really from the very beginning, being just a program with three lines that stores a value in a variable and prints text to the screen. And then I have a for loop after that, but I describe all the different parts of it below the program. So the programs do build up in complexity, and they're all explained below each program. And so you don't need any prior knowledge as you're reading the book.\n\nDid you find, I'm guessing there are a lot of shared initial concepts because they're both sort of beginner books, but were there things that you thought worked better in this format with the Python book compared to the C book or were they really similar?\n\nAre you talking about A Day in Code Python versus A Day in Code?\n\nYeah, so actually they're very similar. What's funny is it's like, I'm a, my background is actually in C programming being in electrical engineering. And so that's why I actually started off with C programming. Everyone was asking me, why did you choose C? Like that's so weird. And so Python just seemed like the next obvious choice because it's so popular, it's everywhere. And so with the first book, I just thought of describing a day because it's a day in code. So it's describing a day and so it just contains these programs that describe these fun events that they have in the day. And so I thought of creating the Python version that would be like the same, like using the same events. At first, I thought it would be very similar, but then after seeing how Python had these data structures for data, like the dictionary and list and tuple, and I realized that I could actually create some very different programs from the C programs rather than just translating from C to Python. I could create some very different programs based on the data structures that Python has that C does not have. That made the programs that really fit with describing real-life situations with code using the Python data structures.\n\nThat's interesting. Yeah, because that's definitely one of the things that I've liked about Python in general is that it's very readable, mainly using white space for sort of structural constraints. And so you can kind of read through the paragraphs. How has the reception been? I'm not sure how long it's been out now.\n\nIt's actually, well, so I delivered to Kickstarter backers a few months ago, and then it actually became publicly available through Amazon and other online retailers just last month on July 27th. And so I have gotten good feedback from people saying that, particularly Kickstarter backers sending me messages and telling me that it has been useful for their kids. And actually, I've also gotten a lot of people who are adults telling me that the books helped them learn to code and describe things in a simple, easy to understand way. And so that's why I said the book is for all ages, despite being geared towards kids as a picture book. I think anyone can have fun learning the basics starting off with this book.\n\nCool. Like, I know there's a lot of adults who like to read, you know, all different levels of books, and I definitely think being someone who isn't from a CS background, I think this is a really great and novel approach, and I also like that all of these stories and the programs that are being walked through have not fictitious names of things. They're actual things and actual activities, and it's something I've been harping on, probably people have noticed that that's a trend for me on the podcast is like, I'm not a big fan of foo and bar and variables named x and things like that. I think that this book is a really great example of that and how that becomes way more tangible, not only for a kid, but for just, you know, early people learning something.\n\nYeah, it's definitely a unique method. I know there's other books that have some programming examples involving like cake or something, but this is the first book that is actually continuous as a story from morning till night, connecting one image, one page to the next, just like for a normal picture book where they have an open donut box on their towel on the beach and there's you see seagulls eating the donuts, but then on the next page you see that there were two donuts left over because you see the two donuts on the next in the next illustration. Yeah, so it's continuous.\n\nYeah, and the code is all, you know, runnable code. It's all run. Oh, yeah. So that's another thing where it's like interactive. So you can run each program on your computer and every program outputs text to the screen with one or more print statements. And so that's why I encourage people reading the book to run the code and also modify the code and see how the output changes. In general, the reception has been really positive from kids. People are telling me that their kid loves the book and it's a really unique idea.\n\nIt's awesome.\n\nThis podcast is sponsored by DataStax AstraDB, built on Apache Cassandra, now made easy in the cloud. Create a free Cassandra database in minutes for global scale on a startup budget with 40 gigabytes of storage free every month. Visit us at astra.dev/python. That's A-S-T-R-A.dev/python.\n\nSo I had this question and it kind of got answered very early on here in our discussion, but I had asked like, what are the types of books you'd like to write in the future? But you've already got one. I don't know if it's complete or not, but you've already got a Kickstarter for your next book, right?\n\nOh yeah. So it's, what's funny, it's called, yeah, it takes everything I say it takes us to the next level. This is next level. Learn Python through nursery rhymes and fairy tales. So what's funny is like my last book, it's just that kind of coincidence. I don't know how, like my last book, it kind of had a castles and dragons theme, a day in code Python. Yeah. Yeah, don't be fooled by the beach scene on the cover because like it starts off with once upon a time and like their computers are telling them stories with castles and dragons. You can see castles and dragons on their computer screens. And then as the story goes, they have an adventurous day and they want to tell the story to their computers. And so that's the context for the programs in a day in code Python that those are programs that the kids wrote to be able to tell the story of their day to their computers. And in the day that the day that they describe, there's allusions to the castles and dragons theme. So like they, there's someone flying a dragon kite. They win dragons at a carnival. They're jumping in a bouncy castle. Yeah. And there's a castle in the background while they're playing mini golf. So you think that that would kind of make you think about fairy tales. And even though that might have like subconsciously influenced me, for some reason, I just randomly thought of this idea of walking outside one day. So I wrote out the code for this concept for learn Python through nursery rhymes and fairy tales. So it translates classic nursery rhymes and fairy tales into Python programs. And it's currently on Kickstarter for pre-order. And so what it does is break down the classic tales logically and describe them with code. So it's a similar concept to my last book, but of course you're already very familiar with these stories. And the programs output the text of the nursery rhyme or fairy tale, which is embedded in the logic of the program. So for example, on Kickstarter, it shows the last page of a sample code page of Goldilocks and the Three Bears when she's trying out each bed. The program consists of if-else statements that test if the bed is too soft or too hard. And it prints either that the particular bed is too hard or too soft or just right. And it also includes the sleep function that creates a delay and represents Goldilocks sleeping. And so that was just, that was too good and I had to include the sleep function there.\n\nYeah, I was gonna ask you what would be your favorite story to portray in there, but that is a perfect one for those sort of conditional things.\n\nYeah, I know, thanks. I was actually surprised how there's actually a lot of other, I don't want to give away the book beforehand.\n\nNo, I understand. Like I have two sample pages, but yeah, actually I was surprised at how a lot of these nursery rhymes, fairy tales actually fit very well and elegantly into being described with the Python code. And so like the other sample page I have is showing the nursery rhyme, the Muffin Man in it. So it uses the Muffin Man's name and address in a Python dictionary to print out the exact words of the Muffin Man. And so yeah, that's a, I like that nursery rhyme.\n\nCool, that one sounds like a lot of fun and definitely a nice follow-up for the other one that I think that's a good fit.\n\nYeah, definitely. Actually, so this book will also, just like the last book, it will comprehensively cover all the major beginner Python topics, but there's a few minor concepts that I didn't include in my last book like this, like for example, the string format method and the ternary operator. And I plan to include that in this fairy tale book. But I'm not going to include class inheritance in the fairy tale book like I did in A Day in Code Python. It'll still include classes though. And another thing is A Day in Code Python uses the random module in a few programs, but in this fairy tale book, I'm not using it because nothing is random. The stories are already set in stone. And so I think the two books will complement each other. Although they'll still both cover all the major beginner topics, there'll be a few different extra topics in each one. So yeah, I think it'd also be useful just to see code being combined and used in different ways.\n\nWhat were some challenges in trying to write for this sort of target audience? I know that there's a larger potential audience, but for writing for kids, what was something that was challenging about conveying it in this format?\n\nI think that what I had to be conscious",
    "x3J0WD4Nhb4": "Welcome to the Real Python Podcast. This is Episode 79. Where are you along the path of learning Python? Do you feel like you're making progress, and what are ways you can put the learning path into a more precise focus? This week on the show, we talked with previous guest Martin Bryce about his recent article, \"How Long Does It Take to Learn Python?\" Martin discusses methods for measuring your progress and the various reasons for learning the language.\n\nWe talk about how different backgrounds will affect your approach. We also suggest resources to help you along your path. We share a couple of recent Python projects to round out the episode. The first is a library to draw stylized maps from OpenStreetMap data. The other is a framework for the analysis and visualization of trees, which includes a set of phylogenomic tools. This episode is sponsored by Rev AI, the most trusted way to build global speech-to-text insights products and workflows. Alright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey Martin, welcome back to the show.\n\nHi Chris, nice to be here again. Yeah, so it's a lot of little changes here with the Real Python family, and since we last spoke, you've become a full-time employee with Real Python, changing from what you were doing before.\n\nYes indeed, yeah, it's cool. So what are some of the things that you're doing now that you're part of the core team?\n\nI'm basically working here as a content creator, which just means there's a lot more of what I've been doing before as an external author and video course creator. So I just make more content, plus and now I also do reviews, articles, and videos that other course creators make, and a little bit of interacting with the community and answering comments and being present on the Slack channel. Things like that.\n\nI guess, as you know, since we're working in a pretty small team, there's always a lot of additional startup-type tasks that come along that didn't just get tackled on the site.\n\nYeah, there's a lot of cross-pollination and different skills being used across different lines.\n\nYeah, I appreciate your help with the reviewing of the videos. That's been great.\n\nYeah, it's been really fun. I've been doing similar things before, and since I've already seen both pipelines, that both the written side of content creation and the video one, it's nice to be a bit in between and get a bit of an insight into all the parts that are happening. Yeah, it's a neat machine to kind of watch it work.\n\nI wanted to have you come on to talk a little bit about the article that you recently had published on the site that asked the question, \"How long does it take to learn Python?\"\n\nYes, the question of all questions. Yes, you have like a one-sentence answer. Yeah, it's exactly 3.4 weeks.\n\nOkay, cool. Great. All right, so why did you end up picking that topic?\n\nI've been working with a lot of students before, and this is just a question that comes up a lot because I think it's partly because of how Python gets presented as this very beginner-friendly, easy language that you just pick up in a weekend, and then you're ready to write production-ready apps or whatever. And there's quite a lot of this sort of blog posts out there where someone's like, \"Oh, yesterday I woke up and decided I'm going to learn Python, and by the evening I had a functioning mid-level startup going.\" Not extremely realistic.\n\nNo, not extremely realistic. I mean, I don't know. Maybe there are some people who really manage to do something crazy like that, but I really think that there is much more to learning anything and also to learning Python, obviously. Like, it depends a lot on what's here. How do you come into starting to learn Python? What's your background? Also, what's really your aim? What do you want to do with it? And then also, what are the resources that you have available, both in terms of time, as well as learning materials and all of these factors really influence quite profoundly, I think, of how fast it's going to be for you specifically to learn Python.\n\nYeah, I think that'd be great to kind of tear some of those apart and dive deeper into them.\n\nYeah, maybe we could start with a little bit of your background. I know we might have talked about it earlier, but we could just talk a little bit about specifically you getting into Python.\n\nSure. For me, I started programming pretty... I don't know if it's pretty late. Who cares, right? Exactly. Who cares about time, right? I haven't been doing a lot of those kinds of conversations. I'm more like kind of been focusing on... Like, what are people doing now with it? But I think in this context, it'd be kind of interesting to see like how you kind of pivoted into specifically Python.\n\nYeah, sure. So I started Python as the first programming language that I picked up, and I started programming really out of the ambition to get a bit of a better understanding of how to think mathematically, I guess. I kind of had the feeling I was always more on the side of... We think about literature, or what's that called actually? There's like a term for this. The Liberal Arts, I think that's what you call it. It's like learning for learning's sake in some cases, and it's very broad spectrum. Like, I really want to get as much as I can out of this collegiate or university experience, and like very broad interest and, you know, just not very scientifically mathematically, I would say. Okay. I kind of had the feeling that this part of the world, or this part of thinking about things, I didn't have it as developed as the other part, and I kind of at some point after school, after university even, I kind of decided that I'd want to invest some time and energy into developing this side of, you know, perceiving the world and just thinking about stuff also a bit more. And it's just going into pure mathematics didn't seem accessible at all. This is this feeling when you look at the Wikipedia math article for me, whereas, where it's just spiked with formulas everywhere, and it's just kind of, yeah, like a foreign language that's really hard to get started on, you know. And programming in itself seemed like a more approachable way to go into that direction because it just has these words that you're working with. Like, you name something, you give it a name, and then you work with the name, which makes it much more approachable for me at least. And so I went into that and also really enjoyed the aspect of that you can actually create things and that you can build something, you can be, you can be quite creative with programming and make little programs that do something that work or build websites that display something and look beautiful if you've got a knack for it or train how to do that, you know. And that's just, that's always been fun and engaging for me. So it's been a way for me to have project-based and actionable things to look into the more mathematical side of my brain, I guess. And train that. That's how I got into it.\n\nIt sounds like you have kind of defined two of those things then. Partly why you wanted to learn Python was partly to explore those areas, correct?\n\nYeah, and I've tried to also lay these out in the article a bit to give readers a chance to just get their own, like a good understanding for what it is for themselves, like why are they really into that and just give a couple of examples. And yeah, I think for me it was a lot of this curiosity and just also wanting to understand how do a lot of things function. You know, you work with a computer or a phone on an everyday basis, but how do you move from being just a consumer of these things to a little bit a creator or at least, you know, an understander? I know that's not a word, but you know what, okay.\n\nYeah, mine was a little more on the side from the article you were writing about where it was a practical, very specific thing where this job position that I was looking at, they were interested in someone who had much more of a Python background. They at least had started to dabble in it. And so I'm kind of one of those people where I had dabbled in lots of different languages. I had, I've said so many times on the show like the main one I was focusing on was working in creating lots of things in SQL and creating things inside of kind of specific tailor-made applications. And then I had dabbled with Swift and Objective-C. And then long time ago had done like C and Fortran and things like that. So it was like, okay, I want to hone up on these things. At the same time, I was dabbling in JavaScript and so forth. So it was kind of a hard pivot. And then I do that immersion thing, which I've said several times on the show, where like I want to get every resource possible in front of me, videos, podcasts, you know, what have you, and I'm going to dive in and learn all this sort of stuff. But with a specific aim of like you wanted to improve for a job, yeah. There's this position I wanted, yeah, yeah, exactly. Yeah, that's a, that's a just like, you know, every reason for for doing this is a completely valid reason for going into it. But they're probably going to make you focus on different aspects and it's probably going to mean that you're going to be faster or slower or just learn different parts of the language because the whole ecosystem around Python is just so huge that learning everything is just unrealistic, you know?\n\nYeah, I was just listening to the conversation with the new director in residence, Wukaslanga, about, you know, he's got this backlog of 1,400 pull requests or whatever for the, you know, C Python and, and every time he goes in to look at one of them, it potentially is a new part of the language that he's looking at, you know, the standard library is huge, you know? And this is just speaking of, you know, core Python, if you want to call it that, versus like the expanded universe of all the different things you can do inside of Python. So, yeah. Mine was like, they were looking for somebody to do automation and potentially build like dashboards and so at least I was able to focus in and and and look at some very specific things, which I think is maybe good. Like it sounds like you were interested in like, okay, I want maybe I want to try to do some web stuff with this. So you can kind of focus on that because I think you could really bite off way more than you can chew with all the different possible things you can jump into.\n\nDefinitely. And that's been actually kind of hard for me at the beginning because of not having such a like a clear aim, I think of like what why am I really doing it? Just for exploring, you know? Sure, there's a lot open to you, but it's also it doesn't really give you any rails to go on, right? I guess, yeah. And, yeah. I also, I started with Python, but then I went into a couple of other languages, just very much at the beginning and played around with R and with JavaScript mostly, those two I guess, but also some other things a bit. And it doesn't make it easier to learn the ground ideas of programming. So I think if you have like some sort of this direction beforehand, it's probably really helpful, yeah.\n\nIt may be best to sort of, well, maybe this isn't a good analogy. I was going to say like if you're digging a hole yourself in yourself, I don't know, I'm going to go with it, you may want to dig down a little deeper before you start just going across. Oh, I see. And the bad part about this is that it's just going to fall in on the sides. Yeah, potentially, I guess. I don't know. Maybe this is not a good analogy at all here. Let me break the subject up.\n\nThe idea that you were talking about of going to like the Wikipedia for math, I saw this thing on Twitter the other day and I, it like kind of blew my mind a little bit because I'm the same way. Like, you know, certain things, you know, one of the things I like about Python is the white space and the way it looks and sort of, in my opinion, the readability of the code. And that's one of the things with higher order mathematics or potentially statistics that they like to use these interesting Greek symbols for things, right? Like sigma and phi and all these kind of different things, right? And so there was this person who posted like those scary looking math things, they're simply for loops, and they explained like how you can take the numbers from above, you know, okay, that's your n, and then this is how many times it's going to loop around, and then this is the actual, it's either summing or it's creating a product, and they had it do a little conversion. I'm like, oh my god, that was a nice explanation. So I'll share that on, that's awesome from Twitter, yeah. It's actually really cool because, you know, it's one of these things, like if you don't live in that world and you don't have it explained well to you, it can be rather hard to think. And now that I've been working with for loops a lot more, like that's a very easy way to kind of pivot it and change it and make me think about it. And I think all those things are really helpful. Like the recent conversation I had with Sherry Eskina, she wrote this series of books that are illustrated. You could think of them as children's books, but they're also a really great way to do like visual learning of something in Python, and having very specific stuff. She's kind of telling these stories. So the first book was like kind of this day in Python, a day in code, and these kids kind of go through their whole day, and the whole premise is like that you're writing the story and code to tell the computer what your day was like and what you did, which was kind of interesting. And then the next one is like taking fairy tales and kind of exciting kids to get into programming by having sort of physical stuff, but the world of sensors have, you know, or affordability of like individual sensors have made the idea of creating your own weather station or creating your own other devices at Internet of Things kind of things inside your house with tools like MicroPython and CircuitPython are really kind of allowing that world to kind of open up. And maybe that's you might be thinking of programming as a hobby or another area that you kind of can explore.\n\nTotally. And just and creativity. You can do digital arts with programming or or just build some fun idea that you have in your head, you know, there's there's really a lot of things you can do. Yeah. I, that's been kind of one of these also transit, you know, definitely on my side of things that I've been trying to include as far as you know things on the podcast to share projects and stuff. And I have another fun one this week, you know, as things around like games or small projects and one of the ones that I kind of keep coming back to is like being able to build stuff that you can complete, you know, like tackling projects that you can kind of finish. So like if that's if that's your goal, keeping your sites kind of a little small initially and then building up, like I've talked to a couple people about sort of game sort of stuff and it's nice to be able to make that list of things that this isn't going to do. Like my game is going to do these things initially, but I'm not going to focus on all these other things. And you know, maybe those are like to do later kind of stuff. I feel like that's kind of related to that idea of when you're learning a language, especially something that is as vast as Python that you might bite way more than you can chew and you get sort of stuck and paralyzed. I don't know if you've had that experience.\n\nTotally. Yeah. And if you define your scope like you said at",
    "nmMFV0qXMnY": "Welcome to the Real Python Podcast. This is episode 80. Have you wanted to create a Python application that goes further than a command line interface? You'd like it to have a friendly interface but don't want to make it a GUI (Graphical User Interface) or a web application. Maybe a TUI (Text User Interface) would be a perfect fit for the project. This week on the show, we have Will McGougan to talk about his projects Textual and Rich. Rich is a Python library for writing rich text to the terminal with color and style. It's a great tool if you want to display advanced content such as tables, markdown, and syntax highlighted code. We talk about how Will started on the project and how it's developed over the years. We also talk about Will's new project, Textual, a TUI using much of Rich at its core. He shares how the project is coming along and what are challenges in developing this type of application. We discuss how a TUI has more in common with CSS and web development than command line or graphical interfaces. We also have a quick announcement at the top of the show from Sea Python developer and residence Lucas Longa about next week's release of Python 3.10. This podcast episode is brought to you by DataStax Astra DB built on Apache Cassandra, now made easy in the cloud. Get 40 gigabytes of storage free every month at astra.dev. All right, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nSo I have a special announcement from an upcoming guest about the release of Python 3.10, and I'll let you take it from there, Lukash.\n\nHi, my name is Lukash Langka. I'm the release manager of Python 3.9 and 3.8. Those are ancient versions by now. So what I would like to invite you to is the release party of Python 3.10, which is going to be happening on October 4th and led by Pablo Galindo Salgado, who is Python 3.10's release manager. There's going to be me, him, and a bunch of other guests on Twitch. You will be able to comment and celebrate it with us and as well just see how a release is actually happening in real time. So again, you're very welcome to attend this with us. Stay tuned for the actual announcement with links. I don't have one yet. It's still upcoming where I'm standing, but see you on October 4th. Cool. So they could maybe check out, like, your Twitter feed or Pablo's feed and get the actual Twitch link at that point. Oh, yes, absolutely. Okay, cool. I'll make sure to include all that in this week's show notes. Now on to the interview with Will. Hey, Will, welcome to the show. Hi, it's nice to be here. We were talking just before we got started how I had been mentioning your projects a lot in my episodes with David Amos and we talked about Rich being used in a lot of these sort of REPL replacement tools. And then we saw the article about the Rich Dashboards thing that was around February of this year. And then with all these interesting developments with Textual and Rich, so I was very excited to get you on to talk about those things. And first off, I don't know if you want to just kind of maybe give a background on Rich as a project and what it is. Will: Yeah, sure. Rich is a Python library for color, style, and formatting to the terminal. There are numerous objects you can write to the terminal to produce Rich formatting such as tables, panels, things like Markdown. It's a large library but it does all these things and it's all quite integrated together. Christopher: Yeah, I really like the, I was looking through some of the documentation and some of the built-in methods and different tools that you have there like you said, like the tables and just sort of formatting things. What are some examples of libraries that are using Rich right now or projects that you know that are using Rich? Will: There's quite a few and recently I found out that HTTPX, oh, okay. That's a Python library which is kind of like the next generation requests. They've got a command line application and they're using Rich there. So if you request an HTTP endpoint, it'll show that with syntax highlighting, nice for HTML and JSON such. Give you a bit of a step above like the basics of pretty print and things like that. Christopher: Well, this isn't pretty printing per se, this is syntax highlighting of the response. So it'll show you the header with various color and style to make it a bit more clear or easier to read and the HTML be highlighted so you'll have the tags colorized. It makes it easier to scan in the terminal when you're kind of like testing API endpoints. Will: Yeah, that makes sense to kind of just be able to see at a glance what's happening and what's coming in. Cool. Yeah, what got you interested in creating this project? Will: So it goes back quite far actually. I was working on another project, my web development framework called Moya, and in that I needed a way of writing to the terminal and I wanted to write content which there wasn't libraries out there to do that, you know. I wanted to format things and start bolding and italic and stuff and there was a few libraries to do it but they wouldn't handle things like text wrapping, you know. You write out a sentence and when it gets to the end, it'll just fold over and you'll get half a word cropped at either end. So I started writing my own routines to do that kind of stuff and it got bigger and bigger and yeah as it does, it always does and it became quite sophisticated. But it was never intended to be used outside of that library but I do think that it had some good ideas there, you know, some things that should probably be offered in an independent library and years afterwards every time I need to write to a terminal, I think, \"I wish that existed.\" You know, I wish that library existed that I've got in the back of my head. Yeah, and after a few years I think it was more than four years I've been thinking about this library and they still didn't really exist and there was lots of libraries that wrote various things to the terminal. Those libraries that did color, those libraries which did style, those libraries which did tables, several libraries which did tables and syntax highlighting and all sorts of things and they were pretty good, you know. I had no major issues with these libraries, they were well written libraries, but nothing which integrated that all together. So I started working on this idea that in my head for four years put it together and the first thing I did was console markup and this is my idea of having a string and be able to start tags, much like HTML but using square brackets. So you're familiar with BB Code, there's like BB Code so you have a tag which says \"bold\" on and then some text and \"bold\" off, etc. that kind of thing. And so I implemented that and I found that quite useful and then I started adding on all the other ideas that I've been thinking about for years and it grew and grew from there. Christopher: Yeah, I've seen it. It's kind of built into these sort of different REPL replacements. I think maybe because they can kind of build on top of the syntax highlighting that you're doing. Yeah, how does that work? Is it parsing individual words or bits of code and identifying them and sort of grouping them? Will: So there's two types of syntax highlighting that goes on. There's fragments based highlighting. That's another library which does syntax highlighting and that you give it the string and you tell the format and then it's got a parser built in that applies it, tokenizes it, and gives it colors. And Rich takes that and that information and then renders it. But there's also another syntax highlighting going on which is something I've created which uses regular expressions. It works quite well for wrapper strings. The thing about the output from wrapper, it's not a formal language which you can come up with a grammar for. So for that, I use regular expressions which seems to work quite well. I can have regular expression for strings which picks out strings and I can highlight those green and anything which looks like a tag, I can highlight that as a tag. And 99% of the time, that syntax highlighting works quite well. Christopher: Moya, you're using that on like your personal site, right? Will: That's right, yeah. My personal site is built on that. Moya has a touch of sadness because no one ended up using it and I worked on that for four years. It's a crazy system. I think it was a revolutionary, but no one ended up using it. It uses XML throughout, so my blog software, for instance, is essentially written in XML. Christopher: Oh, wow. Will: I think, yeah, there's a lot of people have maybe mixed experiences with XML. Christopher: Yeah, and I think that they might be shied away from it like I personally worked at a bank in mortgages and a lot of the vendor, you know, like the external software vendors wanted things sent and received in XML, yeah. And so I think I might have had an allergic reaction if I would have heard you saying that it uses XML, which is not nice to say, but I think that do you think that would be something that affected the uptake of it? Will: Definitely. You're not alone, a lot of people don't like XML and I don't think it's necessarily the fault of XML itself. It's the fault of the applications of it, which seem to be very verbose, yeah. And you end up playing quite a lot of convoluted XML which seems like just making the task in hand harder. The nesting was never easy to parse, in this case, what I was working with and then again, I was converting from SQL which has its own... its own arcane kind of structural stuff that you need to be comfortable with before you come in and out. So, I could I could kind of see as a system I could maybe see how like it would be easy to convert back and forth between that and HTML. Christopher: Yeah, it doesn't... it actually doesn't use the XML for the output. I think, gosh, it's been years since I did this, but I think there are text templates but it's actually the logic that's in XML, okay? And it's not too verbose, I have... I worked quite hard in kind of compressing it into things which are kind of short and expressive and I did this because I noticed that doing web development, I solve the same problems over and over again, yeah. They're not exactly the same problems, they're not like cut and paste type problems. You write a lot of views and you're essentially thinking to yourself, \"Well, I've written this dozens of times.\" So I thought, \"What if I could have something which was higher level? I just needed to tweak the things which change and then keep the rest to keep the routine the same.\" And I found that XML was quite good to express that. It was often better than Python or higher level languages. Christopher: Yeah, it looks cool and the Moya site is really beautiful. Will: Thanks. In fact, the Moya site is really beautiful, MoyaProject.com. Christopher: Let's just send some love that way. Have people check it out because it looks really cool. Were you doing it for multiple reasons? Were there specific things that you needed to solve with it? Will: No, not really. I was working quite heavily in web development and I use Django mostly, okay. And there's lots to love about Django and the documentation, the community, yeah. But again, I found development very repetitive and I kind of wanted to make my life easier and create something which I didn't have to repeat myself quite so much, okay. As far as sort of code that was required in each step of the phase of building a Django site that you had to keep adding these required blocks of things. Christopher: Yeah, there's quite a lot of boilerplate, I think, in kind of like the different phases of building a Django site. That you had to keep adding these required blocks of things. Will: Yeah, there's quite a lot of boilerplate, I think. My mission as a developer is to remove boilerplate, I think. Almost a character for character level is things which exist that's for the computer or the machine, yeah. And things which exist for you to express what you want, yeah. And you want to get that balance where you might much less code for the machine and more code for the human being, yeah. And I'm not knocking existing systems because they're quite powerful. Django is powerful, it runs loads of websites around the world and Flask and all these projects. But even so, I think a lot of the code you write is boilerplate. Maybe it's like one-third of the code expresses a human being's intent and the rest is the necessary machinery for the machine to understand it, yeah. Christopher: I was thinking about that and that made me think about the recent the Co-Pilot thing, you know, the GitHub Co-Pilot. Will: Yeah, how it's",
    "BjajuRgp8Yo": "Welcome to the Real Python Podcast. This is Episode 81. Python 3.10 is here this week on the show. Two former guests and Real Python authors returned to talk about the new version. Garana Giela's article was posted to the site Monday, and it's titled Python 3.10 Cool New Features for You to Try. Christopher Trudeau's video course came out on Tuesday, and it covers the topics from the article with multiple visual examples of Python 3.10 code. Garana and Christopher work together to create code examples of the new features used in both. We talk about more user-friendly error messages, structural pattern matching enhancement to Python's type system, and much more.\n\nGarana and Christopher not only cover the new features, but they offer advice about ways you might incorporate them into your code. We also discuss what you should think about before running the new version for your projects. This episode is brought to you by Snyk. Snyk is like Grammarly for your code. Secure your project with vulnerability scanning and automated fixes. Try Snyk for free at snyk.co/realpython. That's snyk.co/realpython. All right, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nWell, I want to welcome back Garana and Christopher Trudeau. I'm excited to wrap up this sort of Python 3.10 week here where we have Garana's article and then Christopher Trudeau's course. We're going to cover lots of these high-level features initially and then dive into some little grab bag of additional things at the end. Thanks for coming back on the show.\n\nYeah, thank you so much for having me. It's always fun to be here.\n\nYeah, glad to be here. If you're ready to dive in, maybe we could start with talking about the improvements. And this is something David and I have talked multiple times in the progression of Python 3.10 about better error messages in Python 3.10. But if you want to take that one first, Garana.\n\nYeah, so one thing I feel like just with the new sort of annual schedule for Python where they kind of do the releases more regularly and so on, we kind of get the news as well of new things happening. So that when you run the news show, we kind of have heard about some of these things. Yeah, it's been neat. But yeah, essentially better error messages. It's an issue I believe by Pablo Galindo Salgado who is the release manager for 3.10 and 3.11 and essentially working on some of the error messages in Python that sometimes may come off as not very friendly. You kind of leave out the quotation mark or something and it just tells you something like \"EOF at the end of\" or \"EOF\" whatever that means and things like this. So now they're kind of going in, especially on the syntax errors, to make them more precise and more helpful and actually give you suggestions on what is happening. So for instance, if you are leaving out a quotation mark, that would kind of mean that Python, the parser, just runs to the end of the line. That would be an EOL in the old syntax, but now it will kind of actually tell you that there's an unterminated string literal and it'll point to where it started and things like this. And they've done a whole bunch of these. Also, if you're kind of messing up, especially for dictionary syntax or similar things where you might leave out the colon between your items or a comma between items and things like this, it will precisely tell you exactly what you've done so you can kind of go in and fix it instead of being confused by in the old days it would typically just say something like \"invalid syntax\" and then give you a line number that was soft, just wrong. Even, yeah, it'll be like maybe like the last thing that it recognized. Which is kind of weird because that's probably correct, but like everything after it may not be, so it was very confusing. Yeah, and it's, I believe, it's partly due to the new parser that was introduced in the latest in Python 3.9. The old parser was kind of very naive and kind of could just move forward essentially so it couldn't really backtrack once it hit something that it didn't understand, so it would kind of often give you the errors on the next line when it finally realized something was wrong, especially if you're inside some kind of parentheses or brackets or something like this. Yeah, so not only you were talking the parentheses or the quotation marks, but also like, you know, opening and closing of the brackets and pointing to where they started, exactly. I'm really excited about this. Were there other examples that you noticed, Chris? The feature there that I kind of actually had some fun with while I was writing up the course was the suggestions feature. This is something that I've seen in a couple terminal shells now where you type, you make a typo, and it says, \"Did you mean this instead?\" Yeah, and they've added that support to the error messages as well. So if you import the collections library and then try to grab a named tuple out of it and you spell named tuple wrong, it'll say, \"Did you mean named tuple?\" And when I was writing up some of the sample code for the course, it actually helped me. Once I was, I don't remember what error I did, but it was, I typed something wrong and it was like, \"Oh, you meant this.\" I'm like, \"Oh yeah, yeah, I did. Thank you.\" That was helpful. It's a little bit like, um, what do you call it in the editors where they, uh, the auto, auto complete? Auto complete. Yes, thank you. It's, it's a little bit like auto complete, but inside of the REPL. That, that was kind of a neat little feature. The other aspect of it, I find lately I've been on and off helping one of my younger nephews learn some of the coding and a lot of the syntax errors. Just, you know, 13 year old kid doesn't get it right. Like a syntax error, invalid something, doesn't, is not particularly helpful. And now you see things like, I think you forgot brackets or, you know, this should have been double equals instead of a single equals, much, much more readable, much more friendly for, for new coders. The term better is sort of an interesting blanket statement for error messages in the sense that, you know, it's like friendlier or more specific or, uh, lots of these things that are kind of under that, that umbrella of better. But, yeah, it's nice to see these changes. Yeah, I think, this, this, this will both make it much easier for beginners, but also for us more experienced coders, that it will cut down on my debugging time, essentially. So I'm really looking forward to it. Cool. So the other one that has come up on the podcast multiple times up to now is the structural pattern matching. Chris, do you want to talk a little bit about that? Sure. So if you've come from other programming languages that have a switch statement, this is that on steroids. If you're not familiar with it, essentially it's an alternative to large if-then-else blocks. There are two new keywords introduced, one called match, the other called case, and you declare one of these pattern blocks by saying match and then giving it a thing to match. And this is usually a variable. And then inside of that match block, you have one or more case statements that are patterns. And if the pattern fires, then the block underneath that case statement is what gets executed. So in the course, one of the simple examples that I use is I match on name and then has a case with the string Guido. And if the person's name is Guido, then it prints, \"I'm not worthy.\" And if the case is the default case, which is everybody else, which you do with an underscore, then it just says, \"Hello to you.\" So this is a really simple case. And honestly, it's not much of an improvement on if-else. It's about the same amount of code and looks about as complicated. But that's sort of the basis of it. Where this tool gets really, really powerful is the patterns that you can match in those case statements can get really, really crazy. So you can match the integer inside of a dictionary inside of a list of dictionaries inside of a class. And it does that without any problems. You can match, especially with data classes. And because data classes know the order of their own child parameters, their arguments, it will actually populate those for you. So you can say, if you've got a card object that has a rank and a suit, you can actually say, match card objects that have suit equal to hearts. So that kind of thing in if-else would probably take three or four lines of code. Here, it's a single line and relatively readable. This is a bit of a contentious feature. I think anytime you add something like a switch statement from other languages, people get a little uncomfortable. My primary complaint with switch statements in other languages is they're giant foot guns. One of the biggest issues that you have is if you forget to put a break inside of a block, you might accidentally run multiple cases. So I am pleased to see that Python did not do that. So when you're doing a case statement, if it matches one, it will not run the rest. That's far more foolproof than some other languages where I've used this. So it's an interesting feature. I suspect that it'll be a little bit like the walrus operator that's, you know, five or six years from now, there's going to be specific cases where it gets used. But otherwise, you know, once the arguments calm down, you know, what people will just move on. One of the things I thought was interesting, and I'm guessing this is related to the peg parser improvement, the expression grammar kind of stuff, is that it doesn't, as long as you're using the correct formatting of the syntax, it doesn't forego you using the word case or the word match. Those are not keywords. Is that right? Am I getting the right terminology? I didn't realize that. I hadn't attempted that. So I just assumed that they were in the syntax parser. So if they've done that, that's interesting. Now that they've actually introduced a new class of keywords, so to speak, that they call \"soft keywords.\" And matching and case are soft keywords that are kind of just keywords in certain contexts. All right. So you can still use matching case as variable names, for instance. I think that was some of the worries, right? That you could have already, you know, parts of your code that used the word match and now like Python 3.10 would have broken things or potentially, you know, gotten confused because they're suddenly brand new keywords, right? Yeah. And I think, especially match has been used in regular expressions and things like this forever. So you can't really use that as the keyword. I think that would break everything. Yeah. And so that, I like your term of foot gun, of like, you know, potentially shooting yourself in the foot. I know you were talking about that quite a bit with the JavaScript course that you did. Oh yeah, JavaScript. JavaScript's an entire howitzer. It's fun. It's amazing anybody has any toes left, right? I really liked the, there's three peps that are sort of included to kind of discuss this a little further beyond the article and the course that are there. So I'll include links to them, and I did like the pep 636, which included a tutorial actually that'll be part of the Python documentation that you can kind of go through and look at it. And they had kind of a fun example where it was kind of doing a bit of a text adventure kind of thing. And so it had lots of different kind of matching and sort of ways that this would be unique and a little different than how other languages propose it. And then showing off those features that you were talking about where it can be a little more of a detailed structure of things inside of things that it's actually matching, which is cool. One of the examples I don't really remember which pep it was, but they were sort of showing like a typical GUI interface where you're getting an event object, and that event might be from the mouse, it might be from the keyboard, it might be from the network. And because you would have each one of those events be a different class, you can just end up with a case based on that. And of course you could do this before, but it would have been a giant if is instance this, if instance that. And it does for these larger cases become more readable. I wonder if this will affect the world of testing in a large way. It's possible. That there was an article that I was reading this morning. They had gone through and done an analysis of some of the more popular libraries and we're trying to figure out what percentage of those libraries were big if-then-else conditions where this might be applied. And I'm sure they were doing it in an automated fashion because they were doing things like Django, which is too big to be reading casually over the weekend, right? And the article claimed that less than 1% of Django is this kind of conditional block. I think there are cases where it's useful, but I don't think it's going to be a revolutionary change to the language. I think it's, you know, when 3.10 is getting to the place where it's end of life and this feature has been in the language long enough that everybody who is using it has support for it, you'll see it in appropriate places. And in the meantime, you know, what people will just move on. Did you know that 47% of Python projects include known vulnerabilities and there are vulnerabilities in even the most popular packages like urllib3, pyyaml, and Django. Luckily, 87% of Python vulnerabilities can be fixed and Snyk makes it easy and free. Find out if your Python projects are affected by vulnerabilities and get automated fixed advice in your IDEs and repositories with Snyk. Create your free Snyk account at snyk.co/realpython. That's snyk.co/realpython. Moving onward to type hints, and this has been a topic that Garana and myself have gone back and forth with because I did a course based on his excellent article, like kind of getting people started and type hinting and type checking. So what are some of the improvements that they've added this time, Garana? Yeah, so this has been a regular thing now, I guess for many releases that there are small improvements coming all the time. I guess the one that will probably be the most used and kind of most straightforward is that they're just simplifying how to specify union types. So if you have something that could be either one type or another, so say for instance you're working with a number that could be the float or int, and then in the old days you would need or all these um, so right now I guess you would need to import typing and then use typing.union to sort of specify that this could be a float or int. Now there's allowing you to just use the pipe symbol directly and say float pipe int directly. So no imports and nothing, and it will just be directly understood by the type checker. Interestingly, this syntax will also work in runtime checks like if you're doing the isinstance and you can check for several types, which has been possible before using a couple of types, but now you can also use the new union syntax for this. Nice. So that will definitely just quickly clean up your type hints and so on, but yeah, unfortunately it will be 3.10 since it's a syntactic change. Okay. Then there's a couple of other peps that are sort of like more niche uses of type hints, but one is that you can explicitly annotate something as a type alias so that's something that's been supported for a long time is having type aliases where you just essentially say that for instance in our number example I could just define a new variable really that's number equals typing dot union of float and then later in my type hints I could use number just a variable name. Now since these are just look exactly like regular variables in Python, it's been hard for the type checker to kind of really take advantage of these and always kind of you know make sure that what you're doing is really adding type hints and not just some variable that you're going to use. So they're just introducing a way for you to annotate these things as a type alias so that you can get even more help from the type checker. And then they're also introducing something they call type cards. And this is also kind of related to the union type. So for instance, say that you have something that could be either none or a string say or some kind of type. And then to kind of help or to kind of make sure that you cover all the possibilities of your types, you typically will have a check that says if this variable is none then do this if it's not none then do that. And the type checker can kind of recognize these things. So if you for instance do a none check and then introduce or you make sure it's a string if it comes in this num then the type checker will sort of understand that, okay, now it's a string so I can treat it as a string and you can use your string methods and so on. This kind of works for your basic if variable is none or if it's an instance of something, but if you have more complicated things, the type checker will not be able to do this. For instance, if you have a list of strings or something like that, it's hard to make sure that it kind of works out. So what you will be allowed to do in 647 is, no, sorry, in Python 3.10, it's based on pep 647, is to define your own type cards. And again, you'll just annotate this as this is a type card, and then you will be allowed to use those functions and the type checker will then understand that, okay, now the type is narrowed down to whatever you, your type card is, regardless, essentially. Oh, cool. So, but both of these are kind of really nice if you need them, but most people will probably not use them essentially. Yeah, it's like these kind of special cases where this stuff kind of comes up, right? Yeah. Okay. And yeah, the final pep that also about type hints in 3.10 is something called parameter specification variables, which, uh, yeah, is some words combined, I guess. This is kind of related to type variables, which is something that's been in the type system for a long time, I guess, since the beginning, where where you essentially have a type that's not defined in your code, but it kind of just gets a value when it's getting used to essentially like a regular variable",
    "SghTaQuMBxE": "Welcome to the Real Python Podcast. This is Episode 83. Are you interested in sharing your Python project with the broader world? Would you like to make it easily installable using pip? How do you create Python packages that share your code in a scalable and maintainable way? This week on the show, Real Python author and former guest Dane Hillard returns to talk about his new book, \"Publishing Python Packages.\"\n\nDane shares his research into creating Python packages. We talk about tools, techniques, and potential pitfalls of publishing your own packages. Dane also discusses his experiences unraveling projects and determining dependencies. We also covered Dane's recent conference talk at Pi-KE-AThem titled \"Keeping Code Safe and Modern with Semantic Searches,\" and he shares some security tools and practices from the talk.\n\nThis episode is brought to you by CData Software, the easiest way to connect Python with data. SQL access to more than 250 cloud applications and data sources. Alright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey, Dane, welcome back to the show.\n\nHey, thanks. So, it's not been quite a year, but pretty close. Yeah, time is kind of warped lately.\n\nSince I last talked to you, you've been working on your new book. But I thought we could maybe start by talking about a recent talk that you did at Pi-Gotham. So, what was the talk about?\n\nYeah, so the talk is about keeping code safe and modern with semantic searches. The idea is that you have a lot of signals that you can actually draw out of your code to understand things like type safety, syntactic errors, and common constructs that are either dangerous or likely to produce bugs. If you think about the Swiss cheese model to security, right, you can apply the same thing to the correctness of code. So, the more of these kind of patterns you can cover with different tooling, the more likely you are to have safe operational code that you can deliver. And it specifically talks about this tool called Sevengrep, which is not a Python-specific tool but is very good at working with Python. It integrates with pre-commit and CI tooling and all this stuff, and it's sort of like a generalized case of a linter. You can think of it as, okay, where you could use pylint or flake8 to check all the things that are in those libraries. If you have something specific to your organization or specific to your project that you know you need to look for as problematic or something to produce a signal of some kind about, you can kind of build those in a custom way with tools like Sevengrep.\n\nOkay, and that's semgrep?\n\nYeah, I think I say it in the talk too. I think it's short for semantic grep, but I don't know that there's proof of that in their documentation. Okay, that's fine. And just to backtrack just a touch, you mentioned this model of the Swiss cheese approach, and I'm guessing that is sort of the idea that one slice of cheese may have a set of holes in it, but if you layer another piece of cheese maybe at a different angle or something like that, then those holes are going to be in different places and maybe block things. Is that the premise?\n\nYeah, that's exactly right. So, the goal is to get enough slices of cheese that there's no one path straight through all of the layers of security, right?\n\nRight. Yeah, that's interesting to me that I don't know, I've had several people on talking about, you know, we're talking about packaging today, but you know, I've had a handful of people talking about the security and upkeep of packages and you know, the different types of things that you kind of need to pay attention to, so that's that sounds like a nice talk to kind of get people started, you know, down that road of like continuing to look at the security of their open source stuff.\n\nYeah, and there's this renewed emphasis maybe on shifting things left, right? So, the earlier in your development process you can get feedback about things the better. And as you think about these linters and things, the more you can really leverage those ideally before you ever commit your code in the first place, you know, the more likely it is that you'll continue having nice operational code in the future.\n\nHave you used other security type tools that do that kind of checking? They're not a sponsor currently, but Sneak recently sponsored the show, and I've looked at them as another one that does this sort of cross-checking of your projects views and stuff like that.\n\nYeah, I haven't used them specifically. I've used one called SonarQube, which is kind of a cross-language tool. And then I know there's tools like Bandit that look for, they do static analysis at the command line. Yeah, those talks typically go live. I probably don't have a date right now, but probably in a few weeks after this episode comes out, people could probably find it. Yeah, I would imagine so. And I wonder if any of it is available on Twitch too because that's where they were streaming them from. Okay, because I know Twitch you can kind of cut segments from streams, but I haven't checked. All right, well, if we can, we'll toss in a link there if we can find it to share. You were on before and we were talking about the book \"Practices of the Python Pro.\" And then we kind of got into a very philosophical discussion. And the book was kind of more geared that way of this idea of like, okay, well what is a pro? What does that mean? And that sort of, I don't know, I'd call it almost a mind state, but just kind of like a process state of like, you know, as you're moving along as a developer. But your new book is coming at a very different tack, and I find that super interesting. The new book is \"Publishing Python Packages.\" So maybe we could talk a little bit about when you started writing this book and maybe the impetus of why you wanted to tackle this topic.\n\nThe driver for this came out of a desire and a need really to come up with a homogeneous way to do packaging within our organization. We have probably almost two dozen Python packages that we maintain. And really, some of those are much bigger than they should be. So continue to split that up further. But each was kind of developed organically and not all of them were following the same practices or had the same format for all of their configuration. And you know that gets very hard to maintain very quickly. So ended up doing some research a couple of years ago now into some of the best practices at the time and had learned a lot about things found that I was rather behind in what I knew about best practices for packaging and ultimately ended up building kind of a reference architecture, if you will, for publishing packages within the organization and with some of the newer standards and developments in the packaging community in Python. How would you share that within the team? So we actually have what we call a reference architecture documentation within our organization that we kind of share. Okay, the best practices we've defined for a variety of things and then we built like a cookie cutter template for a Python package that kind of incorporates all those things. So you can kind of get a new package up and running rather quickly. Do you mind explaining briefly what cookie cutter is? I think some people might think of that as just as a term, but it's actually a kind of a tool, right? Yeah, so cookie cutter is this really awesome tool that can you can take the heart of a project, for the file structure and the file contents and template out the pieces that someone might want to change. And then you can provide that, usually as a GitHub repository and people can actually create versions of that project with all those variables templated out. It has a nice command line interface and all that for bootstrapping a project from a template. So it kind of like prompts you. Yeah, exactly like in a command line sense, right? So it kind of walks you through and then it builds. I don't know, I want to call them stems, but these parts of all the files that are needed within the project. So you could have like a cookie cutter for, say, Django or I saw one for, I think I talked about it on the show a little while ago about setting up things for like a Docker container. And like being able to have it ready to go. What was funny about the article was the guy was actually throwing out the majority of it, which was really strange. I'm like, why didn't you just make a new cookie cutter? Like why are we throwing away 80% of this? It was really kind of odd. But yeah, that's a neat project. Definitely, I would recommend it if you find yourself repeating yourself with some regularity. Yeah, yeah, totally. That's interesting that a lot of the sort of source of this started, you know, that sort of started making you think about, like, okay, I need to do this within the organization. And then how soon did that move into you wanting to maybe turn it into a book? I guess as I learned a lot more about how far I was behind, I also took stock of kind of across GitHub what it looked like other people were doing. And I saw that a lot of people are still using things that I was using that seem like they're the less recommended way of doing things. For example, using setup.pi for dynamic, well, not for dynamic information, but using setup.pi when you don't need dynamic information, it's better to use static metadata now. Things like that. Just seeing where the industry is and even where some of the tools have adopted certain peps so far kind of shows there's still a lot of catching up to do. And I know I was very behind even on what was possible or what was defined in some of those peps. Just wanted to honestly like more start a discussion and make that more at the forefront than anything else.\n\nYeah, so it sounds like a bit of a research project and sort of documenting your path in some ways. That's a really good way of putting it, I think, because where the first book was very much kind of a broad audience, sort of maybe skewed beginner book, this one I think is certainly a more niche subject and probably more toward the intermediate part of the spectrum. And I think if you're someone who's finding themselves wanting to share their code, finding that the way their organization currently shares code that isn't packaging, and you want to learn more about how to package in a way that means you can install things that your organization has developed, yeah, just the same way you would install something like requests or NumPy or any of the really popular libraries, you know, that's kind of where this is meant to bring you up to speed. So, instead of like having to find the README file that Bob or Jane wrote explaining how to install this particular set of tools, they could simply use something like pip and point it at an internal repository and be ready to go. I think that's really cool. Were there other experiences that you had maybe outside of your work environment that made you want to write this book?\n\nYeah, I mean, we, well, you say outside the work environment, we did open source a package as well that's kind of a builder for REST clients built on top of requests, and kind of is a declarative model for defining API endpoints and things. So we've got a microservice-oriented architecture and found ourselves kind of repeating a lot of the same, here's the way to fetch the host, and here's the way to get to the path, and here's a way to do service discovery. So we kind of abstracted that all into a package that we thought others might find useful, so we open sourced that. I maintained a couple of other open source packages, none of which were particularly popular, I guess. It's not like I'm managing something like Textual at the moment, but just seeing the kinds of things that can go wrong and the kinds of even the kinds of code review that can happen, I think there's something to this general idea of maintainership that is often considered a significant burden, and rightfully so, I think. A lot of the discussion is about attitude and abuse and conversation and feedback, which I think this won't solve, right? But yeah, potentially, if there's any part of the burden that you can unload into an automated process like, I would hope that people can take advantage of that. So, you know, if you're finding your team is code reviewing and saying, you know, the formatting of these lines isn't as readable as it could be, or you're using single quotes instead of double quotes, don't make that a people problem. Try and standardize on that and make a machine tell you that. Yeah, it's like that, those nice code formatters kind of can take care of those discussions without it really ever having to be elevated. Yeah, and so the book goes through some of that too and talks about, you know, how to automate a lot of your core workflow to keep that out of your way and let you focus on whatever it is your package is actually trying to do. Yeah.\n\nI feel like this is a different audience, right? Like that you've decided to write this book for. Instead of like having to find the README file that Bob or Jane wrote explaining how to install this particular set of tools, they could simply use something like pip and point it at an internal repository and be ready to go. I think that's really cool. Do you have like additional resources that you'd want to share? Good additional things that people can kind of look at, yeah. So there's like the Python Packaging Authority who kind of manages the Python Package Index and well, they manage the Python Package Index and you know, they do provide a very good guide. It's rather abridged, I guess. You know, it doesn't probably for smart reasons, it doesn't cover in depth all the different ways you could go about doing things. And what is there, I think is really good. And I guess it's a bit of a maybe a cop out to the question, but one way that I learn a lot of stuff is by doing sort of a global search on GitHub, okay? A really common thing that I search for is, you know, if I'm looking to understand more about how I should use this field or what the syntax is or anything like that, I'll typically add the name of the field and then do like filename colon setup.cfg and that will just show me every file called setup.cfg on GitHub that has that field in it. And then I can just kind of look through those results and see like, okay, these five people are using it this way, these ten seem to be using it this way, and then everyone else is using it this way. So then you can kind of start to understand the nuances of those use cases. And that's what I mean by like landscape analysis that I mentioned earlier. So okay, really gives you a sense of like real world in the wilds type of usage. So, yeah, I think of like Brett Cannon had this post about Pipe Project Toml, but I could see using that technique to look at Toml files to kind of get an idea of like what's going on with them. Absolutely, but yeah, that kind of just to see how people are using it. That's been a common theme for people, you know, again, researching code and kind of learning it but not thought of it of like these other files that are not necessarily pure Python files. These are files that give instructions to all these other tools. Yeah, and in some cases provide metadata and things. So that's where your, you know, again, a package is like software with metadata, right? So, right. Yeah, it's, it's an ecosystem. Another thing that I that occurs to me is we were talking about PyGotham. Simon Wilson had a great, really like speedy talk where he basically went through the process of starting from zero and publishing a package to PyPI in like 10 minutes. So, definitely, definitely check that out too. Cool. And he has an example repo that he links to there that you can go look at as well. So, nice. So, I have these weekly questions I wanted to start with. The first one is, what are you excited about in the world of Python? Yeah, I think it's, it's got to be what Will McGowan is working on right now. You know, Rich and Textual both are really cool. We're using Invoke for a couple of things right now, and they're fairly simple tools, but I could imagine if we ever wanted to kind of enrich that experience and do it in a Python way that those tools would be the first place I'd look. Yeah, I'm excited to just try to find a couple projects I might use in it. Yeah, so. So, what do you want to learn next? Again, it doesn't have to be Python specific in this case. Yeah, I have been spending a lot of time, I mentioned modularization, yeah, I've been spending a lot of time on that concept generally speaking.",
    "xRzybRKLvW0": "Welcome to the Real Python Podcast. This is Episode 84. Have you wanted to generate PDFs from your Python project? Many of the current libraries require designing the document down to the pixel level. Would you be interested in a tool that lets you specify the page layout while it handles the specific details of laying out the text?\n\nThis week on the show we talked with Joris Kelleykins about his library for creating and manipulating PDFs named Borb. Borb is a pure Python library that can read, write, and manipulate PDFs. You can use it to build fillable forms, invoices with attached data files, and multiple column document layouts. We discussed the extensive example repository Joris has created for the library.\n\nJoris shares his background in working with PDFs. He talks about starting the project and the challenges he had to overcome. We also talk about licensing and maintaining an open-source library.\n\nThis episode is brought to you by Cloudsmith. Cloudsmith is a secure software supply chain management tool for your Python packages and dependencies. Try Cloudsmith for free at cloudsmith.com. Sign up now.\n\nAlright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHi Joris, welcome to the show. Thank you for having me. It's so funny because we mentioned the library back in Episode 76. David and I were talking about projects and Borb came up. I was really having fun playing around with the library. I keep talking about PDF libraries pretty commonly because I was doing a lot of work for small businesses in creating forms and other kinds of tools for them. So I'm very excited to have you on the show.\n\nThank you. I was completely surprised last time when Borb came up because I only saw it because somebody linked it to me, and I was like, \"Wow, it's happening.\" Somebody actually published content that wasn't me.\n\nYeah, it's cool. It got featured in \"PyCoders\" a couple of times too, which is great. I'm guessing those are based on the articles that you've been writing about the library. Yes, so I've been trying to get one article out every week, but I see that it's quite a journey to not just get the content out. That's actually the easy part, but remembering to link it on all my social media accounts and every newsletter that I come across, etc. I really hope as soon as we turn into an actual full-fledged company, I'm hiring somebody to do that for me. That's yeah.\n\nSo maybe we could talk a little bit about the history of the project. Certainly. A few years ago, I don't recall how long ago actually, I was working at another software company that builds PDF software. They were a big name in the PDF landscape. They are called iText, and they mostly build software for Java and .NET. I'm still close friends with the founder. He lives two streets away from me. We talk quite often. We have a similar interest in movies, so we see each other quite often in the local supermarket or the local movie theater. But then the company changed, as companies do. The company was brought over by a Korean holding, and a lot of the developers there, including myself, started looking for other pathways in their career. I actually didn't think about PDF that much anymore until a few years ago when I was working in Python, which was a first for me, and I had to write some code to generate a PDF document as the output of a test framework that I had built. Okay. I just wanted to do some basic PDF manipulation, create a table, automatically switch to a next page if needed, etc. To the best of my abilities, I couldn't find a PDF library that was as good in Python as iText is in Java. Most libraries will force you to go down to the nitty-gritty level of telling you like you need to specify exactly at what pixels you would like this piece of text to be. ReportLab would be an example of that, and I've had somebody on talking about it, and it's very intricate and it almost feels like you're doing a form of pixel-perfect layout, which is really painful. Okay. It's great that you can do that, and I can understand that there is a need for that.\n\nIt's funny that there's this development of PDF software in Belgium. That's pretty cool. So I developed a library, as one does when one is confronted with a problem. So I decided to hell with it. I know how PDF works, at least that's what I thought, and I'll write a piece of software that actually does what I wanted to do. That's how this library started. From there on, of course, a lot of the ideas came forth not just from my time with iText, but also from having talked about PDF with other international companies like Adobe, sort of having a finger on the pulse with regards to where PDF is going in the future, what features may be unimportant now but might become very important later on, you know, things like that. Being able to design upfront what the library needs to be able to do, and that's, I think, one of the great advantages because most companies like iText, very good software, but if a company exists for 15 years, you start seeing it in the code base. There are things that you can no longer refactor because a lot of people depend on it or because the software has grown organically in a certain way. So it's certainly an advantage to be able to start afresh but with the ideas and experience of all those years.\n\nI think one of the main challenges of PDF is that it's not just one type of document. It's an umbrella term for a whole collection of standards, each of which derives from the same base standard, ISO 32000, but each of them also tries to improve upon what the other ones got wrong. So you have a standard that just defines what the base PDF looks like, and then afterward, another standard that says, \"Well, you know, we got this part wrong. Actually, you should do it this way.\" I think we're now at version two of the standard, which finally allows for other levels of encryption, allows for algorithms that are no longer deprecated. Good things are still happening in PDF land, but it's always a bit of a nightmare.\n\nAre there ways to your library, which we should talk about a lot more as far as the features of it, but one of the things it does is read PDFs and extract information from that. Is there, globally, this might be difficult to determine, but in your experience, maybe through support tickets or what you're seeing come in, is there some standard level that seems to be standard? Like people are using or are you seeing PDFs from the beginning of the dawn of PDFs coming in and those versions being difficult to read?\n\nIt's actually a lot of different software producers. For instance, Microsoft Word allows you to export to PDF, but then there are low-level Linux commands that also produce PDF documents, which, like you said, are more closer to the dawn of time. In general, actually, it's more likely to be the most recent producers of PDF documents that screw things over. Because only more recently have features been added that make it much more difficult to extract text from a PDF document. And I think it's similar to, for instance, having a standard like ASCII, where you have only that many byte patterns that represent the full alphabet that you needed at one point in time. And then afterwards, people realize, \"Oh wait, there are tons of other languages that we need to support, and we need to somehow hack this into a system that still works.\" And PDF suffers from the same diseases. So you have a very old kind of base standard, and if you only ever want to extract Western text and Western alphabets, that works perfectly, and most libraries get that right to a very high degree. But then you start looking into things like, \"Oh well, I have the letter A with this insane accent on it, right? How is that going to be represented? How is the font that has to be embedded in the file going to represent that?\" And suddenly, it's a lot more challenging to be able to do that.\n\nThe specifications of Unicode, sort of developing alongside these changes in the PDF architecture, and then this, I don't know even what to describe it as, but this explosion of emoji use maybe being a problematic too, like just as far as like, I'm guessing most OCR is just like to say, \"Well, I don't know what that is. It's just a blob.\" Exactly. Now the fun part is, and I've seen that being used, and I was like, \"This is devilish but creative,\" was my first response. I've seen somebody create PDFs where the actual text that is being embedded in the document is just a repeat of their company name over and over again. And that's one of the things that PDF allows you to do. It allows you to create your characters so that you can say, \"Okay, it's going to be drawn as if it is this, but when you extract it as Unicode, you should do this.\" And I've seen people use that as a sort of DRM protection, which is beautiful and sad at the same time.\n\nWell, let's dive into the library a little bit. I mentioned briefly that it can be used for reading PDFs, but where it seems to be most powerful, in the tutorials that you've been doing, is the creation of PDFs. So maybe we could dive into some of the crucial features of it. Yeah. My main goal for Borb is to have a library that makes it as easy to generate documents as you would with Microsoft Word. And that's a very tall order because people are very used to working with that particular program. You're used to being able to add text and that it automatically travels to the next line or that it even automatically hyphenates text. And all of that is non-trivial to do when you're talking about PDF. Borb, like the libraries that we've mentioned before like ReportLab, it allows you to precisely say, \"I would like content at this particular location.\" Because sometimes you have perfectionists. But then it also has a sort of layout engine built into it where you can just say, \"I would like this page to be laid out in two columns or in this way or whatever,\" and then you can just say, \"Add this text, please, in this font size, in this style,\" or whatever, and it will automatically take into account leading and margin and padding and whatever, and the document will just look as you would expect a Word document to look.\n\nIn the case of that, that kind of thing makes me think of two questions, or actually one comment and a question. The first is the idea that it's a little bit like in a GUI per se, where you are defining sort of column type structure and then the window can be adjusted in size and kind of go around it so that you don't have to constantly worry about the pixels. I guess that's almost sort of a CSS type of thing too, as far as web design, you know, kind of this sort of general layout kind of stuff, which I think is really cool. The other question I have that's kind of related to that is you're in laying these things out, you are creating, you're kind of doing this extra work behind the scenes, and I'm guessing that this is the Python stuff behind the scenes of it deciding how to break words, like you said leading and other things. How much kind of work went into doing that?\n\nThat is sometimes you come across a challenge where you think, \"Oh, this is going to be trivial,\" and then it turns out that it's actually an entire field of research, and that we as humanity don't know yet how to best tackle this. And then sometimes, for instance, with hyphenation, I went into this thinking, \"This is going to be one of those days because how the hell do you teach a computer to hyphenate a word correctly in any language that you want to support?\" And then it turns out that there's a beautiful algorithm that most commercial software at least has been using since whenever the algorithm came out, and that it's a simple lookup of certain patterns within a word and that it marks hyphenation locations based on that. So I was very lucky to be able to find that. I was lucky that the license matched with the license of Borb, so that's the algorithm that's currently being used, and it's the same algorithm you will find in other libraries. Nice. Yes, I'm guessing that was one of those things like you maybe started down the rabbit hole in digging and then sort of paused for half a second and said, \"Wait, maybe I should look around.\"\n\nMy first instinct is always to look around. Good. I love learning about new stuff, and I'm not naive enough to think that I'm the first person to have to tackle a certain problem. So there's a good balance between doing it yourself and making use of somebody else's work. I think with Borb, I'm being on the side of cautious. I think there's only like four or five dependencies, so I'm not trying to import the entire Python ecosystem, but I'm also not insane enough to write font handling if somebody else has written a beautiful library that handles font files.\n\nHow are fonts handled inside of Borb? Fonts are handled to the level of reading the files and determining the attributes that a PDF needs from a font is done using the FontTools library. And then for certain built-in fonts, well, to clarify, PDF defines 16 or something fonts as being built-in, so any reader or writer should support them. And for those fonts, I simply looked up the font files and extracted its attributes manually and put them in there as a JSON file so that it would be easier and faster to look up.\n\nSecurity within software supply chains has become the major focus for developer and engineering teams. Cloudsmith is a software supply chain management tool that provides public and private Python repository hosting for ultra-fast and secure delivery of your Python packages. Cloudsmith is a fully compatible PyPI repository. With Cloudsmith, you have the ability to develop your Python packages internally and privately share them with other teams across your organization. To get started with your own private Python repository, visit cloudsmith.com and sign up for more information.\n\nYeah, you're using JSON pretty extensively across the library. What was your decision for doing that? I would like Borb to be as close to open source and free and accessible for everyone. The idea of using a format that only I can read doesn't appeal to me as a developer and as a debugger. If I'm outputting a file somewhere, I would like it to be legible for me so that I know, okay, something went wrong or I need to change this or this is what the system is currently doing. So it's convenient for me as a developer, and it really ties into my ideology as having made this project. I want it to be open source.\n\nOne of the things that I found interesting and I commented on in the podcast episode earlier was that you have a feature of embedding files within the PDF. In the case of that, the kind of thing makes me think of two questions or actually one comment and a question. The first is the idea that it's a little bit like in a GUI per se, where you are defining sort of column type structure and then the window can be adjusted in size and kind of go around it so that you don't have to constantly worry about the pixels. I guess that's almost sort of a CSS type of thing too, as far as web design, you know, kind of this sort of general layout kind of stuff. I think is really cool, and needed. I used a program from Apple called Pages, and I was very familiar with the general idea of it had a page layout mode where you could create these squares or rectangles on the screen and say, \"Okay, this is where this information in,\" and then the feature that I enjoyed about it was, for like a magazine or what have you, you could say the text should flow from this container into this next one. You actually had like little arrows to draw where that would happen. Is that something that's implemented in Borb, like as far as like going across pages with this sort of column type layout?\n\nIt's not implemented to that generic of a degree, so you as the user cannot say, \"Here is a collection of rectangles that span a page, and I would like them to be respected in that order.\" What you can do is use one of the existing layouts, for instance, multi-column layout, which divides the page evenly into columns. There's also a single column layout and some other ones that I'm probably forgetting, but it's a great idea, and I'll see about adding it as a feature.\n\nIt's something that I was really impressed with, like you're saying, that kind of talking about the idea of somewhat abstracting some of the work involved in the layout so",
    "OyUvpwfaKDE": "Welcome to the Real Python Podcast. This is Episode 85. Are you getting the most out of the Django framework? It's a powerful web framework if you're not interested in reinventing the wheel. Django includes a useful template system with inheritance for composing reusable HTML. This week on the show, we have previous guest and Real Python author Christopher Trudeau to talk about his recent articles and courses about Django. Christopher explains how Django templates help you avoid rewriting large portions of HTML for your web applications. His first article covers built-in tags and filters provided by the framework, and the second one dives into how to customize and implement your own filters and tags. Christopher also talks about his process for choosing topics for articles and courses, and we talk about his Django Rest Framework course. But we start the episode by covering a recent article by Senior Python Developer in Residence Lukas Langa. We had talked in a previous episode about his plan to study where all the Python core developer activity goes, and he's gathered several years of GitHub data. Christopher and I discussed the post.\n\nThis episode is brought to you by Cloudsmith. Cloudsmith is a secure software supply chain management tool for your Python packages and dependencies. Try Cloudsmith for free at cloudsmith.com. Sign up. Let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with the community of experts at realpython.com.\n\nHey Christopher, welcome back to the show.\n\nHey there, how you doing?\n\nGood. I wanted to start off this episode with a little bit of a follow-up from Episode 82, where I had Lukas Langa on, and he was talking about compiling all this data in his process of being the developer in residence. He was using this library called Dataset and kind of assembling all this data from GitHub, and so he wrote an article about it on his blog. The title is \"Where Does All the Effort Go: Looking at Python Core Developer Activity.\" I thought it was kind of neat because it really wrapped up our conversation. You know, he was talking, he was going to do this, he was thinking about it. I don't know, I was really intrigued by what he found inside there, these sort of busy areas that are deep inside the interpreter. There's like three or four little areas he focused on. He spent time analyzing date ranges, like when the work was done, which seems to stay pretty far as the pull requests and the merging seems to be pretty consistent. There were some peaks here and there, I guess were definitely like sprints that were happening. And then the area that he was trying to convey in the podcast was that the areas that were getting touched were really deep inside the interpreter. It wasn't clear to me from the article because of the timelines that he was talking about. There's been a fair amount of work done because of the switch of the parser in the last couple of releases. So, it wasn't clear to me. The information is beautiful. I love the fact that he went through and did this. I just wasn't sure because I didn't sit down and go through a calendar and go when did this match what version, right? Right. Break the data set yourself. Yeah, I wasn't sure whether or not it lined up with going to the new parser or not. And I wondered whether some of that internal touching was because of that or whether that was a longer-standing norm. So it might be interesting to see what because I guess most of that change happened in 3.9. So it might be interesting to see whether or not those same internal pieces were touched as much during 3.8. Yeah. The dates kind of start like his generation point for this thing is like February of 2017 as far as the data set that he created for it. So yeah, there's a lot of interesting projects that are out there right now as far as like thinking about ways to speed stuff up. And so maybe these will be areas that continue to have lots of focus kind of going forward. But I don't know. I was intrigued by that. And then he spent some time talking about kind of the top contributors. There's a bunch of bots that are used to kind of merge things in and those were high up there. But then also like Pablo, the release manager for 3.10 and then himself. So release managers had a lot of stuff. But you would, if you look through the list, there's some pretty common suspects in the Python world. You'll see inside their previous guest, Brett Cannon, and you know, Guido himself and a bunch of other kind of interesting people. It'd be interesting to see, and you'd have to grab data from somewhere else or poll the people or whatever, but I'd be interested to see how many of those are paid contributors. Right? Like I know it's a happy volunteer community and it's one of the things that makes Python great, but there are folks who work for organizations who are paying their salaries so that they can contribute to Python. And I'm curious, you know, if you pay me 40 hours a week to play with Python, then yeah, I might be contributing more, right? So, yeah, or the, you know, the couple corporations allow, you know, like a day a week or something like that, yeah. Your 20 time or something like that, yeah, yeah. I think of like Brett Cannon might be one of those because he always jokes that he, you know, works to fund his open source habit, right? And so things like that. But yeah, that would be interesting to kind of get that kind of balance. You know, it's just kind of cool to have somebody actually finally kind of pulled the stuff out. And then the other thing that he wanted to focus on was like the amount of time it takes for merging a PR. So this kind of idea of like a drive-by contributor, or, you know, somebody's not, you know, part of the core team, you know, how likely or, you know, what's involved in reviewing it because there maybe there isn't as much conversation behind this particular PR. And so he did kind of some measurements there and could definitely be an area that could help him work on stuff. But I think it's mostly the idea is just to illuminate what's happening, which I think is great. And then the very end of it, we spent some time in the episode talking about BPOs or bugs.python.org. And his goal is to maybe tackle that data set next, but it's a little harder to wrangle. It sounds like it's definitely organized differently than how GitHub is, so. Right, yeah. Well, he also",
    "ljcg9_Ma-hE": "Welcome to the Real Python Podcast. This is Episode 87. Have you wanted to work with RSS feeds in Python? Maybe you're looking for a new project to build your portfolio that uses Django, unit tests, and custom commands. This week on the show, we have Real Python author Ricky White to talk about his recent step-by-step project titled \"Build a Content Aggregator in Python.\" Ricky's been authoring the Real Python interview series for several years and was formerly our community manager. He talks about what inspired him to create this project and the Python technology and libraries to build it. He also shares advice about adding tests to personal portfolio projects.\n\nWe start the show by discussing Python's GIL, the Global Interpreter Lock, and the efforts to potentially remove it in future versions of Python. This change could make a significant impact on Python code running on multi-core processors. We talk about two recent articles covering the developments.\n\nThis episode is brought to you by Cloudsmith. Cloudsmith is a secure software supply chain management tool for your Python packages and dependencies. Try Cloudsmith for free at cloudsmith.com. Sign up. Alright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey Ricky, it's so great to have you on the program.\n\nIt's great to be here, Chris.\n\nAlright, I want to start off just by congratulating you on your citizenship.\n\nThanks, it took a while but we got there in the end.\n\nYeah, how long was the process?\n\nActually longer than it could have been. So it's one of those strange things that when I came into the country as a green card holder, they told me I could apply for citizenship after five years. So I waited for five years to apply, but at some point the rules changed and I could have applied after three years. But no one tells you that the rules change. Yeah, so I mean it was a little over that. I moved to the US in October 2014 and I became a citizen at the end of September this year, which is 2021 if you're listening in the future.\n\nBut yeah, it's a long process, but you kind of have to. There's a lot of paperwork and yeah.\n\nAre you keeping it as a dual citizenship thing?\n\nWell, kind of. Not really. So the US has rules about dual citizenship. It's a little gray in places. Okay, for travel, I have to use a US passport, which is the crux of it. The UK, which is where I'm from, England, they still recognize me as a citizen. But as far as the US is concerned, I'm a US citizen. So they don't really do the dual thing so much these days. But I mean, that's fine with me. My children are American and they, even though they were born in England, they were registered as Americans at birth and they've been here for most of their life. So they're American and my wife is American by birth. And so, you know, it's probably easier if we're all in the same queue at customs and at the airport.\n\nI can imagine. Yeah, you were working at Real Python for quite a while and you're still doing some stuff. The interview series you were doing. I wanted to ask a question about that. How many interviews have you done?\n\nI think I just published my 33rd article. They're not all interviews, but majority of them are. So, yeah, it's north of 25, if not more.\n\nHow do you select the subjects?\n\nThere's not one way. So sometimes I might hear a guest on a podcast and steal your guests. Doing this vice versa. So, yeah, sometimes it's people I've met online either through Twitter or something or Reddit or something. I just keep an eye out on people in the Python community. And if there's a popular article that comes out by somebody that we've not interviewed, then we'll interview them.\n\nWhat were some of your favorite ones you've done?\n\nOh, I can't pick a favorite. They're all good for different reasons, right? Yeah, I've not quite so. There's been a few core developers, Python CPython core developers I've interviewed. So those are interesting, purely for selfish reasons, right? I get to ask them questions that I want to ask them. And yeah, that's fun. Yeah, so that's the fun part, right? But we've had quite a lot of variety of people interviewing. And that's kind of the point of the interviews is it's not always about the tech. It's about the person and it's about the stories they have. And that's kind of what I try and echo a little bit. Obviously, we focus on Python a lot. Yeah, I try and put some personality in there too because I think it's important for people coming into Python that they see that we're not all the same. And there's a, the Python community is very diverse. And I want to try and represent that the best I can in the interviews.\n\nOn a side note, you're interviewing the guy who hosts the advent of code. The reason I bring it up is Garana is creating an article about it. And I'm planning on bringing him on the show a couple of days after they have this year's advent of code starts to kind of talk about that whole process and stuff. And I don't know, I'm guessing that interview should release probably just before that also.\n\nYeah, I think it's probably next week. But yeah, I think the plan is, yeah, the interview is done. Eric was kind enough to do the interview. And so we talked about advent of code and kind of tips and for solving code problems and yeah, that should be added in the next week. I don't think it's this week, but maybe next week it's due to be scheduled. I haven't looked. Likely, but yeah, yeah, and then that should come out. And then Gears articles should come out either the same week or the week after.\n\nYeah, so yeah, and then that's what I'm thinking. We'll do like an interview and kind of right at the top of December try to get it out that first week there. But yeah, that's kind of fun. Is that something that you've, uh, participated in yourself?\n\nI have in previous, I don't think I did it last year, but I have in previous years. I started, I've never finished. I've never finished not all of them, right? Just some of them. I get about 10 to 14 days through and then life gets in the way or I mean.\n\nI think the hardest part is, is if you miss one day, you could probably make it up. But if you start missing two days in a row and then certainly if you miss three days in a row, there's just then too much catch up to do and it gets really hard to be motivated or make time to do it. So you've kind of got to be disciplined from the start and make it kind of, okay, this is something I'm going to do for my own development.\n\nYeah, that could be hard during the holidays to do that too.\n\nIt is hard during the holidays and it's especially going to be hard for me to do it this year. But it's just something I want to do again and I want to, you know, get through the whole thing. I'll have to see if he wants to come on the show. I'll try to reach out. That might be kind of fun.\n\nAll right, cool. Yeah. I wanted to talk about a little bit of news stuff. This is something that Christopher and Trudeau and I mentioned briefly in our last episode. I'm having, you know, there's a couple reasons to have you on. One is that you're, you know, your recent article about sort of a step-by-step project. I should correct myself. It's not truly an article. It's more of a whole project and taking people through it of creating this really cool content aggregator in Python. And, but I wanted to start off is just talk a little bit about the notes on the meeting about the Python GIL.\n\nIt was something that again, we had mentioned a couple weeks ago. There was this meeting that was held with Sam Gross along with the core Python developers. Lucas wrote an article about it. Basically the title of it is notes from the meeting on Python GIL removal between Python core and Sam Gross. And that came out at the end of October. And there was another article recently. This is on lwn.net. And it's from Jonathan Corbett. And it covers a lot of the same sort of stuff, but kind of a slightly different angle. So I'll include links for both. That one is titled a viable solution for Python concurrency to take one step back. I did an interview with Michael Kennedy pretty early on the podcast. I asked him about the GIL and had him kind of explain it a little bit in terms that hopefully could make sense. But basically it's called the Global Interpreter Lock. And it's used to help manage objects when things are created in your Python programs. All these individual objects are created. And that's something that's kind of a repeated theme that you'll hear people talk about when teaching or talking about Python that everything's sort of an object. But eventually these objects get created or need to be removed as you go along. Otherwise, you can eventually run out of memory. And so there's this system that has a reference count that keeps track of all of them. And the big problem with it is one of these things that people talk about sometimes as a hindrance potentially for the speed of Python is that computer CPUs kind of have this higher level limit of overall speed. The way over the last at least decade or more, computers have tried to move beyond that is to have multiple cores. And then for a language to take advantage of that, it would need to divide up what's happening and processing inside of it into what are called threads. The problem there is then how can it keep track as to what's happening in that thread and references that are created in those other threads and adding and removing them. And so the global interpreter lock is preventing that. Early guests of the show have talked about this idea of this proposal of something called a sub-interpreter that these other interpreters could be used and then they could be sent back to kind of do the same kind of thing of like take advantage of these, you know, look at the processors coming from Apple or from even Intel and AMD that have multiple multiple cores. And very often these, you know, projects that want to take advantage of them sometimes can't. And so, Sam Gross, he wrote, it's basically a fork of Python 3.9 that's called NoGill altogether, NoGill. I think it's best maybe I'll just read quickly the TLDR portion of Lucas's article. Sam's work demonstrates it's viable to remove the GIL in such a way that the resulting Python interpreter is performant and scales with added CPU cores. For performance to be a net positive, other seemingly unrelated interpreter work is required. So at the moment, it's impossible to merge Sam's changes back to CPython since they're deliberately made against the legacy 3.9 branch so that the resulting 3.9 NoGill interpreter can be tested by end users with the currently available base of pip installable libraries and C extensions. To merge NoGill, the changes will have to be made against the main branch and that's currently scheduled, as we've talked on the show, how it's moving pretty rapidly every this yearly thing. We went from 3.9 to 3.10 and we're already scheduled to 3",
    "X9OtZFEA4PA": "Welcome to the Real Python Podcast. This is Episode 88. There seem to be three kinds of Python developers: those unaware of type hints or have no opinion, ones that embrace them, and others that have an allergic reaction at the mention of them. Python is famously a dynamically typed language, but there are advantages to adding type hints to your code. This week on the show, we have Luciano Ramalho to discuss his recent talk titled \"Type Hints, Protocols, and Good Sense.\" Luciano was not a fan of type hints; he's only recently come around to their potential with the introduction of protocols in PEP 544. Python has adopted a gradual type system that is optional at all levels. We discussed the advantages, pitfalls, and recent developments around type hinting in Python. We also talk about the second edition of Luciano's book \"Fluent Python.\" He researched type hints in-depth for the book, which led to his recent conference talks on the subject. He also shares his experience with adding opinionated asides to the book in a fun and unique way.\n\nCloudsmith is a secure software supply chain management tool for your Python packages and dependencies. Try Cloudsmith for free at cloudsmith.com. Sign up. All right, let's get started. The Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nWell, I want to welcome you to the show, Luciano.\n\nThank you, Chris. We passed each other multiple times at PyCon 2021, sort of virtually in the hangout sections. One of them was Lucas's FM synth talk, and then the other one was Nina's Circuit Python talk. I was wondering, are you interested in those different uses of Python, like audio or physical computing and so forth?\n\nSure, yeah. I'm always very interested in that kind of stuff. I am actually one of the co-founders of the first hackerspace in Brazil, called Garoa Hacker Clube. We used to do, before the pandemic, lots of experiments of those kinds of things over there. There's also processing.py, which I've delivered courses, introductory courses using. I have a really good friend, Alexandre Vilares, who is a specialist in that. That's also something that anybody who is interested in Python and art should check out, processing.py. It looks cool. You were mentioning it just before we got started, and I'm looking through a handful of the things that look really kind of fun. Those are the things that get me peaked, you know, as far as, \"Oh, this is something I want to experiment with.\" So that's cool.\n\nOne of the things that I always found interesting about Python is really the huge range of applications that people do with it. The only major missing piece is really mobile, right? We don't really have a very good, there's the beware, collective of projects, but it's kind of experimental. At least it was last time I looked. And so we don't have a good solution for that, but for everything else, it's amazing. Yeah, I'm excited. I'm excited to try out some of these new things too, like, um, I know that Brett Cannon's working pretty hard on trying to figure out WebAssembly, Wasm, as people like to pronounce it. Oh, that's cool. Yeah. And the idea of like figuring out the core of Python and how we could implement it in just in its pure elemental thing kind of brought me to this conversation I had with, you know, the developers behind CircuitPython. And, you know, kind of how it has to be this somewhat of a subset of Python in order to fit in that memory space. Um, which is always kind of interesting too.\n\nYeah, but there's also a third level, which is exploratory programming.",
    "ABOVBwITyzI": "Welcome to the Real Python Podcast. This is episode 89. Are you ready to break open the first days of puzzles from the annual Advent of Code challenge? Advent of Code is an Advent calendar of 25 programming puzzles published each December. Practicing solving puzzles is a great way to build your Python skills.\n\nThis week on the show, we have previous guest and Real Python author Guaran\u00e1 Anah\u00edela to discuss his recent article titled \"Advent of Code: Solving Your Puzzles with Python.\" We discussed the history of this online Advent calendar and the creator Eric Wassel. Guaran\u00e1 covers techniques to help you organize your code and test when solving the puzzles. He shares additional Python tools for parsing text, managing puzzle data, and visualizing your program output. We also talk about even more places you can practice solving programming puzzles.\n\nThis episode is brought to you by SeaData software, the easiest way to connect Python with data. SQL access to more than 250 cloud applications and data sources. Alright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey, Guaran\u00e1, welcome back to the show.\n\nThank you so much. It's great to be back. Always fun to talk.\n\nYeah, definitely. We're making this sort of a tradition here.\n\nYeah, we have a great topic for today as well. I'm excited about that.\n\nTo kind of kick off, you also have kind of a bit of a new role at Real Python, being a little more involved than before.\n\nYes, so up until now, I've mainly been freelancing at Real Python in my spare time. But starting from... Well, yesterday when we're recording this, I've started working full-time with Real Python. So now I'll have much more time to dive into topics, great tutorials, and essentially just work with the team on figuring out what we can do that would be useful for our readers, listeners, viewers, and so on. Yeah, I'm excited myself.\n\nI'm really excited myself. So you had an article come out last week also. This will be coming out on Friday from now about Advent of Code. I'm hoping I'm pronouncing his last name correctly, but Eric Wassel. And that came out just the week before. What is the Advent of Code?\n\nAdvent of Code is an Advent calendar, essentially these things that typically open a door every day in the month of Christmas until Christmas Day or Christmas Eve, I guess. When I grew up, we kind of had them and I got one piece of chocolate every day and my parents made one with a small presence. They tended to be Lego or something like this. Nowadays, I think you can kind of find commercial Advent calendars with all kinds of things. The one I see all the time is one for my pets, you know, give them a treat or a toy every day. So that's nice. Now I've had the last couple of years for myself, I have a tea calendar. So I get that every day. Yeah, it's really nice. Advent of Code kind of takes this idea and turns it into a coding challenge, essentially. You get a coding puzzle every day for the days of December. I believe it was started in 2015, so this would be the seventh year it's running. By Eric Wassel, and he has a great presentation online where he kind of talks a little bit about behind the scenes of Advent of Code and how it kind of got started as this small, almost like a joke project that he was just working on for some friends of his. He talks about how he probably did the worst traffic estimation ever, and in guessing that there might be like 50 people that are interested in doing something like this. And even before the first day, I think only through word of mouth, he had much more than 50 people join. Yeah, I think for the first year at least, there were tens of thousands of people joining already in 2015. So yeah, that's a big surprise. So they had a busy December in 2015, I think. But it's an amazing project. I'm so amazed at what they've been able to do, both in terms of kind of the platform of it, but also the puzzles are so much fun to work on.\n\nFor myself, I actually don't remember how I discovered it, but I dug through my files and realized that the first puzzle I did was in December 2016. Okay, second year, okay. And the second year, I think it took a few days into December, so I think it was like December 3rd or 4th or something that I found this probably through Twitter or Reddit or something like this. And I think the first puzzle I did was, I then actually went back to day one of that, which is helping Santa essentially navigate. So you kind of get these right, left instructions. So you kind of need to navigate somewhere on the North Pole and looking for the evil Easter bunny or something like that. It's always a fun story. Yeah, that's one of the cool features, right? There's this really completely ridiculous story typically about how Santa needs your help to save Christmas. Right? It always turns out that you need to find 50 stars in order to save Christmas. So that sounds like something that happens every year. And these stars you gain by solving the puzzles. So there's 25 days and then each day there is sort of like a two-part puzzle. So you get two stars every day. And then ideally then you'll fill up and manage to find these 50 stars so you can save Christmas. But the nice thing with this is that even though it kind of has this built-in time pressure in the sense and it's kind of especially when it's running into the holiday season, you kind of tend to be busy with other things. Yeah, all the old puzzles are always available. So even if there's a day that you don't have time to get to, you can always go back and redo them later. Yeah, that's my history with it is I found after people have been talking about it for a while and I was looking for ways to sort of practice and I always have been into puzzles and that's one of my favorite areas of video games. And so when I came to learning a new language, I think it was, I was dabbling with like JavaScript or something like that. And that's probably the first time I had heard about it. And so it's a neat way to kind of translate your skills across and yeah, I don't know, I think it's great that it keeps all of them live. You know, I'm excited about it. We're making this sort of a tradition here. Yeah, we have a great topic for today as well. So, oh yeah, I'm excited about that. To kind of, I guess, to kick off is you also have kind of a bit of a new role at Real Python, being a little more involved than before. Yes, so up until now, I've mainly been freelancing at Real Python in my spare time. But starting from... Well, yesterday when we're recording this, I've started working full-time with Real Python. So now I'll have much more time to dive into topics, great tutorials, and essentially just work with the team on figuring out what we can do that would be useful for our readers, listeners, viewers, and so on. Yeah, I'm excited myself. I'm really excited myself. So you had an article come out last week also. This will be coming out on Friday from now about Advent of Code, and I'm hoping I'm pronouncing his last name correctly, but Eric Wassel. And that came out just the week before. What is the Advent of Code? Advent of Code is an Advent calendar, essentially these things that typically open a door every day in the month of Christmas until Christmas Day or Christmas Eve, I guess. When I grew up, we kind of had them, and I got one piece of chocolate every day, and my parents made one with a small presence. They tended to be Lego or something like this. Nowadays, I think you can kind of find commercial Advent calendars with all kinds of things. The one I see all the time is one for my pets. You know, give them a treat or a toy every day. So that's nice. Now I've had the last couple of years for myself, I have a tea calendar. So I get that every day. Yeah, it's really nice. Advent of Code kind of takes this idea and turns it into a coding challenge, essentially. You get a coding puzzle every day for the days of December. I believe it was started in 2015, so this would be the seventh year it's running. By Eric Wassel, and he has a great presentation online where he kind of talks a little bit about behind the scenes of Advent of Code and how it kind of got started as this small, almost like a joke project that he was just working on for some friends of his. He talks about how he probably did the worst traffic estimation ever, and in guessing that there might be like 50 people that are interested in doing something like this. And even before the first day, I think only through word of mouth, he had much more than 50 people join. Yeah, I think for the first year at least, there were tens of thousands of people joining already in 2015. So yeah, that's a big surprise. So they had a busy December in 2015, I think. But it's an amazing project. I'm so amazed at what they've been able to do, both in terms of kind of the platform of it, but also the puzzles are so much fun to work on. For myself, I actually don't remember how I discovered it, but I dug through my files and realized that the first puzzle I did was in December 2016. Okay, second year. Okay. And the second year, I think it took a few days into December, so I think it was like December 3rd or 4th or something that I found this probably through Twitter or Reddit or something like this. And I think the first puzzle I did was, I then actually went back to day one of that, which is helping Santa essentially navigate. So you kind of get these right, left instructions. So you kind of need to navigate somewhere on the North Pole and looking for the evil Easter bunny or something like that. It's always a fun story. Yeah, that's one of the cool features, right? There's this really completely ridiculous story typically about how Santa needs your help to save Christmas. Right? It always turns out that you need to find 50 stars in order to save Christmas. So that sounds like something that happens every year. And these stars you gain by solving the puzzles. So there's 25 days and then each day there is sort of like a two-part puzzle. So you get two stars every day. And then ideally then you'll fill up and manage to find these 50 stars so you can save Christmas. But the nice thing with this is that even though it kind of has this built-in time pressure in the sense and it's kind of especially when it's running into the holiday season, you kind of tend to be busy with other things. Yeah, all the old puzzles are always available. So even if there's a day that you don't have time to get to, you can always go back and redo them later. Yeah, that's my history with it is I found after people have been talking about it for a while and I was looking for ways to sort of practice and I always have been into puzzles and that's one of my favorite areas of video games. And so when I came to learning a new language, I think it was, I was dabbling with like JavaScript or something like that. And that's probably the first time I had heard about it. And so it's a neat way to kind of translate your skills across and yeah, I don't know, I think it's great that it keeps all of them live. You know, I'm excited about it. We're making this sort of a tradition here. Yeah, we have a great topic for today as well. So, oh yeah, I'm excited about that. To kind of, I guess, to kick off is you also have kind of a bit of a new role at Real Python, being a little more involved than before. Yes, so up until now, I've mainly been freelancing at Real Python in my spare time. But starting from... Well, yesterday when we're recording this, I've started working full-time with Real Python. So now I'll have much more time to dive into topics, great tutorials, and essentially just work with the team on figuring out what we can do that would be useful for our readers, listeners, viewers, and so on. Yeah, I'm excited myself. I'm really excited myself. So you had an article come out last week also. This will be coming out on Friday from now about Advent of Code, and I'm hoping I'm pronouncing his last name correctly, but Eric Wassel. And that came out just the week before. What is the Advent of Code? Advent of Code is an Advent calendar, essentially these things that typically open a door every day in the month of Christmas until Christmas Day or Christmas Eve, I guess. When I grew up, we kind of had them, and I got one piece of chocolate every day, and my parents made one with a small presence. They tended to be Lego or something like this. Nowadays, I think you can kind of find commercial Advent calendars with all kinds of things. The one I see all the time is one for my pets. You know, give them a treat or a toy every day. So that's nice. Now I've had the last couple of years for myself, I have a tea calendar. So I get that every day. Yeah, it's really nice. Advent of Code kind of takes this idea and turns it into a coding challenge, essentially. You get a coding puzzle every day for the days of December. I believe it was started in 2015, so this would be the seventh year it's running. By Eric Wassel, and he has a great presentation online where he kind of talks a little bit about behind the scenes of Advent of Code and how it kind of got started as this small, almost like a joke project that he was just working on for some friends of his. He talks about how he probably did the worst traffic estimation ever, and in guessing that there might be like 50 people that are interested in doing something like this. And even before the first day, I think only through word of mouth, he had much more than 50 people join. Yeah, I think for the first year at least, there were tens of thousands of people joining already in 2015. So yeah, that's a big surprise. So they had a busy December in 2015, I think. But it's an amazing project. I'm so amazed at what they've been able to do, both in terms of kind of the platform of it, but also the puzzles are so much fun to work on. For myself, I actually don't remember how I discovered it, but I dug through my files and realized that the first puzzle I did was in December 2016. Okay, second year. Okay. And the second year, I think it took a few days into December, so I think it was like December 3rd or 4th or something that I found this probably through Twitter or Reddit or something like this. And I think the first puzzle I did was, I then actually went back to day one of that, which is helping Santa essentially navigate. So you kind of get these right, left instructions. So you kind of need to navigate somewhere on the North Pole and looking for the evil Easter bunny or something like that. It's always a fun story. Yeah, that's one of the cool features, right? There's this really completely ridiculous story typically about how Santa needs your help to save Christmas. Right? It always turns out that you need to find 50 stars in order to save Christmas. So that sounds like something that happens every year. And these stars you gain by solving the puzzles. So there's 25 days and then each day there is sort of like a two-part puzzle. So you get two stars every day. And then ideally then you'll",
    "hMnANVrXdhM": "Welcome to the Real Python Podcast. This is Episode 90. The Python community continually grows with many users coming from different languages and backgrounds. This week on the show, we talk with developer Hugh Tipping about his Python journey. Hugh is also a member of the Real Python community. Hugh's background is in programming C and Perl, but he started to use Python in a cybersecurity job. He explains the way he used Python to search for malware and provides some suggestions for security packages and tools.\n\nRecently, Hugh has been working with Amazon Web Services (AWS) and using the Bottle 3 library to automate services and manage authorizations with Python. We also discuss his affinity for test-driven development and the use of Pytest.\n\nCloudsmith is a secure software supply chain management tool for your Python packages and dependencies. Try Cloudsmith for free at cloudsmith.com. Sign up! Alright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey Hugh, thanks for coming on the show.\n\nHey, thanks for having me on. So, Dan Bader had brought up your name to me as a member of the Real Python community, and so I reached out and wanted to know if you would want to come on the show and talk a little bit about your Python experience. As we talked before the show, I was really intrigued by your journey. Not only in Python, but just in kind of the different areas and it was similar to me in the sense that it's always kind of finding different ways to do programming and troubleshooting. So I thought maybe we could start there. Maybe start a little bit with kind of your background. We don't have to go all the way back, but we talked initially about you getting into Python and what was the first places where you started using it.\n\nYeah, about a decade ago, prior job, I started using Python at a company that was very Perl-centric. There had been a lot of talk about moving things to Python for various reasons. So we can talk about that as we go along. But I was in a cybersecurity role. I was doing a lot of investigations on malware infections and other types of things. I wanted to do some tooling to help rid some of our Windows PCs of malware by remotely editing registries, and Python seemed the way to go because at the time, the cybersecurity community was using Python a lot and my company did an internal class on Python. I said, \"Let me give it a try.\" Once I discovered it, I really didn't feel like using Perl anymore. Perl was great for me for 12 years before that.\n\nHow were you using Perl in those earlier jobs?\n\nWell, I did a lot of systems administration work throughout my career, and much of it involved troubleshooting, looking through logs, and Perl was the best at doing a lot of parsing and reporting. I mean, Perl stands for Practical Extraction Reporting Language, so regexes and reporting templates and things like that were built right into it. You could throw a regex in the middle of a Perl state and have it just parse data. It was really easy. So it helped a lot with troubleshooting over the years and building out usage reports and other things and just getting us getting really huge logs.\n\nYou mentioned the company that you were working with introduced you to Python. What was it like, a class or a seminar, or how did they do that?\n\nYeah, they brought in an instructor to teach the class, and I was in the class with a lot of some of their senior developers. I felt a little intimidated, even though I attended college for programming, I didn't do a lot as a full app dev, and so this was a little strange being in the class with all these really incredible application developers. But I did well in it. The teacher was good, and Python's ease of learning really lended itself to me being able to pick it up and just use it right away.\n\nHad you been using any other languages before Perl?\n\nYeah, I had done a bit of C. C was a lot of my bread and butter during college when I was going for a computer science major. I had done a lot of C just with a lot of open source stuff that had to be modified. Back in the early days of open source, things didn't always come with if you just do a make install or make build and it just worked. I had to do a lot of modifications of things. So I was definitely putting a lot of my C to use there. Do you see sometimes now also like the kind of way you can have extensions? Yeah, now I haven't used C in a very long time. I have thought about getting back into it so I could do extensions or libraries, but it's never really come up. There's just such a wonderful world of modules out there. I'm just grateful for all the people who put in the time to make these tools that make my life easier.\n\nCan you explain kind of some of the cybersecurity job? How was it looking at Windows machines? Were you working for, doing work that was for internal stuff inside of a particular organization, or was it for other businesses?\n\nYeah, we did it so the work that I did was sort of cross-company. We would get alerts for evidence of malware. We would have to frequently either update AV or if the AV wasn't handling that particular malware, if we had some idea what the malware did, we would have to go in and make some manual changes. When there were particular types of malware at the time that would not only inject itself but it would also do some funky stuff with the Windows registry to make sure that it stayed around and make sure that it executed upon reboot. So one of my first Python scripts, even if I was mostly a Linux/Unix person throughout my career, one of my first Python scripts was a Win32 script that actually remotely connected to a Windows registry. It found the particular chunk of badness that the malware had inserted into the registry and it would remove it. And then if we knew specifically which files were infected or what kind of junk it dropped in the file system, we would also put markers in the registry to mark those files for deletion upon reboot. Okay, so the Python script would take care of that in the registry. It would also actually keep a copy of that hive from the registry in case we screwed up any of the other software on the machine and so we could restore it. And that was very, very helpful because we could call up an individual and say, \"Hey, I need you to log out. I'm going to run this script and then I need you to reboot.\" And then the malware was gone. So it was fun. So almost all in remote, it sounds like. It was remote because we had to deal with people in remote offices and I was fortunately granted administrator remote administrator privileges so that I could run the script with my credentials and be able to do it. It was pretty cool. I was kind of proud of myself. Was your Perl background helpful in the sense that you, I think about this idea of going through the registry and looking for specific elements and maybe regular expressions or something like that would become in handy there or your Perl background would come in handy as you apply it to Python? I learned and got pretty good at regular expressions mostly through all of my Perl work. So when I had to use the Python Re module, my challenge was only just figuring out how to use the Res in Python but not actually build builds the regular expression. So yeah, all the Perl experience definitely helped and that's why you know when you're looking at regular expression engines, they're frequently labeled as pcre - Perl compatible regular expressions. So okay, that's where that term comes. I don't know if that term is used all that much these days, but for quite some time it was. Have you been using any of the other languages before Perl? Yeah, I had done a bit of C. C was a lot of my bread and butter during college when I was going for a computer science major. I had done a lot of C just with a lot of open source stuff that had to be modified. Back in the early days of open source, things didn't always come with if you just do a make install or make build and it just worked. I had to do a lot of modifications of things. So I was definitely putting a lot of my C to use there. Do you see sometimes now also like the kind of way you can have extensions? Yeah, now I haven't used C in a very long time. I have thought about getting back into it so I could do extensions or libraries, but it's never really come up. There's just such a wonderful world of modules out there. I'm just grateful for all the people who put in the time to make these tools that make my life easier. Can you explain kind of some of the cybersecurity job? How was it looking at Windows machines? Were you working for, doing work that was for internal stuff inside of a particular organization, or was it for other businesses? Yeah, we did it so the work that I did was sort of cross-company. We would get alerts for evidence of malware. We would have to frequently either update AV or if the AV wasn't handling that particular malware, if we had some idea what the malware did, we would have to go in and make some manual changes. When there were particular types of malware at the time that would not only inject itself but it would also do some funky stuff with the Windows registry to make sure that it stayed around and make sure that it executed upon reboot. So one of my first Python scripts, even if I was mostly a Linux/Unix person throughout my career, one of my first Python scripts was a Win32 script that actually remotely connected to a Windows registry. It found the particular chunk of badness that the malware had inserted into the registry and it would remove it. And then if we knew specifically which files were infected or what kind of junk it dropped in the file system, we would also put markers in the registry to mark those files for deletion upon reboot. Okay, so the Python script would take care of that in the registry. It would also actually keep a copy of that hive from the registry in case we screwed up any of the other software on the machine and so we could restore it. And that was very, very helpful because we could call up an individual and say, \"Hey, I need you to log out. I'm going to run this script and then I need you to reboot.\" And then the malware was gone. So it was fun. So almost all in remote, it sounds like. It was remote because we had to deal with people in remote offices and I was fortunately granted administrator remote administrator privileges so that I could run the script with my credentials and be able to do it. It was pretty cool. I was kind of proud of myself. Was your Perl background helpful in the sense that you, I think about this idea of going through the registry and looking for specific elements and maybe regular expressions or something like that would become handy there or your Perl background would come in handy as you apply it to Python? I learned and got pretty good at regular expressions mostly through all of my Perl work. So when I had to use the Python Re module, my challenge was only just figuring out how to use the Res in Python but not actually build builds the regular expression. So yeah, all the Perl experience definitely helped and that's why you know when you're looking at regular expression engines, they're frequently labeled as pcre - Perl compatible regular expressions. So okay, that's where that term comes. I don't know if that term is used all that much these days, but for quite some time it was. Have you been using any of the other languages before Perl? Yeah, I had done a bit of C. C was a lot of my bread and butter during college when I was going for a computer science major. I had done a lot of C just with a lot of open source stuff that had to be modified. Back in the early days of open source, things didn't always come with if you just do a make install or make build and it just worked. I had to do a lot of modifications of things. So I was definitely putting a lot of my C to use there. Do you see sometimes now also like the kind of way you can have extensions? Yeah, now I haven't used C in a very long time. I have thought about getting back into it so I could do extensions or libraries, but it's never really come up. There's just such a wonderful world of modules out there. I'm just grateful for all the people who put in the time to make these tools that make my life easier. Can you explain kind of some of the cybersecurity job? How was it looking at Windows machines? Were you working for, doing work that was for internal stuff inside of a particular organization, or was it for other businesses? Yeah, we did it so the work that I did was sort of cross-company. We would get alerts for evidence of malware. We would have to frequently either update AV or if the AV wasn't handling that particular malware, if we had some idea what the malware did, we would have to go in and make some manual changes. When there were particular types of malware at the time that would not only inject itself but it would also do some funky stuff with the Windows registry to make sure that it stayed around and make sure that it executed upon reboot. So one of my first Python scripts, even if I was mostly a Linux/Unix person throughout my career, one of my first Python scripts was a Win32 script that actually remotely connected to a Windows registry. It found the particular chunk of badness that the malware had inserted into the registry and it would remove it. And then if we knew specifically which files were infected or what kind of junk it dropped in the file system, we would also put markers in the registry to mark those files for deletion upon reboot. Okay, so the Python script would take care of that in the registry. It would also actually keep a copy of that hive from the registry in case we screwed up any of the other software on the machine and so we could restore it. And that was very, very helpful because we could call up an individual and say, \"Hey, I need you to log out. I'm going to run this script and then I need you to reboot.\" And then the malware was gone. So it was fun. So almost all in remote, it sounds like. It was remote because we had to deal with people in remote offices and I was fortunately granted administrator remote administrator privileges so that I could run the script with my credentials and be able to do it. It was pretty cool. I was kind of proud of myself. Was your Perl background helpful in the sense that you, I think about this idea of going through the registry and looking for specific elements and maybe regular expressions or something like that would become handy there or your Perl background would come in handy as you apply it to Python? I learned and got pretty good at regular expressions mostly through all of my Perl work. So when I had to use the Python Re module, my challenge was only just figuring out how to use the Res in Python but not actually build builds the regular expression. So yeah, all the Perl experience definitely helped and that's why you know when you're looking at regular expression engines, they're frequently labeled as pcre - Perl compatible regular expressions. So okay, that's where that term comes. I don't know if that term is used all that much these days, but for quite some time it was. Have you been using any of the other languages before Perl? Yeah, I had done a bit of C. C was a lot of my bread and butter during college when I was going for a computer science major. I had done a lot of C just with a lot of open source stuff that had to be modified. Back in the early days of open source, things didn't always come with if you just do a make install or make build and it just worked. I had to do a lot of modifications of things. So I was definitely putting a lot of my C to use there. Do you see sometimes now also like the kind of way you can have extensions? Yeah, now I haven't used C in a very long time. I have thought about getting back into it so I could do extensions or libraries, but it's never really come up. There's just such a wonderful world of modules out there. I'm just grateful for all the people who put in the time to make these tools that make my life easier. Can you explain kind of some of the cybersecurity job? How was it looking at Windows machines? Were you working for, doing work that was for internal stuff inside of a particular organization, or was it for other businesses? Yeah, we did it so the work that I did was sort of cross-company. We would get alerts for evidence of malware. We would have to frequently either update AV or if the AV wasn't handling that particular malware, if we had some idea what the malware did, we would have to go in and make some manual changes. When there were particular types of malware at the time that would not only inject itself but it would also do some funky stuff with the Windows registry to make sure that it stayed around and make sure that it executed upon reboot. So one of my first Python scripts, even if I was mostly a Linux/Unix person throughout my career, one of my first Python scripts was a Win32 script that actually remotely connected to a Windows registry. It found the particular chunk of badness that the malware had inserted into the registry and it would remove it. And then if we knew specifically which files were infected or what kind of junk it dropped in the file system, we would also put markers in the registry to mark those files for deletion upon reboot. Okay, so the Python script would take care of that in the registry. It would also actually keep a copy of that hive from the registry in case we screwed up any of the other software on the machine and so we could restore it. And that was very, very helpful because we could call up an individual and say, \"Hey, I need you to log out. I'm going to run this script and then I need you to reboot.\" And then the malware was gone. So it was fun. So almost all in remote, it sounds like. It was remote because we had to deal with people in remote offices and I was fortunately granted administrator remote administrator privileges",
    "KaEW9Qt0xxY": "Welcome to the Real Python Podcast. This is episode 91. It's been a year of change at Real Python. The Real Python team has written, edited, curated, illustrated, and produced a mountain of Python articles this year. We also added many new members to the team, updated the site's features, and created new styles of tutorials and projects.\n\nTwo members of the Real Python team join us this week, Martin Royce and Sadie Parker. We wanted to share a year-end wrap-up with a collection of articles and step-by-step projects that showcase what our team created this year.\n\nSadie and Martin help to shepherd articles through the multi-stage editing process along with the rest of the team. They make sure these resources impart crucial Python knowledge and provide a thorough didactic experience. We hope you enjoy this review.\n\nProgramming note: there won't be an episode next week, but we'll be back in January and look forward to bringing you a year full of great guests, articles, and topics.\n\nAlright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com.\n\nAfter the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nWell, it's that time of year where we're going to wrap up articles here at Real Python, and I have two guests, former guests of the show at different times. First is Martin Royce. Thanks for coming back, Martin. Happy to be here.\n\nAlright, and the other person you hear kind of laughing in the background, that's Sadie Parker. Hi, thanks for having me, Chris. Yeah, Sadie was on the show back in the summer of 2020 to talk about us adding transcripts to all our video courses. It was 2020 for some reason, I thought it was 2019, but of course, it was 2020.\n\nYeah, it's been a year. Yeah, it's been interesting times. And speaking of which, there have been a lot of new things at Real Python over the last year. Martin, you became full-time in the spring, is that right? That's right, yeah. I've been a full-time content creator since the start of April. What are the other kinds of things that you're doing at Real Python now? So I'm kind of floating in between both the written and the video contents. I'm producing video courses and also written tutorials, and then a lot of the feedback rounds and reviews on all different levels. I'm involved with those as well. Yeah, got your hands in lots of different areas of that. That's great, and I appreciate your help with the video courses. That's been great. Oh yeah, another eye on the reviews of that has been really helpful for me. And Sadie, you've changed to do quite a bit more this year with Real Python. Yeah, what have you started to do now? So yeah, when we last spoke in the middle of 2020, like you said, I started with transcripts and subtitles for video courses. So I've still been doing that, and then in the middle of this year, I guess it was June when Joanna left, I took over copy editing and didactic review and publication and timing type work from Joanna and Jacob. So just a lot of work with the written content pipeline, which I wasn't really involved with before. So it's been pretty cool to see both two sides of content at Real Python. We got the articles and the videos and everything that goes on there. Yeah, so yeah, it's been a lot of fun tasks to take on. It's been really cool to get to know how Real Python works on the inside, all the great review steps and all the processes that are set up. The job has been, I think, like for a lot of people at Real Python, it's a lot of going back and forth between people and tech, which is a pretty fascinating intersection. Right, you're kind of looking at like instruction manuals for how to do X, Y, and Z, and you're looking at the bare bone skeleton of Python, which itself is always changing, and then you're kind of trying to combine that with getting into the minds of people at different levels of Python expertise and from different parts of the world. Yeah, it's a pretty interesting job. It's mostly kind of like, I guess, a lot of jobs like how to communicate effectively and how to view a topic from someone else's perspective. And it's really interesting when that gets combined with technology. It's been fun. Yeah, we have quite the international authorship if you will. It's kind of amazing. Yeah, we've had some interesting changes. There's been a few things that have carried over, additions that we were doing from last year, like office hours, and Martin, you've been really involved in that, and I know you want to talk about that a little bit further as we go along in this episode. But who's been hosting office hours with you this year? So, after David's been doing the office hours basically by himself with the community, and when David left, we kind of tried to take it over as a team and split up the responsibilities for office hours some more. So, I think most of the core content developers that are working at Real Python full-time are now splitting it up, and we've got a little wheel going, and there's often more than one person joining. So, it's developed as quite a nice, I don't know, a community space where we also get the chance to hang out as content creators with each other and with the community and answer questions and go over some tutorials and just do some learning and teaching together. So, it's been quite fun. I'm so glad that that's continued on. I think it's a great resource for all the Real Python members. We have stopped recording them also with the idea that we want to make it really as an inclusive space where people feel comfortable sharing questions that maybe they consider to not be beginner questions or something that they might not want to ask if it's being recorded and just to make it as welcoming as possible. Okay, yeah, that makes sense. Nice. What are some of the other changes? I think this year we started doing the news articles. Yeah, and David started those, I think. I don't know, was it February or March? I think it could be the first one I see is April. Okay, yeah. David was doing those for like several months, at least four months. And then we've got a lot of great news articles from the first half of the year and the second half of the year. David worked on those first ones and we got one by Bartosz Chinsky and by Gearna Kelly. Yep, yeah, they're, I think, really fun. I've enjoyed working on them. What's the point of these news articles? So they're kind of like these short and sweet summaries of what happened during any particular month. They're going to be like particularly helpful for someone who works with Python but isn't necessarily plugged into the day-to-day month-to-month changes with the language or helpful packages or all that type of stuff. Python community news, yeah, yeah, that is a wonderful way to summarize it. I want community news, and it's been quite the year for the news too with everything. I've had episodes about a lot of the stuff like the developer in residence program starting, Python 3.10 was a lot of big changes with that this year, some other kind of squabbling within the community and then the resolution of that. It's been a newsworthy year. So I'm glad that we've been continuing that. I never really thought that I would know much about Python news. I didn't honestly before working on these news articles. I've read is like politics and like celebrities, right? But when reading over these articles, which are like honestly really good summaries of what's going on and they kind of dig into it just enough so that you know where to look for more news, but they're not really like a deluge of information, yeah. And yeah, you get a little taste of the drama. You get an idea of what's happening. Like for example, at the Python Software Foundation, yeah, changes there. Yeah, and yeah, it seems like you've had some of these people who've been in the Python news on your show, which is pretty cool. Yeah, yeah, it's been a fun year for that and lots of positive changes in the world of Python over the last year. So that's been great. Oh, one more cool thing about the news articles that I've noticed is a lot of times, if there's",
    "jFqQk5dzGAs": "Welcome to the Real Python Podcast. This is Episode 92. A year ago, we had Brett Cannon on the show to discuss his blog series about unraveling Python syntactic sugar. Brett has written 15 more entries in the series, and he returns to the show this week to continue our conversation. We dive into unraveling async and await statements and the relationship with Python's generators. While working through the series, he has uncovered some issues lying under the surface of Python. We discuss a couple of these discoveries and how the core developers resolved them. Brett was recently re-elected to the Python Steering Council, and he talks about how the current direction of the council is shifting. We also discuss how Brett uses Twitter polls to gauge community sentiment and factors it into development decisions.\n\nThis conversation covers so many topics that we split it into two episodes. Next week's episode, we'll continue our discussion.\n\nThis episode is brought to you by Honeybadger. Honeybadger offers error monitoring, uptime, and cron monitoring designed to tame your production and make you a better, more productive Python developer.\n\nAll right, let's get started with part one.\n\n[Music]\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey, Brett, welcome back to the show. Thanks for having me. Congratulations are in order. Just a couple of days ago, the Python Steering Council election results. Was it just yesterday? Yesterday for us when we're recording, okay. Yeah, and you're back on the Steering Council. So awesome. Yeah, I squeaked by. I seem to be slowly falling down the ranks of votes. I fell into the fifth slot, so it seems like I might not get back in next year, but at least this year I managed to squeak in and pull it off. We'll have to see how we can influence the vote in the future. I think it's fine. Honestly, I am now the longest-serving member of the Steering Council. I think turnover is a good thing. Even if I did get voted off, I wouldn't take it personally. We've got some new people on, which are great too. Craig and Peter, and I think Pablo just totally killed the amount of his voice. I think literally only six people didn't vote for him because we used to open. I don't know the technical term for the voting system, but it's basically open voting. You can vote for as many people as you want, and whoever gets the top five votes gets in. Okay, Pablo got 61 out of the 67 ballots cast, so wow, he's good. Yeah, it's actually interesting. I think it was kind of a slight referendum on the view of backwards compatibility versus forward progression. And honestly, the people who got in, both plus the two who got in, Peter and Craig, kind of ran on a platform of let's slow things down a bit. Okay, and so I think that's kind of a signal to the Steering Council that people are very much wanting to possibly take a different tact than we used to in the history of Python of all right, we don't need to move so fast. We can think about things, maybe tweak the deprecation policy a bit, or just talk about how we want to move things forward and make sure there's a really clear progression for anything we might want to do, etcetera, etcetera. So I think it's gonna be interesting. It has been a crazy year since I talked to you last January. Yeah, so top of the year, a lot of change going on, the developer in residence, and my conversation with Lucas about that, the idea of, you know, the backlog and kind of going through all of the issues and bugs at python.org. And so there's a, you know, there's definitely a lot of area to kind of focus on if somebody does want to slow down a little bit. Yeah, well, it's a lot of this, I, there's a mix here, right? There's the, there's change from the perspective of the standard library and what people get directly exposed to. But then there's also change at the C level, and that plays into more of performance, right? Like a lot of this is coming up because people are realizing that the C API that we expose for extension modules is so broad and open that actually makes optimizing C Python really hard, especially if you don't want to break extension modules. And so it's this constant battle of, \"Okay, if we took, if we broke this or took this away, how hard would it be to work around it? And is it worth it, knowing full well that there are plenty of probably extension modules out there that will never get updated, right? You always run that risk when you break something that someone will be left behind, right? Because that project's just been abandoned, it hasn't been used anymore. And so it's a constant discussion and balancing act of, \"Is this worth it?\" And unfortunately, it's completely subjective. We can never get good enough numbers. There's enough, what some people call black code behind closed doors that we'll never get exposed to and have any idea about to know really how much this would really influence or impact people. So we have to just do the best we can. And so there's a couple bits to what would be classified as slowing things down or depletions, whatever, and it's a constant conversation, and we're always trying to balance it the best we can. But my suspicion is based on this election, at least the core devs are suggesting like, \"Yeah, we might need to slow the pace down a little bit,\" which, okay, just totally fair. That makes sense. Yeah. On another project front, how's the Python in VS Code project going? This, your main gig right at Microsoft. Yeah, so the pain, the thing that pays the bill so I can do open source in my spare time, right? Has me as the dev manager for the Python extension of VS Code. Although I'm hoping what we are as a whole team actually hoping to make it more the Python experience, because we're starting to look at actually taking our monolithic extension and kind of breaking it up a bit. We actually want to kind of try to lean in to make it easier for people to make their own extensions. Okay? So we're going to try to figure out a way if we can such that Python developers who want to have a VS Code extension can actually do that themselves, right? Like, because VS Code is an Electron app and it's written in TypeScript. Traditionally, extensions that were written in TypeScript, but we use this technology that was developed for VS Code called the Language Server Protocol or LSP. And it's basically a way to let the S Code launch a process to spin up a server that can do things for the editor. And this can be anything from diagnostics like error messages to formatting to autocomplete to specifying the full the areas that you fold your code at, okay? Like, it's pretty rich. And the nice thing about it is it's editor agnostic, right? Like, you can use this with Emacs, you can use this with Vim, Sublime Text, obviously VS Code. There are a bunch of editors that you can actually that have support for LSP via some mechanism. And so what we're going to be looking at is, can we make it so that there's basically boilerplate for people to create VS Code extensions as long as they implement a language server, and that way the amount of TypeScript you got to know is hopefully zilch. You'll just take our template and whatever form that ends up taking, and you can basically just immediately just launch your Python language server that you run Python and only Python yourself, and you just get up and going. And we're going to hopefully be tackling that this upcoming year. Wow, that's cool. Yeah, it's exciting, right? Like, I want to get it to the point where you come to VS Code because you like VS Code, not because we have some specific support. Like, I don't think us having tool support should be our differentiator. Our differentiator should be that VS Code editing experience overall is what you think is the best and not because, \"Oh, we happen to have Flake8 under the hood that this is only available here.\" Exactly. And conversely, I never want you to go, \"Oh, I don't want to use VS Code because you don't support Flake8 or something.\" Right? Whatever tool you want to use, I want it to be so easy for you to bring that tool to VS Code that it's a no-brainer. Either because you can do it yourself or because the tool creator, VS Code user or not found it so easy to create an extension that they did so. Basically, I want to commoditize tool support as much as I can, and it benefits everyone too. Right? As I said, LSP is usable by all editors. So if we can somehow help the community do that, we can get better editor integration across the board for all editors and not just VS Code. And I think that's a great benefit to everybody. So that's the audacious goal of 2022. Wow, yeah, that's a big one. Does that mean like tools like Pylance would be available outside of VS Code then? Pylance is a tricky bit because it's closed source for various IP reasons. Okay, so I wouldn't say anything that way. I mean, DebugPy, which is the debugger that we, that is fully open and lets us help support PTVSD, PTSD anymore, but DebugPy is our open source debugger that we help fund and run that is completely open source. Anyone can use that. I think other editors actually do already use it. Okay. But this is more taking tools from the community and making them brought into VS Code. Yeah. The adding the extension.dev thing was kind of a surprise this summer for like being able to edit a GitHub repository that way. So a lot of really interesting stuff happening with VS Code. I'm hoping to get Savannah on to talk about some of this again. Once things sort of settle down, maybe in the beginning of the year, we can get together and talk about it. Yeah, yeah. Cool. This is kind of just a weird off-the-cuff question that I thought about. You do a lot of surveys on Twitter. Yes. How is that helpful? Like how do you feel like using that informs your decision? Do you feel like you have a wide enough like group of people answering it? Does it change the way you think? So the surveys I do on Twitter are typically a way for me to double check my assumptions. Right? Okay. I've been coding in Python and I just realized this the other day for 21 years. And I've been a core dev for over 18. So I have a historical perspective on things that might not match up with modern-day views. Sure. Right? So I may have picked up a habit from something that was more common way back in the Python 1.5.8 days than is in the Python 3.10 days. Okay. So when I'm at a",
    "5EU4HSZMOC8": "Welcome to the Real Python Podcast. This is episode 93. Would you like a simple command to launch your Python programs using the newest version of the language installed on your machine? This week on the show, we continue our conversation with Brett Cannon. Brett discusses his project, the Python Launcher for Unix. We dive into Brett's workflow to set up projects, virtual environments, and prepare for distribution. He shares some of the tools he employs and reasons for keeping things simple. We also talk about PEP 665, which specifies a file format to list an application's Python package installation requirements. Brett shares why he co-authored the PEP and a bit of the community's reaction. It leads to a deeper conversation about going beyond requirements.txt files to lock files.\n\nThis episode is brought to you by Scout APM. Spend less time debugging and more time building with Scout APM. All right, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nAll right, well maybe we should shift into one other area that you've talked about recently, which is the Python Launcher. I had a question about the development of it and then kind of like your personal uses, how you navigate this. Maybe I can give a little background of how I approach this. I end up using lots of versions of Python as an instructor, as a video creator, as somebody testing other people's code to make sure this tutorial is going to work, going through some other kind of thing and going to talk about it on the show. So, I very inefficiently have installed three, four maybe versions of Python on my computer and I edit the files to choose which one's getting pushed in so that's the current version, which is pretty inefficient, like going in and editing my bash or zsh file, you know. I know that's not an appropriate way to do it, but it's been working. So then I've seen lots of other solutions like pipenv potentially or pipenv and I don't know, there's a whole bunch of them right? Oh yes, had to support all of them in VS Code somehow, so I'm unfortunately well aware of all the options we have in the community.\n\nYeah, yeah and you got to support them, yeah, okay. I didn't know, you know, when I looked at this a little bit more to do some research for the show, I don't use Windows a lot. I have in certain circumstances but I never learned about the Python Launcher, which is kind of old. I mean it's almost 10 years old, PEP 397 March 2011. And then the idea that you could just instead of typing the word Python out, you can type just pi to launch the latest version of Python on your machine. I'm kind of wondering like why did you want to create this Python Launcher for Unix and I don't know if you're the only person involved in that but is it because of like things you need to work through or I don't know, I got a bunch of questions there, sorry, it's a mess.\n\nYeah, sure, so it is just me. The way it came about was two things. There's the original inspiration, the thing that finally pushed me over to do it. The inspiration was some, once again, I follow trainers and I know sometimes trainers feel like, I don't know if they think I personally don't or just the Python Council in general. I know some people think we don't listen to trainers because we keep adding things to Python which makes their lives harder, right? But I do listen, we do care about the beginning, getting started experience and keeping things simple and all that. So I do this. And one of the things someone was lamenting was the fact that if beginners when they install Python on Windows don't pay attention and click that box that says please add Python to path, yeah, you can't type Python and have it show up. Now, Windows 10 changed that a bit because if you type Python, it'll open up the Windows Store and that you install Python from the Windows Store, which is great because it makes it way quicker and easier to install and now it will install the launcher and all that stuff. But the thing was is at the time that wasn't really happening and because it took me a few years to get the launcher done, people were just going like, uh, it sucks every time I teach these courses. Like, I have to tell the Mac people one thing, I tell the Windows people another thing. There's just this constant friction point for everyone where it's just like, yeah, why can't we have one set of instructions to tell people what to do. And so, one approach was Steve Dower, who is in charge of the Python build for outside the Windows build for Python and include, which also includes obviously how it gets installed. His solution was to talk to the Windows team and get that shim for the Python command put into Windows so that it'll launch the Windows Store. My solution was to think about, well, why don't we have pi as a command on Mac or Linux? I mean, the trainers were running into more on people bringing Mac laptops and anything and like, huh, that's an idea. But then what really did it for me was I work at Microsoft, I have a Windows laptop and I started to do work in Windows itself and just to see what it was like for Python users on Windows because I historically been a Mac, Flash, Unix person, okay. And the pi command was handy. It's like, oh, this is convenient. Much like you, I typically have multiple versions of Python installed because right reasons, just it's me. I just install all of them, it doesn't matter. Testing purposes for the extension for the Python extension for VS Code, so all sorts of stuff. So I have multiple versions and the pi command turned out to be handy. And so, I just finally got to the point was like, yeah, you know what, I get people's complaints about having to teach people two different ways to do it, especially if they didn't install Python with you there for you to tell them click that box or the pre-Windows 10 days before the command opened up the Windows Store and so you worked out some of the kinks on the earlier versions of the Python versions, like the 3.10 version, so I started this code like four years ago, I think. Okay, so I just finally, okay, you know, I'm gonna try to fix this and when I went and looked at the Windows implementation, it's all in C and I just mean I went, I don't want to write C, I don't want to make this all work on Unix, this looks like a pain. And I went, oh wait, I've been wanting to learn Rust and so I realized that this was like a perfect Rust project. The semantics aren't complicated, it's totally something you want to be self-contained and just something you just download and run, right, which I know is a complaint people have about Python compared to compiled languages. I mean, it's very easy just to compile a Rust program into a single binary just there you go. It seems to have just the right level of complexity to have to learn pretty much all facets of the language to some extent and so I decided, yeah, all right, you know what, I'm going to implement the Python Launcher for Unix in Rust and yeah, to see how it goes. And it took me three years, mainly for no real reason other than it's a side project that no one was really asking for and it wasn't really going to have a massive impact on the community necessarily, so it was just and I was learning Rust while I did it, so I just had to have enough time to learn Rust while working on it to figure out how best to do things and all that and I just chipped away at it bit by bit and as I did it, I became my own dog fooder so I'd use it on my Mac as the way to run Python and that's how I came up with the inspiration of like, oh yeah, you know what, I always create my virtual environments and they, I always name them .venv and I create them in the directory of the project I'm using them for, right. I'm just not a virtual live wrapper kind of person or whatever, I don't keep them all in some global directory for me that drives me nuts because I don't know which of these environments are for what, if they're for a specific project, why aren't they kept with the project, that's right, my problem there, yeah, I understand some people hate that and they want to own the global directory because like the idea of being able to just delete that whole directory and get rid of all their environments at once, whatever, change their own. Never made sense to me, real quick, yeah, the dot makes it hidden and does it provide other functionality in the sense that like it might ignore it immediately or I don't know, like get won't ignore it immediately but VS Code will ignore it immediately, okay, yeah, exactly. So for me, that was another motivator, right, like when I do code searching, I don't want to search through my third-party installed packages, I'm not looking in their code, I'm looking at my code, okay, and if I really care, I could always open the site packages in VS Code and search that way or pull up a terminal and just use rip grip or whatever gripping tool I want to search in there, if I really wanted to, so it just fit my workflow and once again, I'm the only one making this and one thing I have learned over the years is being opinionated is not bad but by being opinionated, it makes it easier to say no, right, so which keeps projects simpler to maintain because then I don't constantly feel guilty for not implementing someone's requirement if it doesn't meet my requirements, like that's great, feel free to fork but that doesn't meet my needs so I'm not going to do it, sorry, which let me keep this project small and something I'm happy to maintain because as long as it keeps meeting my needs, that works, that's it is basically I kept using it, kept finding these little ways to improve my workflow and eventually got to the point where with the automatic virtual environment usage on top of always describing the newest version of Python, I don't really type the word Python anymore when I'm doing development on my machines, I always just type pi and it's just p y, yeah, okay, yeah, literally if I open up a new project and I don't have a work department, I just do p y space dash m v i v dot v e m v and then I just type pi from there on, like I literally don't have to type Python anymore, I really don't and it's just so convenient that it's just kept going, I've been extremely lucky I've not had to do a single point release for it yet, the semantics have held off, no one's really probably in bug reports, all the problems have been around documentation, FAQ to help people like using pi env or homebrew to help the launcher find their installs, but otherwise, yeah, it's really worked out so that's cool.\n\nHow does it find the most recent installation? So the semantics are really simple, so it reads your path environment variable and then what it does, so it reads that environment variable, gets the list of all the directories, it gets a list of all the files in those directories and looks for anything named Python something dot something, it then parses out those two numbers, the major and minor versions and then it just does a sort, okay, and whichever one has the bigger major and then bigger minor, that's considered the newest version and that's the one it uses. Now there are ways to override it, there are environment variables like pi underscore python is an environmental variable you can set to say what the max version is or the version specifically to use if you don't specify a Python version which is handy if like let's say you install Python 3.11 alpha but you don't want to use that in your day to day, but that's still on your path, you can set pi underscore python equals 3.10 and that will make Python 3.10 be the one that you use if you don't specify a specific version for the launcher to use, okay, but otherwise that's that's really it, it really just, it's not complicated, it's really just search path for all the Pythons, find the one that's got the biggest major and then if there's a tie, the biggest minor version and just run it and it's Unix so it uses an exec ve which replaces the process that you launch the launcher with with the actual other Unix process and away you go, nice, yeah, cool, yeah, nice and simple.\n\nScout is an industry leader in application performance monitoring. This low overhead tool is designed to help developers quickly find and fix performance issues with a super intuitive UI and tracing logic that ties bottlenecks to specific lines of code. You can quickly pinpoint and resolve problems before they reach your customers. Scout's unlimited seats and applications allow your whole team to use Scout without the headache of additional costs. See why software engineers worldwide call Scout their best friend with a free 14-day trial, no credit card needed. Learn more at scoutapm.com, that's scoutapm.com.\n\nYeah, so you don't use a lot of these other tools for managing your virtual environment and all those kinds of things. So no, which is kind of the way I like to roll right now too because I feel like, I know it sounds strange, but like the idea of having it all in that directory kind of means it's sort of like controlled. It's not, I deal with audio and video files. So like virtual environments are not large in my opinion. No, and so like having them in a centralized space makes it way more confusing to me because it's, it's usually a fairly convoluted path to, to find them. So yeah, I mean, I don't know, it's always seen the way to go. So, so, so I'll make two comments about that. One is, okay, I do get exposed to a lot of people with machines that are not that powerful. So I do understand from the perspective for someone who's in some place in the world where their laptop's not very new and they have very limited space and need to be very careful about that space usage. Oh yeah, I do understand wanting to make it easy to just wipe that all out when necessary if they're running out of digital space. Oh yeah, but I will say I, for me, keeping them all centralized in a place and I have to use tools to use it feels very, I'm an editor guy, not an IDE guy. Right, like, okay, I use VS Code, I don't use Visual Studio, right? And there's a reason, it's just the way I like to work. Using these other tools that manage my virtual environments for me, like that feels more of an IDE thing. And I am more of that, I want to understand, I'm happy to use tools to simplify my life, but I don't want to have to use the tool in order to get something done more portable, right, right. So like perfect example is the Python extension for VS Code, right? Like our integration with this Flake 8, we're still running, giving you Flake 8, we're not giving you just some bespoke thing, right? We're, we are never going to give you a formatter that's custom to us. We will always just use the formatters in the community because they're good enough, right? Just use Black, if you don't like Black, you can use Autopep 8, right? Whatever, it's up to you. But there's no need for us to reinvent the wheel, but the key point is, is I don't want us to become that thing where we, you have to come to us because you're using our formatter. If you switch to another formatter, suddenly you're in trouble and your whole team then has to start using VS Code because of that formatter. I'm not interested in vendor lock-in, okay? And to me, those tools almost feel like weird in a way, vendor lock-in for that workflow, for virtual environments, yeah, especially when they become subscriptions and the whole, let's not deal with that, yeah. But like with Virtual Wrapper, I just don't use it because I just don't feel the need to be tied to that tool. Now, this is not, don't get, take me wrong here, that I am not suggesting that people who like Virtual Wrapper are doing it wrong at all. Like if you like that flow, that's great, it's just for me personally, right? I don't want to have to rely on a tool to make, to use my virtual environments, right? It's, I'm happy to just put them right there. I can activate them manually if I have to. Some tool that does the thing manually for me automatically is great, but I'm also totally going to be able to work with it even if I don't have the tool. And this is just the way my brain works.\n\nYeah, as far as like something like a tool like pip and where it is doing a little more of the management, like if you're going to package this thing up later of like including the lock file and some of these other kinds of things, are there other tools that you use in those circumstances? So my workflow is I always use the Python launcher because it's just simple for me. I create the virtual environment locally in my directory, name it .venv because that way the Python launcher will find it and it's local and it's hidden. If I am doing an app and thus I need to pin my dependencies, I will use pip tools. Okay, I have to use pip for installations and stuff. If I am packaging a project, I use Flit. So that's because I try to avoid writing C code as much as possible in my life. Yeah, that's pretty much it. Okay, I mean, this is actually one of the reasons that so I wrote a PEP. It's PEP 665. It's under consideration now and it's actually my attempt to standardize lock files. Yeah, I don't know if it'll be accepted. It's a little controversial because it only supports wheel files. That's because you can't really easily pin when you have source distributions because it's because source situations mean you're compiling to a wheel, which means your dependencies are dynamic based on what that executed code decides are going to be your dependencies. So you can't really accurately lock them down. It's kind of a hope that it won't be different on another day, right? There's nothing stopping you, the tool that you run your build tool back end for your Sdist to go like, well, it's Tuesday, so on Tuesday you have to install Datutil, but on Wednesday, not so much, right? There's really nothing stopping codes from just deciding if what day of the week it is, it's going to change what the requirements are. So because of that, you can't really have a good lock file. You can",
    "h9XqsLTOtvE": "Welcome to the Real Python Podcast. This is episode 94. Are you looking for a project to practice your Django skills? Designing the fundamental interactions of a social network is an instructive way to explore models and relationships while learning advanced Django skills. This week on the show, we talk with previous guest Martin Broyce about his new four-part series titled \"Build a Social Network with Django.\" Martin talks about the design process and ways to include user-focused features. He shares a handy CSS library to make your Django front end look modern with minimal effort. We digress into a discussion of personal versus professional use of social networks, and we also talk about additional Real Python resources to build out the rest of your project. \n\nThis episode is brought to you by Honeybadger. Honeybadger offers error monitoring, uptime, and cron monitoring designed to tame your production and make you a better, more productive Python developer. Alright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real world Python skills with a community of experts at realpython.com.\n\nHey Martin, welcome back to the show. \n\nHi Chris, glad to be back.\n\nYeah, we're diving into a pretty intense set of tutorials that you wrote that all culminates in one really big project. It's a four-part series, which I think is really cool. We end up talking a lot about Django here, which has been interesting. This is another kind of large Django step-by-step project that you're building. When did you start on this thing?\n\nYeah, that's been a while ago. I think I actually started writing this just after I started working full time for Real Python, which is soon going to be a year ago. So it's been a long time in the making.\n\nYeah, I saw Dave's name on it. I saw a couple of other people that you know. Yep, a lot of people helping you.\n\nYeah. So yeah, maybe we could talk a little bit about the article series and the project. \n\nYeah, sure. So first of all, I'm really happy that it's out now. To be honest, because of this long process, it's really nice to see these things also come to a final spot and then actually make it into the light of day.\n\nYeah, the project in itself is to build a very tiny social media platform. It was kind of the idea behind it, to just give you... So it really doesn't do a lot, but it kind of sets the stage for what are the basics of a social media network, I would say. And that's really just to create some sort of content and then be able to view a bunch of profiles and view their content and then decide who you want to follow and who you want to not follow. You choose whom to follow, and you can unfollow profiles as well. And that's kind of the basis for a lot of social media that's out there, I would say.\n\nYeah, it definitely... You know, this is definitely the foundation of where you would think to sort of start there, like, okay, you need to create these connections between the different users and the ability to sort of curate what you want to follow and look at. And then you can really dive into the nitty-gritty of all the other complexities. I liked the first part where you actually took some time to say if you're going to create a project like this, you as the creator of something like this need to decide what's going to be in it, or maybe you can kind of describe how you did in the article.\n\nI guess one point here is that the best thing I found to do when you start working on any sort of digital project, probably any sort of project, is that you take a moment before you start working on it and try to limit the scope. Figure out... I mean, give your brain a bit of freedom and just dream up what could it be in the long run. You know, take notes about this, of course, but then once you're there, just try to figure out what's really the thing that you can accomplish at what's really the essence of it, right? And then start with that and see whether you can get that to work. Because just having too many things that you want to implement and start working on them actually right away and start coding right away puts you into like, I don't know, it just... I don't know, this happened. I don't know if it happens to everyone, but it happens to me that I then like code myself into a corner, so to say, and then I... Sure, I spent a lot of work on something that doesn't go anywhere and the project stays unfinished, and it's kind of frustrating and you end up not really having anything. It's been a theme I think that we've talked about it, I think with Ricky, you know, when he was talking about creating his RSS aggregator.\n\nYeah, what he was talking about in creating his RSS aggregator and then a couple of times with the video game people that I've had on the show that talk about creating video games by using Python is this idea that, okay, yes, you've seen other amazing games that are out there that have a billion features, but what is it that you can create and stand up and then get to a complete status? Because what I think can happen sometimes is you get in the weeds of these really elaborate things, and then you start to... the maybe the waterline starts kind of climbing above your head, and you're like, you know, oh my god, I just want to get out of this because I'm drowning.\n\nYeah, and that's also why I wasn't sure whether it's the right term for it because I also know these big ones, and I know they're called messaging or message queue systems, and I'm not sure, yeah, exactly. I would assume it's pretty much it's a similar thing. Within Django, like you said, but yeah, I want to learn more about it. I'm definitely going to try to dive into that somewhere as I continue on.\n\nKind of continuing on in the series, you spend quite a bit of part two talking about sort of front-end stuff, which is something a lot of Django users maybe don't think about that often. They might just kind of choose a very simple sort of template and just kind of go with it. But I enjoyed that you took the time to show a new tool that I wasn't familiar with. You were showing off a thing called Bulma, if I'm pronouncing it right.\n\nYeah, I think you are. Bulma is a CSS framework similar to Bootstrap, which is, I think, the most famous of the lot. It works, actually, in a very similar way that the framework defines certain CSS style rules and gives you, you know, like, gives those names that you can then put on your HTML elements to style them in the way that's defined in the framework. You have all these great tags ready to go, like, okay, this is what you'd use for buttons or this is what you would use for sort of chunks of text and so forth so that you can just sort of notate them in the little bit of HTML that you might have to write, right?\n\nYeah, and I think as far as I know, there's no JavaScript component to Bulma, so it's really just the CSS framework, while Bootstrap has also this JavaScript component, yeah, for some things. But apart from that, it's pretty similar. It's really just what you need to do is know about which classes exist and then apply them to your HTML elements and you get pretty nice. Well, and you need to include the stylesheet, the Bulma stylesheet, but you can do this via CDN, which is what I'm showing in the tutorial too, where you just add it at the end of your base template, basically, so that it propagates to all of your templates and is available everywhere. And then it just loads it on the internet and applies the styles for you, essentially.\n\nYou can also, obviously, you can download it and you can include it in your project directly, but that's just, again, going back to, you know, how do you design a big project like that, that you want to teach step by step. How can you, my, so my idea here was why I wanted to include the CSS framework was because I think it's easier to be proud of a project that you build if it actually looks kind of nice, because it's always a little, especially if you're showing it to people who are not that much, yeah, if it just shows up and it looks like 90s web, yeah, Times New Roman, you're just like, but it's gonna be nice. But people can't get past that, especially if you show it to people who don't do much with programming. I don't, if you want to show a project to your family that you've been working on, look, I've been learning Django programming, I made this website and then you show it to someone and there's like some sort of, there's a very, very high expectation from people who are not, who don't do anything with programming that the design would look good. Otherwise, it's not really worth much, right? Everything that's on the web looks amazing, right, generally, you know, if it doesn't, then you know, we question it very quickly, you know, there's sort of a, even a design level that you could kind of go back and look at five years ago, ten years ago, and so forth and very easily be able to tell the age, the archaeological or geological age of the internet, and if you try to explain any sort of finesse of how your model relations are set up and interact with each other to anyone who isn't in this field, they're just not going to be very interested, probably. So, I think it's nice, you build a project and you want it to be something that you can show off, also, I don't know, just to some friends, maybe, or also to if you're applying somewhere, you know, it never hurts if it looks nice. So, I wanted to have this visual component part of it.\n\nThat's great. Yeah, I like that it doesn't have JavaScript for a couple reasons. Partly because it's a whole other additional rabbit hole that you can kind of get sort of caught up in, and so I like the idea that it's sort of self-contained in the fact that it's a CSS, and CSS is extremely powerful now as far as doing everything from knowing what type of viewport you're looking at, like on the, you know, is it need to be mobile on a phone or an iPad, so all those components are doing that sort of scaling automatically, which I was really impressed with it. So, and a lot of these CSS frameworks, they take that into account and give you relatively easy to remember class names that you can apply that then change the viewport sizes and change the styling depending on that type of stuff. And Bootstrap includes that too, and you can use Bootstrap also just as a pure CSS thing, you don't need the JavaScript, but it's not really designed like that, or for me, I never really liked the style that Bootstrap gives you, I guess. That's also part of it, and I think the style that you get with Bulma CSS is pretty nice.\n\nYeah, so the additional parts that you're doing in part two are kind of, you know, you mentioned the front-end styling, but then you're also setting up the initial sort of templates and things that the user would be looking at, right?\n\nYeah, it's like the standard website thing, you know, like you have a list of all the user profiles or a list of all items of something, and then individual pages for each of those items. This is like a very common concept in many websites, you know, if you think of a shop, for example, you have a list of items you can buy, right? Individual or user list, and then user profiles like in this case. So yeah, there's this, this is some standard website setup that's, you could also do in a different way. Like I'm using function-based views, and here you, this is also something that Django has pretty nice solutions in class-based views, so if you want a little challenge, you could go in there and try to rewrite it with class-based views, and that's something you could try out to play around with.\n\nBut I guess this brings me to, who is this project really for? Which is, I think it's, if you've been working, so Django is not completely new to you, and maybe you've gone through this intro project on the Django website, the poll tutorial, and maybe you've written one or two other Django projects, I think that's a good place to pick up this tutorial. I",
    "WgXxrYa8RQ0": "Welcome to the Real Python Podcast. This is Episode 95. What are ways you could speed up Python? Have you thought of using a JIT (Just-In-Time) compiler? This week on the show, we have Real Python author and previous guest Anthony Shaw to talk about his project Pidgin, a drop-in JIT compiler for CPython 3.10. Anthony has been working on Pidgin over the past year and recently released version 1.0. He talks about how he took over the project from Brett Cannon and Dino Viehland. He covers the background on compilers and assembly he needed to take on this project. We discussed where a tool like this can speed up your Python code and alternative solutions. We also talk about his desire to make the project as deeply compatible with Python code as possible. Anthony talks about how his dive into writing the \"C Python Internals\" book led him into the project. He describes what type of developer would benefit from exploring the book. We also cover his recent Real Python article titled \"Advanced Visual Studio Code for Python Developers.\" It's an excellent resource VS Code users should bookmark to revisit as they grow with the tool.\n\nThis episode is brought to you by Honeybadger. Honeybadger offers error monitoring, uptime, and cron monitoring designed to tame your production and make you a better, more productive Python developer. Alright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey Anthony, welcome back to the show.\n\nHey Christopher, how are you doing?\n\nGreat. It's very winter here, and I was looking at your pictures on Twitter of dogs playing in the surf and being a little jealous.\n\nYes, in the middle of summer. So literally the opposite. Since we last spoke, you are working at Microsoft. So what are you doing there?\n\nYes, I'm a Cloud Developer Advocate. In two weeks' time, I'll have been here for a year, which seems crazy because it's gone past so quickly. I bet. It's quite difficult to pin down exactly what I do, actually. There's just so many things from week to week. But really, the focus is looking at how Python developers interact with Microsoft Clouds, which Azure primarily, and also Visual Studio Code and the Python tooling around that. I kind of sort of take the try and put myself in the shoes of a Python developer and use the products and services and like interact with them and just look at the documentation and tooling and see what can be improved and work with different teams to do that. And then also do things like share knowledge about the right way to use it in the form of blog posts or documentation or videos or sometimes I just get stuck in and actually work with the engineering teams to change the product. \n\nOkay, so they might bring you over to cover some of these things that people are discussing and you would present them the way that you feel that other users are using it and you know could help improve their situations, yeah. For example, we've got a platform called Azure Web Apps, which is where you can run Flask or Django or any kind of Python web app without worrying about the server infrastructure. So you basically just have your packaging, your requirements file, and it does all the rest for you. It hosts it all for you. What I really wanted to do was to use the debugging features in VS Code but to debug the actual live server and that wasn't something that was supported. So I basically just worked on implementing that and that was rolled out late last year. \n\nSo Honeybadger offers error monitoring, uptime, and cron monitoring designed to tame your production and make you a better, more productive Python developer. Alright, let's get started. \n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com. Hey Anthony, welcome back to the show. Hey Christopher, how are you doing? Great. It's very winter here, and I was looking at your pictures on Twitter of dogs playing in the surf and being a little jealous. Yes, in the middle of summer. So literally the opposite. Since we last spoke, you are working at Microsoft. So what are you doing there? Yes, I'm a Cloud Developer Advocate. In two weeks' time, I'll have been here for a year, which seems crazy because it's gone past so quickly. I bet. It's quite difficult to pin down exactly what I do, actually. There's just so many things from week to week. But really, the focus is looking at how Python developers interact with Microsoft Clouds, which Azure primarily, and also Visual Studio Code and the Python tooling around that. I kind of sort of take the try and put myself in the shoes of a Python developer and use the products and services and like interact with them and just look at the documentation and tooling and see what can be improved and work with different teams to do that. And then also do things like share knowledge about the right way to use it in the form of blog posts or documentation or videos or sometimes I just get stuck in and actually work with the engineering teams to change the product. \n\nAlright, let's get started. \n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com. Hey Anthony, welcome back to the show. Hey Christopher, how are you doing? Great. It's very winter here, and I was looking at your pictures on Twitter of dogs playing in the surf and being a little jealous. Yes, in the middle of summer. So literally the opposite. Since we last spoke, you are working at Microsoft. So what are you doing there? Yes, I'm a Cloud Developer Advocate. In two weeks' time, I'll have been here for a year, which seems crazy because it's gone past so quickly. I bet. It's quite difficult to pin down exactly what I do, actually. There's just so many things from week to week. But really, the focus is looking at how Python developers interact with Microsoft Clouds, which Azure primarily, and also Visual Studio Code and the Python tooling around that. I kind of sort of take the try and put myself in the shoes of a Python developer and use the products and services and like interact with them and just look at the documentation and tooling and see what can be improved and work with different teams to do that. And then also do things like share knowledge about the right way to use it in the form of blog posts or documentation or videos or sometimes I just get stuck in and actually work with the engineering teams to change the product. \n\nAlright, let's get started. \n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with",
    "xkGN-A9BqD4": "Welcome to the Real Python Podcast. This is Episode 96. Would you like to experiment with analyzing or manipulating audio with Python? This week on the show, we have Braden Riggs from Dolby IO to discuss extracting audio features and Python libraries for reshaping audio. Braden shares techniques from his recent talk at PyData Global titled \"Unlocking More from Your Audio Data.\" We share several articles, tutorials, and Python libraries to get you started working with audio.\n\nWe begin with a quick introduction to digitizing audio and feature extraction. After discussing modifying audio files, we share tools and techniques for exploring audio analysis through data science. Braden talks about converting speech to text, sentiment analysis, and NLTK (Natural Language Toolkit). He also shares a valuable collection of audio technology resources for developers.\n\nPython packages, including urllib3, have known vulnerabilities. Get a free t-shirt for fixing vulnerabilities by registering for the Big Fix at sneak.co. That's snyk.co/realpython. Alright, let's get started.\n\n[Music]\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey, Braden, welcome to the show. Hey, how's it going? It's going great. When you reached out to talk about coming on the show, it got me very excited. Most people probably know, based on the 90-odd episodes so far, that I'm kind of an audio geek. So somebody coming from that background and having similar interests is definitely a fun topic. I thought we could make it a bit of not only an interview but also a way to share how people could manipulate audio with Python. Yeah, that sounds great. I love interacting with the audio community, and of course, I've seen your podcast before. So I thought it would be a great time to link up and maybe throw a few cool articles out there for anybody that hasn't gotten their feet wet in the awesome space of audio yet. Yeah, totally. So you work for Dolby IO, and I have a lot of familiarity with older iterations of Dolby. Definitely tools that I used, tape machines, and other things like that have had that brand name on it or standalone encoding/decoding devices. What is Dolby IO right now? Yeah, it's a great question. You know, when I think of Dolby, I think of cinemas, I think of the old VHS tapes that I'd watch, and all that stuff. But Dolby IO is kind of like our answer to bringing a lot of that really amazing technology that makes cinema stuff exciting and putting that in the hands of software developers so they can implement it into their apps and programs. And that sort of takes the form of two different suites of technologies. Our first suite is like our communications APIs, which you can think of as being used for video conferencing or building live streaming platforms and things like that. And then we have our media processing APIs, which are more focused around audio enhancement and transcoding. I spend more time focusing on the media APIs, but there is that whole second side to the suite. When I did reach out to you, you know, it was to talk about cool audio stuff, which is some of the stuff that we can do with media processing APIs. Yeah, cool. I was looking through the site and looking at some of the different things that you provide, and definitely of interest. I think it's neat. I know of a couple of meeting platforms that use the Dolby tools kind of underneath it. And I have definitely looked at the idea of having a tool that I can send audio to and have it process it and kind of send it back to me, which is pretty slick. Yeah, definitely. It's just a lot of developer tools. There's all kinds of cool stuff that you can do with it. I can talk more about that if you want. Otherwise, you know, I'm happy just to talk about audio-related stuff. Cool. Maybe we could talk a little bit about not the entire history of your background, but like why are you interested in audio and programming? Yeah, that's a great question. So I originally got my start as a data scientist when I graduated last year from the University of California. But when I was studying my data science degree, I spent some time working in the cognitive science department, studying neural signal processing. The cool thing about neural signals is they do share some similarities with audio signals, so a lot of the tools that I picked up and was working with to understand various brain functions also work for helping us decompose audio signals so that we can remove noise and do a lot of this stuff in Python. So it seemed like a really natural fit for me to get working in the audio space. That's cool. You're kind of taking this study of literal brain waves and moving it toward audio waves in some ways. You'd be really surprised. Actually, in the early days of brain signal processing, they didn't have a lot of tools specifically for neural signals. Yeah, so they had to use a lot of these audio tools that audio engineers use in order to remove noise so they can isolate particular brain functions or try to find where a specific part of the signal is coming from the brain. That's just a funny relationship that the two fields have. I mentioned this before. I'm trying to remember who I was talking to, but when I was working at the school for recording engineers, there was a newish software company that had created a product, and it was called Cool Edit Pro. That was the name of it, and it was able to work at incredible frequencies as far as something called the sampling rate. I'll talk a little bit more about digital audio because that's a field that I taught for quite a while. The fact that this new tool that they had created could work at 192 kHz and had all these other more advanced tools, a lot of science interests were coming into it. Not that audio isn't a science in itself, but other organizations were looking at it as a tool. What's funny is the story kind of ends with Adobe purchasing them, and that is the foundation of this thing called Audition now. Oh, well, that's super interesting. Yeah, it's kind of funny that these guys were really focused on this deep level of what can you do with audio and how high resolution can you make it, and then do things like you're talking about like there's a thing called a noise print where you can analyze background noise of audio and then be able to process it out or invert it or whatever to make it kind of come out of the signal. They were doing a lot of that stuff and demonstrating it to us, which was really fun. Nice. I thought maybe we could talk a little bit about digital audio just to get a general aspect of it because as it moves into data science, it kind of gets changed a little bit. So if someone was going to talk about digital audio and bring it into a computer again, like I had a big background in this, and so I won't go too far, but the fundamentals are that you have this analog sound coming into this microphone, and it basically creates this voltage signal. The problem with that when bringing it into a computer is that it needs to be turned into zeros and ones. There's this thing called an analog-to-digital converter (ADC) that does that, and then it operates with two mathematical tools inside of that: a thing called a sampling rate and a bit resolution or bit depth. The sampling rate is kind of like a photograph of the waveform, where it was at that moment, what height and amplitude. If you've seen the picture of a waveform moving up and down and it's that resolution, the sampling rate is going to continue to take pictures to capture how things are moving up and down across that. Each one of those photographs, if you will, these samples, has an amount of resolution or bit depth that is where you get the amplitude or, in a lot of cases, what that's going to do is show you how loud or soft something is. So the first tool there, the sampling rate, is going to capture the frequencies, and there are some rules behind that on this thing called the Nyquist theorem, which somebody can research a little further. But a common number that you would see on these computers is 48,000 times per second or 44,100 times per second that's what CDs used, and a lot of the idea behind that is that as long as it's twice the range of what you want to try to capture, in the case of human hearing, it's like 20 Hz up and down to 20,000 Hz, which is the range that we think of as perceivable. That should be good; we can capture everything we need. So that sampling rate is pretty standard on a lot of equipment, and then there are other tools that try to go higher, like I mentioned Cool Edit Pro was able to work at like 192,000, and you might think to yourself, well, is that something somebody can hear or perceive? Those frequencies are there, and maybe human beings don't perceive them as notes per se, but it actually does affect the spectrum of what you hear and the positions of things. It's a very interesting science, and we don't need to get all into the hi-fi high audio thing, which a lot of people get into. The more resolution you have, the better it's just like a camera in a lot of ways. And then the bit resolution has to do with basically how loud or soft stuff is. You've got typically the resolutions were 16 bits, which allowed for a certain amount of dynamic range, and then newer systems allowed for a greater range like 24 bits. That doesn't necessarily allow things to be louder; it allows for things not to be thrown away as far as the subtle quiet areas of resolution where notes are sort of decaying down and so forth. Anyway, that's kind of the raw stuff that's happening, the sampling and the resolution being captured. And then on the other side, to turn it back to play out your speakers, it has to go through a digital-to-analog converter (DAC), a DAC, and that's how it comes back out. What's interesting to me is where data science comes in and says, okay, sure, we talk about the sampling rate and bit resolution, but now how can we determine something more than just like these frequencies happening or the signal is this amount loud? It gets into this idea that's pretty deep into the machine learning and that whole side, and that's what I want to turn to you and talk about the term, I guess, audio features or feature extraction. Yeah, well, so I think one of the really amazing things about audio data, and I like to joke about this, is that it is actually kind of big data in its way. It's much larger than a lot of other stuff that we work with, like text. Yeah, exactly, but people sometimes forget that a lot of people, I think, jump straight to doing computer vision-related stuff, or they go and do natural language processing on the text specifically. But audio data actually has a lot going on in the background and the underlying bytes that make it super interesting. I joke that it's sneaky big data because it sneaks up on you in how big it actually is. So the challenge that we have is that we have these signals, or we have all this data stored in this sample rate and this bit depth, and our goal is to take this raw unstructured data and convert it into something that we can use to understand human words or to understand the sentiment behind things that people are saying or to understand what instruments people are playing or to understand whether it's a child talking or an adult talking. And that process where we decompose these things is called audio feature extraction, which is quite similar to feature extraction that you see for a lot of other data types. But specifically, audio feature extraction is kind of like this necessary step in audio signal processing where we take these small windows of the signal and process or manipulate it to extract key features or indicators that tell us more about the underlying data. It can also be used for stuff like removing unwanted noise and balancing time-frequency ranges by converting digital to analog signals and a bunch of fun stuff like that. To pause you for a second there, when you're talking about moving beyond the individual samples, which don't provide a lot of information, it's just sort of a plot point, you're expanding this sort of window to look at a chunk of audio, right? Yes, yes. So there are kind of three different ranges, let's put it, that people work with. So there's high-level abstraction, mid-level extraction, and low-level abstraction. High level is the easiest to understand because humans understand it. It's the level at which features are understood and enjoyed by humans. So think chords, melodies, rhythm, genre. Then there's mid-level where we can perceive these features; however, they're not quite as well understood as something like melody. But these are things like pitch, beat, as well as note fluctuations, things like that. And then there's low level, and these are purely statistical features that will be understood by a machine but humans can't really understand or grasp them. These are buzzwords like energy and spectral flux and zero crossing, right? Right. And so by pulling these features out, you can do kind of at a basic level, and we'll talk about some tools and we'll talk about some libraries and a few articles to kind of get people started if they're interested in stuff. By looking at this, having the computer do it, you could do something like say find the silence in an audio track and say, \"Okay, I want to remove those large gaps of silence.\" Absolutely. In fact, that's a great example to start with, right? Like we can see when decomposing this signal regions where there is little to no noise recorded and then there's regions where there's a ton of noise recorded. And we can build, we can use these features to build a tool that can rip out all those segments and remove any awkward pauses or whatever. But it can get a lot more advanced than that. You can actually break it down to build something that can tell the difference between instruments or tell the difference between speakers. Yeah, or whether one speaker is perceivably more agitated than the other speaker or all kinds of complex, really cool stuff. Yeah. I thought that was pretty interesting, and I think we'll kind of provide lots of off-ramps for people to say, \"That's what I'm interested in\" and go explore. Did you know that 47% of Python projects include known vulnerabilities? There are vulnerabilities in even the most popular packages like urllib3. Luckily, 87% of Python vulnerabilities can be fixed. The Sneak team is hosting the Big Fix, an online event where you can earn swag for fixing vulnerabilities, plus get hands-on support from security experts during the 24-hour live stream on February 25th. Register at sneak.co, that's snyk.co/realpython. Alright, let's get started. [Music] The Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com. Hey, Braden, welcome to the show. Hey, how's it going? It's going great. When you reached out to talk about coming on the show, it got me very excited. Most people probably know, based on the 90-odd episodes so far, that I'm kind of an audio geek. So somebody coming from that background and having similar interests is definitely a fun topic. I thought we could make it a bit of not only an interview but also a way to share how people could manipulate audio with Python. Yeah, that sounds great. I love interacting with the audio community, and of course, I've seen your podcast before. So I thought it would be a great time to link up and maybe throw a few cool articles out there for anybody that hasn't gotten their feet wet in the awesome space of audio yet. Yeah, totally. So you work for Dolby IO, and I have a lot of familiarity with older iterations of Dolby. Definitely tools that I used tape machines and other things like that have had that brand name on it or standalone encoding/decoding devices. What is Dolby IO right now? Yeah, it's a great question. You know, when I think of Dolby, I think of cinemas, I think of the old VHS tapes that I'd watch, and all that stuff. But Dolby IO is kind of like our answer to bringing a lot of that really amazing technology that makes cinema stuff exciting and putting that in the hands of software developers so they can implement it into their apps and programs. And that sort of takes the form of two different suites of technologies. Our first suite is like our communications APIs, which you can think of as being used for video conferencing or building live streaming platforms and things like that. And then we have our media processing APIs, which are more focused around audio enhancement and transcoding. I spend more time focusing on the media APIs, but there is that whole second side to the suite. When I did reach out to you, you know, it was to talk about cool audio stuff, which is some of the stuff that we can do with media processing APIs. Yeah, cool. I was looking through the site and looking at some of the different things that you provide, and definitely of interest. I think it's neat. I know of a couple of meeting platforms that use the Dolby tools kind of underneath it, and I have definitely looked at the idea of having a tool that I can send audio to and have it process it and kind of send it back to me, which is pretty slick. Yeah, definitely. It's just a lot of developer tools. There's all kinds of cool stuff that you can do with it. I can talk more about that if you want. Otherwise, you know, I'm happy just to talk about audio-related stuff. Cool. Maybe we could talk a little bit about not the entire history of your background, but like why are you interested in audio and programming? Yeah, that's a great question. So I originally got my start as a data scientist when I graduated last year from the University of California. But when I was studying my data science degree, I spent some time working in the cognitive science department, studying neural signal processing. The cool thing about neural signals is they do share some similarities with audio signals, so a lot of the tools that I picked up and was working with to understand various brain functions also work for helping us decompose audio signals so that we can remove noise and do a lot of this stuff in Python. So it seemed like a really natural fit for me to get working in the audio space. That's cool. You're kind of taking this study of literal brain waves and moving it toward audio waves in some ways. You'd be really surprised. Actually, in the early days of brain signal processing, they didn't have a lot of tools specifically for neural signals. Yeah, so they had to use a lot of these audio tools that audio engineers use in order to remove noise so they can isolate particular brain functions or try to find where a specific part",
    "MvOUaxV6LAw": "Welcome to the Real Python Podcast. This is Episode 97. How often have you thought about your developer experience? How do you improve your workflow, find documentation, and simplify code formatting? This week on the show, Adam Johnson is here to talk about his new book, \"Boost Your Django DX.\" Adam provides advice on improving your experience developing specifically inside Django and within Python. We discuss tools to simplify code formatting and linting, and Adam shares a couple of his own Django tools designed to simplify development and keep your projects updated. He also covers documentation resources for finding answers quickly.\n\nThis episode is brought to you by Scout APM. Spend less time debugging and more time building with Scout APM.\n\nAll right, let's get started. The Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey Adam, welcome to the show.\n\nOh, thank you. Hi, Chris. You kind of reached out and I was fascinated by all this work you've been up to, and I really like your book, \"The Django Developer Experience Book: Boost Your Django DX.\" I'll take the title, \"The Django Developer\" is in my mind. [Laughter]\n\nSo you are a member of the Django Project Technical Board. Maybe you can explain the difference between the Python Software Foundation, the Django Software Foundation, and the Technical Board.\n\nSure. The Software Foundation is like Python's, a non-profit dedicated to keeping Django alive and spreading its use, and teaching people, helping conferences out. And then there's the Django Software Foundation Board. That's the people responsible for running the charity, and they're elected on a yearly basis. And then the Technical Board is on the side there, and we're a group of five people who have the kind of last say on technical matters. We're basically contributors who've been working on Django for a while. And once in a while, not very often, there's an issue that's maybe a bit contentious and can't be settled just through the normal channels of finding consensus on the mailing list. Okay, so we have the final vote. Is there a version of something like PEPs, the Python Enhancement Protocol process that you guys use? Exactly, it's called DAPs, Django Enhancement Proposals. All right, there you go.\n\nHow did you get involved with the Technical Board?\n\nIt's been a bit of a journey. I started working with Django in 2012, and I've gone from one Django job to the next. I started really contributing to the community from 2014-2015 onwards. At some point, I was voted in to become a core member. That's what it was called at the time. That would have been the end of 2016. Okay, and that was just people who had commit access. There were quite a lot of people who were contributing and maybe had commit access. And since then, the process has been formalized a bit with DAP 10. That's another of those steps. Yeah, okay. And that's when the Technical Board was founded as, like, here's the people who have the voting rights. We're elected on a major release cycle basis. And so I've had the luck to be voted in for Django 2, 3, and 4 now.\n\nYeah, I was thinking about it. I started in Python three, four years ago, and it was still Django. I think it was at 1.11. It was like one of the big releases that kind of was, right as Django 2 started, which I was very excited about because I like kind of the direction things were headed. But it seems like there's quite the velocity lately with Django.\n\nYeah, and part of that change in the release process that happened just at the end of 1.11, where the decision was to move to have a schedule for when deprecations happen. So each version of Django is going through a 0.0.1.2 release. These are a bit more like feature releases, really. But if your code works on Django 2.0 without deprecation warnings, it will work on Django 3.0. That's the guarantee. Okay, and maybe we'll have new deprecation warnings, but yeah, the most recent release of 4.0, when did that come out? That was in December, okay. So it just came out. And what would be like a headline feature?\n\nWell, there's a few. There's functional unique indexes, which sounds quite neat niche, but that allows you to do things like all my users in the database must have a unique email address after applying lowercase. Oh, okay. So before that wasn't possible without custom SQL. A bunch of testing changes, which are really good, including randomized testing. That's what I'm a fan of. All these testing features. I wrote a post explicitly on those. What's another one? The widget and form rendering is now done through templates. So that should make it pretty easy for you to roll out a framework like Bootstrap by just dropping a few extra templates in your project. And then you could style every form on your site or every date widget on your site with custom classes or HTML. Nice. Those actually sound really great.\n\nMaybe we could dive into the book a little bit and say, I looked at the beginning of it and I was fascinated because you use this term kaizen, which I've learned about in a couple of other kind of business settings. Maybe you can explain why you mentioned that and put it at the top of your book.\n\nYeah, I guess it's something that just resonates with me. Kaizen is a Japanese name for continually improving a process. So it comes out of things like the Toyota manufacturing line where they started doing the first just-in-time production. And every manager at Toyota, for whatever part of the assembly line they're in charge of, they have to make two improvements every fortnight or something like that. So they're always looking for the next thing that could save a few seconds, reduce risk of injury, save costs, etc. And that's kind of what I see DX as. We can always improve the way our projects work for us so that we make fewer mistakes in the future, deliver features quicker, reduce the amount of typing needed to get something out, etc.\n\nI've mentioned in the past that I worked as a trainer at Apple, and then I was a consultant on a lot of music studios and individuals who wanted to just get to writing music and creating music and wanted to have the technology help them set them up and so forth. So I would have this process where I would watch the person work for a little bit. They would say a lot of times they would say just fix it for them, and I'd say, well, show me what you're trying to do right now and let me just watch for a little bit. And it might be as simple as like in the case of when I was working at Apple, the person is using one of these brand new laptops at the time they came out with that all single surface trackpad, which no longer had a button that was dedicated at the bottom. And I would watch people because it was maybe the first time they've used a computer that was like that, and they would try to drag something and they would hold their finger down and try to drag it and then try to switch to another finger. So I would like see these kind of processes. I'm like, oh my god, this is going to kill them if they keep trying to do it this way. And then say, oh you can use your thumb and just hold the button down and then use your finger to move like it used to be that's not obvious you know but it's hidden right there. Yeah, and so I think of those kinds of things or you know I watch somebody work with a piece of music equipment and say okay this you're creating too much gain at the beginning of this whole chain of things and that's why you're having problems with feedback and all these other kinds of things and ways to kind of simplify and you've been a consultant for a while is that a process that you go through with with your clients.\n\nYeah, I'd say it's something very similar and it's also something kind of applied to myself. I guess there's I think with DX there's always this step of like watching yourself do something and then be like okay what was the hard bit here because software is infinitely malleable you there is always the option to go and change what the tools are doing for you yeah so yeah often I'm dropping into client projects and they've they've all been doing a certain thing a certain way for a long time I'm like there is a better way it's you know this tool over here that perhaps you haven't heard of or this feature in Django or Python that perhaps you haven't seen before yeah and that can save quite a lot.\n\nScout is an industry leader in application performance monitoring. This low overhead tool is designed to help developers quickly find and fix performance issues with a super intuitive UI and tracing logic that ties bottlenecks to specific lines of code. You can quickly pinpoint and resolve problems before they reach your customers. Scout's unlimited seats and applications allow your whole team to use Scout without the headache of additional costs. Software engineers worldwide call Scout their best friend. With a free 14-day trial, no credit card needed, learn more at scoutapm.com. That's scoutapm.com.\n\nAre there other areas that you have found that have a big impact to developer experience? Some other general area?\n\nThe first chapter of features in the book is about documentation. I find just getting faster at looking at the docs is one of the things that can smooth out writing new code quite a lot.\n\nI wanted to talk about that because you mentioned a handful of different ways to kind of get to the documentation kind of quickly, and you mentioned this, I'm not sure what to call it. I want to call it a tool of DevDocs, but it is sort of a site also like a website that you can go to. Maybe you can explain a little bit about what, and it's spelled D-E-V-D-O-C-S. DevDocs, yeah. Maybe you can kind of explain like how you found it, but also like what it does.\n\nYeah, sure. It's a website or like a web app that works offline and holds docs and gives you very fast search over them because they're all local. So you can grab the Python docs, the Django docs, the Flask, Jinja docs, and other things like HTML, JavaScript, all in there. And then you can search and you know it updates every letter you type, it's searching and showing you the results. And it smooths over the process so much. I see a lot of developers who are used to like going through Google and then they have to pick out where's the python.org result page if they know what they're looking for. But they still have to spend quite a lot of time figuring out how to get there. And I was impressed with it. Yeah, with the versions that it has, all the, you know, like for Django it, you know, has 2, 3, you know, all the different sub-releases in there and even 4. And the idea that you can kind of go through them and then one of the things that you mentioned in the book is that you could download this so that you could have it offline.\n\nYeah, in fact, it's just a couple of button clicks away. It's one of the few like offline-first web apps that I actually use that uses all the browser features. Very impressive. And all community-built.\n\nYeah, super cool. What is wondering about with the search functionality, can you specify what it's searching within?\n\nYeah, you can search across all your docs, which is sometimes useful, but more often I'm like searching within the Django docs or the Python docs. And you can filter just by typing like \"DJ\" tab and then you'll get to filtering within the Django docs only. Nice, for example.\n\nThat sounds really great and then you mentioned another tool for potentially offline stuff and we talked about this a little bit before we started. How there are lots of developers worldwide that may, well number one, you may be traveling and you may not have internet or that are in other countries or other places where internet connections are not always great or they only have them for a little while. Maybe they meet up at like a school or something like that and then they go home and they don't have it at home. And so the idea of having the documentation with you on the computer because you know as you're developing you don't necessarily need an internet connection to be coding but for a lot of us it needs some kind of reference materials.\n\nYeah.\n\nAnd so you mentioned not only DevDocs but a tool called wget that I hadn't used before but I've heard of where you can use it to download like an entire website or portion of a site. How does that work?\n\nWget is like the GNU cousin of curl which many developers have used. Okay, but it's really focused on mass downloading from a web server and there's a recipe which I've used when I needed it over the years that I've put in the book that I found online too for downloading a whole site under a sub-prefix. Fixing up all the static asset references like CSS and JavaScript so they work relative to the local copy and then you can just open that in your web browser and browse that site offline. Very useful if you're following a tutorial like the Django Ghost tutorial or some other informal documentation that perhaps you can't find through some a tool like DevDocs. And one of the tricks that you show in the book is that if it's maybe a little bit of a fancier site that isn't going to just hop from like one HTML element to another that you can have it hosted using Python's built-in web server. Yeah, that's a pretty neat little hack. Like the Django Ghost site uses JavaScript for its navigation between pages which speeds them up on an internet connection because it does partial page loads I think but locally that feature won't work if you just open the HTML file in the browser because browsers don't allow all web features to work when it's a file URL. But Python allows you to just serve files in a folder up on a local port with python -m http.server. Yeah, that was really cool. You just got to make sure your terminal is starting at the right place that you're in the right appropriate directory. That's really nice. You know, again, kind of on the documentation side, I'm a fan of DuckDuckGo and it sounds like you are too based on what you're writing about in the book and what I was a fan of originally was I was working for a law firm. We talked about this concept of filter bubbles and that's one of the premises that DuckDuckGo wants to say is that they aren't really gathering information about you and trying to hone in on like what your experience is so like potentially on Google if you're logged in you type a search and I type a search we may get completely different results even though we're kind of trying to look for the same thing and I always thought that was kind of interesting inside of that but even after that idea of it not necessarily filtering it down is this idea they have this thing called bangs or the exclamation point and then like a couple letters and then I I've used something similar like kind of doing like a sort of Google foo of like okay you can use a colon like site colon and then real Python and then your search term after it but that's a lot to type and this is way quicker like if you wanted to search the Python documents their documentation you could just do what's colon py right and then type what you're looking for yeah exclamation mark py and then type say http.server and you'll go straight to the Python search page no intermediary.gov page yeah it saves you a few seconds each time you do it but now those seconds really could add up to maybe hours in a week yeah totally and the idea that you could kind of quickly narrow the search across like three or four sites that you trust instead of just leaving it open is kind of neat so you can do the same for the Django docs also or Stack Overflow yeah or yeah so it's like what DJ what's the Stack Overflow on so I think yeah okay yeah anyway so I'll include links for that stuff and it's again hopefully going to save you some effort and some time definitely a nice tool that's in there when you think about the concept of developer experience and someone coming to this book do you have an intended developer or audience in mind when you wrote the book I definitely wanted to make it accessible to everyone no matter the level so that's why for some things like DevDocs that are right at the start I explain it with screenshots and walk you through the steps of running it I think it's pretty useful for someone who's maybe new to coding to see that how you actually do this but then it does it does ramp up in levels there's definitely some stuff that you will only understand if you've been coding for a while but hopefully it's something people can come back to and implement one technique or tool at a time and be like oh now my experience is a little bit better what's the next thing is that how you see someone using it yeah yeah hopefully it's kind of like just biting off a little bit at a time instead of trying to devour the entire book yeah\n\nSo I had like there's a couple areas that that I wanted to kind of get into one is this has been a pain point for for me as sort of an intermediate dev I've again done a handful of different Django tutorials and done some kind of basic cloud hosting stuff on like Heroku or the Google Cloud and one of the areas that I had trouble with and and I think a lot of these beginner or even intermediate tutorials have a hard time focusing on is the idea of like the environment files and and the idea of moving from like a locally hosted to you know cloud hosted I feel like that's definitely one of the pain points that that I've felt and does the book kind of get into that stuff right yeah I do explain how you can use environment variables I think there is a bit of a a gap there because there can be like so much that you can explain in general here's how you might do this when you deploy and then you pick a deployment platform like you say Heroku or Google Cloud Run or whatever yeah and then they have to explain here's how you can set your environment variables or secrets or whatever they do and often there isn't like a Google Cloud Run exactly how to do it with Django or a general Django tutorial that you can go and go okay I'll do this on Google Cloud Run there's this kind of gap yeah because it's you're you're saying that you know where that information can be sort of held and sort of set up safely and securely is different depending on the platform exactly like Heroku's environment variable management it's very good I would trust that but if you just go put environment variables on a file on a disk on a VPS then they're sitting there for other processors on your computer to read so that's a bit different yeah yeah and there's like hundreds of different options out there these days like small tools that people have built that encrypt environment variables or or other secrets yeah you just have to figure one out that works yeah I guess that's kind of the problem I think that the book could kind of get into that you as something in your mind graduates to that you",
    "g2qcHd03aQI": "Welcome to the Real Python Podcast. This is episode 98. Have you wanted to explore fractals and complex numbers in Python? Would you like to practice working with APIs in Python with a new project? This week on the show, Christopher Trudeau is here, and he's taking on the task of curating new issues of Pi Coders Weekly going forward. He'll be joining me as a co-host every other week and bringing a fresh batch of Pi Coders Weekly articles and projects.\n\nWe discuss a Real Python article about drawing the Mandelbrot set in Python. The tutorial guides you through creating fractal art using Matplotlib and Pillow. We also share a new step-by-step project building a weather reporting command-line interface app. We cover several other articles and projects from the Python community, including a news roundup, a better Pie game main loop, working with static and media files in Django, and a library for pleasing console output.\n\nThis episode is brought to you by SeaData software, the easiest way to connect Python with data. SQL access to more than 250 cloud applications and data sources. Let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey, Christopher, welcome back.\n\nHi there. It's good to have you on the show. This is going to be a new trend for us going forward. We're going to talk Pi Coders and news and projects every other week. At least that's kind of the plan going forward. I'm looking forward to it.\n\nCool. One little wrinkle is we decided that maybe we could talk a little bit about some of the stuff that's going on in Python news before we dive into some articles and projects. My first story is talking about Black, the Python code formatter. We've mentioned it several times on the show up to this point. It is now considered stable and has given it a no longer a beta product stamp of approval. Version 22.1.0.0 is the version number that's up there right now. It's the first non-beta release and the first release that has a new stability policy. They've removed Python 2 support and introduced a dash dash preview flag which allows you to try out new things that they're experimenting with. So, under the stability policy, they would have the same code formatted with the same options that will produce the same output for all releases within a given year. So they're using feature flags and something that's only turned on if you configure it, but otherwise it's in the release.\n\nThe preview flag is exempt from the policy. The first release in a new calendar year may contain formatting changes, although these will be minimized as much as possible. It's just becoming a much more stable product and hence a stable project, I should say. Everybody I talked to uses it, so I don't know many that don't. I found the announcement kind of funny. It sort of reminded me of Gmail. It was like we're in beta for two decades and now it's in production. Everybody's been using Black, you know, love it or hate it, one way or the other, for years now. Oh, it's stable now? Okay, fine, great. What were you doing to my code before?\n\nThat's nice. What's your first story?\n\nJust a sort of quick little hit about Apple making some changes to what they're shipping. For a long time, Apple shipped with Python right inside of macOS, and it was there for underlying support scripts. This is a historical thing because macOS originally had its roots in BSD, and the problem is they've been shipping Python 2.7 that was there because of these support scripts, and they've never bothered to upgrade anything. So as of Monterey 12.3, which is currently in beta, they've decided they're getting rid of it. This is great news for folks like myself who are on a Mac. I can't tell you the number of times I've forgotten to enable a virtual environment and accidentally installed something in Python 2.7. I would love to have it go, \"No, what Python? I don't know what you're talking about.\" It'll make it an awful lot easier, and then what they're doing is the Xcode toolkit, which is one of their standard bundles for developers and for the Swift language and all that kind of stuff, has a lot of programming tools in it like Git and other things. So they've been including an upgraded version of Python in that for a while now. I think they're on Python 3.8, so that will be the way to get it if you want to do it through the Apple channels, or you can do what most of us have been doing, which is just download it straight off python.org or use something like one of the packages to install your Python. It's kind of nice to see that this little foot gun is disappearing.\n\nI think it's interesting that they're doing it mid-cycle, if you will, not like on a major number. That's great. I knew it was coming. The rumors had been there probably for the last year and a half talking about they were going to remove it. I don't know how many people always rely on a built-in Python 2.7 outside of the Apple engineers using these older scripts that they didn't want to rewrite or older programs and stuff. Yeah, it's good and also probably more secure and forward progression. I'm happy about that.\n\nIt's always a bad sign when your production code is shipping something that isn't supported by the people who put it out there, right? Totally. And this is sort of a trend you're seeing with a bunch of the Linux distributions as well, that they're slowly trying to get away from this, and eventually we'll get to a place where 2.7 is a badge of shame rather than, \"Oops, we're still there.\"\n\nSo my next one is a GitHub survey on languages and more developer things, which I think is funny. The web address is octoverse.github.com. The 2021 state of the Octoverse is a huge survey that they took across millions of developers, and some of the numbers are kind of staggering when you kind of look at it. There's just three charts in the main part that I want to talk about just briefly. The first one was the top languages over the years, and this survey is going back as far as charting this from 2014. It's interesting to watch the languages kind of shuffle around to see things like Ruby kind of dropping from fifth place down to from fifth to tenth. Python is now moved from fourth all the way up to second. JavaScript and TypeScript are both high up there. JavaScript being the number one and has been the number one for seven years here, and Java dropping down, working with static and media files in Django and a library for pleasing console output. This episode is brought to you by SeaData software, the easiest way to connect Python with data. SQL access to more than 250 cloud applications and data sources. All right, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey, Christopher, welcome back.\n\nHi there. It's good to have you on the show. This is going to be a new trend for us going forward. We're going to talk Pi Coders and news and projects every other week. At least that's kind of the plan going forward. I'm looking forward to it.\n\nCool. One little wrinkle is we decided that maybe we could talk a little bit about some of the stuff that's going on in Python news before we dive into some articles and projects. My first story is talking about Black, the Python code formatter. We've mentioned it several times on the show up to this point. It is now considered stable and has given it a no longer a beta product stamp of approval. Version 22.1.0.0 is the version number that's up there right now. It's the first non-beta release and the first release that has a new stability policy. They've removed Python 2 support and introduced a dash dash preview flag which allows you to try out new things that they're experimenting with. So, under the stability policy, they would have the same code formatted with the same options that will produce the same output for all releases within a given year. So they're using feature flags and something that's only turned on if you configure it, but otherwise it's in the release.\n\nThe preview flag is exempt from the policy. The first release in a new calendar year may contain formatting changes, although these will be minimized as much as possible. It's just becoming a much more stable product and hence a stable project, I should say. Everybody I talked to uses it, so I don't know many that don't. I found the announcement kind of funny. It sort of reminded me of Gmail. It was like we're in beta for two decades and now it's in production. Everybody's been using Black, you know, love it or hate it, one way or the other, for years now. Oh, it's stable now? Okay, fine, great. What were you doing to my code before?\n\nThat's nice. What's your first story?\n\nJust a sort of quick little hit about Apple making some changes to what they're shipping. For a long time, Apple shipped with Python right inside of macOS, and it was there for underlying support scripts. This is a historical thing because macOS originally had its roots in BSD, and the problem is they've been shipping Python 2.7 that was there because of these support scripts, and they've never bothered to upgrade anything. So as of Monterey 12.3, which is currently in beta, they've decided they're getting rid of it. This is great news for folks like myself who are on a Mac. I can't tell you the number of times I've forgotten to enable a virtual environment and accidentally installed something in Python 2.7. I would love to have it go, \"No, what Python? I don't know what you're talking about.\" It'll make it an awful lot easier, and then what they're doing is the Xcode toolkit, which is one of their standard bundles for developers and for the Swift language and all that kind of stuff, has a lot of programming tools in it like Git and other things. So they've been including an upgraded version of Python in that for a while now. I think they're on Python 3.8, so that will be the way to get it if you want to do it through the Apple channels, or you can do what most of us have been doing, which is just download it straight off python.org or use something like one of the packages to install your Python. It's kind of nice to see that this little foot gun is disappearing.\n\nI think it's interesting that they're doing it mid-cycle, if you will, not like on a major number. That's great. I knew it was coming. The rumors had been there probably for the last year and a half talking about they were going to remove it. I don't know how many people always rely on a built-in Python 2.7 outside of the Apple engineers using these older scripts that they didn't want to rewrite or older programs and stuff. Yeah, it's good and also probably more secure and forward progression. I'm happy about that.\n\nIt's always a bad sign when your production code is shipping something that isn't supported by the people who put it out there, right? Totally. And this is sort of a trend you're seeing with a bunch of the Linux distributions as well, that they're slowly trying to get away from this, and eventually we'll get to a place where 2.7 is a badge of shame rather than, \"Oops, we're still there.\"\n\nSo my next one is a GitHub survey on languages and more developer things, which I think is funny. The web address is octoverse.github.com. The 2021 state of the Octoverse is a huge survey that they took across millions of developers, and some of the numbers are kind of staggering when you kind of look at it. There's just three charts in the main part that I want to talk about just briefly. The first one was the top languages over the years, and this survey is going back as far as charting this from 2014. It's interesting to watch the languages kind of shuffle around to see things like Ruby kind of dropping from fifth place down to from fifth to tenth. Python is now moved from fourth all the way up to second. JavaScript and TypeScript are both high up there. JavaScript being the number one and has been the number one for seven years here, and Java dropping down, working with static and media files in Django and a library for pleasing console output. This episode is brought to you by SeaData software, the easiest way to connect Python with data. SQL access to more than 250 cloud applications and data sources. Let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey, Christopher, welcome back.\n\nHi there. It's good to have you on the show. This is going to be a new trend for us going forward. We're going to talk Pi Coders and news and projects every other week. At least that's kind of the plan going forward. I'm looking forward to it.\n\nCool. One little wrinkle is we decided that maybe we could talk a little bit about some of the stuff that's going on in Python news before we dive into some articles and projects. My first story is talking about Black, the Python code formatter. We've mentioned it several times on the show up to this point. It is now considered stable and has given it a no longer a beta product stamp of approval. Version 22.1.0.0 is the version number that's up there right now. It's the first non-beta release and the first release that has a new stability policy. They've removed Python 2 support and introduced a dash dash preview flag which allows you to try out new things that they're experimenting with. So, under the stability policy, they would have the same code formatted with the same options that will produce the same output for all releases within a given year. So they're using feature flags and something that's only turned on if you configure it, but otherwise it's in the release.\n\nThe preview flag is exempt from the policy. The first release in a new calendar year may contain formatting changes, although these will be minimized as much as possible. It's just becoming a much more stable product and hence a stable project, I should say. Everybody I talked to uses it, so I don't know many that don't. I found the announcement kind of funny. It sort of reminded me of Gmail. It was like we're in beta for two decades and now it's in production. Everybody's been using Black, you know, love it or hate it, one way or the other, for years now. Oh, it's stable now? Okay, fine, great. What were you doing to my code before?\n\nThat's nice. What's your first story?\n\nJust a sort of quick little hit about Apple making some changes to what they're shipping. For a long time, Apple shipped with Python right inside of macOS, and it was there for underlying support scripts. This is a historical thing because macOS originally had its roots in BSD, and the problem is they've been shipping Python 2.7 that was there because of these support scripts, and they've never bothered to upgrade anything. So as of Monterey 12.3, which is currently in beta, they've decided they're getting rid of it. This is great news for folks like myself who are on a Mac. I can't tell you the number of times I've forgotten to enable a virtual environment and accidentally installed something in Python 2.7. I would love to have it go, \"No, what Python? I don't know what you're talking about.\" It'll make it an awful lot easier, and then what they're doing is the Xcode toolkit, which is one of their standard bundles for developers and for the Swift language and all that kind of stuff, has a lot of programming tools in it like Git and other things. So they've been including an upgraded version of Python in that for a while now. I think they're on Python 3.8, so that will be the way to get it if you want to do it through the Apple channels, or you can do what most of us have been doing, which is just download it straight off python.org or use something like one of the packages to install your Python. It's kind of nice to see that this little foot gun is disappearing.\n\nI think it's interesting that they're doing it mid-cycle, if you will, not like on a major number. That's great. I knew it was coming. The rumors had been there probably for the last year and a half talking about they were going to remove it. I don't know how many people always rely on a built-in Python 2.7 outside of the Apple engineers using these older scripts that they didn't want to rewrite or older programs and stuff. Yeah, it's good and also probably more secure and forward progression. I'm happy about that.\n\nIt's always a bad sign when your production code is shipping something that isn't supported by the people who put it out there, right? Totally. And this is sort of a trend you're seeing with a bunch of the Linux distributions as well, that they're slowly trying to get away from this, and eventually we'll get to a place where 2.7 is a badge of shame rather than, \"Oops, we're still there.\"\n\nSo my next one is a GitHub survey on languages and more developer things, which I think is funny. The web address is octoverse.github.com. The 2021 state of the Octoverse is a huge survey that they took across millions of developers, and some of the numbers are kind of staggering when you kind of look at it. There's just three charts in the main part that I want to talk about just briefly. The first one was the top languages over the years, and this survey is going back as far as charting this from 2014. It's interesting to watch the languages kind of shuffle around to see things like Ruby kind of dropping from fifth place down to from fifth to tenth. Python is now moved from fourth all the way up to second. JavaScript and TypeScript are both high up there. JavaScript being the number one and has been the number one for seven years here, and Java dropping down, working with static and media files in Django and a library for pleasing console output. This episode is brought to you by SeaData software, the easiest way to connect Python with data. SQL access to more than 250 cloud applications and data sources. Let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python",
    "PHCv_3zfM_Y": "Welcome to the Real Python Podcast. This is Episode 99. Have you thought about what authentication system you want to use for your Python project? Should you use an existing Python library or a third-party service? This week on the show, Dan Moore is here to talk about authentication systems and OAuth2. Dan is the head of developer relations at Fusion Auth. He shares advice about setting up an authentication system, setting up device grants, social login, and privacy issues.\n\nDan also provides multiple resources to learn much more about the topic. All right, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey Dan, welcome to the show. Thanks for having me.\n\nYou reached out and you want to talk about authentication and we had a, I guess it was just about this time last year, we had a couple of guys on from a company called Oso to talk about authorization. So it's nice to be able to talk about the other side because they were very adamant about saying, \"Okay, we need to separate these two things.\" That's great. Yeah, no, I'm excited to do that. I have not worked directly with Oso, but I've definitely seen some of their stuff and done some stuff with people that are in the same space. So I'm a big fan of what they're doing.\n\nYeah, it's cool. Maybe you could talk a little bit about Fusion Auth and what you guys do there. Sure. So we are an identity provider. It's the kind of technical jargony term, but basically what that means is every application, almost every application needs to have a way for someone to log in and be identified and then get some certain set of permissions. And Fusion Auth came out of this need. It was actually for another product that we have. We extracted that functionality and we realized every application needs this, and it's just undifferentiated functionality, right? Like forgot password pages, login pages, registration pages. You want them to look like your application, but they don't add value to your app. No one says, \"Oh gosh, you know that login page really blew me away.\" They just want to get through the login page to get to your features. And so, right, that's what we're offering is kind of a drop-in way for app devs, especially focused on developers who have a certain set of needs to add that functionality to their applications easily. Yeah, it's one of the things I think you guys mentioned on some of the pages as I was looking through it. One is this single responsibility principle. What does that mean? \n\nIn the context of this, you know, in the context of authentication in general, the way I think of it is, in the 60s, data storage was all wrapped in with application code. Okay, and then the database was invented. So you could separate out the two, right? And we're starting to see that with authentication and other things too, right? Not just authentication, but authorization, caching. There's this realization that it is better to have one component that is really, really focused on something, and in authentication or with user data, I think it's even more important because you have things like the CCPA or the GDPR, you know, and frankly, tons and tons of breaches of user data, unfortunately, right? Exactly. You know, companies need to be very careful with this data in a way that they might not need to be careful with some of the other pieces of their architecture. Yeah, and it's interesting because I think a lot of people that listen to this show are definitely in that range of beginner to intermediate developer, and they probably have gone through some tutorials, gone through some project setup sort of stuff, and maybe done a lot of it locally and haven't really had to think about, \"Okay, well, what's the next step if I want to deploy this?\" I could maybe use built-in tools like something that comes with Django or something I can kind of model after libraries that are kind of built with something like Flask. What does an authorization or an authentication system like require? The ones that are included with something like Django? You mentioned it already that you might need a database. What are all the things that kind of come into play when you think authentication system? Sure. So first of all, I would say that all your listeners who are starting out with Django, you know, user table and/or like Flask login or something like that, that's head down the right path, right? You absolutely should not roll your own authentication password hashing. Use the library. Okay. That's the first thing, right? And I have written my own many years ago, and you know, I made mistakes, and luckily it was for a toy application, so nothing bad ever happened. But the first thing is use a library. Where we start to see people say, \"Oh man, an off server makes more sense,\" is when they have one, two, three, four, five applications. And if you do that in Django, you have a couple options, right? Like you can create different user silos, which may or may not suit your needs depending on the applications. Or you can have one Django server be kind of like the primary, right? And have all these other ones leverage, you know, talk to it either via something like OAuth or OIDC or some other kind of protocol. And the issue with doing that is that you now have entangled like an off server essentially within your primary Django application. And so they might have different requirements around security or availability. They may not, but if they do, then you can take a step of like separating out that Django application and then maybe you send up a separate Django application that just becomes an off server. And essentially, there you are. Then you've had, you have an observer, it's separate, it's in your, it's in whatever your technology stack is. And that's a great place to be as long as you're okay with the surface area, the attack surface area of Django being around your being available on your off server. And it has all the functionality and features you need. If it doesn't, that's when it might make sense to go to the next level, which is a specialized focused off server like Fusion Auth or You Know, Fusion Auth is not the only one out there. Newsflash, you know, Key Cloak, Auth0, Octa, there's, there's a number of other options. But that standalone nature is kind of an evolutionary thing. And I would say one last thing is just like any kind of major architectural changes in any application. You can choose to take the pain now or the pain later. Okay. And where it makes sense depends on where your business needs are. Yeah, that makes sense to me. That you kind of have to look at the situation, the user experience of what it's like to access all the different applications that you have. And then also have to think about you as a developer. I just had somebody on talking developer experience and this idea of like, okay, this isn't my specialty, which is a whole other thing, right? That idea of like, okay, how do I want to manage these things? Sure. So that's cool. What maybe we can kind of take a little bit of a step backward and talk about when you set up something like authentication using the standard user table things inside of Django. Is there a name for that type of authentication? You know, I have not seen anything that's like standardized. I would call it kind of a, the auth as library pattern. Okay. Because it's really just like it's entirely enclosed in your application, right? Okay. And then there are lots of standards. And one of the things that we wanted to talk about today is OAuth. And maybe we can talk about like kind of why that came to fruition and kind of where it's at as far as advantages to some systems that are like that. Where did OAuth come from? Yeah. And actually I want to be kind of careful here in case anyone listening to your podcast is pedantic. OAuth is an authorization protocol, but later on top of it is something called OpenID Connect, which is OIDC, right? OIDC exactly. Yeah. Yeah. And they really go hand in hand. Like it's very, I have not seen too many situations where you have OAuth without OIDC because typically you want authorization, authentication to be connected. If not, you know, unitary. Okay. But so basically OAuth came out of this problem of, people wanting to allow applications to access their data. And so this is in the kind of 2000s. And the way that it happened is, suppose I have an application that is like an address book application, and I want to allow it to access my Gmail contacts. Okay. And back in the 2000s, I might, the address book application might have popped up a little, you know, form that said, please enter your Gmail username and password. And then it would, yeah, use that to connect to Gmail. And they would get the contacts and would bring them back. But users quickly realized that, and I don't know if there was a specific incident that caused any kind of realization, but basically once someone has the username and password, they can do whatever the heck they want with it. And not just them, but anybody who gets access to their database. Yeah, and that's obviously a major security issue. And so OAuth came out of this idea of, we need to solve this problem of secure delegated access without handing over kind of the whole enchilada, sort of thing. Yeah, everything, yeah. Yeah, I was gonna, I was gonna say enchilada too. Yeah, one of the famous ones was, path, I think, that kind of goes in the news was a social network that ended up, you know, having that sort of thing where you gave them access to it because they wanted to grow the network, right? And share it in that way. And it's kind of been a wake-up call in some ways. Definitely. So were these engineers at like particular companies thinking about it, or was it like an open sort of standard? I mean, hence the name. Yeah, my understanding is, and you know, I'm not a tech historian. That's okay. I mean, I understand it was a couple large companies. Flickr was one of them. I heard of and they actually worked on kind of OAuth one first, which was a... If you've ever heard like two-legged and three-legged off that comes from that era. And okay, again, I haven't done a lot with OAuth one, but my understanding is it's a more complicated protocol. And in I want to say 2010 or 11, they realized that the some engineers realized that they needed to do a new have a new standard that remedies some of the issues that OAuth one had. And so they standardized a separate thing through the IETF called which OAuth one was also standardized through the IETF called OAuth 2, which was not backwards compatible, which had a whole slew of, you know, just kind of differences. It accounted for more mobile apps. It spa's were starting to happen more. And so they kind of laid the groundwork for that. And one thing they did that I think was really smart, well, two things. One is they said, Hey, we're going to delegate the can a transport layer security to SSL. Okay. And just say, Hey, do everything over TLS because that removes like a whole class of problems. And the second thing they did is they said we're going to be extensible. And so they have over the last 10 or 12 years, we've, there's been a whole number of other things that have extended that standard. In some ways for things that weren't really imagined or weren't well defined when that standard was first implemented. So in general becoming more secure, more extensible. Working with these kind of new solutions have to involve like everybody owning multiple devices and the way we're connecting across the web, I guess. An example of like a new thing that I don't think that they really thought of when they were rolling it out is something that's called the device grant. Okay. Are you familiar with that or no? To make it quick over. Yeah. Yeah, sounds good. Okay. Cool. So basically the idea is that you can, if you have a TV or a fridge that has like this very limited UX. Oh yeah, like an Apple TV kind of thing. Exactly. You may want to log into that, but you do it with your phone, which has a really sophisticated UX. But there's like this defined dance between the place where you're logging in and the TV and your phone that lets it get, right? A token, which is kind of the end goal of all the OAuth grants without actually requiring you to log in and like click around the Apple TV, right? And enter your password, right? Which is very painful. Yeah, it could be if you have a good password. It should be painful. Yeah. Let's just leave it at that. Yeah, exactly. Yeah. So those are the kinds of things where it might pop up, go to this website and then you could use your mobile device to do it. And for various different devices you may own. So yeah. Okay. Cool. So those are grants. You know, yeah. So grant is basically anything that's like this, like set of processes and data flows that define how someone goes from logging in basically to this token, which is a time-bound like, you know, fixed length of time thing that is, it's essentially like a username and password because it's good for things. It's a set of credentials, but it's limited extremely. It can and it can be limited in different ways based on the grant you go through, but it's limited in scope. So, okay. And that's what everybody downstream of the authentication process should actually be looking at, right? Is that token to be like, oh, this says this is Dan, you know, this is Dan's token and the, what I use the example of, not the two application, it was, um, an address book application, Dan's, yeah, adjust book application account, want access to this Gmail. And all it can do is read contacts and it can't send email, it can't do anything else, but all that can be encapsulated in the token, okay? And so for some of these TV streaming boxes or something like that, it would, the grant could include like a certain amount of time, like in the case of, you know, somebody like Netflix where they're like concerned about all these people that are using other people's credentials and so forth, they could set like a certain amount of time or, or like if you were to update the application or something like that, then it might require it to log back in, what have you. So it's those are set by, I guess the authentication server, like there would be parameters that you would adjust for those kinds of things. So, you know, example of what might be in that token is like the tier of the service that someone had, right? Like, are they at the $15 or the $7 tier, okay? I don't know if that's a $7 tier anymore, but you get one disc a month. [Laughter] But I mean, one thing that's interesting and we actually have a client that, like, is it, is not Netflix to be totally clear, but is in a similar situation where they basically want you to log in once and they don't want you ever logging again, right? Because, right, unless you get your password stolen, it's a bad experience. Yeah, it's a horrible experience, right? And Netflix is not in the business of making experiences bad, right? They want you to sit there and binge as much as you can. So there's this other grant called the refresh token. So basically, okay, how that works is, when you log in, the application says, \"Hey, I want a refresh token.\" And so, the authentication server, it's called an authorization server in the parlance of OAuth, but the authentication server says, \"Okay, I'm going to give you both a token, which is that credential that we talked about, right, that has the information about the level of service and whatnot, but I'm also going to give you this refresh token. And when that time-bound token expires, you application, right, your TV or back-end TV service probably more like than the TV, can present that to me, to the authorization server, to the app authentication server, and I will tell you if this account is still valid, and I'll give you a new token each time. So you can have your tokens, your AC, they're called an access token, you know, five or ten minutes in lifetime, but you have this refresh token that you can be good for two years, okay? Because you're talking to the authentication server each time, the authentication server knows if you've logged out, if you've discontinued service or anything like that. So it's a pretty transparent thing and it's a way for you to get a user to essentially silently re-authenticate. Nice. So, all that sounds so complex as far as like all the coding involved, and so",
    "tpfbkYVxs70": "Welcome to the Real Python Podcast. This is episode 100. How do you define Python functions that accept optional arguments or default values? Or maybe you're wondering how to go beyond being a beginner with Python. This week on the show, Christopher Trudeau is here and he's brought another batch of Real Python articles and projects. Christopher shares a Real Python article titled \"Defining Python Functions with Optional Arguments.\" We talk about function flexibility, specifying default values, and using args and kwargs. We discuss resources for a Python beginner to move beyond the basics and become more competent. Both of us share our experiences moving past these hurdles.\n\nWe cover several other articles and projects from the Python community, including a news roundup, 10 tools you may have wished you knew when you started working with Python, manipulating your zip files efficiently with Python zip file, how one company optimized Python API server code by 100x, a dependency-free Python library for downloading YouTube videos, and how to use Python in the command line with other shell commands.\n\nThis episode is brought to you by CData Software, the easiest way to connect Python with data. SQL access to more than 250 cloud applications and data sources. All right, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at RealPython.com.\n\nHey Christopher, welcome back.\n\nHey there. This week, we got a bunch of PyCoder's articles and projects. We're starting off with some news again, and this week it's very pep-heavy.\n\nYeah, actually, I want to stop before you get there, Mr. Bailey. I think it's really important to mark the occasion. This is episode 100. That's quite an accomplishment. You work very hard on this. You do good work, and everybody at Real Python thanks you for that and thanks to our listeners for getting us this far.\n\nYeah, thanks everybody. It's been a wild ride all the way. It's been pretty fantastic just watching people be interested in coming on the show and having, you know, I've met so many people virtually now, and I don't know, I'm excited to keep going. Here's for the next hundred, yeah.\n\nThat's it. It's a real contribution to the community. Thanks.\n\nAwesome. All right, so what's our, oh, now we can dive in, so now I'll start. The first little bit that I'm going to talk about is the Django project, which has been promising for quite some time to reformat their entire code base with black, has finally done it. The change was recently committed and merged, so it should be coming out in one of the next releases. It hit over 2,000 files. Ouch. And the first stab at it broke a whole bunch of unit tests and needed some cleanup, as you can imagine if you're touching that kind of stuff. However you feel about black, and everybody seems to have an opinion, you have to admit this would have been a fairly daunting thing and is one heck of a commit.\n\nDefinitely. Yeah, and then we have a good link on that, and then the whole discussion thread on Hacker News that kind of continues from that.\n\nMy first story is diving into a set of these PEPs, as I was mentioning before. The first one is about PEP 673 and the self-type. It was accepted. The PEP introduces a simple, intuitive way to annotate methods that return an instance of their own class, so it kind of gets rid of some messy stuff that was involved with typing.\n\nIn your case, the foreign language of Python, I came from a lot of bespoke kind of languages. I'd worked in Access and I'd worked in Swift. I'd played with the most programming I had done a little bit in C. I'd done C and Fortran in school a very long time ago, and then I spent a lot of time hacking away in SQL and building tools in there. That's probably the real tribal fire moment that got me really into programming again. And so when a job came up that said, \"Hey, you want to do Python?\" I said, \"Okay, let me immerse myself.\" So like I said, I did the podcast. I looked at a few books at the time. I went through a Flask tutorial by Miguel Grinberg, which is really great. I've mentioned it before. It's like the mega Flask tutorial, and I built that tool. That was very helpful. And then I looked at Real Python a lot. I got a lot of resources from there, along with the books and the websites. I was able to get the gig. I did like a real basic coding interview kind of thing. And at the time of getting the job, I had work to do, which was great because then I really could apply it. And that has always been kind of my way of learning is I need something to do. I have a personality type where I really want to help others.\n\nAnd that's a wrap. Thank you for listening to the Real Python Podcast. Make sure to click the follow button in your podcast player. You can find the show notes with links to all the topics we spoke about in your podcast player or at realpython.com/podcast. If you have a question or a topic you'd like us to explore, leave us a message at realpython.com/podcast. I've been your host, Christopher Bailey, and I look forward to talking to you soon.",
    "3JxhdzWCMjU": "Welcome to the Real Python Podcast. This is Episode 101. Today, we'll be discussing different ways to set up Python in your environment, including managing multiple versions of Python and virtual environments. Calvin Hendricks Parker, co-founder and CTO of Six Feet Up, will be joining us to talk about bootstrapping your Python environment. Calvin has extensive experience setting up Python environments for various projects, from in-office projects to cloud-based applications.\n\nWe will cover tools for installing Python, managing multiple language versions, configuring virtual environments, setting up command line applications in isolated environments, and even traveling with Python using an iPad. This episode is brought to you by Scout APM, a performance monitoring tool built for developers by developers. Let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. Each week, we feature interviews with experts in the community and discussions about topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey Calvin, welcome back to the show. It's great to have you here. Today, we'll be discussing various topics related to setting up Python environments, including installing Python, managing multiple versions, configuring virtual environments, and more. I was inspired by your YouTube history, where you shared valuable advice on these topics. Additionally, I thought it would be interesting to discuss using Python on an iPad, as David Amos recently wrote an article on this topic. So, we have a lot of mini topics to cover today.\n\nI noticed you have done a lot of talks at IndyPy in Indianapolis. Could you tell us more about that?\n\nI'm actually one of the co-founders of the Indianapolis Python User Group, IndyPy. We've been running the group for 15 years now, and we're celebrating our anniversary soon with an anniversary party. If you're in the area, feel free to join us for the celebration.\n\nOne of the talks that caught my attention was \"A Half a Dozen Ways to Fail at Python.\" Can you share the main points of that talk and how users can avoid common pitfalls?\n\nPython is a powerful language, but setting up the environment can be challenging. Many users end up with multiple versions of Python installed, leading to confusion and compatibility issues. To avoid these pitfalls, it's essential to follow the Zen of Python principles and focus on simplicity and clarity in your environment setup.\n\nI recommend using tools like Pyenv to manage different Python versions and virtual environments. This allows for better control and scalability in your projects. Additionally, leveraging Docker containers can help create a consistent development environment across different platforms.\n\nWhat are your thoughts on using tools like Pipenv for managing project dependencies and ensuring reproducible builds?\n\nPipenv is a useful tool for managing Python dependencies and creating virtual environments. It simplifies the process of installing packages and ensures consistent builds across different environments. By specifying dependencies in a Pipfile and using tools like Pip Tools for package management, developers can maintain a clean and organized project structure.\n\nI'm excited to learn more about setting up a portable Python environment and using Python on an iPad. Can you share some tips and tools for achieving this?\n\nSetting up a portable Python environment can be challenging, but tools like Pyenv and Pipx can simplify the process. Pyenv allows for managing multiple Python versions, while Pipx helps install and manage Python packages in a portable manner. Additionally, using tools like Blink for terminal access and Chamois for dot file management can enhance the Python development experience on an iPad.\n\nThank you, Calvin, for sharing your insights and tips on setting up Python environments and using Python on an iPad. It's been a pleasure having you on the show.\n\nThank you for listening to the Real Python Podcast. Make sure to click the follow button in your podcast player to get notified of new episodes. If you enjoy the show, please leave us a review. You can find all the show notes and links mentioned in this episode at realpython.com/podcast. See you next time!",
    "VK2QfDXPg6k": "Welcome to the Real Python Podcast. This is Episode 103. Do you wonder if you're taking the right approach when shaping data in Pandas? Is your Jupyter workflow getting out of hand? This week on the show, Matt Harrison talks about his new book Effective Pandas: Patterns for Data Manipulation. Matt discusses working as a corporate consultant and migrating Excel users toward Python. We explore several numpyisms that beginners get stuck on, and Matt shares advice about chaining operations in Pandas, which some developers find controversial.\n\nThis episode is brought to you by Sea Data Software, the easiest way to connect Python with data. SQL access to more than 250 cloud applications and data sources. Alright, let's get started.\n\n[Music]\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey Matt, welcome to the show.\n\nHey, thanks for having me on. Excited to be here. I wanted to talk a little bit about what you do as a consultant. I find it interesting that you focus not only on Python but on Pandas specifically.\n\nYeah, for the last eight years or so, there has been enough interest to me that I've done a bit of consulting around Python, data science, predictive modeling, reporting, that sort of thing. I would say that most of my bread and butter these days is corporate training, going into large companies and making them proficient in Python. One of the reasons Python is so popular today is not just for developers, but also for the scientific community and people who are using Python as a tool, who aren't necessarily programmers or trained as programmers or don't necessarily want to be programmers. There are over 350,000 libraries that you can use with Python. A lot of those match up with what people want to do, so a lot of these people are using Python instead of Excel or some other tool because it will make their life a lot easier.\n\nI definitely want to talk about that because I feel and have seen that myself. I have a background of working with small businesses and the tools they were using and thinking about ways to move them beyond Excel. I have a friend who does environmental science, and they did a lot of fieldwork. His girlfriend works in Hawaii with the Department of Health. She was a total Excel person, super deep, doing all these elaborate macros and stuff. I think she turned the corner this year after I talked to her a little bit about getting into Python, and it's changed everything for her.\n\nExcel is the most popular programming environment in the world, for better or worse. It has an awesome out-of-the-box experience where you can take a third-grader and sit them down in Excel, and they can do some pretty cool things. But when you're programming, there are some hard-learned rules that can make your experience better. I think a lot of people who leverage Excel or are power users from Excel can do really cool things, but it tends to be more on the right once, make it easy to write, but when you come back or try to collaborate or share with others, that's where the difficulty starts. Leveraging some tricks of actual programming, software engineering best practices can help with that.\n\nA lot of those people are going to start with scratching their own itch, kind of like automating a simple process, or maybe even a more elaborate process, combining things, and doing things that they would normally do in Excel or reports that they needed to generate. Those would end up being like singular scripts. The trouble becomes, how do I communicate these techniques to others, and how do I systematize it? Those are the kinds of things you're talking about.\n\nI wouldn't even say scripts, I would say Jupyter notebooks. This is just like some notebook hanging around on someone's desk, and it's like, yeah, it works for me right or it worked yesterday or a month ago. But how do we make it work, and how do we move from, I guess, similar to like Excel makes it really easy to do things, and Jupyter makes it really easy to do some things, but if you put some guardrails in, it can make it easier to collaborate and share with others.\n\nThis episode is brought to you by Sea Data Software. Connect, integrate, and automate your data from Python or any other application or tool. At Sea Data, we simplify connectivity between all the applications and data sources that power business, making it easier to unlock the value of data. Our SQL-based connectors streamline data access, making it easy to access real-time data from on-premise or cloud databases, SAS APIs, NoSQL, and big data. Check out cdata.com to learn more.\n\nAlright, let's get started.\n\n[Music]\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey Matt, welcome to the show.\n\nHey, thanks for having me on. Excited to be here. I wanted to talk a little bit about what you do as a consultant. I find it interesting that you focus not only on Python but on Pandas specifically.\n\nYeah, for the last eight years or so, there has been enough interest to me that I've done a bit of consulting around Python, data science, predictive modeling, reporting, that sort of thing. I would say that most of my bread and butter these days is corporate training, going into large companies and making them proficient in Python. One of the reasons Python is so popular today is not just for developers, but also for the scientific community and people who are using Python as a tool, who aren't necessarily programmers or trained as programmers or don't necessarily want to be programmers. There are over 350,000 libraries that you can use with Python. A lot of those match up with what people want to do, so a lot of these people are using Python instead of Excel or some other tool because it will make their life a lot easier.\n\nI definitely want to talk about that because I feel and have seen that myself. I have a background of working with small businesses and the tools they were using and thinking about ways to move them beyond Excel. I have a friend who does environmental science, and they did a lot of fieldwork. His girlfriend works in Hawaii with the Department of Health. She was a total Excel person, super deep, doing all these elaborate macros and stuff. I think she turned the corner this year after I talked to her a little bit about getting into Python, and it's changed everything for her.\n\nExcel is the most popular programming environment in the world, for better or worse. It has an awesome out-of-the-box experience where you can take a third-grader and sit them down in Excel, and they can do some pretty cool things. But when you're programming, there are some hard-learned rules that can make your experience better. I think a lot of people who leverage Excel or are power users from Excel can do really cool things, but it tends to be more on the right once, make it easy to write, but when you come back or try to collaborate or share with others, that's where the difficulty starts. Leveraging some tricks of actual programming, software engineering best practices can help with that.\n\nA lot of those people are going to start with scratching their own itch, kind of like automating a simple process, or maybe even a more elaborate process, combining things, and doing things that they would normally do in Excel or reports that they needed to generate. Those would end up being like singular scripts. The trouble becomes, how do I communicate these techniques to others, and how do I systematize it? Those are the kinds of things you're talking about.\n\nI wouldn't even say scripts, I would say Jupyter notebooks. This is just like some notebook hanging around on someone's desk, and it's like, yeah, it works for me right or it worked yesterday or a month ago. But how do we make it work, and how do we move from, I guess, similar to like Excel makes it really easy to do things, and Jupyter makes it really easy to do some things, but if you put some guardrails in, it can make it easier to collaborate and share with others.\n\nThis episode is brought to you by Sea Data Software. Connect, integrate, and automate your data from Python or any other application or tool. At Sea Data, we simplify connectivity between all the applications and data sources that power business, making it easier to unlock the value of data. Our SQL-based connectors streamline data access, making it easy to access real-time data from on-premise or cloud databases, SAS APIs, NoSQL, and big data. Check out cdata.com to learn more.\n\nAlright, let's get started.\n\n[Music]\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey Matt, welcome to the show.\n\nHey, thanks for having me on. Excited to be here. I wanted to talk a little bit about what you do as a consultant. I find it interesting that you focus not only on Python but on Pandas specifically.\n\nYeah, for the last eight years or so, there has been enough interest to me that I've done a bit of consulting around Python, data science, predictive modeling, reporting, that sort of thing. I would say that most of my bread and butter these days is corporate training, going into large companies and making them proficient in Python. One of the reasons Python is so popular today is not just for developers, but also for the scientific community and people who are using Python as a tool, who aren't necessarily programmers or trained as programmers or don't necessarily want to be programmers. There are over 350,000 libraries that you can use with Python. A lot of those match up with what people want to do, so a lot of these people are using Python instead of Excel or some other tool because it will make their life a lot easier.\n\nI definitely want to talk about that because I feel and have seen that myself. I have a background of working with small businesses and the tools they were using and thinking about ways to move them beyond Excel. I have a friend who does environmental science, and they did a lot of fieldwork. His girlfriend works in Hawaii with the Department of Health. She was a total Excel person, super deep, doing all these elaborate macros and stuff. I think she turned the corner this year after I talked to her a little bit about getting into Python, and it's changed everything for her.\n\nExcel is the most popular programming environment in the world, for better or worse. It has an awesome out-of-the-box experience where you can take a third-grader and sit them down in Excel, and they can do some pretty cool things. But when you're programming, there are some hard-learned rules that can make your experience better. I think a lot of people who leverage Excel or are power users from Excel can do really cool things, but it tends to be more on the right once, make it easy to write, but when you come back or try to collaborate or share with others, that's where the difficulty starts. Leveraging some tricks of actual programming, software engineering best practices can help with that.\n\nA lot of those people are going to start with scratching their own itch, kind of like automating a simple process, or maybe even a more elaborate process, combining things, and doing things that they would normally do in Excel or reports that they needed to generate. Those would end up being like singular scripts. The trouble becomes, how do I communicate these techniques to others, and how do I systematize it? Those are the kinds of things you're talking about.\n\nI wouldn't even say scripts, I would say Jupyter notebooks. This is just like some notebook hanging around on someone's desk, and it's like, yeah, it works for me right or it worked yesterday or a month ago. But how do we make it work, and how do we move from, I guess, similar to like Excel makes it really easy to do things, and Jupyter makes it really easy to do some things, but if you put some guardrails in, it can make it easier to collaborate and share with others.\n\nThis episode is brought to you by Sea Data Software. Connect, integrate, and automate your data from Python or any other application or tool. At Sea Data, we simplify connectivity between all the applications and data sources that power business, making it easier to unlock the value of data. Our SQL-based connectors streamline data access, making it easy to access real-time data from on-premise or cloud databases, SAS APIs, NoSQL, and big data. Check out cdata.com to learn more.\n\nAlright, let's get started.\n\n[Music]\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey Matt, welcome to the show.\n\nHey, thanks for having me on. Excited to be here. I wanted to talk a little bit about what you do as a consultant. I find it interesting that you focus not only on Python but on Pandas specifically.\n\nYeah, for the last eight years or so, there has been enough interest to me that I've done a bit of consulting around Python, data science,",
    "yVsonM9zpO8": "Welcome to the Real Python Podcast. This is Episode 104. Do you understand how a hash table works? What if you could learn about building one while practicing test-driven development? What are best practices when designing a REST API? This week on the show, Christopher Trudeau is here and he's brought another batch of PyCoder's Weekly articles and projects.\n\nWe talk about a recent Real Python article titled \"Build a Hash Table in Python with TDD\". The tutorial shows how to implement a hash table prototype from scratch in Python. It also provides a hands-on crash course in test-driven development. Christopher shares an article on designing REST APIs and provides some of his own best practices. We cover implementing authentication, good naming conventions, versioned APIs, and how to specify dates.\n\nWe cover several other articles and projects from the Python community, including a news roundup, removing dead batteries from the standard library, comparing the Python list versus tuple, how to write user-friendly CLIs in Python, just enough Cython to be useful, an ASCII animation package, and running Black on Python code blocks and documentation files.\n\nThis episode is brought to you by Anvil. With Anvil, you can create web applications entirely in Python and deploy them on the web. You don't need any web development experience. Start building Python web apps for free at anvil.works.\n\nAlright, let's get started.\n\n[Music]\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com.\n\nAfter the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey Christopher, welcome back.\n\nMr. Bailey: Good to see you or hear you. Yes, we haven't been doing the video thing yet. No, for the sake of our listeners, that's probably a good thing.\n\nYeah, you know, we were going to start off with some news again between PEPs in Python releases. I think we got plenty of news to cover for sure. So I'm going to start off talking about PEP 594. Python refers to itself as the \"batteries included\" language, meaning you get lots of stuff in the standard library. More common now with a lot of languages, but when Python first came out, this was not as typical. Having everything built in was sort of a benefit of going to the language. Of course, the problem is, one person's everything is another person's clutter, and every package in the standard library has got to be maintained. It makes the more stuff you have, the harder it is to fit it into small devices, and in some cases, you've got duplication of functionality as things have grown and changed over the years. So once in a while, you've got to do a little bit of house cleaning, and PEP 594 called \"Removing Dead Batteries from the Standard Library\" is, well, it's springtime, and we're going to dive into that kitchen drawer filled with old cords and dead batteries and tidy up a bit.\n\nAs with most PEPs in the news, this one's been kicking around for a couple of years, but the reason it's popped up on the radar is because the work is being done in the 3.11 alpha release. So the PEP's been around for a while, but now we're doing the work.\n\nWhat's in the drawer that's getting cleaned up? There's a bunch of audio libraries for formats that were kicking around when grunge was popular, several of which I had never heard of. There were some CGI libraries, which made me feel old. That's web stuff back from the Dark Ages. And then there was some cryptography things that are old and basically almost historic dinosaurs and easy to break, a couple of asynchronous tools that AsyncIO now that it exists really don't really need the originals, and then there's some other odds and ends. So all told, there are 21 libraries scheduled for removal. I've been writing Python for a little over a decade now, I've only ever come across two of them, so these aren't big popular things. About half of the 21 libraries have direct replacements, either stuff already in the standard library or packages out there that take care of the same thing. Nineteen of the 21 are going to be fully removed in 3.13, so they're being deprecated in 3.11, and the two async libraries are going to get out the door just a little earlier in 3.12.\n\nGreat. For the most part, this will affect very, very few people because the reason they've been identified to be cleaned up is they aren't really getting used much anymore.\n\nYeah, I think we've discussed it when I had Brett on the show, and he was talking about kind of going through the library and seeing what's been touched, what's been updated, outside of just formatting changes or other stylistic changes, that where something maybe got caught up in an update across several things. But yeah, I think it's good. You know, you've got to do that, especially if you're going to have a batteries included type of language. You probably are going to need to keep an eye on those things.\n\nParticularly with the duplicates, that just is confusing.\n\nYeah, when there's three ways of doing something, but part of the Zen of Python is there's only supposed to be one way, right? So as a newbie coming to a library, you start looking for something, you're like, \"Oh, there's this one or that one. Which one am I supposed to use?\"\n\nThis one's kind of a fun roller coaster of a set of things. On March 16th, Python 3.10.3, 3.9.11, 3.8.13, and 3.7.13 were available. Lots of updates as far as security content for these updated Python versions. And the last time they were started this paragraph with last time around, I was complaining about cursed releases, which ends up being kind of this theme because maybe I should talk about the updates generally. There were in this 3.10.3, there were like 220 commits since 3.10.2. So large amounts of bug fix stuff going on in there. You can kind of check out the logs there. The other updates in 3.9.11 had some of the same kind of stuff happening in them, 163 commits in that one. The other ones, 3.8 and 3.7, those updates were mostly kind of geared towards security, which is the state that both of those are in. You might note that 3.6 is not included there. They mentioned their Python 3.6 is pining for the fjords. Python 3.6 is no more. It's an ex-Python. It has ceased to be. So anyway, some Monty Python humor there.\n\nYeah, it reached its end of life December 23rd, 2021, which is interesting because that's like, 3.6 is definitely the one that where I really started using Python. So it's kind of interesting to think about.\n\nBut then on the 24th, there was this tweet from Wukaslanga, and it was 3.10.4 and 3.9.12 are now available out of schedule. So shortly after releasing them, like literally under a week, they identified a regression that caused Python to not build properly on Red Hat Linux 6, and their new release addressed that. So again, diving deeper into the cursed releases thing happening there. They note that even though it's an 11-year-old version that is now out of maintenance support, it's still used in a lot of production workloads. And some of those rely on 3.9 and 3.10, and in particular, they have their own many Linux 2010 image that's used to build widely compatible Linux wheels based on CentOS 6. They've been feeling this kind of curse of having to do multiple releases as I go. The hope is to not see any new releases or changes until May. Hopefully, when they have their next regularly scheduled bug fixes. But yeah, I have a long talk coming up next week with Pablo, and we talked a little bit about being a release manager, and so this is kind of some timely news of the kind of stuff that he's having to work through. Obviously, Lucas has been on the show a couple times, and both of them have been working not only on 3.8, 3.9, but 3.10, and like I said, the alpha releases for 3.11. There's a lot kind of coming in there.\n\nWe talk about PEP 594, Python refers to itself as the \"batteries included\" language, meaning you get lots of stuff in the standard library. More common now with a lot of languages, but when Python first came out, this was not as typical. Having everything built in was sort of a benefit of going to the language. Of course, the problem is one person's everything is another person's clutter, and every package in the standard library has got to be maintained. It makes the more stuff you have, the harder it is to fit it into small devices, and in some cases, you've got duplication of functionality as things have grown and changed over the years. So once in a while, you've got to do a little bit of house cleaning, and PEP 594 called \"Removing Dead Batteries from the Standard Library\" is, well, it's springtime, and we're going to dive into that kitchen drawer filled with old cords and dead batteries and tidy up a bit.\n\nAs with most PEPs in the news, this one's been kicking around for a couple of years, but the reason it's popped up on the radar is because the work is being done in the 3.11 alpha release. So the PEP's been around for a while, but now we're doing the work.\n\nWhat's in the drawer that's getting cleaned up? There's a bunch of audio libraries for formats that were kicking around when grunge was popular, several of which I had never heard of. There were some CGI libraries, which made me feel old. That's web stuff back from the Dark Ages. And then there was some cryptography things that are old and basically almost historic dinosaurs and easy to break, a couple of asynchronous tools that AsyncIO now that it exists really don't really need the originals, and then there's some other odds and ends. So all told, there are 21 libraries scheduled for removal. I've been writing Python for a little over a decade now, I've only ever come across two of them, so these aren't big popular things. About half of the 21 libraries have direct replacements, either stuff already in the standard library or packages out there that take care of the same thing. Nineteen of the 21 are going to be fully removed in 3.13, so they're being deprecated in 3.11, and the two async libraries are going to get out the door just a little earlier in 3.12. Great. For the most part, this will affect very, very few people because the reason they've been identified to be cleaned up is they aren't really getting used much anymore.\n\nYeah, I think we've discussed it when I had Brett on the show, and he was talking about kind of going through the library and seeing what's been touched, what's been updated, outside of just formatting changes or other stylistic changes, that where something maybe got caught up in an update across several things. But yeah, I think it's good. You know, you've got to do that, especially if you're going to have a batteries included type of language. You probably are going to need to keep an eye on those things. Particularly with the duplicates, that just is confusing. Yeah, when there's three ways of doing something, but part of the Zen of Python is there's only supposed to be one way, right? So as a newbie coming to a library, you start looking for something, you're like, \"Oh, there's this one or that one. Which one am I supposed to use?\" This one's kind of a fun roller coaster of a set of things. On March 16th, Python 3.10.3, 3.9.11, 3.8.13, and 3.7.13 were available. Lots of updates as far as security content for these updated Python versions. And the last time they were started this paragraph with last time around, I was complaining about cursed releases, which ends up being kind of this theme because maybe I should talk about the updates generally. There were in this 3.10.3, there were like 220 commits since 3.10.2. So large amounts of bug fix stuff going on in there. You can kind of check out the logs there. The other updates in 3.9.11 had some of the same kind of stuff happening in them, 163 commits in that one. The other ones, 3.8 and 3.7, those updates were mostly kind of geared towards security, which is the state that both of those are in. You might note that 3.6 is not included there. They mentioned their Python 3.6 is pining for the fjords. Python 3.6 is no more. It's an ex-Python. It has ceased to be. So anyway, some Monty Python humor there. Yeah, it reached its end of life December 23rd, 2021, which is interesting because that's like 3.6 is definitely the one that where I really started using Python. So it's kind of interesting to think about. But then on the 24th, there was this tweet from Wukaslanga, and it was 3.10.4 and 3.9.12 are now available out of schedule. So shortly after releasing them, like literally under a week, they identified a regression that caused Python to not build properly on Red Hat Linux 6, and their new release addressed that. So again, diving deeper into the cursed releases thing happening there. They note that even though it's an 11-year-old version that is now out of maintenance support, it's still used in a lot of production workloads. And some of those rely on 3.9 and 3.10, and in particular, they have their own many Linux 2010 image that's used to build widely compatible Linux wheels based on CentOS 6. They've been feeling this kind of curse of having to do multiple releases as I go. The hope is to not see any new releases or changes until May. Hopefully, when they have their next regularly scheduled bug fixes. But yeah, I have a long talk coming up next week with Pablo, and we talked a little bit about being a release manager, and so this is kind of some timely news of the kind of stuff that he's having to work through. Obviously, Lucas has been on the show a couple times, and both of them have been working not only on 3.8, 3.9, but 3.10, and like I said, the alpha releases for 3.11. There's a lot kind of coming in there. We talk about PEP 594, Python refers to itself as the \"batteries included\" language, meaning you get lots of stuff in the standard library. More common now with a lot of languages, but when Python first came out, this was not as typical. Having everything built in was sort of a benefit of going to the language. Of course, the problem is one person's everything is another person's clutter, and every package in the standard library has got to be maintained. It makes the more stuff you have, the harder it is to fit it into small devices, and in some cases, you've got duplication of functionality as things have grown and changed over the years. So once in a while, you've got to do a little bit of house cleaning, and PEP 594 called \"Removing Dead Batteries from the Standard Library\" is, well, it's springtime, and we're going to dive into that kitchen drawer filled with old cords and dead batteries and tidy up a bit. As with most PEPs in the news, this one's been kicking around for a couple of years, but the reason it's popped up on the radar is because the work is being done in the 3.11 alpha release. So the PEP's been around for a while, but now we're doing the work. What's in the drawer that's getting cleaned up? There's a bunch of audio libraries for formats that were kicking around when grunge was popular, several of which I had never heard of. There were some CGI libraries, which made me feel old. That's web stuff back from the Dark Ages. And then there was some cryptography things that are old and basically almost historic dinosaurs and easy to break, a couple of asynchronous tools that AsyncIO now that it exists really don't really need the originals, and then there's some other odds and ends. So all told, there are 21 libraries scheduled for removal. I've been writing Python for a little over a decade now, I've only ever come across two of them, so these aren't big popular things. About half of the 21 libraries have direct replacements, either stuff already in the standard library or packages out there that take care of the same thing. Nineteen of the 21 are going to be fully removed in 3.13, so they're being deprecated in 3.11, and the two async libraries are going to get out the door just a little earlier in 3.12. Great. For the most part, this will affect very, very few people because the reason they've been identified to be cleaned up is they aren't really getting used much anymore. Yeah, I think we've discussed it when I had Brett on the show, and he was talking about kind of going through the library and seeing what's been touched, what's been updated, outside of just formatting changes or other stylistic changes, that where something maybe got caught up in an update across several things. But yeah, I think it's good. You know, you've got to do that, especially if you're going to have a batteries included type of language. You probably are going to need to keep an eye on those things. Particularly with the duplicates, that just is confusing. Yeah, when there's three ways of doing something, but part of the Zen of Python is there's only supposed to be one way, right? So as a newbie coming to a library, you start looking for something, you're like, \"Oh, there's this one or that one. Which one am I supposed to use?\" This one's kind of a fun roller coaster of a set of things. On March 16th, Python 3.10.3, 3.9.11, 3.8.13, and 3.7.13 were available. Lots of updates as far as security",
    "P4SmcMu5OLg": "Welcome to the Real Python Podcast. This is Episode 106. Do you know the difference between creating a class instance and initializing it? Would you like an interactive tour of the Python Pillow library? This week on the show, Christopher Trudeau is here and he's brought another batch of PyCoder's weekly articles and projects. We talk about a recent Real Python tutorial titled \"Image Processing with the Python Pillow Library.\" It walks you through manipulating, filtering, and creating images from scratch.\n\nChristopher shares an article about Python class constructors, exploring the two-step instance creation and initialization process. We also have a couple of discussions this week. The first is about contributing to open source projects, and the second is about searching large code bases before adding features. We cover several other articles and projects from the Python community, including the counter-intuitive rise of Python in scientific computing, preparing for interview questions, bringing the \"hell of pointers\" to Python, and a fast and powerful graphical user interface toolkit for Python with minimal dependencies.\n\nThis episode is brought to you by FusionAuth. FusionAuth is an authentication and authorization platform built for devs by devs. Try FusionAuth for free at fusionauth.io/download. Alright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com.\n\nHey, Christopher. Welcome back.\n\nHey there. How are you?\n\nGood. I'm excited we're going to bypass doing some news this week and dig right into some topics and kind of double up on the discussion thing. We've got some good stuff to discuss.\n\nI'll be starting it off. I mine is a Real Python one to start with. It's \"Image Processing with the Python Pillow Library,\" which I've mentioned Pillow a handful of times on the show. I had Mike Driscoll on the show before to talk about a book that he did on the Pillow library. This is an article by Stephen Grupetta. I really had fun going through the entire article. I think people already know that I like messing with graphics and playing around. I had already kind of used a little bit of the Pillow library, but probably my favorite thing about this tutorial is it's done by exploring the library using it in an interactive REPL. You could use whatever interactive REPL you want. It could be like a Jupyter notebook or IPython or what have you. I just end up typing Python and playing with it and importing. But you really get this kind of feel of play of messing around with it, and I really think that's a nice way to kind of approach this stuff and I think it encourages people to explore what you can kind of do with photos in a tool like this. He references a book several times. It's called \"Digital Image Processing\" by Gonzalez and Woods, and it seems like a really good resource also if you're interested in this.\n\nBut at that point, you're working on really processing the image and talks about convolution kernels and these filters that kind of work inside that. It has a lot of built-in stuff. It has blurs, box blurs, Gaussian blurs, shows you techniques of sharpening and smoothing and some of the math really kind of behind all of that and how that's kind of working which I think is really kind of a neat thing to explore sharpening and smoothing, edge detection, edge enhancement, embossing, things that you might have played with in the filter section of something like Photoshop or even a simpler tool for doing filtering. And then it gets into the mode and the idea of an image being made up of channels, the red, green, blue channels, RGB, and how you can segment an image into that and how each one of those will have its own sort of luminance in there and from that it kind of is leading into this idea of, well, maybe we could look at building something to superimpose an image on another by kind of making a mask. So you look at the different channels and which one has the most contrast in it and then you're defining things and then he gets in this really cool thing where he's like setting thresholds and then using a tool of erosion and dilation within the simple image to take a, it uses a really nice simple image of a white circle on a black background. The image is sort of split in half, the other half is a white background with a black dot on it, and so as you do something of like eroding it, you can see the changes on both of those sides, are dilating it and how you can kind of push the threshold one way or the other and in the end result again hard to explain over podcast. You build this image where it's a picture of a cat and you want to sort of cut the cat out of the background and have it by itself by building this filter and then superimpose it using this paste tool that's part of the library and it turned out really cool. It's, I think it's a neat technique of working through that. And then one of the other tools is creating a watermark. At the very end, he's playing with some NumPy stuff where you're using methods to do things like, you know, those little puzzles they have in the newspaper sometimes, spot the differences between two images, what's changed, you know, there's like five things that have changed or whatever, and he's using NumPy to kind of do that from one image to another to kind of literally extract those things that are different from one or the other, which is neat, kind of using some of the methods and mathematical tools that are built into NumPy to do that. And then he uses NumPy to actually create raw images and then do some kind of cool basic animation at the very end. I just really dug it. I had fun going through it and again, it was very playful because it was all the REPL, kind of playing around and messing with. I could see this being a fun experiment to do with kids in the sense that they can kind of mess with this and see results right away. Again, I always kind of like those things where you're getting kind of instantaneous results from it. So yeah, I dug it a lot. Cool. Pillow's one of those libraries that I use a lot and very little of it. What do your tools use? No, I don't mean like from switching to other tools. I mean it's one of those things that it's like this really deep library and I only almost only ever use the surface level stuff. So you're like resizing and cropping and things. Yeah. So particularly when you're doing anything on the web where people are uploading images, you almost always need to create some sort of thumbnail that kind of stuff. Yeah. And there's plugins in Django that help you do this and, you know, they're hitting a Pillow underneath. So it's one of those places where it's like I'm familiar with it, I kind of know what it does and I use whenever I use it, it's like three lines of code and then never do anything else with it. Yeah. The thing that Mike's book, he was trying to sort of head toward at the end is to involve a GUI library and kind of make a rudimentary photo editor. I have existing tools that go way beyond the scope of something like this. So I would think of some of these more coarse, very specific things like you're talking about generating thumbnails, you know, changing the format that it's in, maybe reducing its size or whatever, those are probably common things that you could kind of run through it, but I could see a handful of these other ones like the ability to kind of do sort of basic enhancements to something or again create these sort of filtered effects that you could kind of apply in a regular fashion, a programmatic fashion, or batch processing fashion. I sort of connected to that. You mentioned the whole background removal piece. There's a project that came across that we'll probably be including in PyCoder's in the next issue called RemBG. And it is built on top of Pillow and it's a tool for removing an image's background. So essentially they've taken the code that does that thing that you talk about of bringing the kitten out, yeah, yeah. And you put an image in and it spits the foreground out. The Pillow, again, you know, it's got the basic pieces are definitely there. It's a deep, deep library, but it's also one of the things that there's all sorts of tools out there that folks have built on top of as well. I suspect it's one of the more commonly imported or used libraries. Yeah, I think, yeah, I think it's one of the more commonly based tools that a lot of other tools are built on top of. It's a foundational library. Yeah, I think so too. Mike's book just to reference it is Pillow: Image Processing with Python. And we talked about it quite a bit while he was still sort of finishing the book up. And one of the things I neglected to mention is we talked about the idea of like extracting metadata from that which I think actually maybe even cleansing that would be kind of a nice kind of batch processing tool like as people submit images. A lot of people don't realize that, you know, like your phone and other camera tools like have not only information about like the lens that's being used on it and the resolution and date and so forth, but also location information that could be compromising public information that you don't want to share. So that might be a nice kind of thing you could do with it and Pillow has that ability too. So lots of stuff in that library. It's very powerful. What's your first one? So everybody knows, right? Python's slow. We all know it. Everyone talks about it. It's got to be a fact. So the article that I'm talking about first here is by three researchers at surface, which is a European scientific research institute. And they posed the question, since everybody knows Python is slow, why is everyone in science using it? The article is called \"The Counter-Intuitive Rise of Python in Scientific Computing.\" They start with a comparison with what used to be the dominant scientific programming language, Fortran, and speed-wise, spoiler alert, Fortran wins hands down. There's no question. It's fast. It's a compiled language and Python's an interpreted one. So this is sort of a no-brainer. The interesting point though is that nobody in the scientific community codes in pure Python. So it's a flawed comparison. You're almost always using something like NumPy or scikit-learn or pandas or something like that. And as the scientific stuff's all number crunching, NumPy's one of the more common ones and it has a huge speed difference. So in the tests they ran, they were seeing between a 100 to a thousand times performance improvement between doing it straight in Python versus doing it in NumPy. And they've got a nice little graph that shows Python and NumPy and Fortran and some others and Fortran still beats NumPy. But it's a lot closer than Fortran and Python. Interestingly, Cython, which we talked about a couple episodes back, beat out Fortran by a tiny amount as well. So that part of their argument was you can even just tune this a little more and you can even beat Fortran. And the article could stop there, right? The argument being NumPy gets you close enough performance-wise that the cost of that performance difference might be worth paying in order to code in a more modern language. But the article doesn't stop there. It takes it one step further. So they tell this little story about the adaptation of an internal tool that does a high level of computation in a 3D point cloud. And in the story, their programmer Bob, whose name is in quotations, imports this program from Fortran to Python and NumPy. What Bob discovers after getting things into NumPy is that there are a whole bunch of libraries out there that can do data representation and management that aren't there in Fortran. By using a better algorithm that Bob would never have coded himself, he was able to take advantage of some computational optimizations. And the end result, that thing that took six and a half hours to crunch numbers in Fortran ran in four minutes. Wow. And this is what I like to call the unit test argument. If you've got good unit tests, you're more likely to feel safe to experiment. So the tests will tell you if you broke your codes. You're willing to play around a little more, right? So the same thing kind of goes here. Bob, you can hear the quotations in my voice, would never have attempted to use this KD tree representation in Fortran because he would have had to have coded it himself. And upfront, he wouldn't have known whether or not there would have been a return on investment in that effort. But because it can be plugged into NumPy easily, almost for free, there's this value in going, \"Okay, let's try it.\" And it turns out that there was a huge gain. This is where library compatibility and language flexibility can vastly outweigh a small performance difference in an algorithm. Of course, any article that says it is okay that your language of choice is slow is going to feed my confirmation bias. But my confirmation bias makes me happy. So I like that it was an interesting article. Yeah, that kind of dovetails into my last conversation with Pablo Glenda Salgado. He had",
    "eHjUDsTwVaY": "Welcome to the Real Python Podcast. This is Episode 107. Are you using an object-relational mapper or ORM for your Python projects? What if it could work with SQL or NoSQL databases and be fully type-safe? This week on the show, Robert Craige talks about Prisma Client Python. Prisma Client Python is built on top of Prisma, which was created for TypeScript and Node.js. It uses a schema file to declare your application's data models and relationships in a human-readable form. The schema file allows you to easily switch the database type. Prisma Client is different from other Python ORMs. It's fully type-safe and can be used with or without async.\n\nWe talk about how Robert started the project and the types of hurdles he's completed. He also shares areas of improvement and how to contribute to the project. We also have a conversation with several Real Python core team members about PyCon US 2022, which is happening this upcoming week. We'll have a booth at the conference where we hope you'll come by and connect with us. The team also shares what to expect from PyCon and what they're excited about this year.\n\nThis episode is brought to you by Linear B. Their free Worker B for Pull Request Chrome extension gives your team context about your PRs so that they can pick it up and review it faster.\n\nAlright, let's get started. The Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com.\n\nHey, Robert, welcome to the show.\n\nHi, Christopher.\n\nYou had reached out to talk a little bit about your project, Prisma Client for Python. Have you worked on other open-source projects before?\n\nNot really. I've done quite a few small fixes or features that I've wanted in open-source projects before, but I've not worked on anything like being a maintainer or anything big.\n\nWere you just submitting pull requests and things like that?\n\nYeah, so the last thing I contributed to was Pyright, which is the type checker and language server that powers Python in VS Code. I added support for auto-completing typed keys because that's what Prisma Client Python uses. That's how the queries are structured.\n\nOkay, that's improved the usability so much. That's great.\n\nYeah. So, I guess we could start with what Prisma is itself before we kind of dive into what the Prisma Client for Python is doing. How did you find Prisma and what is it?\n\nI found Prisma in the TypeScript space. I was working on a website in XJS, and I heard about it and thought it sounded really cool. Prisma is a database toolkit designed for type safety to improve developer experience when working with databases. It comes with things like Prisma Migrate, Prisma Studio, and the Prisma Client for TypeScript.\n\nIs it one of the more popular ORMs in that world?\n\nYeah, it's really popular in TypeScript. I think it has 40,000 dependencies on GitHub, so it's really popular.\n\nPeople love it because of the auto-complete it gives you as well.\n\nThat's the best thing I've found about it. It just makes it so easy to use.\n\nIs it considered an ORM or an object-relational mapper?\n\nIt's considered an ORM, or an object-relational mapper, which helps you avoid mistakes that you could be making and makes it generally easier.\n\nEspecially with the type safety, it helps you catch so many mistakes that you would be making if you're just writing raw SQL directly.\n\nAnd those kinds of things can be minor mistakes but could lead to even bigger consequences depending on how you're approaching it.\n\nExactly. So, it's a really small mistake, like if you're selecting a record and then when you test it, that record always exists. But it's not always going to exist, and you might easily forget to write code to handle the case where that doesn't exist. And then your application will just block. And then if you have type safety, you can sort of force to handle that case because your editor will get annoyed at you if you don't.\n\nThe idea of it becoming less of data returned from a query, you're kind of addressing these things as objects, which you know, as the world of Python, everything is an object. So, you're kind of breaking away from having to think at the table and row sort of level.\n\nYeah, that makes it way easier for me. It's just providing an easier abstraction over SQL. That's the main benefit, I think.\n\nAre there other types of problems that Prisma is solving for developers?\n\nI think it's just mainly the developer experience. That's their main goal. They want to make it as easy as possible to use databases, make database migrations, and actually query on your database.\n\nIf you need low-level access to the actual database connection, you shouldn't use Prisma. If you're highly performance-sensitive, then you shouldn't use Prisma either. But I'd also say you shouldn't really be using an ORM if you're that worried about performance because it can be slow sometimes.\n\nThe abstraction adds a layer of performance hit.\n\nPrisma has zero-cost type safety for your database, meaning that the type safety it provides comes at no extra cost for you as a developer to add.\n\nI was going through some of the tutorial and working up the database and so forth, and you create a schema initially. You know that you need to kind of send to set everything up. I found it kind of interesting that the language that the schema file is written in is not quite Python, and it's got kind of an interesting sort of layout to it. They've called it the Prisma Schema Language.\n\nThey've called it the Prisma Schema Language, which I think there are some pretty good advantages to having a different language just for writing the schema because then you can share the same schema between, say, you wanted a TypeScript project and you wanted a Python project, you could share the same schema between both of them so you wouldn't have to rewrite your schema all in the Python models, for example.\n\nIf a project is migrating across languages or potentially you want to practice setting things up, at least the schema files are going to transfer across. All you have to do is add a generator, which is a Prisma-specific, so you can do whatever you want with that schema.\n\nSo, what goes into creating the client? Like, are there lots of hurdles in trying to get that ported over from being, you know, TypeScript specifically to having the client behave in Python?\n\nActually, it wasn't that difficult. I ran into some issues, but they were nothing major. The core of Prisma is written in Rust, so the way it works internally is that Prisma has generated GraphQL API, and that's how queries are sent to their Prisma query engine. It was actually quite easy to support it.\n\nOne of the statements that's there is the idea of a zero-cost type safety for your database. What does that mean?\n\nThat means having the type safety that Prisma provides comes at no extra cost for you as a developer to add. So, if you like, there's nothing you have to do to change in your editor or something to get the type safety that Prisma provides.\n\nI am interested in learning Rust because I haven't worked on really low-level stuff at all, and that is really interesting to me. Also, just the memory safety aspect because I've done a little bit of C, and I did not really enjoy that. That was really confusing.\n\nThat's what I was going to ask you is like, \"Oh, you want to get into memory management, you could dive into C, but it sounds like Rust would be a much nicer abstraction from that.\"\n\nYeah, definitely. The way it works currently, though, is that instead of communicating, Python has built-in C extensions, so you can use that to communicate directly. You can call a Rust function from Python, but that's not how it works right now. Right now, Prisma has pre-built binaries, and then you download them and then run them as a separate process. That's how that works. So you don't need to know any Rust to write your own Python and write your own Prisma client.\n\nIt would definitely help if you sort of understand some of the structures and being able to look at the code from that side of the fence, if you will, of what's being created.\n\nBecause I had to listen to that as well for some obscure error messages and try to figure it all out as well.\n\nOne of the things that I was wondering, you know, anytime you talk to a database, this might be useful, but are there specific areas where something like this would excel?\n\nWell, I think Prisma can be used basically anywhere, especially because there's also the Prisma Data Proxy, which handles all your database connections for you. So that's really useful in serverless environments where you'd be restarting, like Lambdas a lot, and where you're having to manage the database connections inside the code.\n\nIt's a bit more data returned from a query. You're addressing these things as objects, which, you know, as the world of Python, everything is an object, so you're kind of breaking away from having to think at the table and row sort of level.\n\nYeah, yeah, that makes it way easier for me. It's just providing an easier abstraction over SQL. That's the main benefit, I think.\n\nAre there other types of problems that Prisma is solving for developers?\n\nI think it's just mainly the developer experience. That's their main goal. They want to make it as easy as possible to use databases, make database migrations, and actually query on your database.\n\nIf you need low-level access to the actual database connection, like you would if you're using asyncpg, for example, which lets you set lots of different connection parameters and configuration options, because all the connections are handled by Prisma in Rust, that's not exposed to you, and you have no control over the actual database connections.\n\nIf you need to use them, that's when you shouldn't use Prisma. And if you're highly performance-sensitive, then you shouldn't use Prisma either. But I'd also say you shouldn't really be using an ORM if you're that worried about performance because it can be slow sometimes.\n\nThe abstraction adds a layer of performance hit.\n\nDefinitely.\n\nOkay, are there other projects that you're working on currently?\n\nThe other project I've worked on is a Python wrapper for Pyright, because Pyright is written in TypeScript. So, if you wanted to install it and run it locally, you'd have to install Node and install that through npm. But, so I've written a wrapper over that, which will install Node for you if you don't have it and then install Pyright.\n\nNice. I'll definitely share links to that project too.\n\nWell, I have these weekly questions that I like to ask everybody, and the first one is, what's something that you're excited about in the world of Python right now? It could be an event, a book, a project.\n\nThe thing I'm most excited about, which coincides with our brand, is typing in Python because lots of people don't actually use it yet. So, I saw statistics from PyLance, which is the Python extension for VS Code, and only about 1% of their users actually turn on any form of type checking, which is way lower than I thought it would be.\n\nI'm really excited for more people to start using it and learn about it and make better Python applications.\n\nI can understand why people are against it because Python is a dynamic type language, and there's so much stuff you can do that you just can't represent with type hints.\n\nSo, I can understand people are against it, but I think just the usability that you get from your editor is way worth it for me.\n\nIt sounds like from things that Guido has said and other people have said that it will remain a dynamic language, but as it needs to interoperate and communicate with other languages and other packages and the wider programming world, it makes sense to at least make it available and usable.\n\nThat's great, yeah.\n\nSo, what's something that you're interested in learning next, again, it doesn't have to be something Python specific.\n\nI'm interested in learning Rust because I haven't worked on really low-level stuff at all, so that is really interesting to me.\n\nAlso, just the memory safety aspect because I've done a little bit of C and I did not really enjoy that. That was really confusing.\n\nThat's what I was going to ask you is like, \"Oh, you want to get into memory management, you could dive into C, but it sounds like Rust would be a much nicer abstraction from that.\"\n\nYeah, definitely. Because I had to listen to that as well for some",
    "IGfWO3fljNs": "Welcome to the Real Python podcast. This is episode 108. Have you heard about the projects working toward getting Python to run in the browser? Maybe you'd like to try it out for yourself by building an interactive Python REPL with Pyodide in WebAssembly. This week on the show, Christopher Trudeau is here, and he's brought another batch of PyCoder's Weekly articles and projects.\n\nWe talk about a step-by-step project that shows you how to build a Python code editor in the browser using WebAssembly through Pyodide and CodeMirror. You're going to be hearing a lot about Pyodide in the coming months, and here's a chance for you to play around while building a small project.\n\nChristopher shares an article about the power of Python f-strings. It covers some lesser-known features like variable debugging, nesting, and detailed formatting. We also have a couple of topics up for discussion this week. The two are related to finding work as a Python developer. We cover several other articles and projects from the Python community, including the 2038 date problem, a primer about Python virtual environments, how to build a site connectivity checker in Python, a free book on digital signal processing in Python, and a project to build a voice-activated password-protected wooden box.\n\nI just got back from PyCon, and I want to say thank you to all the listeners who came up and said hello at the Real Python booth this year. It was really great to meet you and talk to you. Through PyCon, I met a huge number of potential guests that I'm looking forward to bringing to you over the next several months.\n\nThis episode is brought to you by Sea Data software, the easiest way to connect Python with data. SQL access to more than 250 cloud applications and data sources. Alright, let's get started. [Music]\n\nThe Real Python podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey, Christopher, welcome back to the show.\n\nHey there, glad to hear you. Yeah, we have a handful of interesting articles this week, kind of a big discussion at the end and some more projects, but instead of sort of a news thing, you had a little different thing to start with a tweet that you wanted to bring up.\n\nThis is a pseudo-discussion. It started when at XSS Bunny, which I love the handle, tweeted that they'd attempted to take off the week of January 18, 2038, and their boss denied the request because it broke the vacation system.\n\nSo, if you're not aware, 2038 is one of those magic numbers that, at least as a year, can be problematic in computer systems. The POSIX standard for datetime tracking uses a number that starts counting seconds since January 1, 1970, and a positive number is after January 1st, and a negative number is before. This all comes about due to UNIX being invented in the '70s, and it all seemed good enough then.\n\nIf you're using 32-bit integers to count those seconds, you're gonna overflow that value on January 19, 2038. So, for programmers, this would be a good week to have off, right? So, for those of us who are old enough to have lived through Y2K, this is essentially like that all over again, but this time when the date rolls around, most computers are likely to be 64-bit, which means you're not hopefully going to run into this problem, but smaller systems or embedded systems or older systems might still be 32-bit, and it could be a bit of a challenge.\n\nWe posted about this in PyCoders and included a link to the Wikipedia page that explains what the 2038 bug is, and deep down on that page is another link, which I fell down that rabbit hole, which is a list of other dates that are problematic. There's over 40 of them. Even if you just stick with 2038, there's multiple problems. So, there's UNIX and Windows, we use very similar systems, so they're both could have this challenge. Then the Digital Video Broadcast standard, which is what governs how a lot of satellites and cable transmissions work, it uses a different kind of counter. It's only 16-bit, but by coincidence, it also flips in 2038. So, in April of 2038, that might start having problems. Even not just taking the week off in 2038 might not be good enough. You might need to take the quarter off. Just take the year. Yes, this is my sabbatical. Yes, retire in my version.\n\nFor me, there's issues with 2040, 2042, 2048, 2051. Like it just keeps going, and seconds aren't the only problem. So, 2079 is when a 32-bit day counter will overflow. So, if you're just counting the number of days from 1970, you're gonna run into a problem. And then, some astronomy programs have to worry about things like year counters. We always think of this as being a calendar problem, but if you're trying to model when that asteroid is going to show up in our neck of the woods again, that might be 10,000 years from now, right? So, these are problems depending on the space you're in.\n\nYeah. So, exactly like you've got time before and after this whole span. I'll stop there because it could go on forever, but there's one last thing that I kind of like, which is tongue-in-cheek, which is the year 292 billion problem. And that's when the 64-bit UNIX value will overflow. So, if you were smart enough to move to 64-bit, there's still a problem. It's just quite a ways into the future. The good news is most physicists believe that's probably past the lifetime of the universe. I'm pretty confident I'm not going to be around. So, it's going to be somebody else's problem. Too funny. It's kind of weird. Like I wonder across all systems. You said it was a UNIX standard that they chose the 1970 starting or epoch or whatever.\n\nIt's the UNIX epoch, and because UNIX was the operating system at the time, you know, Windows DOS, all that basically used the exact same mechanism, yeah. There were some of the other dates in the list are mainframe-specific and happen earlier than that. So, yeah, this is, we didn't learn from our mistakes is really what it comes down to.\n\nI was trying to learn how to make movies and stuff on the cheap back in 2007, 2008, and there were these things where like, okay, 48 hours, you have to make a movie, and they would, you'd meet on a Friday night, and they'd give you like a prop and a line of dialogue and so forth, right? And the guy joked, he's like, well, nobody's done a musical before, and it's like, oh, God, a little like writing all this stuff and so forth. But like coming up with music, that's a lot. And so somebody did that one year, and they did Y2K: The Musical. It was all, you know, like six minutes or whatever, but it was, it was pretty funny.\n\nIt's, yeah, I'm pretty sure it was a Simpsons Halloween episode did a segment on it. Oh, yeah, how the world would end in Y2K. So, and I suspect that was in Halloween of 1999. If you're going looking for it.\n\nNice, yeah, those are always good ones. Cool. So, my first article, this is a Real Python one. It's a topic that, oh my gosh, gets mentioned almost every single time somebody starts a project in Python, which is it's titled Python Virtual Environments: A Primer. It was an article on Real Python for a while and then kind of got rewritten from the ground up by previous guest Martin Royce. It's a great just resource. Definitely bookmark it if you have questions about it because it goes across all the kinds of questions you might have about it, why, what are you doing, what's going on behind the scenes, but also just like a primer on how to get started using Python virtual environments. It's been updated, so there are code examples and console examples in Windows and Mac. There's a new thing that they've added on a variety of the Real Python article pages where you can kind of click on a tab and it'll switch to show you what the code looks like either way in Windows or Mac. And it goes into creating virtual environments, activating them, installing packages into them, and then eventually deactivating one. But probably beyond the nuts and bolts that a lot of people are going to go to, I think this is one of the most common questions I got even as a new Python developer in an office job. I was asked very often, you keep talking about virtual environments, like what are they? What are you doing? And so forth. And so, I think it does a good job of explaining kind of what's happening and why you want to do it. And a lot of it has to do as you develop code for Python, there's this need to add additional packages or software. We've talked about packaging a lot on the show, we've talked about pip a lot on the show, and the default behavior for pip is to install into your system Python if you're not specifying those kinds of things. And that can become this whole messy sort of deal where you've installed a whole bunch of different things that you need to kind of maintain or update. And what if you go and you're going to work on a different project and it needs different types of requirements, different types of tools with it, and that's the whole idea is this sort of separation, avoiding sort of system pollution. It really separates the dependencies and the conflicts, but then also helps you with this idea of reproducibility of your projects in that whole like avoiding the well works on my machine kind of thing. So, virtual environments really solve a lot of that, and this article goes very deep into it beyond the why that I just sort of talked about. It talks about, okay, well, you know what is it? It's this sort of folder structure and this isolation of your particular Python install in that sense. And then how does it do that? It gets into like copying the structure and the files and linking back to the standard library, modifying your paths, and then setting things so that you can run it anywhere with this absolute path. And then it gets into some other kind of interesting like little details on the end where, you know, how can you customize a virtual environment to change what the command prompt looks like, overwrite existing environments if you wanted to do that, what if you needed multiple environments, updating core dependency, so a whole bunch of really interesting stuff there. So, I won't belabor the point, but I think it's a great resource if you've kind of scratched your head as to like, well, I kind of know the basic commands as to what's going on here, and they keep showing it to me in every single tutorial or article that I look at that I should be doing this, can maybe help you with a little more of the why and the how and the what is kind of happening behind the scenes, which I really enjoyed that part of it. And then it has a little bit of a stuff on the end where we've talked about this a little bit on the show where we've talked about there are different tools like V-E-N-V, which is built into the standard library in Python, which is great. It is one of the ways to do this, but maybe you want to use different solutions, different tools for this, if you're in the data science world, Conda and the Conda package management and environment manager, those tools kind of like pip in some ways, but it also includes this environment manager, will help you create virtual environments, and that is one of the more popular ways if you're working in data science, and a lot of those packages are kind of grouped and bundled together in ways to kind of work with that, and so that might be the way you look at it too. A handful of other ways of managing multiple environments, and so it touches on a little bit, that gives you like resources to go look at it. One of the things that I thought was interesting about, you know, something that's come up a lot is now that you've created this virtual environment, that gives you this resource where now when you go to install using pip, these are the things that I like to add here, I want to install Flask, or I want to install Django, or I want to install requests or what have you. You know, it's being added into this virtual environment, and you can specify then at the end of that, freeze your requirements and do these other kinds of things. Very often people have said, you know, smartly that you should use this command of Python -m to pip install, and what that's doing is specifying the current Python version that you're using, making sure that it's going there as opposed to installing pip installing it into a system Python or maybe some other virtual environment. And I saw this tweet this morning from Tushar Sadwani. He wrote, \"My current solution is to add this to my bash profile, and he's exporting pip_require_virtual_m equals true, and so pip will reject all commands outside of a v and v. If a virtual environment is activated, pip will always install it in the right place.\" And so somebody else said, \"Well, why isn't this the default?\" And not everybody's using virtual environments, not everything needs it, and so it doesn't necessarily make sense as the default, but this would avoid, if you're in the know and you're using virtual environments, this might be a nice thing to add. So I'll include links to the tweet, which has some more details on it, but it's just a good article to kind of, it's literally a primer on what's going on with virtual environments and where and how and what and all those kind of questions that anybody would ask as far as getting into using them. I hadn't heard about that shell variable before. I that that's a very cool thing. I'm definitely going to go go away and set that, because I make that mistake all the time, particularly because I'm running like four or five different versions of Python. The other thing that it's maybe this is a, you know, it's obvious",
    "3h8xehjFvgw": "Welcome to the Real Python Podcast. This is Episode 109. Did you know you can add testing to your Python code while simultaneously documenting it using docstrings? You can create examples of how your functions should interact in a Python REPL and test them with the built-in doctest module. This week on the show, Christopher Trudeau is here bringing another batch of PyCoder's Weekly articles and projects. Christopher shares an article by previous guest Mike Driscoll about testing with doctest. This is a great way to get started with testing your own code and it offers the added benefit of documenting functionality. \n\nWe talk about a recent Real Python article titled \"Pagination for a User-Friendly Django App\". Spreading your content across multiple pages can significantly improve the user experience of your web application. This article takes you through configuring Django's built-in pagination tool and how to combine it with other web tools. \n\nWe discuss a recent article about Python type hints and the author's disappointment with them. We also include reactions from a couple of online communities to the article. \n\nWe cover several other articles and projects from the Python community, including why it's important to close files in Python, how dunder methods are awesome, a bidirectional Python dictionary, prettier get diffs, and a command-line game to learn Git. \n\nMailtrap is an online tool for email testing in dev and staging environments. Assess the deliverability of an email without sending it to real people. No dummy email accounts needed. \n\nAll right, let's get started. The Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com. \n\nHey, Christopher, welcome back.\n\nHey there, how you doing?\n\nGood, good. So I hear you're just back from PyCon US. How did you enjoy it?\n\nIt was really awesome meeting the Real Python team in person. I know a lot of people say that, but it was really fun. These are people I've been working with for just over three years. And then a few are a little newer, but that was really fun. And then to have people come up to me at the booth and say they've heard the show and are fans was really cool. Somebody actually wanted to get a picture with me, which is awesome. \n\nOh, you're internet-famous.\n\nI guess, yeah, the second best kind. \n\nYeah, I think so. Yeah, and probably the funniest thing was that I sounded different because I wasn't at one and a half times speed.\n\nI know that people probably listened to the show sped up a little bit. I speak fairly fast. They said, \"Yeah, everybody else signs into 2x.\" I was like, \"Okay, so I have that going for me.\" \n\nYeah, well, I know all about that. I review my courses myself and listen to them at 1.6x. And when I go back into the editor and I'm like, \"Wow, I'm slow,\" and most people would not accuse me of being a slow talker. \n\nYeah, so that was really neat. And then as I mentioned briefly on the last episode in my intro, I met a real large group of people that I'm going to have as guests. I'm just really excited. I'm actually sending out the invitations today to try to start lining them all up. They're all kind of across the whole spectrum of Python, from data science to environmental science kind of stuff to other teachers, people that work on VS Code, all these different organizations. And it's fun. I'm excited because sometimes there were times where I couldn't get enough guests on the show and be like reaching out to try to find some people who want to be on. And now I have like a nice big backlog, which I'm excited to share with everybody coming up soon. \n\nAnd lots of talks to talk about coming up. I hope they get on YouTube soon. Did you have a favorite? I got to see the beginning of Wukas's keynote. Wukas Lang, the developer in residence. And he was talking about types, which we're going to have as part of our discussion today. \n\nYes, and I'm looking forward to it. I didn't get to see all of it. I got to see the beginning of it. So we were taking shifts at the booth, kind of going back and forth. So I was in and out of a handful of them. They didn't quite align time-wise on the hour, which is not uncommon, I guess, for a conference. But I really enjoyed what he was talking about. He's very, very passionate about type checking and kind of helping to shepherd forward a lot of these PEPs that we've been talking about off and on for a while now. \n\nThat was really interesting. I got to see again about half of the introduction of PyScript, which was with Peter Wang, who's from Anaconda. And he's agreed to come on the show, so I'm going to get that scheduled soon. A lot of people are very excited about that. And I'm hoping maybe I can get Russell Keith-McGee back on who worked on Beware. I believe he's still working on that project, but he is now actually working on PyScript also, which is kind of building on our conversation last week. It's on top of PyO3. So there was a lot of Python inside of web browser kind of talk and interesting stuff there. There's been a lot of buzz about it. Yeah, and you know, it's really early days so that it's going to need a lot of work on it. \n\nKind of the most excited I've seen people being in quite a while in the Python space about this stuff and getting a group like Anaconda behind it is great because they have all these kind of connections with trying to get the libraries that data science world all uses and financial world and so forth use behind the scenes to get that working in it too is great. \n\nSo yeah, a lot of the keynotes and then there was a Sean and Kelly, Sean T. Bohr and Kelly Shucha Paredes who do the Teaching Python podcast. We got to hang out a little bit which was really fun, but they hosted the Education Summit, which unfortunately I don't think is videoed and going to be online. But there was a lot of really neat talks in that and I enjoyed that quite a bit. They talked about a subject where the assumption that a lot of people have to get kids interested in programming is, \"Oh, everybody loves games.\" And it's like, \"Well, actually no, not everybody does.\" Right? And so like using that as your foundation for teaching is maybe kind of a misstep, which brings up a previous conversation I had with Alex Weigard, which is somebody else I got to see and hang out with. So that was really fun. And he's got an upcoming book about recursion that we're probably going to have him talk on the show. So yeah, it was really cool. Talked to Pablo again, Pablo Galindo Sagado about MemRay. He'd like to come on and talk about that memory profiler. Also something that's getting a lot of buzz. \n\nYeah, it was just really cool. You know, I don't get really starstruck, but I was just excited to put names to well, you know, when you're already internet famous yourself, you're just repping with the other internet famous people. That's the way it's supposed to work. \n\nYeah, I lost my voice though trying to speak through my mask to everybody. So, but yeah, it was very cool. I enjoyed it quite a bit. We don't really have so much news per se, but we do have several topics and a discussion this week and of course our projects. I was wondering, you want to start first? \n\nSure, I'm going to start out with one of the Real Python articles. This one's by Ian Curry and it's called \"Why is it important to close files in Python?\" It's actually more of a computer science article with Python examples than a capital P Python article. And that's okay. Not that that's a bad thing, it's just talking about things like file handles and resource usage, and this is universal to pretty much all coding languages. So, you know, even if you're not a Python person, there's some value here. Most of the examples of opening a file to read or write in Python usually use a context manager. And that's kind of best practice. So that's usually what you see. If you're not familiar with that term, a context manager is a block of code that starts with that with statement. Everything indented under the with statement is in a context, and behind the scenes you can run pre and post conditions. So when you use the open function with that with block, what happens is there's a post condition that closes the file for you. So that's a thing of beauty that means you don't have to remember to close the file yourself. You don't have to manage it yourself. So without a context manager, you've got to actually call close on a file handle manually. And this can get more complicated than it sounds because the wrong exception might mean that you would skip over the place where you called close and it would sit there open. File management is one of those places where you tend to get a few more exceptions because you're hitting the operating system and you know something might be wrong with the file. So best practice before the with block was to use a try accept block with a final statement and then have the close inside of the finally. But if you're coding in Python, the answer is use a with statement. There's really no excuse. It's been around since PEP 343, which was 2005, and Python 2.5. So we don't even have a two versus three thing here. Just do it that way. Yeah, that's a lot of talking and I still haven't actually addressed the article's question, which is why file handles are controlled by the operating system, like memory or use of the CPU or what processes you can see. These are all things the operating system is responsible for. I'm going to keep using the phrase file handle because I grew up in the Unix world. If you're on the Windows side, you may see it called a file descriptor. It's more or less the same thing. Okay, so file handle is actually underneath, it's just a number and the operating system uses it to map to a particular file that you're interacting with. So you can see the actual number in Python by calling fileno. That's no as in short for number as a method on your actual file handle. So I'm actually in the process of writing a course for Python's map module and it actually uses these file numbers instead of the file handles. So there are lower level operating system kind of calls where you'll see this kind of stuff. The handles themselves are limited by the operating system. This is usually done for safety purposes. If a single process is opening an enormous number of files, something's probably gone wrong. So the operating system usually restricts this. It varies from operating system to operating system as to what the restriction is, but the numbers typically somewhere in the thousands. Each file you have open at a time is also in a risky sort of state. If your code crashes, it's possible that the file will get corrupted and both your OS and Python try their best to stop that. But sometimes stuff just happens. So when I was in school, I worked part-time in the engineering department support center and people would come in for account resets and general issues and that kind of stuff. And one day, a PhD student came in to me with a corrupted Word file. It was his only copy of his thesis. And I wasn't able to recover the whole thing, but I was able to pull the text out of it and he was very, very grateful. Okay, just have to reformat it now. Yeah, he kept smiling at me even while I was lecturing him about backups. He was just, \"Yes, yes, thank you. You can talk to me however you want now. Now I'll go put my diagrams back in my document.\" Anyways, where was I? So file handle limits. If your process tries to open too many files, Python will raise an OS error exception. And the article shows you a little code snippet and a REPL opening 10,000 files for writing in a tight loop that does that. You can see it actually happen and play with it. And one of the things to keep in mind is in many operating systems, everything is a file. File handles are used to abstract socket connections, shared memory, inter-process communication, and other stuff. So although thousands of file handles sounds like a lot, if you're writing a web server, you might actually run into these kinds of limits and have to deal with them. The article's got a nice little collapsed aside that talks about LSOF on Unix and a similar tool on Windows called Process Hacker. Both of these tools allow you to see information about the file handles in the system. I've used LSOF a lot, particularly to get information about open sockets in a system. So again, because Unix treats everything as a file, listing the file handles shows you a lot of information. And then finally, the article shows you how to actually crash your program so you can see the results of an open file. File writes actually happen in chunks, so one possibility is that you thought you wrote something, hasn't actually been written yet. The write buffer gets flushed automatically when you close a file, so if you haven't closed it and you haven't called flush, you might miss some data. For example, there are other consequences as well. In Windows, only one process can own a lock on a file at a time. So crashed programs can sometimes leave the file locked, making it impossible for another program to open it. There are also potential security risks if I've dropped a file handle because the program's crashed and another file goes and tries to grab that and is able to pick it up. It can inherit the security privileges on that file, which allows you to act as somebody else, and that can get messy. So there's not a lot of Python in the article, but there's plenty to learn. Beyond the simple use of a context manager, there's some good depth on how your code interacts with your",
    "Qsx6YbNGhBM": "Welcome to the Real Python Podcast. This is Episode 110. Would you like a way to send structured data between different platforms and languages? What if the data was self-documenting, could automatically generate Python code, and validate itself? This week on the show, Liran Jaimovic talks about Protocol Buffers and communicating with microservices through remote procedure calls. Protocol Buffers, aka Protobuf, are a language-neutral, platform-neutral system for serializing structured data. Liran talks about how they go beyond text-based protocols like JSON, providing benefits along with faster transmissions and a smaller footprint. Liran shares how his company uses Protobuf to communicate between their tools.\n\nWe also discuss using gRPC to communicate between microservices and scaling infrastructure in either direction. If you're listening to the show on a platform that doesn't include the show notes, links, chapters, and more, remember you can find all that good stuff at realpython.com/podcast.\n\nAlright, let's get started. The Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey, Liran, welcome to the show.\n\nHey, Christopher, it's a pleasure being here. We kind of gone back and forth a little bit via email, and I got very excited when you mentioned that you wanted to talk about the upcoming talk that you're, well, upcoming because we're recording this in the future, for your PyCon US 2022 about Protobuf and gRPC. We're recording this before you do your talk, which will be next week, and then this will come out a little bit after that. So, again, we're doing time traveling, which is always fun.\n\nYeah, so this talk is going to be taking place in actually 10 days from now, but it's probably going to be three weeks in the past or so by the time you hear this episode. I'm hoping it's going to be as fun as the last time I was at PyCon, actually almost three years ago now. Okay, it was one of my first conference talks. It was super fun, also one of the busiest. There were about 700 people back then, which I know today, in COVID times, thinking of 700 people in the same room is shocking all by itself.\n\nYeah, it's going to be quite the culture shock. Everyone I work with, I mentioned this on an upcoming episode too, that I'm going to meet all these people in person for the first time that I've been working with for like two to three years, so that's going to be fun.\n\nYeah, I know for me, conferences have been missing, and actually I got to be at a few conferences over the past few months, and it's been a blast. Oh, good. I know being in the city of startup and meeting our customers, meeting new potential customers, people who are psyched about our technologies, and getting their feedback and learning from them, talking at conferences, all of that is super fun, super cool, reflects a huge part of my job, and that was very missing for me for a long time during COVID times. Did the reality meet your expectations of getting back into it?\n\nDefinitely. Whether it's about meeting the people, whether it's about seeing what new vendors are offering, keeping track of the community, or just reconnecting with people you know, it's, I actually, back then, before three years ago, I was traveling a lot. I traveled, I don't know, maybe six, seven, eight times a year, and I got to make a few friends, especially in the Bay Area and other places where I got to often, yeah. And all of a sudden, I was disconnected from them. Now, even beside me, one of our solution engineers had family in New Zealand. She hasn't seen them in almost two years. Actually, she just went back to them a couple of weeks ago. Yeah, so it's the world's gotten, we used to think of it so small, gotten crazy big.\n\nSo let's talk some technology, I guess. Well, what did you talk about last time you were at PyCon?\n\nLast time I was at PyCon, I talked about debugging Python applications, about how are the internals of Python debugging are built. If you might be familiar with the sys.saturates function, you're probably not. It's probably the single most complicated function within the Python standard library. So I talked about that, I talked about how to use it, what's its performance, spoiler, it's not very good, and what can you do about it, how can you further improve it, what can you do if you're stuck with it? I kind of, a lot of the research I've done about four or five years ago as I was founding Rookout and trying to build tools that allow you to debug in production in real time.\n\nCool. Well, I'll definitely include a link to it and people can kind of look into that a little bit further. I wanted to, before we started to get into the talk that you're going to do, you do a podcast right now yourself, right?\n\nYeah, I have a podcast that I started about nine months ago. It's called the Production-First Mindset. We focus on all the culture, technology, the tools, the processes, everything that you have to take into account and you think that your code, you know, when you write a code, it's not just about what's happening on your laptop, it's not about what's happening in the lab early on, it might be, but you know, once software becomes commercial, once you're really building apps, then it's all about how do your apps run in production? How do they serve your customers? How do they interact with people? And how do you deliver those applications? How do you monitor those applications? How do you secure them as they are running in the real world? So the podcast is called a Production-First Mindset, and that's what we focus on. And I interview different guests every time, kind of try to give a different perspective. It can be about cloud, it can be about machine learning, it can be about security, anything at all, depending on whatever the guest is an expert on.\n\nCool. That sounds fun. So this upcoming talk that you have is about Protobuf, and Real Python had an article in 2021, and we talked about it briefly on the show. It was titled \"Python Microservices with gRPC\" by Dan Hippman. David was talking about the article, and so I kind of learned a little bit about Protobuf there, and then a little bit about gRPC. But maybe we should start with the kind of the background. I had thought that it was a fairly new concept, and then I went and looked at the documentation, but it looks like Google's been doing stuff with this since like 2001.\n\nYeah, I find that kind of really interesting. So maybe we could start there, or where would you like to start?\n\nSo I've actually been a serialization convert, so to speak, for the past, I don't know, over a decade, maybe 12, 14 years. And that's because serialization is such a huge part of everything we do in software engineering. Think about it. When you write code, I mean variables are at the core of everything we do. The state of the application, you can't get very far. I mean, maybe you've written \"print hello world,\" but that's as far as you're gonna get without variables. Now, once those variables have to cross space and time, whether it's making a network call, whether it's being stored in a database for future use, or anything else at all, you have to find some way to transform those variables into a stream of bytes, an array of, so to speak, and then send it somewhere. And then when it goes around, you have to, all of a sudden, take that stream of bytes and read it. And there's so many complexities will go into it. On the one, it's the magic that enables modern applications to happen, whether it's about again databases, networking, service meshes, anything, requires civilization. But there are tons of difficulties, ton of challenges. And so I've been a fan of that. I've actually written a few protocol officializations from us myself. And when I founded Rookout, we pretty quickly settled on a protobuf. And we've actually, I think we've become some pretty advanced use cases for that in both gRPC and protobuf. So kind of taking this opportunity to show the community some of what I've learned, some of the basics on the one hand, as well as some of the more advanced fancy stuff on the other hand, which is definitely useful when you're in a bind and trying to squeeze every bit of performance out of it.\n\nWhat kind of languages were you working in to create your, were you working on like libraries and things like that?\n\nSo I was actually working on an agent written in C++ okay. And we required some pretty fancy serialization stuff. It was a remotely controlled agent. So we wanted to serialize the commands and the inputs and outputs of that agent as it were transferred. And we wanted to make it very agile and sort of abstract away the transport layer from the command layer. Okay. So we had a whole bunch of interesting requirements for civilization. And we ended up kind of writing our own, which I think was definitely justified at the time. We got to do some pretty expensive stuff. I also got to use some of the most advanced features in C++ templates nobody ever knows about, which is probably not for our listeners right now. But if you want to do crazy stuff with C++ templates, definitely hook me up. And I'll share with you. But yeah, I mean, when you're serializing, especially if you're trying to make it easy, kind of integrating your code, your variables and making it easy to move from the state in memory of the variables to the serialization and move back again, there is a lot of syntactic sugar about how easy it is, and you can very easily end up writing tons of boilerplate code just converting between the two of them. That's actually one of the things I like the most about protobuf. It's been around, as you mentioned, for almost 20 years. It's supported in pretty much every language out there. We at Rookout use it for our agents for Golang, Ruby, Python, .NET, JVM, and Node. Or I think 36 agents. And so we use it for all of them, use it interchangeably, and it's super easy for all of them. So that's actually a big rule for that. And it's not just about supporting those runtimes, it's about supporting them in an idiomatic and easy to use manner.\n\nThe idea of it being a standard that can move across these different languages is one of the big benefits that you see of it. It's kind of interesting thing behind it, in the sense that you are mapping out what you're going to serialize in some ways in that you have to kind of make a bit of a definition of what you're sending and receiving is. Is that right?\n\nYeah, I think that takes us kind of to the topic of static versus dynamic typing. Okay, and I know early on in computer sciences, everything was about static typing, and that was because in a way computers were dumb or not so much as dumb as they liked. They lacked computing power. And so we had to literally spell everything out for the computer because it didn't have the mental capacity or the compute power to figure it out for themselves. Then in the 90s came runtimes languages such as Python and JavaScript that used the fact that computers were of a sudden more powerful to use dynamic typing to spur you me the listeners, all the humans here, yeah, the effort of declaring what we want to do because the computers no longer needed that. I think the trend we've seen over the past decade or so and that actually has come to Python as well, is that all of a sudden we're seeing people using types again. I mean, even Python is typing or an optional typing system now. And part of the reason for that is that types today are not used so much to help humans communicate with machines. It's more about having humans communicate with other humans. And in that regard, the data we provide the compiler, the data we provide the interpreter, the typing data is, it's not meant to make it easier for the machine. The purpose is to allow the machine to provide feedback to our either future self or our colleagues as they are working with the code or format we've created to make better choices and to more easily understand what's going on. Now one of the benefits of protobuf or one of the attributes of protobuf, if you don't consider it the benefit, is that it is indeed statically typed rather than dynamically typed. And I think that's actually a fairly common attribute for most binary serializers. If you're using a text-based serializer such as JSON, then it's much easier to go down the dynamic route. Well, if you're working with a binary serializer where performance tends to be of a higher priority, then you would most often see a static typing coming as part of the bargain to allow you to get better performance out of it. And some of that has to do with, if you can sort of define what things are going to be, you can kind of set aside the amount of space or memory or what have you for each of those kinds of materials and then also potentially reduce the size of them in some ways when you can be able to convert it into binary. Is that right?\n\nYeah, it's even more important, I would say, because if you don't specify your schema ahead of time, if you don't provide a type data, then the format is going to have to ex to contain that as metadata. Yeah, okay, so in session you're creating tons of metadata and often in dynamic typing, that metadata becomes at the field level. So let's say you have a serialization tree that contains, it's a big tree, it contains a million attributes, a million pieces of information tied together into one data set. Now, if you're using dynamic typing, chances are you're going to have to add some level of type data to each and every one of those attributes, to each one of those millions. You're probably going to have to add both a name and a type for each of them. And that information can be even more expensive in terms of, especially in terms of size, in terms of size of the message than the actual data you're trying to transfer. Well, if you've created static typing and the machine already knows what goes where, what's the type, what's the value, name for each of those fields, then it's much, much cheaper to encode them in a space and a time efficient manner, in space and a time efficient manner. That's funny the information about the information takes up more space, but that is the case. Definitely. I think the biggest benefit for using binary serializers is the message size. Now, often you don't care, and if you don't care about the message size, then you're, there's a good chance you would be better off using a text-based serializer such as JSON. You obviously can use XML as a binary serializer, but you probably won't be better off if you use XML for any reason at all. Please don't do that. I'm kind of joking, but yeah, XML is a bit outdated. I understand. Yeah. I had to work with a bunch of XML in, I worked at a bank, and so we were trying to communicate with lots of other banking and financial systems, and you would go through reams of paper of XML like definitions and try to figure out what's going on. It was, you know, yes, potentially it was human readable, but not, not exactly. Yeah. If you think about what I've mentioned about, you know, the having more metadata than actual information, XML is the perfect example of that. You have so much metadata, way beyond what you're actually trying to transform. JSON is much better. It's being human readable. It's pretty much a global standard. You can find great libraries in For Any runtime. It's truly human readable. It's performant, but still you're going to probably find that the message sizes for JSON are pretty large. And you can easily get significant size benefits if you use a binary serializer. Obviously, there are other options, compression and other stuff, but that goes into a longer story, but you can definitely get significant performance both in size and processing time benefits by using a binary serializer, making things much, much faster. And besides the way I think if you build out a format one that's destined to live for a long time, hopefully then you are probably better off going with a static serializer, something that's going to hold metadata about what's, about how the data is supposed to be read and written. So it's going to be easier to maintain that, it's going to be easier to adapt that, it's going to be easier to read very old messages because you know how they are written and why.\n\nYeah, so definitely recommend that. And kind of going to the end of the conversation for a quick preview, if we talk about gRPC, which is an RPC remote procedure call based on Protobuf, then here you are actually building contracts, you're building APIs, and it makes perfect sense that when you're building APIs that are supposed to be consumed by other services, you declare them in a static manner because it's much easier to version them, it's much easier to understand them, and you can think of it more as part of the documentation itself rather than just telling the machine what to expect. Yeah, that's kind of the thing that I'm seeing across the Python community over the last couple of years at least. I've been doing the show, you're right, there is this sort of parade of PEPs about typing and adding it, and in a lot of ways it can be acting as a form of documentation to kind of see what's going on, but also just like you said, it's this ability to like communicate across these boundaries between languages and machines, and that's what I kind of find fascinating about this idea that JSON is ubiquitous in some ways for doing API calls and lots of these other types of web communications, but I could see how something like this is going to give some additional benefits. I think that the hard part might be just like wrapping your head around it and seeing having those benefits spelled out to you because it almost seems like there's like a bit of a little extra step in the setup, but once you've done it, not only does it document itself, but it also has all these other kind of benefits of being a little more easy to move from language to language.\n\nYeah, it's all about how long do you expect the piece of code you're writing or the piece of data you're building",
    "WpEKiPhcoO0": "Welcome to the Real Python Podcast. This is episode 111. What are the differences between the various Python game frameworks? Would it help to see a couple of game examples across several libraries to understand the distinctions? This week on the show, Christopher Trudeau is here bringing another batch of PyCoders Weekly articles and projects. We discussed a Real Python article by previous guest John Fincher titled \"Top Python Game Engines.\" John compares five different game frameworks and provides thoroughly commented example projects for each. We talk about a blog post by recent guest Adam Johnson about determining if a project is well maintained. He suggests 12 questions to decide whether to add a new dependency to your project. We cover several other articles and projects from the Python community, including a news roundup, Python decorator patterns, finding the smallest and largest values with min and max, a discussion about the most used Python packages, the Pony Object Relational Mapper, and a project to read PEPs in your console. This episode is brought to you by CData Software, the easiest way to connect Python with data. SQL access to more than 250 cloud applications and data sources. All right, let's get started.\n[Music]\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com. Hey Christopher, welcome back.\nHi there. We're back doing a little bit of news this week. The first story I have is about the release of the first beta for Python 3.11. So that includes a feature freeze, and there are going to be four planned beta release previews before the actual release of Python 3.11 in October. The main reason I'm mentioning it is that it's really strongly encouraged to test your code with 3.11 during this beta phase and report issues found to the Python bug tracker just to make sure everything's working and looking good. There are a whole bunch of PEPs that we've talked about already. I'm not going to re-list them, but I have a link to the article that includes about 9 or 10 of them. And then there's actually kind of a cool little update about the faster CPython project and how it's already giving some exciting results. I have two links connected there, one for the faster CPython project with a whole list in order of the different packages and how much faster they're going. So your results may vary depending on what you do and what libraries are being used. But it shows a speed up of all but two of them. And the only two that are slightly slower, it's a very small amount of slowdown for these couple. And everything else is sped up quite a bit. And I think the overall was something around an average of 1.2x 1.22x on the standard benchmark. So looking good for a first bump up, potentially 10 to 60 times faster than Python 3.10.\nIf you're not following along on the releases, this is a good way to catch yourself up, see what's going on. And then last year I had Joanna Jablonski on and we talked about the Python Language Summit. Well, that did occur again at PyCon and this year Alex Waygood was the reporter writing up all the different things that happened. And he has one of the more interesting things that has been news is this project by Sam Gross which is called No Gill. That conversation kind of continued, he's been working on it a lot more. He has offered some potential changes in his initial proposal like ways that they could approach doing a sort of a No Gill version of Python. He's still working on Python 3.9, and I think he is currently it's on like 3.9.10. And I think the idea behind that is to make sure it works across a really large amount of the different software that's out there running Python. And his new idea is to maybe instead of having a runtime flag, to have a compiler flag that can reduce the risk inherent in the proposal. In his quote, as you have more of a way to back out, additionally using a compiler flag avoids thorny issues concerning preservation of C ABI stability. Sorry if you're interested in kind of following along with those couple projects, a little bit of news happening there not only with the release, but progress with faster CPython and the project happening there. And there was an announcement at PyCon from the team working on faster CPython and they really would like you to run your code and let them know if you're seeing, you know, results one way or the other. They just need more people to run and check this stuff out. So the faster CPython is project, I'll have a link for that too. They keep developing things onward beyond this feature freeze that is for 3.11. And so as they continue to do that, they would love to have people try out other stuff with it. What were the couple news things that you had?\nOh, there's three little items here. The first of which is on the same kind of topic of performance improvements, and that's PEP 690. And it proposes lazy imports. So right now when you start up your Python script, it imports everything, so every import that you have runs all the imports that it has. And you know it's turtles all the way down, it just keeps importing everything. Yeah, and as the proposal's name implies, the idea is to allow for the interpreter to wait until the imports being used before importing it. So the first reference to a function or a module would actually trigger the underlying import. So this would only be for top-level imports, so if you put those things that are at the top of the files, so if you do something inside of a class or a function, it would trigger immediately. And the feature would be off by default and enabled by a dash L flag or an environment variable if it's implemented. They suspect it could do a lot for startup speed of more complicated programs because you just, you wouldn't be paying an import tax on every module in the program, just the immediate script. Nice, that sounds cool. I could see how depending on the different functions and things that you're approaching with your code that maybe only a little area, you know that's maybe not often used, uses a particular module. Like okay, now we're going to do PDF output export or something like that. Yeah, and quite frankly, like when they start, you know, it's great that they're speeding it up, don't get me wrong. I love that they're speeding up Python because it's one of Python's bad reputations. It's slow, right, but the one that I find impacts me the most is really the startup time, okay, because I'm not and I think it's common, I'm not doing a lot of really complicated things in Python. The expense isn't, you know, once the program's running, I have no problem, it just runs because it's not a lot of throughput and a lot of the work I'm doing. But the sitting there watching it think about doing something as it starts up is there's a little stab in the ribs every time you run something. So if they can do something about that, that'd be great. Yeah, that sounds like a great proposal.\nThe other two pieces are a couple of conferences, Django conferences, one for the US and the other for Europe. So DjangoCon Europe this year is in Porto, which is Portugal's second-largest city. The event is September 21st to the 25th. The deadline for proposals is soon, it's May 31st. So if you're listening to this on the day the podcast is released, you've still got a couple of days to get something in there. DjangoCon US is in San Diego, California this year and runs from October 16th to the 21st. The call for proposals is on now. Their site's a little vague about the deadline but they are offering travel grants for some presenters and those grant proposals are due by June 10th. So I'm assuming the general call for papers is around that time as well. Those both sound like fantastic places to come visit. San Diego's beautiful and Portugal's on the bucket list so yeah it might be a good thing. Awesome, yeah the guys from DjangoCon Europe were on the show a little while ago and it's nice that they were able to keep it there and open everything goes smoothly toward an in-person conference for them this time. That takes us into articles. My first one is a Real Python one. It's by John Fincher. He was the second guest on the program and we were talking about games and so hey, guess what this one's about games. And it's an article he's been working on for quite a while. It's called \"Top Python Game Engines.\" He took it upon himself to do a real survey across the landscape of sort of Python game engines and tools. And the whole goal of the article is to help you understand the pros and cons of several of these things and get an idea of what they look like. And he provides two examples for every single one of these tools. The first one is a super simple example and both have really great documentation that you could almost kind of use as a template. Like here is where you put this and here is where you should think about this and so forth. And these programs are not really long, except for it's probably about half documentation. So something to think about there. And the simple example, you are basically creating like a window creating a few graphical elements like a square and a couple of other items in there, sort of individual sprites if you're familiar with the term. And then text also setting up a loop, displaying the graphics, and then also having a way to quit. So real simple, but again fundamental stuff you need to know in each one of these engines and know what that sort of if you will boilerplate kind of looks like. Then he makes a more complete game, it's still a simple game. It does have controller input which is a nice ad which you need to understand. In this case, he's using a mouse and you could use other things, modify it to be keyboard or whatever. So it's again a good jumping-off point. He starts with Pygame, which is what Christopher and I have both done courses on. I did kind of a very basic course but going really deep into the fundamentals of Pygame that you can check out and I might include one or two of them as the video course spotlight this week. And then you did one on Asteroids that was by Pavel Furtek that you were able to take and turn into a video. And so I don't want to spend too much time on that. It's probably the library we've talked about the most. It's the one that's been around the longest. In my opinion, one nice thing about it is it really has stabilized, at least for me, over the last two years. When version 2 was sort of coming out, it was a little buggy, especially on the Mac platform. And now with version 2.12, which is the version that he sort of pinned here, it's working great. It's even working great on my new laptop which is using M1 PiGame.\nWhat's, sorry to say about it, it's been around a long time. It's a very good library for doing this sort of stuff. There's lots of examples. I mentioned that book a couple of episodes ago, Pygame 4000. That's a nice additional resource there. And again, the whole goal of the article is to see the engines in action, see the code, understand and compare what it's like to write in each one of these, and then learn about, you know, just what's available in them. And why should you write a game in Python versus writing it in something like Unity and Unreal or some of these other like dedicated engines. And what it comes down to is that you know you probably like writing Python that's why you're listening to the show and this is an opportunity for you to kind of explore that in games. And there's no reason that you couldn't jump off into some of these other engines, but they're kind of slightly different focus and in a lot of ways you're abstracting even more of the programming away. And that's something else I want to get into as we go is like there's these sort of abstraction layers that you can kind of build up. The second engine that he talks about is called Pygame Zero, which is based on Pygame but it is designed to kind of simplify a lot of things. You are not having to create a game loop, which is nice. It's already there, it already has an event model to handle drawing, updating, input handling. There's standardized or uniformed image and text sound handling so it kind of helps to structure a little bit more of that stuff than what Pygame comes with by default. And so it reduces the code almost like, I don't know 30%, in a lot of cases. Designed more towards education and sort of accessibility and kind of geared a little more toward beginning programmers where you can kind of focus a little more about game design and some of the fundamentals of programming in it. I've used it, it runs really similar to Pygame in a lot of ways. I've seen a couple of different sort of gaming sites where the examples where they might take like classic arcade games and they seem to prefer to use Pygame Zero for their examples because of I think some of the reasons I mentioned there that it sort of abstracts a lot of the other stuff and you can kind of focus on more about the design of the game and programming that part. The next one that he gets into is Arcade, which he actually did a really great article and tutorial sort of step-by-step project on how to make a platform game in Arcade. Arcade is by primarily Professor Paul Craven, somebody I may try to get on the show to talk more about game stuff. Arcade is more modern, it supports OpenGL, it has type hinting, it has frame-based animation, has its own built-in physics engine for doing things like shoot-'em-ups and other like platform kind of dynamics that you'd want where you don't have to program all that stuff in or potentially import one in. It's got a lot better documentation as far as like it's all sort of gathered together and includes tutorials in it and then has a little more consistency in the naming of commands and functions and parameter names and things like that so it's nice to really compare all these things like I said between these three sort of primary, if you will, video game engines. And then he wraps it up talking about two kind of other potential directions you could go with the game and they're both kind of geared around adventure games. The first one is literally called Adventure Lib and you're building a text adventure, um, sort of interactive fiction if you've ever heard of Zork or, gosh, I'm trying to think some names, the other ones, the original Colossal Cave and some of these other things where you would be presented with, you know, a pop-up saying you're here in a cave and exits are to the north and east and the west. Hitchhiker's Guide to the Galaxy on the Commodore Vic-20, I believe. I'm dating myself. Yeah, yeah, no, I played some of these games myself and I'd gone to the back of magazines and typed them in. I think I talked about that with Al Swaggart. And what's nice is Adventure Lib is helping you structure all that sort of stuff, like it has elements already built into the concept of a room, the concept of possessions, and the concept of a parser and so forth. And so that's kind of nice that could be sometimes the hard part if you are just wanting to create a game and it's not that you couldn't abstract even or do even more advanced things with Python on top of it. So, um, in this case he's made two little adventure games. Um, one again very simple and the next one a lot more advanced in the sense that there's a lot more kind of going on and like lots of steps that you have to kind of follow to accomplish it. You have to meet a couple people and have them help you through the course of the text adventure. And then the other one is called Ren'Py, which I don't know if we've talked about it, but it's built on top of Pygame. There's sort of this style of a visual novel that that's kind of another genre of video games that's out there where it's presented as like kind of graphical, almost like a text adventure with like sort of slides and not really animated graphics, but like flipping between different things, you know, characters appear on the screen. And it's very interesting. And what's different about Ren'Py, even though it's built on top of Pygame, it is really more of a full- like you have to download a software development kit, an SDK for the thing, and then it has its own little special launcher for it. So it's a lot more structured, in my opinion, a lot of the games look and feel the same, and maybe that's good or bad depending on what you're trying to do. They definitely have a structure to them, and you're actually kind of more like writing a movie that's interactive. It actually has a script, that's one of the names of the files, and in it, your character says this, and the name of the character does this and so forth, and you're really scripting out everything else. So I think it might be really cool if you're interested in wanting to write sort of game design stuff. I don't know how much Python you'll learn in it; you'll definitely be learning Ren'Py, so anyway, but it's interesting and then it includes branching and decisions and hence it's, you know, similar to the Adventure Lib with graphics and stuff on top of it. So he built the same sort of game in it and all the games are there, you can get them all from the repo and try them out with the graphics and the sound and everything ready to go. You create a virtual environment and install your requirements, you know, pip install that stuff except for Ren'Py, which you will need to, and he has links for it, download a special SDK and so forth to kind of get into it. And then he talks a little bit more about general stuff about game engines, several other ones that he mentioned before on the show, that these are other potential options, there's some 3D stuff that's out there, and then at the very end, he talks about getting assets for games and he actually uses a couple of them in the game that he created there. So it's a real complete survey, in my opinion. There's a lot of information here, and I really enjoyed it.\nYeah, I love articles like this one. They're a huge amount of work to do because you have to play with each one of these pieces, and very few people, even those who are deep into the industry, use all of the tools for all of the things. But I find if you're just getting out and you're just starting in an area and you want to know how to do something, it's like, \"Oh, okay, I'll read the survey and here are the pros and cons.\" That'll help me decide which one I'm",
    "HAbszXlV5Xk": "Welcome to the Real Python Podcast. This is episode 113. Would you like a fast way to share your data science project results as an interactive dashboard instead of a Jupyter notebook? Streamlit is a library for creating simple web apps and dashboards using just Python.\n\nThis week on the show, Christopher Trudeau is here, bringing another batch of PyCoder's Weekly articles and projects. We talk about the article \"Forget about Jupyter Notebooks: Showcase your research using dashboards.\" It covers the basics of turning a data science script into an interactive dashboard using Streamlit. We also share some additional resources to get you started with the library.\n\nChristopher discusses an article covering ways to make life easier when working with Python regular expressions. He talks about composing verbose regexes using F-strings and potentially reusing these patterns. We cover several other articles and projects from the Python community, including a news roundup, a step-by-step project to build a URL shortener with FastAPI, how Python's functions are sometimes classes, an automatic water pistol pigeon deterrent project, a discussion about music playlists for coding, a project for Python metadata extraction without execution, and a powerful audio to MIDI converter library.\n\nThis episode is brought to you by Rookout. Rookout live debugging debugs without restarting your app. Non-breaking breakpoints identify bugs quickly for dev, staging, and production in any environment. Try it free at rookout.com.\n\nAlright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com.\n\nAfter the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey, Christopher. Welcome back.\n\nHey there. We're back to doing a little bit of news this week and paying attention to some security stuff that's happening. So maybe we should start with that and then actually another incident in the Python world kind of popped up right in the middle of us discussing it.\n\nYeah, it's a little bit disheartening. There's been news kicking around about the ctx package on PyPI. It was found to have an exploit in it. This is one of those libraries that you may not know you're using, but you might be using. It gives a dictionary the ability to be accessed like an object. You can access the keys in the dictionary through dot notation as well as through square brackets. So it's a small library but it gets used by other libraries. Someone stole the credentials of the owner of ctx and then injected some malicious code. The library has since been taken down. The person doing the exploit was grabbing environment variables and sending the contents of those environment variables off to a server, like Heroku, which is important because a lot of hosting services put the keys for your website inside of environment variables so that they're not permanently inside of your code repositories. By grabbing environment variables or grabbing things like AWS keys, which you could theoretically do other horrible things with. I did find a report on theregister.com saying that the responsible party claimed he had no malicious intent. He did it to show the potential security problems in third-party libraries and hasn't done anything with the content. You sort of cross your fingers that that's true. How wide is this person's hat?\n\nExactly. So we've seen exploits like this before in other coding communities. They don't seem to pop up in Python as often, but this is the reality of the internet. So, you know, pin your versions, boys and girls. Don't do auto-updates. Configure your servers so that they can only call out to known addresses. These are the sort of typical security things you do if you're running production code. And if you were doing those things, you wouldn't have gotten caught by this. But unfortunately, a lot of us don't do that often. And then, if that wasn't fun enough, just as the community was sort of dealing with this, it popped out yesterday. Somebody found a bunch of typo-squatting attacks. And this is where someone registers a package in PyPI, which is a genuine package that has a name that is similar to the name of an existing package. In this case, it was requests with two S's. And if you accidentally added two S's to the middle of requests, you'd be getting this package instead. And it had malicious content in it. Once it was found, PyPI disabled not just the repo, but also took down the account that registered it. The account had three or four other typo-squatters on it as well. So this was obviously somebody who was going down that path. Crypto mining was what they were trying to do on that one. You know, this is one of those things, right? Like open source is really built on trust. And we wouldn't have got here to where we are without it. But the flip side of it is you kind of have to be paranoid at the same time. Next week, I had a listener, James Plummer, who heard me saying, \"Hey, I'd really like to talk more about security packages and things like that.\" And he's somebody who's worked in the security industry and worked a lot with Python and has lots of suggestions for anybody interested in getting into that stuff. So it should be a fun episode covering a lot more in the security world. And then, you know, we've done a couple other previous episodes about supply chain stuff. So yeah, stuff to stay on top of. The good news of it is with it being open source, and particularly the way most Python things are packaged, if you wish to be truly paranoid about it, you can always look into exactly what you're using. Yeah, in the closed source world, you can't do that. The flip side of it is there's, you know, hundreds of thousands of people contributing and that makes it a little harder. You know, I don't know about you, but I don't have time to read every line of every code of every library that I'm using or a level of vigilance that might not have. That's why he had some suggestions, different packages that can kind of scan through things and look at stuff. And we've mentioned tools that do that and stay on top of it, but I guess a lot of them resource kind of known vulnerability lists and things like that. It feels very much like the malware world, you know, in some ways. But yeah, good to stay on top of that kind of brings us into some articles. And my first one is a Real Python one. It's by Philip Ascani. It's another step-by-step project one. And this one is named \"Build a URL Shortener with FastAPI and Python.\" We've talked about FastAPI in the show a couple times. Very popular library for building APIs. Kind of as the name implies, very quickly. This one goes in a slightly different direction with what they're doing with it. It is using SQLAlchemy in a role to kind of do some of the storage and retrieval and CRUD kind of stuff that you would need with a database with FastAPI. So it kind of feels a little different to me. It was really good practice for me to kind of do other things with FastAPI. I enjoyed it. It was an interesting project and I could kind of see definitely the next steps, the kinds of things that you would want to add on top of it. It's used as some other familiar tools that we've looked at before. Uvicorn is one that it uses as kind of a development web server. And it's a good one to practice with that again. It uses that flag where it kind of looks at as you save, it will reload everything, which is nice. And you start out just again, step by step going through preparing your environment, installing all the different packages. It talks a little bit about the 12-factor app, which I'll include a link for, which is this sort of methodology for designing apps in a way that is considered sort of professional, sustainable. And part of that is what you were just talking about of environment variables and things like that, those kind of credential things and knowing how to use them and store them and manage them properly. Again, I learned a lot about SQLAlchemy just kind of not only from this, but an upcoming course that you are working on or just completed and we're just kind of working through how to get it published, but it was really kind of fun to kind of see it again. This one is using a SQLite database and if you're not familiar, it's very much like a Bitly or other type of site that you would use where you give it a web address and it provides you a short version of that. It has a lot of kind of nice techniques where you'll go through creating the basic version of it and stand up and get it running and then you go through refactoring the code and why you might want to separate things out and move them to different pieces and you create the basic root location with FastAPI and then pretty quickly you're into using its really nice built-in Swagger UI which helps you work with the API kind of directly and try things out. And then in this case, you are actually able to create entries and put them into the database. And it's a nice step-by-step project. It gets you pretty far along into it. It's mostly the Python side of it, in my opinion. I think if you were going to present this to someone else to have users use a tool like this, the things that you're going to really need to get into next is like, \"Okay, well, how do I want to host this and then how would I maybe want to make a front end for it?\" I enjoyed it. I think it's a really good tool here kind of getting in and using some of these familiar tools in a slightly different way. Another handy step-by-step project. Years ago, a startup I was at, we wrote one simply because we wanted a shortener that was branded under our URLs for our customers rather than under Bitly or one of the Google ones. Yeah, and we used Django to do it and the internal name for it was the Duke of Earl. So nice, there you go. I like it. Get the needle out of your haystack and stay in production with Rookout. Rookout uses non-breaking breakpoints to debug code without stopping your app, without adding code, and without restarting. Generate live logs and ship them automatically to your other monitoring tools. Quick, simple, and dynamic. Live debugging makes changes five times faster. Try us out at rookout.com. That's r-o-o-k-o-u-t.com. Rookout is dynamic observability. So what's your first one? This is an article from Trey Hunter and it's entitled \"Callables: Python's Functions Are Sometimes Classes.\" Title might be a bit confusing at first, but the essence of it is that many things you think of as a function in Python, in fact, I do this all the time. I shorten it in my head as that's just a function. A lot of them just aren't functions. And this isn't a philosophical \"everything is an object\" sort of argument. It's the fact that many of the function-like things are actually classes. To see this, you open up the REPL and you use, say, int, which is used to turn a string into an integer. But if you just put int without the parentheses, you'll see that it actually is a class. Same goes for reversed, enumerate, range, all these things that we tend to think of as functions because we use them that way. And Python kind of doubles down on it because all of them are named with small case and we tend to name our classes with big case. So all the more reason you think of it as a function. So what's going on here? Well, Python has a way to make a class act as if it's a function. And this is known as making it callable. So this is a nice little callback to our last few podcasts where we've been talking about the magic of dunder methods. In case you're not a regular listener, and really, why wouldn't you be? Dunder methods are the special methods that begin with double underscores in a class, which are used to make the class behave like a Python library object. So you can use dunder methods to get instances of your classes to compare to each other, you know, greater than, less than, and that kind of stuff, or respond to like the length function, that kind of stuff. So in this case, the dunder method is called double underscore call, double underscore, and any object that implements this is callable. And the method takes star args and star star keyword args. So when your object is used like a function, whatever you pass into that function, like things, gets passed into call. Article walks you through a whole bunch of use cases, shows you where it's commonly used in the standard library, and then sort of wraps it up by pointing out, you know, the beauty of Python is the caller doesn't really need to care, right? It's function or callable, they all quack like a duck. It just, you know, as a user, it just works. So it's, you know, another tool in the toolbox, is something that you can do if you haven't done it before. And the article walks you through it nicely. Yeah, Trace stuff's really good, the Python morsels. Yeah, it definitely ties into everything we've been speaking about lately. That's nice. You need a theme, right? Yeah, I think we do. Speaking of stuff that's been mentioned a whole bunch, I have shared over the gosh, the last two years, kind of glancing looks at this particular library. I'm going to talk about next, and it's based around a recent article that's by Steph Smeets that's published on Medium and published in Netherlands eScience Center. The title of it is \"Forget about Jupyter Notebooks: Showcase your research using dashboards.\" I'm a big fan of visualizations. I'm a big fan of dashboards. That was something that I actually really enjoyed building and creating and still and very interested about like that part of the problem solving, which is to share what you've created with others and give them a way to kind of interact with it and play with it and see what they can. And Jupyter Notebooks are not maybe the best tool for that. Yes, you can potentially share them, but one of the biggest downsides of that is that they're filled with code and that code can look really overwhelming to people and for them to see the results in it might require some training. If you want to share a pure Python Jupyter Notebook, you're going to be doing some installation, putting some libraries together, maybe creating environments, and it also leaves it open for modifications. And there are places that host this stuff like Google Collab or Binder or some other things, but anyway, hopefully you're seeing maybe there are some downsides of potentially just tossing a Jupyter Notebook to somebody or saving it as a static thing, which then again, that kind of defeats the purpose of being interactive. So dashboards, and we've talked about some other potential solutions in the past. We've mentioned a tool called Dash, one called Panel. There's a few other ones, like I've mentioned how you could kind of set up Bokeh to do some of these things. And there's one that we haven't kind of mentioned before called Voila. But the one that has come up in our episodes is Streamlit. For reference, there's a detailed comparison post by Steven Commons that's on Data Driven Insider, another Medium post. It has a comparison of those four: Dash, Panel, Voila, and Streamlit. This particular article is about Streamlit that I'm talking about. Also, it's the one that's been mentioned in previous episodes. In fact, episode 15, which is like the first episode in this style for Real Python podcasts, where we had PyCoder's kind of style stuff with David. David had mentioned an article about getting machine learning to production. I'll include a link to that, and it kind of talks about getting going with using Streamlit there. And then he mentioned it again in episode 64, talking about detecting deforestation with Python, which is another article on Medium that was going in and doing detection of deforestation with satellite images and then creating a dashboard behind it. And again, they use Streamlit. So the author here, their impression was after having played with Streamlit for a week, they found it really straightforward to get started with, and I did too. It was real easy to kind of walk through this simple tutorial in this post. It works in a very interesting way. It has a very linear execution model. It basically runs your code just straight through the list, and there isn't any need to do any kind of web development at all. It has everything kind of built in for that, and so that's probably the biggest advantage over some of the other dashboard tools where if you want it to look anything kind of nice, you end up having to kind of get into HTML and potentially JavaScript land of kind of working with this. So this doesn't have to do that, which is really nice. It's a real simple API. It's easy to manage. It's maybe in some ways, simple, but again, then maybe you can fit it in your head. So there's kind of those balances there. And then a lot of people consider it one of the fastest ways to get this stuff up and running. And so that's why it keeps being mentioned. So you build in this article a real simple dashboard. It uses Matplotlib in this case and adds three controllable sliders and header. As many other tools you might have worked with, you are creating really simple client server situation where you run it and then it serves it up and then you can go to that address. So like something on an internal intranet would be an easy way to kind of host this thing. The Streamlit has a free option for their cloud version. And so in that, if you wanted to host for them, and in that case, you can put all of your code in a GitHub repo and point it to Streamlit and it opens up and hosts it. And along with the GitHub, you know, your Python code there, you have a requirements file to kind of say any additional libraries that you're using there. I just really kind of dug it. If you go through this tutorial that gets you started here, I would suggest you go right to their Streamlit docs. It has a create an app page, and that one you're doing a little more complex stuff. And to me, it's starting to actually show what makes it special. It has these nice kind of areas where you can choose to look at the original data, which is a nice tool that's in there. It shows like not only sliders and other toggle things, but like you can add switches and other types of controls. So it has a nice mix of those things in that one, a little bigger example. And so I think that would be a good next step if you're looking at it. I think there's a lot of things that kind of make it sort of special. Like its interactive controls are really easy to utilize. It looks nice right out of the box. It has exporting of graphics, which is really nice. Again, simple concept. If you adjust the controls, it runs your script again top to bottom. So it just does that all that kind of",
    "JSIGnUvrB6Y": "Welcome to the Real Python Podcast. This is episode 114. Are you interested in a career in security using Python? Maybe you would like to stay ahead of potential vulnerabilities in your Python applications. This week on the show, James Plugger talks about Python information security incident response and forensics. James has been doing information security for over 15 years, working at some of the biggest companies, government agencies, and startups. He shares numerous Python resources to dive into detecting threats and improving your projects. We discuss ways to learn security topics and how to get involved in the community. And definitely make sure to check out the massive collection of links in the show notes this week.\n\nAlright, let's get started.\n\n[Music]\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey James, welcome to the show.\n\nHey, nice to be here.\n\nSo you reached out to me via email and sent me this amazing email with all these details about security stuff. You said you were a new listener of the show. I actually have a quick question about that. How did you find the show?\n\nI like podcasts. I love listening to them in the car and I just randomly happened upon it.\n\nOkay, cool. Awesome. Well, welcome. I hope you're not having to listen to all 100 of them or whatever it is that's out.\n\nI've got a few in the backlog.\n\nOkay, good. All right, hopefully you can pick and choose.\n\nYou work in security and I guess there's lots of terms for that. A lot of people like to use the word cyber security or basically security research. But maybe we could talk about defining a lot of those things to start with. Like kind of talk about roles and positions and jobs. I think it's kind of an amazing field and it really has intersected with Python in a big way. And that's kind of what you were mentioning in your email. So maybe we can start there. Like maybe talk a little bit about your background and then we can dive into some different roles and then get into some specifics.\n\nSecurity is an interesting thing. I think over the last 10-15 years it's evolved. It's gotten huge. You know, it went from something where, you know, if you were to look at security 20 years ago, they pretty much categorized it as bugs and break-fix type of work. Whereas today, people understand what's going on. You can exploit these things and do all sorts of nasty things on computers. Definitely in the news, right?\n\nYeah, exactly. The one thing I will say is, you know, first and foremost, like, I apologize if somebody is listening and they've been harassed by security people. You know, there are some folks that get it. You'll never see those folks. Just recording this podcast, there's probably hundreds of security people that have touched all the different pieces of software, you know, and things like that. You probably never even thought about that from the browser, you know, to all the web services, things like that.\n\nYeah, and all the packages of software in between. Yeah, it's crazy. And there's folks that get it and folks that don't. You know, and we always get frustrated when people get a bad taste of security in their mouth because, you know, folks get harassed or, you know, there's really dumb stuff going on. I've been doing security work for probably 15-20 years at this point. You know, I've been around for a while. And it's amazing how many different focus areas there are. And kind of bringing it back to Python, I mean, I started using Python probably like 2007, 2008, somewhere around there, like really consistently.\n\nOkay, and it's been interesting. Like the security community really leverages it in so many different ways. It's pretty cool.\n\nCan we talk just briefly, just touch on reasons for that? You know, it's interesting. I think it was kind of a time and place type of thing.\n\nOkay, and ironically, you know, the way that Python 2 handled strings, it actually lended itself really well towards, you know, doing stuff. So like one of the big things, if you've ever migrated code from like 2.7 to 2 or 2.7 to 3, okay, the whole Unicode versus bytes and strings, that was actually kind of a really nice feature for folks because on the security space, there's so many times where you're basically doing bit manipulations or things like that. You're looking at a packet or something like that, and it really made it super easy to do that either looking at files or things like that because the stuff was in a more stricter format as opposed to what's in Python 3.\n\nYeah, exactly. Okay, so like, for example, let's say you had a character, you load the one byte, you could basically do bitwise operators really easily just on that string without having to convert it and cast it as a byte and then recast it as a, you know, ASCII character or things like that. And so it was kind of interesting on that. Okay, you could tell the intent of strings a little easier than maybe what you would do now.\n\nYeah, exactly. Well, and the thing is you can still do that today. It's not like, you know, they've removed any of these features, but it, you just didn't have to like cast them as different character types and things like that. Yeah. So I think that's one of the things that like a lot of people really liked, you know, because before then, we would have to write C programs or do it in Perl and you know, have these like giant scripts that basically did the same thing that we could do in like two lines in Python.\n\nNice. So that was like one of the things that spurred adoption. Okay. But I think, you know, a lot of the things is somebody said Python's like pseudocode that actually runs, right? Very readable. Yeah, exactly. And it works really well when it comes to security type of work.\n\nCool. One of the things I was thinking about with that is when you look at writing these things, you mentioned before we started that there's processes that are much more based around sort of shallow stuff and then sort of deep stuff. And I wonder about that sort of shallow stuff and those kinds of roles that could be in there where you're needing to act kind of quickly. Is that another advantage that you could kind of write it quickly and not need to compile it and, you know, try your things out kind of quickly? Is that part of the appeal also?\n\nOh yeah. I mean, I'll be honest. You know, and we can probably dive into this as well and just kind of the different areas of security, you know, but when we're doing an incident, like let's say somebody's been compromised or there's some sort of hacking activity that's gone on, okay, being able to quickly massage data, look at things, you know, modify it and like iterate really quick, those are super important, you know, during those, yeah.\n\nOkay, that makes sense. Yeah, you want to be able to make sure you're headed down the right path quickly before you hit, you know, have to hit like compile and all these other kinds of things. That idea that you could kind of just stand up scripts and get going quick, it's probably crucial as far as timing, yep.\n\nYeah, and it's interesting, like on the security side, there's really kind of two main focus areas. So, you've okay, you might have heard these terms before, but you've got kind of a red team and a blue team. And for those of you who aren't familiar, it actually kind of comes from some old military, like wargaming type of stuff where, you know, and this is, you know, probably a little dated now, but you know, back when the Soviet Union was around, they would have the red team, which represented the Communists and, you know, okay, if you're from the US, it was the bad guys, right?\n\nYeah, we were the blue team, you know, on that. And then we would be the blue team, you know, on that. And like, theoretically, you know, the good guys versus, you know, the bad guys. And it kind of spread into the security side of things. Really, there's two main focuses. You've got a offensive where people are trying to write exploits, find vulnerabilities, things like that. And you've got a defensive side where, you know, you're basically trying to defend somebody's network. You're trying to understand what's going on and block the attacks. And that's really, if you were to kind of categorize the different types of security work, it kind of fits into one of those two buckets. My career has mostly been focused on, you know, more of the defensive side of things. Okay, the blue side, if you will, exactly. And, you know, it's really interesting because there are so many different paths that folks can take. And you touched on a little bit before, like you can either go deep or you can go wide. And, you know, it's great for different types of personalities because the things are changing all the time. So, if you're somebody that, you know, is like myself, where I get bored fairly easily, you know, yeah, there's so many different things that are going on in the security community all the time that you can always find something interesting and something that catches your eye that you can kind of focus on. That's cool. Just a total aside, there's a video game, Halo, yep, and there was a cartoon series based upon the red versus the blue characters that kind of dives into that. And that's something that made me think of it. But yeah, totally. It's weird to have the last several months to think about the red team in different ways now too.\n\nYeah, maybe we could talk about not only the idea of these sort of narrow and deep roles versus the sort of, you know, spread out kind of roles, but maybe we could talk about what are some of the positions and maybe we can name some of these things because I feel like having not worked in it, I wouldn't even know like what you would apply for or, you know, what would these things kind of look like in, I guess they might vary depending on the industry or background.\n\nYeah, so there's a couple of really common terms that you'll see. So kind of the mixed side where it's kind of a combination of red team and blue team type of activity. There's a lot of AppSec engineering folks. So like one of the things that a lot of companies have, you know, if they're running a platform or something like that, they need folks to triage bugs that come in. A lot of folks run bug bounty programs, yeah, where they basically pay people to submit security vulnerabilities and things like that so that they can proactively deal",
    "CGxdnj0SaBQ": "Welcome to the Real Python Podcast. This is Episode 115. Have you heard about PyScript, the brand new framework that has the community excited about building interactive Python applications that run entirely within the user's browser? Would you like to dig into the details beyond the hello world examples?\n\nThis week on the show, Christopher Trudeau is here bringing another batch of PyCoder's Weekly articles and projects. We talk about a Real Python tutorial from Bartoszinski about PyScript. The article provides an initial look at the framework and then takes the reader deep into the intricacies. We also share additional resources to help familiarize you with the project.\n\nChristopher talks about another Real Python article about how to approach managing errors in Python. The tutorial, \"LBYL Versus EAFP: Preventing or Handling Errors in Python,\" is from frequent contributor Leodanis Pozo Ramos.\n\nWe cover several other articles and projects from the Python community, including discussing the PSF's Python Developer Survey 2021 results, Django static files and templates, how to profile Python code, a launcher for penetration testing, and a project for confirming Python versions through syntax errors.\n\nThis episode is brought to you by CData Software, the easiest way to connect Python with data. SQL access to more than 250 cloud applications and data sources. All right, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com.\n\nHey, Christopher, welcome back. I'm glad to be here. All right, so we're diving into a couple of big Real Python articles, and then we've got a couple of other tools and resources to dig into. We're going to bypass the news a little bit, though our discussion is a little bit newsworthy, so let's get rolling.\n\nMy first article is by Leodanis Pozo Ramos. It's called \"LBYL Versus EAFP: Preventing or Handling Errors in Python.\" Let's start with the bulky acronyms. LBYL is Look Before You Leap, and EAFP is Easier to Ask Forgiveness than Permission. The heart of it is how you deal with error conditions in your code. Historically, preventing errors before they happen is the most common strategy. I disagree with him here. Doing nothing and having your program crash is probably the most common, but I get his point.\n\nThe first one, Look Before You Leap style, is the idea of checking whether something's going to fail before you do it. A simple example of this would be a conditional that looks to see if a key is in a dictionary before you try to access it. By contrast, Easier to Ask Forgiveness than Permission style would be directly accessing the desired key, and of course, if you don't want to crash, you have to deal with the key exception. In Python, this is done with a try-except block, and inside the try-accept block, you access the key, and inside the accept part, you catch a key error and do the same kind of error handling you would have done in the else condition that I mentioned in the other style. These are just two different ways of doing it. Most modern programming languages support both mechanisms. Some of the older ones don't have exceptions, so this is one of those contrasts that happen in language design.\n\nAs with a lot of things, you can expect there are pros and cons to both, and of course, flame wars have erupted out of less. The advantage of using try-except is you can usually get away with fewer checks. You can wrap a longer block of code inside of the exception catch, and you're not having to constantly go if-then, if-then kind of thing as you're going along. The other advantage, which I kind of like, is it tends to be a bit easier to read. Having every line of code wrapped in a conditional means you're visually parsing the conditional to see what the code is doing, whereas in a try block, you just see the code. I find it tends to be a little more readable.\n\nSo those are two good reasons to use the try-except. Why might you want to use preventative instead? Well, there's performance implications. This one varies from version to version of Python. In fact, in the coming release of Python 3.11, a bunch of work has been done to reduce the cost of exceptions. But the more exception checking you do, the more overhead the code has. So for a small number of possible errors, try-except might win out. But if you've got a big variety of exceptions that can be thrown, your code may take a performance hit. A profiler can help you figure out if you're paying this cost, and that's some foreshadowing which we'll hand off to you for later.\n\nThe article is full of snippets for each of these cases, showing you why you might prefer one or the other, and then digs even deeper in with a series of examples that are quite concrete. And in case you want to take another crack at this around the same time this article came out, Luke Plant, who we've linked to before, wrote one called \"Raising Exceptions or Return Error Objects,\" which then became a topic on Hacker News. So we'll include links to all of this, but there's sort of three different ways to go at the same subject material if you're interested in this.\n\nI wonder if some of this came up, especially the stuff kind of around 3.11 and these sort of faster ways of dealing with exceptions, and sort of the overhead cost of them. That's definitely, you know, a new topic if in case people are interested.\n\nYeah, I haven't dug into this part explicitly yet, but there's this banner headline called \"Zero Cost Exceptions in 3.11.\" Yeah, and it's a case that it doesn't, it's not zero cost all the time. There's sometimes when it costs zero, and there's sometimes it costs more than that, and I haven't read anything yet to dig into how the difference is. But even if you're removing this cost, sometimes that can help the speed in a lot of people's code.\n\nYeah, that's cool. And then I think it's really funny that it just kind of is a theme for Python, and I'm having this conversation with Bruce Eckel in a couple weeks here, where we talked about how Python has so many different ways that you can approach it, let alone the, you know, foreshadowing something we're going to talk about later of like the survey of how people use Python, but literally like how you develop inside of Python, you can kind of choose the path you want, and I'm just really finding that to be such a common theme.\n\nSo here's yet another one, like you're saying, that some languages kind of steer you in a direction. One of them typically just is all about exceptions versus the other way, it tends to be the other way around. Some of the older languages like C didn't have exception management in them, right? So try-except blocks were added in C++, okay? So you just can't use exception mechanisms there. There are things you can do that approximate it, but then you're basically inventing exception handling inside of your code. Yay, roll your own.\n\nCool, yeah, so that's great, and that leads me into nicely talking about how to profile Python code. This is the title of this article, and this one is a blog called Code Solid, and the author is John Lockwood. This is a really nice overview to get you into thinking about profiling, but also not just profiling. He also kind of has this section where he's talking about the differences between benchmarking and profiling the performance of Python.\n\nDoes that ever come up on the show?\n\nYeah, you know, we can always broach a new topic if in case people are interested.\n\nYeah, and this is kind of an interesting thing in that sense that often I feel like the development cost is always the thing that is the big win with Python, like how quickly you could kind of develop things is really nice. Do you need to profile stuff? That gets into an interesting argument there, and then when to profile is a whole other one.\n\nI thought it was really kind of interesting. Primarily, the bulk of the article is about sort of a short survey of seven different profiling tools, how you can kind of use them and check out how your code is performing either on kind of an overall level or at like a line-by-line or function-by-function kind of level.\n\nBefore diving into those tools, he covers some of these profiling terms and key concepts to get you a comparison of them. The first concept is profiling is a late-stage activity, and then I put in parentheses based on what he described or is it a question mark. He feels that profiling helps find bottlenecks. This is a quote: \"The famous dictum that premature optimization is the root of all evil did not mean that you shouldn't optimize at all, but rather that you shouldn't optimize the wrong things, which you're likely to do if you don't know where the bottlenecks are.\" So he's arguing somewhat in this that it's good to check for the bottlenecks sometimes as you go. I guess that really depends on how you develop. I would always think of, like, you would want to stand everything up and kind of go from there. But I guess it kind of depends.\n\nI think he's just getting at least say if you're doing test-driven development or something, you don't have to wait until everything's done. If I've got my function done and I want to check it, then you know, profile the function, right? That kind of makes sense, right?\n\nThe other aspect of this, which is kind of the big picture aspect, is something called Amdahl's Law. Essentially, this talks about diminishing returns. So, you know, if you've got a part of your calculation which is taking up 80 percent of the time and you improve that, you're going to get a big boost, yeah. But if you've got part of your calculation that's only taking 5 percent of the time, even if it's the slowest part, fixing it may not make any difference. So you kind of have to balance this act between how do I optimize my piece versus how do I think of the whole.\n\nWhat I think is interesting in that process is there's a lot of references to doing things in Jupiter Notebooks. The idea there very often is that you kind of are really breaking apart your code into these cells and kind of running the cells and then being able to kind of gauge the performance of those cells as you go. I think is really kind of handy. And there's lots of tips and tricks there, and then also just snippets and, you know, how to apply these techniques in there. One of the other terms and kind of key concepts is the difference of profiling versus benchmarking. Benchmarking is more like a macro view of performance, like overall timing of things, you know, how the whole thing kind of runs, and you can kind of see the overall sort of speed. And then he kind of gets into this wall clock versus CPU time thing. But profiling is much more micro. It gets really into showing you individual portions of your code and how they're performing, and maybe how much memory they're using, and the wall clock versus CPU time gets into whether or not throwing parallelism will fix your problem. Absolutely, yeah.\n\nAnd then he has another little section on deterministic profiling versus statistical profiling. I'll let you kind of dive into those, but it, I like that he did that, that he kind of covers some of these terms and key concepts that can kind of really dive into much deeper areas if you want to get into them. And then he shows a typical scenario, provides a few examples, and again, what I really like about it is he's showing using the commands and some of the common flags that you would use to not only run it in the console, but then again, shows you how you could use them in a Jupyter Notebook. In his case, he starts with profile and cProfile, but I wanted to mention time it first because it's kind of the one that I have seen the most. And again, it is more in that benchmarking side. It measures the average execution time. You can measure an individual function, or you can use it to measure a whole program. Then, profile and cProfile, those modules, this is, if you were to read the Python docs, they're the recommended tool inside of it. He mentions a couple other additional ones here. Line profiler, which needs to be pip installed, which focuses on function calls, over like say cProfile. Memory profiler is more about visualizing the allocation of memory and the deallocation of it, kind of again, watching your program do that sort of stuff. Again, he provides what in Jupyter parlance they call it magic methods, which is like this percent sign you may have seen in front of things like time or time it. So he then also shows ones like p run and lp run and some of these other ones that are more individually for some of these other profilers. Then, he gets into two other tools that are a little more advanced, that are kind of again, more like an overall picture kind of thing. One is called scalene, I guess that's how to pronounce it, which is a profile that profiles not only the memory use that we've talked about already, but also CPU and GPU, the graphic processor unit use, and it provides like a web-based graphical user interface, GUI kind of thing that shows percentage of time in the various parts of the code. And then the one he ends with is called Yappi, which I like, I think it's like a small dog at that point. It provides support for understanding CPU versus clock time, and that's really good for this sort of idea of profiling multi-threaded code, like you mentioned, and or heavily using asyncio and stuff like that, kind of seeing the performance there. So it's a really nice overview of all these different sort of tools. I guess seven different tools, some are built-in, some you may have seen before, and I thought it was a nice survey. And if you're interested in getting deeper into the profiling area and kind of seeing the performance of stuff, lots of opinions there of like when and where to use it, and then lots of support for not just running things command-line, but also, you know, potentially running them in your notebooks as you work through things in there.\n\nDo you use any of the tools you mentioned?\n\nI've used timeit quite a bit. I have started to look at profile and cProfile, but I a lot of my programs, I don't. It's kind of like the testing thing. Like, I'm standing it up and making sure it's running and so forth. I'm getting a little better about test-driven development, which actually kind of leads into your next thing. The bigger projects I've done have lately been more like Django types of projects, and I was actually following some of that author's books, Will Vincent's books, and he's very much heavily into having you build the test as you go, and so that's been part of it. Right, I haven't really had this sort of hit the place where I saw performance bottlenecks was in data science and watching people do things where they would just sort of shrug and go, \"Well, I guess this will be done in a few hours.\" And I'm like, \"Right, is this the best way to do it? Is to make it be a break in your day kind of thing, while it runs the programming? Because I would think sometimes there'd be some efficiencies that you could really look at, but very often people are like, \"Well, I'll just do other things while that's going,\" sort of their own version of multiprocessing, yeah.\n\nYeah, that's cool. And then, I think it's really funny that it just kind of is a theme for Python, and I'm having this conversation with Bruce Eckel in a couple of weeks here, where we talked about how Python has so many different ways that you can approach it, let alone the foreshadowing something we're going to talk about later of the survey of how people use Python, but literally, how you develop inside of Python, you can kind of choose the path you want, and I'm just really finding that to be such a common theme.",
    "vhTO5-YtzyE": "Welcome to the Real Python Podcast. This is episode 116. Would you like to explore the functional programming side of Python? What are the advantages of this approach and what tools are built into the language?\n\nThis week on the show, author Bruce Eckel talks about functional programming in Python. Bruce is the author of several programming books, including \"Thinking in Java,\" \"Thinking in C++,\" \"Thinking in Python,\" \"Atomic Scala,\" and most recently, \"Atomic Kotlin.\"\n\nHe's been an explorer of programming languages over his career. Functional programming has recently caught Bruce's attention with its lack of side effects, transparency, and potential for parallelization. Bruce's talk \"Making Data Classes Work for You\" at PyCon US 2022 explored the idea of the invariance of objects.\n\nWe also discussed his next book project, the Python community, and his affection for unconferences. Bruce is hosting the upcoming Summer Tech Forum in Crested Butte, Colorado this August.\n\nAll right, let's get started.\n\n[Music]\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com.\n\nAfter the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey, Bruce, welcome to the show.\n\nWell, thank you. I'm excited to talk. We met at PyCon US 2022, and I wasn't that familiar with your background, but a bunch of people around me were like, \"Oh my god, Bruce Eckel. He's written all these amazing books.\" So then I did research, and I was like, \"Oh wow, okay.\" And I guess I just haven't spent as much time in Java and those kind of programming languages. I kind of took a long time off in between my programming journey. I started in the late '80s in college and then went down this whole route as a musician and then kind of came back to programming with SQL and then Python and a few other tools, and obviously the web kind of happened in between there.\n\nMusicians seem to make good programmers. That's interesting. Why do you say that?\n\nI mean, that's been my experience. I've known a fair number of musicians who are also programmers, and you could just say, \"Well, look at sheet music. It's like a computer program.\" Yeah, so you know, maybe that's why it's so easy for musicians to kind of make that jump. It's a lot of interesting problem-solving also and making things fit harmonically, sure.\n\nYeah, and improvising too, I guess, in some ways, which is very crucial, right?\n\nYou had reached out about some potential topics. Yes, the one that we thought that would work initially here to start with is kind of built on the talk that you did at PyCon, which was about data classes and it was titled \"Making Data Classes Work for You.\" It kind of leads into functional programming. I've only talked about functional programming really briefly on the show with my previous co-host, David Amos. Maybe we could get a little background on some of that.\n\nSure, that's something we're going to dive into deeply, but maybe we should also talk about some of the other stuff that you do, like you have a podcast yourself.\n\nYes, my friend James and I do the Happy Path Programming podcast, so that's just happypathprogramming.com. And we came to that name because that's where we want to go, and it's also kind of ironically where, when you go down that path, I guess when you traipse down that path, it usually gets you into trouble. But that's still what we'd like is to be able to say, \"Here's what I want to do,\" not so much, \"Here's all the things that can go wrong.\" Okay?\n\nAnd that's kind of what functional programming is.\n\n[Music]\n\nI mean, this is a problem because you pick up books on functional programming and most of them have different perspectives on what it is, and often it's like a list of features. So one of the things that I've been struggling with is, yeah, what is the essence of functional programming, or basically what problem are we trying to solve? That's the question that seems to keep coming up. Okay, and like most of these recent endeavors, it's like you ask that question, \"",
    "T6IXgFUVTec": "Welcome to the Real Python Podcast. This is episode 117. How maintainable is your Python code? Is it possible to hold the code of your functions in your head? When is it appropriate to use measurements in a code review? This week on the show, Reika Horvath and Ben Martino from Sorcery are here to discuss their recent PyCon talk on how to use and how not to use code quality metrics.\n\nReika and Ben share their thoughts on how metrics can provide insights into your Python code. We discuss four measurements of code complexity and what factors into each. We also talk about deciding whether to refactor or rewrite your code. Ben and Reika share their experience in code review situations and the importance of shifting the conversation from subjective opinions toward objective measurements.\n\nThis episode is brought to you by Seadata software, the easiest way to connect Python with data. SQL access to more than 250 cloud applications and data sources. Alright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey, Reika and Ben, it's good to have you on the show. Hi, hi, nice to be here. Yeah, Reika, we kind of know each other from the stuff that you were writing for Real Python. You wrote a couple tutorials there. Do you want to talk about them a little bit?\n\nSo I wrote two tutorials about vendors back in 2020, oriented for beginner intermediate level. Yeah, and I quite enjoyed it. So at some point, I might write articles again. Yeah, we'd love to have you come back and write some more. And then we did like a social thing that we do from time to time where team members get to meet each other. So we kind of met virtually. It must have been at least a year and a half ago. But it was also really fantastic to see you actually meet both of you in person at PyCon. And that's partly why we were here to talk about your PyCon talk, the talk titled \"Actionable Insights Versus Ranking: How to Use and How Not to Use Code Quality Metrics.\" I like that capitalization of the entire word \"not.\" How did you start down the path of coming up with this talk?\n\nSo this actually started when I began to work for Sorcery last year in the autumn. And at the beginning, I was even going to suggest that we should remove metrics as a feature because I completely didn't see the point of why we are having them. And that completely changed my mind about this topic. I was reading the summaries of several user interviews, and I was quite surprised to read from multiple people that, yes, the metrics have been really, really useful and they helped them reasoning why they are going to refactor a specific function. And this was both helpful when discussing with team members, other developers, that yes, this should probably really be changed, and also when explaining management that this is something we should invest at least a bit of time into it. Yeah, I was trying to start exploring in which ways we can use these numbers, even if we know their limitations. So you're a convert. So the feedback which we got from users definitely changed my mind in the beginning. Yeah, cool. Ben, how did you start on this one?\n\nYes, it was Reika approached me after she decided to do this talk, so I was definitely kind of just joining in. I joined Sorcery a little bit later as well. So I was kind of a little bit less familiar, I think, at the time that we started preparing it for PyCon. Yeah, how big is the team now? Oh, we're six people. Because I had Nick and Brendan were on the show pretty early in the life of the podcast. So that was really fun to talk to them. And you guys both came on within the last year, you're saying? Yeah, I joined in November. Yes, and I joined in October also last year. Okay, cool. That's really interesting. And when you guys kind of talked to me briefly at PyCon and kind of went around a little bit about how we could maybe do an episode about this. And so I watched your talk, which is great. All those talks are up from PyCon now, everybody can kind of check them out. And I maybe kind of go down a bunch of rabbit holes about kind of thinking about this stuff about code quality metrics. So that'll be a fun topic for us to kind of get into. And maybe we can start with the concept of like, okay, well, code reviews, which I know are, it's kind of interesting that you had sort of this initial reaction about code reviews generally. Had you had bad experiences before where you felt like metrics were used like as a weapon per se or something like that? You had kind of a bad experience or what was your feeling there?\n\nThat I definitely haven't had such experience with code quality metrics. I have seen meaningful and less meaningful usages of metrics generally. So both in software development and other areas. And okay, and with code reviews, it could be generally when talking about code, I put here that we often use adjectives for describing code like elegant and nice and messy and ugly on the other side of the spectrum. But that's something we very rarely try to quantify. And so I might be worth giving this a try. And those users talking about it that will definitely convince me that, okay, in some cases, this might improve the conversations and guide them into a more objective direction. Okay, what's your experience been with that, Ben, with the code reviews?\n\nYeah, it's kind of interesting. There's a similar Reika and I were chatting a little bit about this earlier, and I think Reika, you brought up this really interesting thing that happened with your English teacher talking about the differences between the code review and the editorial process for a normal piece of text. And I think it's kind of true that there's a couple one of the odd aspects of a code review is that you're actually doing quite a lot of investigation into some code at once. You're looking for everything from bugs to style errors to interpretability things like docstrings, things like types. And all of this gets folded into this quite complicated single process. And I, yeah, I don't know, it was fun chatting about that 'cause I'd never thought of it that way. But one of the good parts about trying to get a handle on things like code quality metrics is like so many other aspects of the design process for code, things like writing tests and things like writing docstrings. It's a way of setting that aside compartmentalizing it so that you've got a way of thinking about the problem in such a way that it doesn't sort of have too much of a, you know, blowout effect on everything else. Yeah, yeah, yeah. I think about that with people very often say they want to use a code format or to kind of get rid of those conversations, yeah, about like how things are sort of organized. Hopefully that can eliminate a lot of those kind of issues. But one of the things that wasn't in your talk, partly because it was mostly about thinking about these metrics as the documentation side, which I think is, you know, really crucial. And I know you touched briefly on the end of like things that are kind of hard to sort of consider, which is maybe like the naming of things and things like the quality of the docstrings and how something's explained and, you know, or maybe too much documentation or what have you, which I guess could get kind of testy. I think the idea between some of the metrics that you're highlighting in your talk is a way to kind of make them be more objective.\n\nYes, making them more objective. And I also agree with that point by which them brought up that when I compare a good review to, for example, the process which I saw at Real Python, that's okay, when I am ready with the draft of an article, there will be at least three different review rounds from three different people, yeah, by different angles. And in a code view, that's quite a mixed bag of things. And I don't think that the solution is to have an involved review process for each single PR because that would mean probably multiple days a week. But I think that we should really appreciate all the different tools which are able to give specific feedback around one topic within seconds or within some minutes, okay, the way that you could kind of self identify some of these things.\n\nYeah, so the reviewer has perhaps a bit less to watch out for and perhaps the reviewer gets some also some ideas where to look specifically so we, I think they don't think about these numbers and the tools that this should replace you, my reviewer, but instead of supporting and guiding this process, okay, have you had experiences similarly then with like code review, like things getting hung up on different topics that are maybe not as objective?\n\nSometimes I mean there's a sort of interesting question here for what objectivity like means at the end of the day.\n\nSure, one of, you know, we can say that we well, you know, the function length is like an objective sort of thing but there's a subjectivity in choosing that as the thing that you're focusing on. Sure, and I think that's that's partly what a lot of the subjective objective kind of discussions that you have around code review sometimes boil down to when somebody says that they prefer something in some style or another. It's not so much that like they could come up with some objective matrix that demonstrated their point. Okay, but I think maybe this is sort of moving ahead a little bit but one of the interesting things to me that came out the talk was that although there aren't necessarily like objective sort of specific things to talk about that what looks interesting when you sort of look at the whole group think open source projects was that there were standards that seemed to be pretty well held across a whole bunch of different repositories and that was really exciting because then it means well, it's not so much we're talking about objective or subjective but we are talking about consistent or sort of agreed upon things. You know, a sort of democratic approach. Yeah, and that's been interesting. I don't know sort of coming back to the original question. Yeah, there are sort of some specific types of code review where you know, I've had like arguments with people doing the review to you know, I'll say I think this is better because X, Y, and Z and they'll go well, I prefer this and you know, you just go away and see what everyone else is doing. Basically. Yeah, when the word preferred comes in, it sounds kind of, yeah, not objective anymore. Yeah, well, it's exactly that, it's like objectivity probably isn't right, but you know, yeah, as you say preferred or agreed upon or conventional perhaps is a good way of putting it. See data software connect, integrate, and automate your data from Python or any other application or tool. At CData, we simplify connectivity between all of the applications and data sources that power business, making it easier to unlock the value of data. Our SQL-based connectors streamline data access, making it easy to access real-time data from on-premise or cloud databases, SAS APIs, NoSQL, and big data. Check out to learn more.\n\nYou guys referenced a comic that I thought was funny when I dug down the rabbit hole to kind of look at it. It's from Tom Howard, it's from like 2008 and it was a measurement maybe for code review that was the WTFs per minute. And I thought to myself, okay, like as you look at something and there's different levels of heat for that WTF, it could be like, I don't understand what this is as opposed to like why or oh my gosh, like that's really interesting, you know, like there's, it's a good measurement for like several things, I think of like media. Somebody else was using it to like think of like as you watch a TV program, you know, and sometimes you may want that and sometimes you really don't want that, depending on what it is. But yeah, it was an interesting kind of thought-provoking measurement. Another expression along these lines which I like is the principle of least",
    "ADnJyZ8CoVc": "Welcome to the Real Python Podcast. This is Episode 118. How do you start building your project documentation? What if you had a tool that could do the heavy lifting and automatically write large portions directly from your code? This week on the show, Christopher Trudeau is here bringing another batch of PyCoder's Weekly articles and projects. We talk about a Real Python step-by-step project from Martin Bryce about MkDocs. The project walks you through generating nice-looking and modern documentation from markdown files and your existing code's docstrings. The final step is to deploy your freshly generated documentation to a GitHub repository. Christopher talks about a pair of articles arguing for and against using Python dictionaries. The first article, \"Just Use Dictionaries,\" pushes to keep things simple, while the second article, \"Don't Let Dick Spoil Your Code,\" contends that complex projects require something more specific.\n\nWe cover several other articles and projects from the Python community, including discussing the recent beta release of Python 3.11, 2FA for PyPI, procedural music composition with Arvo, building a Tic-Tac-Toe game with Python at Dekenter, a discussion covering common issues encountered while coding in Python, a type-safe library that generates SVG files, and a lightweight static analysis tool for your projects.\n\nThis episode is brought to you by Sneak. Sneak is the security platform designed for developers securing the software development lifecycle from the tools and flows devs use. Sign up for free at sneak.co/realpython, that's snyk.co/realpython.\n\nAlright, let's get started. The Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey Christopher, welcome back. Hey, it's been a while. How's your summer been? Summer? It's hot out. Yeah, summer, it's hot.\n\nThought we'd come back and do a little bit of news stuff, just kind of a short set of almost release notes kind of things. It's just sort of top line stuff. So did you want to start that? Sure, the first ones we've come across a piece inside of one of the Python mailing lists, just a couple weeks ago, that indicated that they're kind of behind on the release schedule for Python 3.11. Okay, and on top of that, already being behind, they're not entirely happy with the stability of the current beta, and so they've been discussing with the steering committee whether to add a couple more betas, and if that happens, it might mean 3.11 won't go until maybe December. Okay, I like the fact that they have timed releases, it makes things predictable, but I'd really rather stable than unstable, so let's hope it goes smoothly from there. It's currently scheduled for October, so there's a little bit of playroom in there, correct?\n\nKind of on top of that, there was a tweet and then a post on python.org about this whole trend of them calling the latest releases \"cursed\" just because of things that are happening during the releasing of it. This one, they just had a real, you know, all caps \"please help us test this release\" thing, and due to the modified release schedule and the stability concerns regarding the past beta releases, please, please, please, please, please help us test Python 3.11 by testing this beta release, and they had this whole bunch of lists of stuff. If you maintain a library or a third-party package, test the beta release. If you have code that you maintain at work, research center, classroom, whatever, test the release. If you're a multi-million corporation that uses Python testers, and even down to the single new person, I'm detecting a pattern here, test the release, yeah, exactly. If you use Python for work, research, teaching, literally anything, test the beta release. So, and it's not hard to do. I know it's some work, but getting the beta releases is not difficult to do, well, and particularly seeing as you should have automated testing for all your code anyways, it really is just a matter of installing the new release and running your own unit tests, so there you go. Should be on top of that.\n\nThe second news item in the Python world is a change with PyPI and two-factor or 2FA. They put out a tweet thread, and then there's some additional stuff on that. They've begun rolling out 2FA requirement that kind of brought up some other stuff that we're not going to deal with here, but they've begun rolling it out. Soon maintainers of critical projects must have 2FA enabled to publish, update, or modify them. So, along with that, they have a post on pypi.org that one is to ensure these maintainers can use strong 2FA, they're distributing 4,000 of hardware security keys, those are USB-style keys, either standard USB, I guess A and USB-C style. Project eligibility is based on downloads. Any project in the top 1% of downloads over the prior six months is designated as critical. Out of what, 300,000 different projects, they're talking around just over 3,000 or so. Anyway, they've notified people via email, and anyway, you can kind of look at the information there. I thought it was interesting that they chose hardware keys and they had some links to some information about that and also a really good FAQ about the program if you're curious. Someone of the details, and hopefully you can get some of your questions answered instead of screaming out into the void of like, \"What is this?\" And they had this link to getting factor right in 2019 on the Trail of Bits blog. What I found interesting about that is even back in 2019, they were talking about how what I use for authorization for most things, which is tools like Authy or the Google Authenticator app that use like a QR code kind of thing. I guess there's some potential pitfalls there, and so this article kind of gets into that. So I'll include some of the links, and I guess we've got to wait for the next level, which is going to be hopefully the authorization with our devices, which seems to be coalescing and coming together. So I hope that will make it easier.\n\nA little bit of news at the top there. Do you have any other notes there? And of course, this is all to mitigate the potential of people stealing each other's repositories, and we've talked about that in the last couple of episodes. But there's been some issues lately. So, really, as far as I'm concerned, I know that anytime this kind of thing happens, there's always a bit of a fuss. But I think they're trying to be responsible, and the internet will debate because it's the internet, but I think they're trying to do the right thing, right? And the 1% of the 1% will, you know, be upset, but hopefully that doesn't get amplified. Yeah, well, and you know, I think it should be constituted a bit of a badge of honor, right? If they want to ship you a key, that means your repo has been massively successful, right? So, yeah, yeah.\n\nWhich is nice. That gets us into articles and tutorials this week. I'm going to start with one from Real Python. It's by a previous guest, Martin Bryce, and it's a step-by-step project. I think actually both of our Real Python ones are step-by-step things. This one is titled \"Build Your Python Project Documentation With MkDocs.\" Things that I thought were really nice about this, it provided a really good set of best practices for not only kind of documenting your code internally, things like docstrings and so forth, but also like what are best practices as far as the types of things that need to be created for documentation for your own packages. Like, if you're going to put up something on GitHub and you want to share it openly, this project, what are things you should be thinking about as far as documenting it? And if you've done documentation within your code, such as putting actual docstrings in with your functions and so forth, there are tools that can help you create really nice, pretty documentation kind of automatically or even better, as you make changes, update all the documentation for you too, and actually output a set of HTML files and so forth that you can then host on a GitHub page also. And this takes you through that. It starts with a really simple example project. It's a simple calculator tool, so the functions are like add and multiply and so forth, but that's really not the point. The point is to kind of get you into the mindset of using these tools. There are some kind of big prerequisites, like you should be at the point of thinking about, quote unquote, a project. Hopefully, you're familiar with virtual environments, using pip to install packages, but also like freezing requirements, and then how to organize your code into modules and packages yourself. So there's some really good resources for each one of these. I'm mentioning on Real Python that are linked also. So there's good links to kind of get you up to speed, and then fundamentals of code documentation, and then the basics of GitHub and GitHub repositories going beyond using git on your local machine, but also pushing code in and out of a repo and so forth. In the tutorial, you work with a tool called MkDocs that produces static pages out of markdown, and then it also can pull in documentation from your docstrings using another tool that's kind of related, MkDocstrings. And then again, lots of best practices stuff, and then he's using, we've talked about lots of sort of themes that kind of help you with sort of CSS and making stuff look a little nicer. In this case, they're using the material set of standards from Google. And so there's a package called Material for MkDocs, which is sort of theming everything to make it look good. And then at the end, you're sort of hosting the documentation up to the GitHub pages. So I won't go all the way through step by steps, but you basically are setting up the environment, creating your Python package. Again, there's a sort of built-in one. You're writing your docstrings. And that is one of my first, like, kind of takeaways is I didn't know there were so many standards for docstrings. They mentioned three in the article, and the one that I'm most familiar with is the Google one. I didn't know that it was actually labeled as that, but that was the style that I've seen the most. And maybe that familiarity makes me feel like that feels like the best one for me. There's a numpy style, but then there's a Sphinx style that's the ones that are mentioned and sort of linked there. I learned there's three other ones that are also potentials. And one's there. And that led me to a kind of a cool takeaway is there's a VS Code tool called AutoDocString that you can download as a plug-in for VS Code. And it'll help building your docstrings, generating them for you. And you can kind of in your preferences choose which style you would like it to help you kind of format in there, which I think is really nice. Again, things to help kick you in the direction of doing better documentation. And that's the whole point behind that whole area of docstrings, you know, creating them under your functions, and then writing examples that you could potentially use testing through doctest, which we've mentioned recently, type hints, and providing automatic type information, and then kind of going further into like what kind of docstrings are inside of actual modules, and then starting to use those tools using MkDocs and building the documentation, and then hosting it up in GitHub. I think it's a good resource for anybody who's interested in taking this to the next level and diving in and wanting to make good-looking documentation and not knowing where to start. This, I think, will get you up and running pretty well, and lots of additional resources and like I said, best practices.\n\nYou were mentioning to me that you're more of a fan of using the Sphinx tool, right? Yeah, I've never actually compared. It's just where I started, and so I haven't had a reason to go do anything else. But most of the libraries that I maintain, I use Sphinx, and there's connectors to read the docs so you can push it all up and get it up on the main site. So, yeah, the docstrings for the Sphinx style, I wasn't that familiar with. It has lots of extra colons in there. I was just like, \"That looks different.\" But it makes sense that you kind of have to preset a bunch of rules to kind of have it identify these elements, to separate them out and put them together.\n\nThat's it. It's really just another way of tokenizing things. The, um, I do find I use it fairly often, but it's one of those things I often seem to have to look up. There's basic things like the parameter on the function or on a method. I remember how to do that because I do it often. Every time I try to put in a reference to another class and I want that to show up as a link, I almost always have to, \"Okay, is it pulling in the backslash, what?\" And I always have to look it up. So, yeah, I think that's pretty common. So, what's your first article?\n\nIt's actually two, just for variety's sake. All right, kind of a head-to-head thing. The first one is called \"Don't Let Dix Spoil Your Code,\" and it's by Roman Emkolov. Roman's premise is that as your code grows, those simple dictionaries you use to store data may become harder to maintain. One of the examples of this highlights what happens when you have a function that takes a dict as an argument. This can be really fragile, right? An upstream change to the dictionary, say renaming a key or adding a key, could impact the function, and it's not going to be discovered until runtime when the function fails. And it's really hard to type this kind of stuff and catch that with mypy or something along those lines, okay? So Roman goes on to describe the use of a good use of Dix, which is what he calls the wire format. And due to, well, the internet, JSON has sort of become the de facto standard for a lot of data interchange, and it only takes a single line of code to go from JSON to Python dict. So Roman says basically, don't stop there. Use the dictionary to populate a declared class, and do so in a way that the keys in the dict aren't in the class. They get ignored. That way, you're kind of fragile-proof, is really what it comes down to. Going that further step and getting into say, a data class or something like that gives you the safety of more type info, and someone mucking with your keys upfront won't break your code. Okay? So he goes on to talk about, you know, data classes and pedantic. Both of which give you more structure. Pedantic is a data validation and serialization library that includes a bunch of type info. I've actually been using it recently indirectly because I've been using Django Ninja, and it's built on top of PyDantic. So a lot of the serialization pieces and things like that are built using that. That's a tool for API design, right? Yeah, for API design, that's right. And then finally, Roman also points out that you can also use the mapping object, which is in the typing library, and it essentially gives you a dictionary that's a little more rigid. So you give it a pattern, and then it solidifies the keys. And then if you try to use a key that's not supposed to be in there, it's disallowed. So this gives you again more type safety. So remember when I said I had two articles? Well, the next one is called \"Just Use Dictionaries,\" and it's by David Vujic. I don't believe it was written explicitly in response to Roman's article. He doesn't mention it, but it really could have been. David's premise is, \"Don't overuse classes. Dictionaries are often good enough.\" And the first example he uses shows a data relation problem where you're mapping desks to offices. And the class-based implementation gets messy quickly because you've got this nested thing. You have to have an office type and a desk type, and the relationship between them. And the dictionary, it's like, \"I have a list and that's it. I have a list.\" And so, of course, the dict doesn't have the type safety, but David's argument is, \"You know what? There's about a third of the amount of code here, and less code means less code to maintain, and you're probably better off from that perspective.\" Right? So he goes on to comment that, \"As programmers, we have a natural inclination to want to define objects for things. Our data often maps to physical things in the real world, so it makes sense to want to encapsulate it.\" And this goes double for those of us who've spent a lot of time in the Java or C++ worlds, because it's ingrained in you. Yeah, we're going to make classes, exactly right? And he argues, though, that this really is just often overkill. He goes on to talk about data classes and pedantic, and it's not like he says, \"Don't use them.\" He just says they have their uses, and here's some examples where they shine. But if you're not doing these examples, is it overkill? So fundamentally, David's argument is the KISS principle: \"Keep it simple, Sam.\" That's what the second S stands for, right? Silly, sure. So these articles have varying viewpoints. Something neither of them really talks about, though, that I find is important, is scale and scope. They both seem to be doing it this way, and my argument is, okay, are you maintaining a million lines of code? Well, Roman's got a solid argument for you. Are you writing something smaller? Well, then Roman's overkill, and David's approach might be best. That's what I was thinking about. In that",
    "1LIOH18zsdM": "Welcome to the Real Python Podcast. This is Episode 119. How do you process and classify text documents in Python? What are the fundamental techniques and building blocks for natural language processing? This week on the show, Jody Burchell, developer advocate for data science at JetBrains, talks about how machine learning models understand text. Jody explains how ML models require data in a structured format, which involves transforming text documents into columns and rows. She covers the most straightforward approach called binary vectorization, and discusses the bag of words method, along with tools like stemming, lemmatization, and count vectorization. \n\nWe jump into word embedding models next. Jody talks about WordNet, the Natural Language Toolkit, Word2Vec, and Gensim. Our conversation lays a foundation for starting with text classification, sentiment analysis, and building projects with these tools. Jody also shares multiple resources to help you continue exploring NLP and modeling.\n\nThis episode is brought to you by Sneak. Sneak is the security platform designed for developers securing the software development lifecycle from the tools and flows devs use. Sign up for free at sneak.co/realpython. \n\nAlright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey Jody, welcome back. I'm excited to have you on the show. \n\nYeah, I'm really happy to be here and I'm super excited about the topic we're going to talk about today.\n\nYeah, when you presented this stuff to me, I was like, \"Oh wow, this is going to be great.\" There's so many questions I have already, and so we have like a shared document where we're kind of throwing stuff back and forth, so as usual, we'll have tons and tons of links. \n\nSo if this is something that you're interested in exploring, I think we're going to give you a bunch of knowledge to kind of walk in and be a little more familiar with the topic, but also maybe some good resources for you to play with this.\n\nYeah, and that's really my goal here. I kind of came into natural language processing like cold. I didn't train in this at all, and this is what I was doing in my first job out of academia and industry. And when I first got started, I was like, \"What the hell? How are you going to put a piece of text into a model? It didn't look anything like this tabular data that I was used to working with in previous work that I'd been doing.\" So what I'm kind of hoping is we can break things down a lot today and be very practical and give people something that they can take away and try at home.\n\nDefinitely. Yeah, that's going to be the goal for all the data science topics that we go forward. I feel like there's a lot of people that converse about these things, and it all seems so lofty and not touchable by the non-anointed monks of the field. And we definitely want to break that barrier and get you in and playing around with this stuff as much as you can because I think it's really fascinating, and it allows you to at least understand it even if this isn't your focus per se. I still think there's some nice usable things, and also there's a lot of this technology being used on the fringe of all this stuff, and we'll definitely get into that too. Like where is this being used in our industry? \n\nCool. Alright, so where do we start? \n\nI guess maybe we could start by having a chat around things that have been happening with natural language processing lately. So the one that comes to mind for me is the stuff that was happening in June with this Google engineer who basically thought that Lambda, the dialogue model, had become sentient. Do you know the story about that? \n\nI know a little bit. I did not read the New York Times scripture, so I hit the paywall pretty quick. But I did find an article, and I'll include that on Medium. The article's titled \"On the NYT Magazine on AI: Resists the urge to be impressed.\" By Emily M. Bender. She's done a bunch of other, I think maybe like a side thing. I feel like a lot of people have to do that today. There's so much hype around it. \n\nSo what was the story there? Because again, I didn't dig too deep into the Lambda thing. \n\nThere was basically a Google engineer called Blake Lemoyne. He was working testing Lambda, and Lambda is a model that Google says they've developed in order to help power chatbots. So what they did was, yeah, they specifically trained it on a whole bunch of examples of dialogue. So it means that, you know, if you use these kind of current generation language models, they sound quite convincing, but this one works better than others for having a conversation. So Lemoyne was testing out this model, and he's a spiritual guy. And when this model mentioned having a soul, he sort of started believing then, \"Okay, this is a sentient being. It's communicating with me. I want to protect it.\" So he had good intentions, right? He tried raising ethical concerns within Google, and they pushed back. So he published transcripts from his conversations with Lambda outside the company, and this was a breach of confidentiality. So Google fired him. \n\nIt's a really interesting story. And if you read the transcripts, they do kind of feel sentient. But I read through that article that you sent. This was written pre this whole Lambda hype. This was the article you sent was about another model, GPT-3, which we'll also be talking about. \n\nYeah, I read a really great article, which I've shared with Chris. I'm guessing you're going to, oh, yeah, I'm sure. Yeah, that was good. Basically, this author gave this really wonderful description about why this sort of sentience that we see in these language models is not true sentience. And what they said was, you know, as humans, when we learn language, we learn it for a reason. So we learn it to express these sort of feelings and behaviors we have within ourselves. So they gave an example of, you know, say I bite an apple and I have a sensation that that apple is crunchy and sweet. I want to learn language to express these concepts. But language models learn language just by seeing all of these relationships between words in a sentence and learning the probability of them co-occurring. And it's done in this very deliberate way. It's not really done to express anything. It's done to mimic this process of what we do to express sentiment. So it's fascinating, but it's kind of an illusion. They don't have general intelligence yet. They just are very convincing. \n\nWell, that was what immediately made me go back in time and think about Eliza, which was created in 1964 or 1966 in MIT. And it basically used pattern matching and this idea of substitution methodology to basically create the illusion of, you know, talking to a psychotherapist. And so it would just, you know, tell me more about that, you know, it would like, you know, what is the connection, do you suppose? And, you know, it would ask these kind of good general questions like, you know, what is the connection, do you suppose? And, yeah, can you think of a specific example? And it's like, you know, these are good questions that a therapist would ask, but they're not prompted on necessarily what you're truly saying. \n\nYeah, there's a bunch of models of that that you can try out. It's kind of a cool Python project if you will to build an Eliza. I'll see if I can find a good Python example of it, but I've seen a few that are just running. \n\nSo we've been here for a while, I guess. \n\nDefinitely. \n\nSo you wanted to kind of dive into, you know, kind of the understanding of this and going past like early things like Eliza and stuff like that to actually looking at text and speech and seeing what's in it. And there's a lot of sort of layers to it. And so we're going to do our best to kind of dig through them and see how far we can kind of get and maybe we might split this up. We've talked about that already. If you need to based on that because we don't want to overwhelm people. \n\nExactly. Let's get in there. \n\nSo, how do we even start to tear this apart? \n\nI guess I said like I want to skip over sort of the earlier stuff and what I want to get started with is stuff that's still relevant now. So I don't want to give a history lesson because that's not really useful. What I want to start with is sort of how we can restructure text in such a way that it's useful for tasks like classification or sentiment analysis or anything that you might want to use for feeding into a machine learning model. And I want to talk about the ways that we can represent text in a way that a machine learning model can understand starting from sort of the simplest approaches that people are still using and then working up to how you can actually get your hands on stuff like GPT or BERT and be using these latest cutting-edge models. \n\nYeah, let's look at that because that definitely is what I was thinking about. Like, you know, what do these columns and rows per se mean? And that definitely makes sense to me that you can't just take a raw paragraph and feed it into a Python program and, you know, kind of understand it. So cool. \n\nAnd I used to always kind of think of it as like, you know, kids with that block game and it's like you've got like a triangle and you're trying to shove a square in there. Like that's sort of how it felt. \n\nSneak doesn't just find vulnerabilities in your code, open-source dependencies, containers, and cloud infrastructure. It also provides expert remediation advice and automatic fix PRs so you can merge and move on knowing that your applications are secure. And since Sneak was designed for developers, it works right from your favorite dev tools like PyCharm, Git CLI, and more. Start your free forever account at sneak.co/realpython. \n\nSo the first approaches that I'll be talking about are kind of generally called bag of words. And the reason that they're called this is because the approach you're taking is trying to capture meaning about a text by looking at the words that it contains. It's a pretty straightforward idea. \n\nIf I'm reading a piece of text and it mentions cats and dogs, I can probably infer that it's about pets. If I'm reading another piece of text and it's about wheat and corn, it's probably about grains. So it makes me think of the instead of like scrabble being individual letters, there was like those poetry magnets that you could put on a fridge. \n\nYes, yes. \n\nSo you just toss them all in a bag. \n\nI used to live with a couple of liberal arts students and of course we had several sets of those, especially the Shakespeare one. You know, there you go, starter kit for liberal arts. \n\nYeah. So the kind of most simple way to think about this is I have a bunch of documents and what I do is I take every single word that occurs in those documents and I create a column for every single one. And then what my row represents is a document. And then what I do is I go along and I see whether the word occurs in that document or not. If it does, I put a one in the column and if not, I leave it as zeros. So this is called binary vectorization and it's basically the stupidest, most like naive approach you can take, but it does actually get you results if you've got pretty good separation between your documents. So like you want to do classification and you have your documents that are about crime tend to focus very heavily on words that are just about crime and your documents that are about sports tend to focus very, very heavily on that. Then it can actually get you pretty good predictions in a model. So I want to say it's a dumb approach, but sometimes dumb is fine. \n\nWhat I do want to talk about though is you might already be seeing some issues with doing this and the first issue is like if you think about a really big collection of documents, they're going to have like tens of thousands, maybe hundreds of thousands of words and a lot of those are only going to appear once. And if you think about this when we train machine learning models, what we're trying to do is get them to see patterns. So with this approach, if we have columns that represent words, what we want the machine learning model to learn is okay, well if the word \"cat\" occurs usually in documents that are about house pets, then okay, I can see that if a new document includes cats, I could probably classify it as about house pets. But if it only ever occurs once, then, you know, it's useless. You don't want to include those words. \n\nSo one thing you can do to clean up is just include your N most common words in your collection of documents. \n\nOkay, so you're sort of filtering and sort of setting a scale of saying this should be within this many times mentioned. \n\nExactly, exactly. And it sort of depends with these models. If you have more occurrences, especially if you've got lots of categories, it's better to have more than 10, maybe more than 15. There's no kind of formula for it, but it's not good to have very rare terms. It just doesn't do much for the model. \n\nThe next thing I want to talk about is another problem, which is something you might have also thought about. If we're literally taking words, raw words and we're splitting every single one into its own column, you're going to have problems where, say, \"cat\" and \"cats,\" which mean the same thing, end up in different columns. \n\nSo, or \"feline\" or \"yeah,\" \"yeah,\" \"yeah,\" \"yeah.\" And we'll talk about how to solve for the feline problem in a second, but we can do some tricks to solve for the grammatical differences. \n\nSo one is called stemming, and another is called lemmatization, which is a ridiculous word. \n\nSo basically, both of these are approaches where you're kind of trying to reduce words that mean the same thing, so like \"packing,\" \"packed,\" \"packs,\" to the exact same root or stem. Stemming just does it in a kind of dumb way. Like it doesn't really do it in a grammatically correct way. \n\nLemmatization, however, will apply proper grammar rules to try and, you know, correctly resolve something like \"am,\" \"is,\" to be. \n\nStemming is literally like tearing the word apart and like kind of doing \"cat,\" \"cats,\" the stem of \"cats\" is just the word \"cat,\" and there's an \"s\" pluralizing it or whatever. \n\nOr, you know, if they're verbs, then you can think of the \"ion\" version, yes. \n\nAnd then what's the limitation is more of the meaning, yeah. So limitation is more that it will actually apply, like, correct grammar rules. So what it'll do is it'll go through the text and be like, \"Okay, this is a verb, this is a noun, this is an adjective.\" So if I want to do, like, I want to take it back to its base form, which is called the lemma, I basically need to, oh, okay, I need to convert this particular verb in this way so that it's, you know, the infinitive form, the base form. \n\nYeah, it's really effective in terms of, like, how it can actually convert text. But the issue is, you can imagine, like, it's extremely expensive. So when you have huge amounts of text, lemmatization, I usually don't use it because it's just so expensive. You usually just go with stemming. And you mean expensive as far as the time and the resources, exactly. It can eat up, yeah, yeah, yeah. It is free to use through a package. \n\nYeah, yeah, yeah. \n\nSo, that's going to cost you. \n\nWell, we will be coming to that later, but, uh, luckily at the moment, we're not in that territory yet. \n\nOkay, cool. And then the final is, again, when we're splitting every single word into its own column, we can miss meaningful combinations of words. So, a couple of jobs ago, I worked at a job board, and I was helping to improve the search engine, okay? And, uh, this was a job board here in Germany. So, at the time, we didn't have \"Rust Developer\" as one of our search terms. And obviously, \"Rust\" and \"Developer\" mean something very different to \"Rust Developer.\" \n\nAnd when people searched for \"Rust Developer\" on the site, it got them results for developer jobs in this town called \"Hust\" in Germany, which had this theme park. And basically, like, you got all these recommendations for jobs in this tiny little theme park in this town in the middle of nowhere in Germany. \n\nYeah, not the language \"Rust\" at all. \n\nSo, yeah, not the language \"Rust\" at all. \n\nBut, alright, yeah. I was thinking like \"Rust Developer\" could also be like something that, you know, you get like painting jobs or you get other kinds of weird oxidation experts. \n\nYeah, I think we had a few of those as well. It was a mess, but yeah, then once we figured that out, it was fine, and we actually gave the poor \"Rust Developers\" their correct jobs back. \n\nSo you had to tie the words together, yeah. \n\nExactly, and this is called capturing engrams. So, N, okay, N basically means like it's a number. So, it could be two grams, and that's, you know, terms that are comprised of two words",
    "gsMBV_XkeOw": "Welcome to the Real Python podcast, this is episode 120. Is there someone in your life you'd like to inspire to learn Python? Mission Encodable is a website designed to teach people to code, built by two high school students. This week on the show, Anna and Harry Wake talk about their creation and motivating people to start coding. We discuss why they decided to build the site. Initially, Anna and Harry felt the site would be for other students but soon felt it could be helpful for anyone interested in starting to code in Python.\n\nWe cover the project-based approach and how they implemented the interactive browser-based tool replit.com. We talk about learning Python in the classroom and how they found additional books and tutorials to supplement their coding education. We also cover how Anna and Harry created a resource hub to help teachers take advantage of the site.\n\nThis episode is brought to you by SeaData Software, the easiest way to connect Python with data. SQL access to more than 250 cloud applications and data sources. All right, let's get started.\n\nThe Real Python podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHi Anna and Harry, welcome to the show.\n\nOh, thank you for having us. It's really nice to be here.\n\nYeah, so you guys reached out to Dan through a couple of people at Real Python that you were hoping that people could check out the site that you had created. Dan passed you to me, and I was like, \"Oh, well, I have a bunch of questions for them, so maybe they should come on the show.\" We've kind of been going back and forth about how we can get you on the podcast. Maybe you could talk a little bit about yourselves. You're both young students and where you're from.\n\nI'm from London in the UK, and Harry's from Manchester, also in the UK. We're both students in Year 10, so we're about 14 and 15. I don't know what it is in the US, but that's what it is here.\n\nOkay, Year 10. And Harry, you live outside of London?\n\nYeah, I do. I live in Greater Manchester. I go to a comprehensive school where I've been taking computer science recently.\n\nOkay, awesome. You have created a website called missionencodable.com. Maybe you could tell us a little bit about the site and your goal for it.\n\nMission Encodable is a website that teaches young people to learn code, aimed at 8-16 year olds, but obviously anyone can access it. It offers beginner-friendly coding tutorials that are a little bit different. We're broken down into levels, and at each level, you make two projects. Alongside teaching you all about how to code using Python, we also give you exercises so you can test what you've learned. Then we'll show you how to make two really fun, cool games. So we're putting that theory that you're learning into practice and getting you making projects and games all by yourself.\n\nAnna, do you have anything to add?\n\nNo, but we really hope that it can be used in schools because we think it will be a really helpful resource for teachers and also at home for students who are interested in it. So that's what we hope in the future will happen.\n\nMaybe we could talk a little bit about how you came up with the idea for the site. Have you done a project like this before?\n\nWe've done a few projects before, but none of them have been on this scale, I'd say. But I think we came up with this on holiday in Anglesey in Wales, and we've been thinking about a new project for a while. I don't actually remember how we came up with it, but probably we just thought it'd be really nice to create something because we both really like Python and we wanted to share that with others.\n\nNice. You kind of mentioned your goal of directing it towards 8-16 year olds who are interested in learning Python. Are you looking at expanding the site and adding more lessons and levels to it?\n\nYes, so we've got lots more things planned for it, and we're hoping that although the tutorials might be aimed at 8-16 year olds, it's really great for anyone looking to get an introduction into Python. We might expand that in the future so that everyone can use it and just get a feel for it and sort of get their first introduction, write their first \"Hello, world!\" and get hands-on with the code.\n\nAnd we know that both of our grandparents are doing it, so that's really nice as well.\n\nOh, you've got some beta testers or just testers internally. That's nice.\n\nWhat are other places that you've shared it? I know that you guys have been on a couple of podcasts already, but what are other ways that you've been promoting it and sharing it?\n\nYes, we both obviously go to school, and we've got computer science teachers there who teach younger students, so we've told them a little bit about it. So at my school, they're running a coding club with some of the younger people that I go and help out with. And also, they've been sharing it with other teacher friends across the country, so that's been really nice just to get it used in a few schools to see what people think.\n\nWhat were the podcasts that you were on?\n\nSo we've been on Craig and Dave, who are two computer science teachers. They've got really great YouTube channels for anyone studying computer science or interested in it. So we went on their show. That was the first one. Then recently, we've been on Learning Dust and House of EdTech. Those are the three that we've been on so far. But I don't know if those last two have come out yet. They might come out before this one comes out. So it's one of these things during the summer time sometimes we record in advance. So, yeah.\n\nSo if they're ready, I'll include links for them. And then I was going to mention this later, but if people wanted to learn more or follow kind of the updates to Mission Encodable, I noticed a little Twitter link at the very bottom of the page there. So people can follow along with updates there. Great. Yeah, thank you. We are @MissionEncodable on Twitter. If anyone would like to follow us and see what we are up to, we'll share lots of updates and resources on there in the future. Hopefully. So yeah, yeah, give us a follow.\n\nI liked the types of projects that you had people create in them. I did die multiple times playing Treasure Island. And the guy chose all the wrong answers initially. And then the game you mentioned, the age thing, the 8 to 16 year olds, the age game really missed my age by a bit. But you had kind of neat ways that people could potentially expand those games, which I thought it's kind of nice. They're both kind of launching points that people can kind of look at, create something, and then potentially share it with somebody else. And I also rock, paper, scissors, which is a very popular getting started programming. It's a good tool. And I was wondering, have you heard of the variation for rock, paper, and scissors?\n\nI actually haven't. No, could you tell us more about that?\n\nYeah, there's a variation. I guess it was on Big Bang Theory, but there's a lizard and Spock additions to it. And so yeah, so that's another thing that you can look at when one of our real Python authors modified our edition of rock, paper, scissors and added those two hand symbols to it too. I like that you're teaching modern Python stuff in there, like you're teaching about F-strings and other areas of Python. Are there other parts of Python that you start out initially getting people going with, creating strings, doing input, interacting with the user, setting up variables, and I was wondering, like, what are other parts of Python that you're interested in teaching and looking at adding in in the future?\n\nWell, we're in the process of adding another two levels, and I think one of those is on dictionaries mainly. And the next one is about subroutines and kind of scope, so it gets a little bit more advanced. Yeah, you start to be able to create projects like Hangman and Quiz games and stuff. So that will be really fun.\n\nYeah, early on, you're also, in order to do one of the games, you're having them import random, and so you're kind of having to teach about modules and those kinds of things. Are these things that you've been learning in your classes? Is Python one of the main classes that you have for computer science?\n\nYeah, Python's part of both of our GCSEs over here in the UK, for those not familiar, which is the exams you take at the end of secondary school, essentially. And half of mine is on Python programming. So that includes all kinds of things. I think it goes pretty much up to sort of iteration and for loops and that kind of thing. And that's how advanced it gets. So we might be going a little bit beyond that and what we're teaching soon. Although, yeah, we've had an introduction at school.\n\nNice. How has the response been to it? I mean, you mentioned that you've shared it with your teachers and you've mentioned it on a few different shows and gotten a little bit of press. How has the response been to it for you guys?\n\nWell, I think it's been really positive actually. We've had a few people say, \"Oh, maybe you could include video tutorials or some kind of audio thing,\" which I think probably would be a good idea. So we'll think about that and just like little other things we can make to make it better. But in general, it's been really nice for people to let us, like you come on your podcast and it's been really nice to see that people like it.\n\nYeah, definitely. One of the things that I found unique about the whole process is that you're using this replit engine, r-e-p-l-i-t dot com. Is that right? And I find that as a programmer who's been working for a long time, it's kind of nice in the sense that you're teaching a bunch of advanced ideas of having this interactive repel of showing the demonstration people can kind of run the end result so they kind of know what they're getting, which I think is really important with all sorts of coding projects, which is great. But then they're able to have their own replit account and fork it and basically have their own copy of the code that they can explore and play with, which I found kind of unique. How did you guys come up with that? Is that something that you were shown at my school at least? It's quite common, the forking the replit and then using your own copy. And normally we do use replit as well. So and it makes sense because it's browser-based as well. So it's very easy to get started. I don't know if Harry has anything to add to that, but yeah. So I think, well, we've both been introduced to replit, I think, at school. We thought we might explore ways we can use it on our website. And actually, we think it's been really good because often if we make people download their own IDE, it'd be quite difficult for them because often you either have to pay for it or it's just really difficult to download, particularly in schools. So we thought it'd be a lot better to use something browser-based that's obviously free and interactive. So it's just a really quick way of getting Python writing some code straight away.\n\nI think that's really a neat way of doing it. And it kind of teaches some of these interesting ideas of managing code somewhat. In other projects, like, in this case, for Mission Encodable, are you using tools like Git or GitHub?\n\nYes, a lot. Okay, yeah, we have a big GitHub repository that I think all of our code is on. And my dad keeps giving us lessons about all the good things that we can do with it.\n\nThat's nice. So that's been good. I was wondering if that's something that would be taught in a school at that point, or is that kind of like maybe a little more advanced kind of stuff that you've been able to find on the side of your education at school?\n\nThat hasn't been taught in my school.\n\nNo, mine neither, actually. But I think that we've found it to be really good to use because dad suggested it and it's really nice to be able to track change and what's been done. And that seemed like the professional approach, so we've got a really big repository. We use VS Code ourselves to edit that.\n\nYeah, and it's a good way for me and Harry to share our code as well, being in different locations, so we can share it and review it and collaborate on it.\n\nI can see that in there. [Music]\n\nSeaData Software: Connect, integrate, and automate your data from Python or any other application or tool. At SeaData, we simplify connectivity between all of the applications and data sources that power business, making it easier to unlock the value of data. Our SQL-based connectors streamline data access, making it easy to access real-time data from on-premise or cloud databases, SAS APIs, NoSQL, and big data. Check out cdata.com to learn more. [Music]\n\nIt's a really pretty site. Who's mostly in charge of the design? Is that both of you?\n\nI would say Harry.\n\nThere's a nice pause there.\n\nYeah, I like the color scheme and the design. It looks really nice.\n\nOh, thank you. Yes, so Harry's parents, if we're going to mention or not, own a retail tech startup. So they've been really nice because they've showed us their brand guidelines. So that's really helped us get some ideas and inspiration for our website. So we know what to do with it. And then obviously we both collaborated. I've done quite a lot of wireframing in Figma. That's what I use to sort of design what page is going to look like. And then we basically share building them. So yeah.\n\nYeah, it's been really nice to hear that. I'm glad that you like look at it.\n\nYeah. What are you using? A different framework for tying all the web elements together? Is that in Python also?\n\nWell, we use a JavaScript framework called React to make the website. And that has CSS as well. Okay, but it's not with Python now.\n\nOkay. And then are you hosting the majority of the web stuff is not using something like a Flask or Django or some of these other libraries you might have heard of? It's in this case, React, you said?\n\nYeah.\n\nOkay. Great. Is that something that, again, you kind of have done on the side to kind of learn more about it?\n\nYeah.\n\nI don't know what your experience is of trying to learn JavaScript versus learning Python.\n\nWell, I think we both went through a big Udemy course, okay? I'm not sure that we quite finished it, but yeah, that took us a really long time. Yeah, it did take a long time. Yeah, because I think when we first started making our website, I think it's Alan's dad that said, \"Well, maybe he wants to use React for it.\" But none of us really knew all that much about React. So we had to teach ourselves, we bought this enormous Udemy course, which is a website where you can learn all kinds of things for these video tutorials. And I think, I don't know, it's like 36% of the way through. We are now, so yeah.\n\nAll right. I think the results are good. You're definitely getting what you need out of it at this point. So that's great. That brings me to a couple of questions more about yourselves in learning programming. You already kind of mentioned that part of your school and the level exams have Python in them. Are they teaching you other languages or did they start with Python for any kind of CS stuff?\n\nAt my school, it's Python at GCSE, and then at A level, you start to do more kind of functional programming. So languages like Haskell, but at GCSE, just Python, I think.\n\nOkay. Yeah, so I'm also doing Python. So I think the exam board that I'm taking it with basically decided that everyone doing it is going to learn Python. So that's at A level. And then 50% of our exam is on screen programming using it. So I think it does vary, but Python is the main one that's used, certainly in my area at least. So yeah, it's quite popular.\n\nOkay. I guess this is kind of related question as far as schooling. How much of your schooling has been remote over the last couple of years?\n\nWe haven't had any this year. There was, I think the last time school was remote was kind of January 2020.\n\nOkay. But that was it, I think. Maybe I meant 2021 there, I think.\n\nOh, yeah. Yeah. I did, sorry, because that would be before.\n\nSo yeah, the first lockdown, I think was sometime like March, April 2020, was it? And that's when we first went remote. We were remote for a large chunk of 2020. 2021, it was kind of on and off, wasn't it, I think?\n\nYeah. And then...\n\nBut I think the only time for us it was remote was kind of winter.\n\nYeah. And then we've been in school the last year or so, ish now. So that's been a lot nicer, I think.\n\nYeah. In some ways, working with a computer and being remote, did that change your ability to learn in some ways and change the way that you kind of were able to learn about programming? Like, I would think instead of being in the classroom and necessarily book-based, that somebody who's interested in this stuff and interested in computer science could kind of explore some more things like that. Or did it change your learning in other ways?\n\nI'd say yeah, it definitely changed the way that we learned because beforehand, I'm not sure if I'd have been open to just teaching myself stuff. But because we were quite independent during it, obviously like we'd be told what to do sometimes, but we got very used to the concept of teaching ourselves things just online. And from that, that's what made me want to start learning programming more and teaching myself a lot of stuff without always being told exactly what to do. So it made me quite independent, I'd say, and sort of introduced me to the world of learning remotely and independently.\n\nYeah, you already mentioned the Udemy course and some of these other things that you were able to find. What was your experience, Anna?\n\nYeah, similar to Harry, I think in those years, for me, it was kind of year eight and nine. So I don't know if that's just something that my school does, but that was really the year that learning Python really picked up. So we started to do a lot of kind of online learning of Python and a lot of replete. And also we had a lot",
    "WVM09Ri4MbI": "Welcome to the Real Python Podcast. This is episode 121. What's the big breakthrough for natural language processing that has dramatically advanced machine learning into deep learning? What makes these transformer models unique and what defines attention? This week on the show, Jody Burchell, Developer Advocate for Data Science at JetBrains, continues our talk about how machine learning models understand and generate text. This episode is a continuation of the conversation in episode 119. Jody builds on the concepts of bag of words and word defect and simple embedding models. We talk about the breakthrough mechanism called attention, allowing for parallelization and building models. We also discussed the two major transformer models, BERT and GPT-3, and along the way, Jody continues to share multiple resources to help you continue exploring modeling and NLP with Python. Alright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey Jody, welcome back. Thank you, I'm very excited to be here again. Yeah, yeah, we're going to continue our conversation. We dug pretty deep into the first sort of two techniques of understanding text using these data science techniques and then also giving people lots of resources for doing that with Python. And now we're kind of building on top of those two techniques. It was bag of words models and then sort of word to vec. Yeah, ready to dig into our next level.\n\nWhere we left off with word to vec was that we were taking every single word in a set of documents and converting it into a vector. Some of you may have been wondering, well, what happens when a word has different meanings in different contexts? So let's say something like a riverbank versus Bank of England. Well, the problem is, as much as I love my wonderful word to vec, it's a bit stupid on that account and it can't tell the difference between them. So all meanings of a word will just be collapsed onto the same token. And this can obviously cause problems when those meanings of the word are quite different. So not always the best. What the newer models are attempting to take into account, and we're talking now about the current generation of models that are being used, is the total context for a word in a sentence or a paragraph. Okay, so going beyond this little window that we were doing inside word to vec, which was maybe the three or four words that this word is around, more phrase-like. Now we're kind of going into like a full sentence or more. Exactly. So let's take like a really classic example. So let's say we have the sentences \"I want to go to France at the end of this year. I was thinking of enrolling in some courses and picking up some new skills.\" So now I want to learn. What would you complete that as, Chris? \"How to cook.\" That's why I would go to France. Ah, true, actually true. So what we're hoping the model would predict is \"French,\" though. But you know, maybe the model is tricking me, right? Yeah, that's good. Yeah, I want to learn the language. So obviously, you kind of need to understand the context right from the beginning of this sequence in order to infer that we're trying to get that prediction of French or learning to cook could also make sense. So the original approaches tried to basically go along a sentence or a paragraph word by word in the exact same way that you would read it left to right or right to left, depending on the language, and kind of develop this little memory for what the model had already seen. The hope would be the model could remember this French, sorry, this France that I'd seen right at the beginning and then go, \"Ah, okay, I need to output something related to that.\" And, you know, the logic was sound. These original models called recurrent neural nets, and then there was a sort of special version of those called long short-term memory models. But the problem is, in practice, they didn't actually work that well. And there were two reasons for this. The first is that, like, after around 20 words, this memory started failing in the models, and pretty much information from the beginning of the sequence was forgotten. So in this phrase that I said, it definitely would have forgotten France by the time it got to the word that it needed to predict, and it would probably be like, \"I want to learn to swim,\" or something like that. What? I'm trying to think of why it's losing that. What is it that, um, is it the amount of actual quote-unquote memory, or is it just it got too complex thinking about all the contexts of everything coming after it that it lost all its meaning? Yeah, it's a very, very technical reason, and I'll sort of try to explain it in a simple way. So basically, these models, they have a lot of different layers, and you sort of do transformations of the data at each layer, and these particular models were using a transformation that sort of squashed the data, and it meant that the deeper and deeper these models got as you sort of tried to send data back through in order to train it, it just got so squashed that there was no signal anymore. It's what's called the vanishing gradient problem. And yeah, the complexity of the model was just kind of too big, and you know, you just couldn't send information all the way back through and set the weights properly. The other reason, actually, though, that these models kind of lost popularity was like a practical reason. You can imagine because you're processing sequentially, you can't actually scale that well. Because as the length of your sequence increases, your processing costs and times also grow, and you can't parallelize that entire thing. So you imagine you're trying to feed in like these huge sequences and train these really big models, it's not very attractive. Okay, so it can't, you know, the advantage of parallelizing, parallelizing, I always mess that word up. I missed the extra L in there. It, uh, the problem is that it has to keep all of that in one process to know its relationships. It could potentially do a paragraph over here, a paragraph over there, but they're not going to necessarily be able to share the context with each other. No, okay, no, they can't. So this is, yeah, like a pretty huge problem, especially when you start thinking about the size of these models and the fact that, like, the reason we've been able to get a lot of gains with deep learning models is because of this parallelization and training. So there was a paper that came out a few years back called \"Attention Is All You Need,\" and this basically rocked the natural language processing community to its core. What it proposed was a mechanism that's called attention was already known, but it sort of proposed using it in a new way to basically solve all of these issues and create models that can learn about the context in which words occur, but in a way that can be parallelized. So I'm going to give a very dumbed-down explanation of it. It's totally fine, yeah. Sure, I think it's for the best to keep people paying attention. Oh, God, I went through so many iterations of this, guys. Like, I really, I tried my best to explain it, and I'm like, you just can't. It's just, yeah, maybe someone more clever than me, but I couldn't. So we're going to do a really dumbed-down version. So basically, where we start is with these same word embeddings, like the ones that Word2vec created. So every single word starts with a single word embedding, but then what we do is we start adding in information. So the first bit of information that we add in is a weight to represent the position of a word in a sentence. So obviously, we're looking at an input sentence here. I should clarify that. And then what we do, an input sentence, what does that mean? Oh, input, input, sorry, like, okay. Okay, accent, accent, yeah, that's right, yeah. So we start with this sentence, we have word embeddings, so these vectors from like Word2vec for each one, okay? And then basically we then add some information, so we weight those word embeddings based on where the word sits in the sentence. So you can see already we've got more information than we would have with a simple Word2vec model. But where the attention mechanism comes in and sort of where this sort of differentiates from something like Word2vec is what you do is you generate weights for each word in the sentence to represent how much its meaning or grammatical form is dependent on other words in the sentence. So it's a bit of a weird concept, but no, I'm kind of grabbing it in the sense that it's like grammar. If this is the subject of the sentence versus the, you know, the verb or, you know, the different kind of components, like if this is just describing the other words, like, you know, the sort of relationship between the words. Yeah, yeah, exactly, exactly. And you can basically represent these relationships between words in, you know, just a matrix of values. So it's like for the first word, it will have the amount of attention it needs to pay to all of the other words in order to gain its meaning or grammatical form. And so forth for every single word in the sentence. And then you basically combine this information about the word embeddings, the basic meaning of the word, its position in the sentence, and then how much it interrelates with all of the other words in the sentence to have its final meaning to get a final representation of that word within the context. Okay, you basically train these models in different ways. We'll kind of touch on a few different ways with BERT and with GPT, but the general idea is over many, many training examples, the model starts to not just internalize words, not just internalize word meaning, but it starts to internalize rules of language that we understand when we read. So this is sort of like what I was talking about. These models are iteratively over time gaining more and more of that internal understanding of what language is conveying when we read. It's pretty cool. It's again, almost like magic, but it's not. It's just math. Yeah, yeah. Well, in the sense that it sounds like the models are not having a single training session. They're being sort of retrained and kind of, you know, almost like an athletic regiment. Yeah, yeah. Yeah. So yeah, becoming a real language model. Okay. Okay. So I don't want to kind of spend too much more time like going into deep theory, but the kind of thing that you need to know is that attention is the basis of what you'll see called transformer models. And this is what you'll see this current generation of language models called. So it's just a particular way of putting together deep learning models in a way that, you know, is based around attention. So the ones that I want to talk about are BERT and GPT, as I said in the last episode, but I think you alluded to the fact that we have like a few, a few really fun names. Yeah, yeah, definitely, especially for, especially for the BERT ones. Yeah, they're having, you know, I guess this is the one chance, uh, science people get a chance to play around is in naming. So, and that's the thing. I can actually tell you, like from my time doing academic research, if you can come up with a good acronym, you are king, man. Like people love that. So, I can imagine that's funny competing with each other. Cool. So let's just kind of talk quickly about BERT. So BERT basically is a general purpose language model, and it's kind of designed to be like a Swiss Army knife of language models. And you can use it along, like across many, many different tasks. Such as, I don't know, do you want to detect if a sentence is grammatically correct? Do you want to detect if question-answer pairs go together properly? Okay, do you want to detect, yeah, like, so I can think of like a right away, real-world uses, things like Grammarly or something like that. Exactly, you know, a tool that actually is identifying things like that. Okay, cool. Yeah, and BERT was kind of the first of the transformer models to really get like mainstream recognition. It was the first one I ever played with. And who created this one? This one's from Google. It's a 2018 model. Okay, it's funny now, like BERT, it was such a big deal when it came out, and now it's such a teachy little model compared to like some of those stuff that's being used, but it's still like a really important and very accessible model to use. And I'll talk a little bit about, or in a little bit, I'll talk about how you can use it yourself. Okay, nice. It's not walled off from the general users. No, no, definitely not, definitely not. So the other one I wanted to talk about is GPT. So as we talked about last time, there are three different generations of GPT models. So GPT-1, 2, and 3. So GPT is not a general purpose model. It's a text generation model. And it was basically trained to generate the next word in a sentence. So, so it's kind of the reverse in some ways. It required other tools before it to be trained and built, but its goal is to actually output text as opposed to analyze what's coming in. I mean, I guess it kind of goes both ways. You gotta prompt it. Yeah, but it's funny, like text generation is like such a distinct task compared to, I would say, more traditional machine learning tasks. So like classification, it's really like, okay, BERT can do that for you. Okay, but GPT, it's very weird thinking about like text generation in the sort of context that I'm used to thinking about machine learning. It's a very other sort of task. Is that where the names kind of come in? Because BERT is what, bidirectional representation of text? And then GPT is, is that the generative part of it, pre-trained transformer? Exactly, exactly, yeah. And BERT's also, its name comes from how it was trained. So basically, it was trained in two ways. It was trained to detect and try and predict a missing or masked word in a sentence. Okay, like you're saying, the France trip. Yeah, yeah, yeah, exactly. But what they try and do is mask words that are in the middle of a sentence. So like say you had two sentences. This masked is called \"Henry, he comes from Sydney.\" Then basically, BERT would need to use quite a lot of information there. So he'll need to use, no, he, but he's not a he. The model will need to use, could be Robert, could be Albert, could be Camembert. But you can see that, you know, the masked word doesn't occur at the end of the sentence. It occurs sort of as the second word. So BERT would need to say, \"Okay, there's words on either side and also there's a he in the next sentence.\" So, you know, there's a good guess that the missing word is \"man.\" Okay. So, yeah, it's like intelligent Mad Libs. Intelligence, exactly. Yeah. All right. This week, I want to shine a spotlight on another Real Python video course. It's about a segment of data science involved in making predictions based on data. It's titled \"Building a Neural Network and Making Predictions with Python AI.\" The course is based on an article by Deborah Mosquitta. And in the course, Douglas Starnes takes you through how both machine learning and deep learning play a role in AI, how a neural network functions internally, what are weights and vectors, how to reduce prediction error, and how to build a neural network from scratch using Python. Like most of the video courses on Real Python, the course is broken into easily consumable sections. You get code examples for the techniques shown, and all courses have a transcript including closed captions. Check out the video course. You can find a link in the show notes or you can find it using the search tool on realpython.com. I kind of wanted to give maybe a bit of a taste of how far you know these models have come over you know the last few years. So yeah, that's what we started with in general. Like the idea that you know is this thing sentient, this chat bot. Yes, yeah, okay. So little story. So this job that I was talking about in the last episode at the job board, I was very lucky to work with a lot of computational linguists and linguists. So people who were super super interested in language and you can still actually access this endpoint. There's a company called Hugging Face and they have this endpoint where you can input like sentence fragments or prompts and it will use a bunch of different models including GPT-2 to generate text for you. And the thing was GPT-2 is great, but it has some limitations in how it actually generates text and detects the meaning of the prompts that you input. So let's uh let's take an example of a prompt that I put in. So why do you want this job? It's kind of a typical interview question. It has certain implications, there's a certain context, and what GPT-2 gave me is I'm a little frustrated about how hard it is to make your own money. Like, okay, like grammatically it makes perfect sense, but you would never say that. I mean, unless you're in context, yeah. I'm trying to think of the term, um, if you're going to print your own money, you're a great, it's kind of hard to actually quote unquote make your own money. It's funny, but not for the reason that you think it should be. Wow, yeah. So there's an artist, a musician, and I loved that he actually decided to name his, you know, his project Big Data. Oh, nice. It actually has some pretty good songs out there. Well, maybe that, maybe that was what happened, exactly. It went over my head, GPT, yeah, you missed the, the connotation in the musical context. Outsmarted again. That Big Data, oh, I didn't know we're talking about individual. God damn it. So yeah, so this leads me to how you can use these models, and this is actually a very interesting kind of conversation and debate that's coming up. But GPT was trained as I said in 2018. At the time, it was considered a model that was sort of prohibitively expensive for individuals to train. So it used around three billion words. Apparently, it took four days on 64 tensor processing units, and it had an estimated training",
    "iE6pQcySBDo": "Welcome to the Real Python Podcast. This is episode 122. Have you attempted to set up a Python development environment on Windows before? Would it be helpful to have an easy-to-follow guide to get you started? This week on the show, Christopher Trudeau is here bringing another batch of PyCoder's Weekly articles and projects. We talk about a Real Python tutorial for configuring a Windows coding environment. The guide contains valuable suggestions, best practices, and powerful coding tools. It also covers how to use a package manager, a new Windows terminal, PowerShell Core, and a program to manage multiple versions of Python.\n\nChristopher covers another Real Python article about using TOML in Python. TOML is popular as a configuration format for building and distributing your own packages. We discussed how TOML parsing will be added to the Python standard library in version 3.11. We cover several other articles and projects from the Python community, including technical writing for developers, a news roundup saying goodbye to obsolete Python libraries, uncommon uses of Python in commonly used libraries, a prettier ls, and a project for advanced hot reloading Python.\n\nAlright, let's get started.\n\n[Music]\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com. Hey, Christopher, welcome back.\n\nHey there. Alright, so we're going to start out with some news this week. I kind of left it all in your lap to do this week. So, um, yeah, that's alright. It's summertime, what else do I have to do? Yeah, sure. A couple of quick hits. Python 3.10.6 is out, so that's a bug fix release. The biggest part of it is there were a couple of security fixes in it, one affecting the built-in HTTP server, there was an exploit, and the other was some memory being used after it was freed in the underlying engine. So that's why you write Python instead of C so that you don't have to worry about that kind of stuff. Yeah, nice. So core developers worry about it, you don't.\n\nAnd then, following a couple days just after that, 3.11 release candidate one came out. I've also got some good news on that. A few podcasts back, we were talking about the fact that there might be a delay. Yeah, it looks like they're targeting October 3rd, so they must have got over whatever it is they were worried about and solved the problems. Nice, so looks like they're on time, which is nice. Are they considering this a cursed release because that was like the ongoing? I think you're not supposed to say it out loud, right? I think you may have just cursed it right there. So we'll see what happens.\n\nAlright, and then the second bit was Django 4.1 went gold. It's continuing on with some changes in the 4 line, adding a bunch of asynchronous capabilities. This time they've added async to the ORM, so for the high-performance crowd, that should make a bit of a difference, right? And the part that I'm looking forward to is they've changed how form rendering is done. It used to be done with some string concatenation and now it's built on the template engine. This is a weird little devil in the details thing but when you get into crafting your forms you can now use the engine the way other parts of your templates were used, so there's some potential there that may make particularly dealing with things like Bootstrap and some of that easier. Cool, that sounds good.\n\nIt's good to see the async stuff kind of improving. Also, yeah, it's a slow, steady kind of chipping away at the problem, yeah. The last one I had here, unfortunately, we keep talking about this so I just keep bringing it up, but just let people know it's out there. But there has been another set of malicious packages discovered on PyPI. 10 of them this time. A couple of them are actually looking in your local storage for tokens, passwords, and cookies. So this isn't just the AWS key things that we've talked about in the past and they're starting to get more sophisticated. A couple of them that are pretending to be other packages have copied the entire home page and the graphics and everything so that if you're looking at it quickly it looks like exactly what you're expecting, which makes it a little trickier. Yeah, and I guess just sort of a shout out to the folks at Checkpoint who keep scanning this stuff and getting it taken down. Because, you know, it's unfortunately it's a little bit of a game of whack-a-mole but somebody at least is wielding the hammer.\n\nGood to know that we have some people there paying attention. But also, that's a little spooky that they're spending so much effort to actually remodel the web pages and make it be more attractive. I have a little tiny thing on that front. This is an article that kind of related. It's from TechCrunch and the story is by Axe Sharma. The title of it is \"Protest Wear on the Rise: Why Developers Are Sabotaging Their Own Code.\" So I'm just going to leave it as a news thing but it kind of hits on one particular person that we didn't focus on last time when we were talking about the two-factor thing that was being added to PyPI for the top one percent. Well, his project fell on the top one percent and he had his own sort of version of protesting it. In this case, he really didn't want to have to do the extra stuff, was mad, you know, like \"I do this free open source thing, why do I have to add this extra stuff just for corporations and blah blah blah.\" What the story is really interesting gets into is that it then becomes into a different form of protest. Yes, there's other people protesting big corporations using their stuff and open source, but there's actually a whole bunch of devs that are using their software to sort of protest Russia and that's very interesting. So it's very localized kind of stuff that's happening with it with either messages to the Russian people about Ukraine or some other kinds of things that are doing their own active protest in that way. So interesting article about that and weird, you know, with open source how things can be used in different ways. So something to kind of keep an eye on, I thought it would kind of fit in that theme this morning.\n\nRight, cool. That takes us right into topics. So what's your first one? I'm starting this week with a Real Python article by Gerard Hill, a long-time contributor and somebody I might be working with shortly as Python 3.11 sneaks up on us. If the pattern continues, this article is actually a bit of a preview topic for 3.11. It's called Python and TOML, New Best Friends. So I don't know if you've ever looked around and said, \"What the world needs is another configuration language,\" but Tom Preston-Werner did, and the world got TOML. So TOML is short for Tom's Obvious Minimal Language and is a simple-to-parse configuration language supported by a wide range of programming languages: C, C#, C++, Java, JavaScript, Swift, Python, of course, and a whole bunch more. So lots of choice out there. Now you may have been seeing some fuss about it lately, and that's because it's about to become a first-order feature in Python 3.11. It's already used a fair amount in the Python community. It's very common, particularly with package configuration purposes. So if you've ever seen a Pyproject.toml file, that's in TOML format, kind of makes sense, right? So for those who've used an INI file in Windows, this format is fairly similar. It has sections and name-value pairs. The sections are denoted by square brackets. So if I was going to define a section for user info, I might have an account section in a file. So that would be the word \"account\" surrounded by square brackets. And then underneath that, you get name-value pairs that are variable definitions. So I might have username equals Bob and password equals, you shouldn't store passwords in a config file exclamation point, right? Right. Every name-value pair is inside of a section, and essentially the section continues until you see another section definition. TOML is type-aware, so those examples that I gave would be strings and would be surrounded in quotes. All the keys in the name-value pairs have to be words. It can get tricky. You can do things with numbers, but it still treats them like words, so you're better off just sticking with the way you define variables",
    "hn0QIaWYo-w": "Welcome to the Real Python Podcast. This is episode 125. Have you thought the standard output from Matplotlib is a bit generic looking? Would you like a quick way to add style and consistency to your data visualizations?\n\nThis week on the show, Christopher Trudeau is here bringing another batch of Python Coders Weekly articles and projects. We cover an article about the magic of creating style sheets for Matplotlib. You can quickly customize plots and graphs with a single line of code. We share additional resources for you to try out new styles and learn what parameters are customizable.\n\nChristopher covers an article about using async for web development in Python. The creation of Python generators inspired the development of async functionality. He discusses recent changes and async additions within Python web frameworks. We cover several other articles and projects from the Python community, including how you can install a pre-release version of Python, caching in Python with LRU cache, ways to get better at debugging, suggestions of libraries that deserve attention, a Python library for creating mathematical animations, and an extremely fast Python linter that is written in Rust.\n\nThis episode is sponsored by Platform SH. Discover an alternative to DIY for your web fleet and all the stacks it contains on a single stable platform. Find us at platform.sh. All right, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey, Christopher, welcome back, Mr. Bailey.\n\nGood to be here.\n\nYeah, I'm excited to dive in this week. We have one little tiny news thing I wanted to hit on, and then one kind of related news item. On the 7th of September, there was a quick security content thing that came out. Python 3.10.7, 3.9.14, 3.8.14, and 3.7.14 all became available. Lots of regular bug fixes, and I'll put a link to that for you if you're just learning a little more about it. But yeah, keep your Python up to date for security content.\n\nThe other one is related to the upcoming release of Python 3.11. We've been talking about it a lot this year on Real Python. Our Python release article, writer-in-chief, Garen Yela, started writing articles as sort of beta releases and even some of the alphas as he kind of went along. These sort of previews. We're getting to the point now that it will be the first week of October that the new version should be coming out, and we're going to do our typical coverage, which would be an article talking about the new features, a video course, which you're going to be involved with, Christopher Trudeau there, and we'll probably also do a podcast episode, which has been our trend. So lots to expect from, but I wanted to mention an article that came up on Real Python that Garen also wrote that is in a new format for Real Python. It's a Q&A sort of question-answer format. And this one was, \"How can you install a pre-release version of Python?\" And that may seem really obvious, but in some cases it can be a little odd. And there's actually four little sections on it. It's a fairly short tutorial/article that gets into it. The first method that he dives into, oh, maybe I should mention briefly, like, you know, we've mentioned also that throughout these betas and alphas that you should try it out on your code base. And just to reiterate what Pablo Glenda Salgado was saying, he being the release manager for Python 3.10 and 3.11, his summary is, \"No matter who you are and what you do, test the beta releases if you can.\" And now we're up to the release candidates, and I would agree that those fall in the same boat as the beta releases that you should try to test them out. And right now, I think we're on release candidate one. This article goes through that, and the first methodology for installing a pre-release method is to use a tool called PyM, which we've talked about on the show a little bit already. It allows you to manage multiple versions of Python. We have a pretty good article diving into it and a video course if you're interested. One trick with PyM generally is that it isn't supported directly on Windows, so there's a fork of it that you can install. And a recent article that I covered from Ian was about your Python coding environment on Windows and that sort of setup guide covers the tool Chocolaty that lets you install a version of PyM and covers the details there. So I'll include links for both of those if you're interested to learn a little more. The other way of installing a pre-release is to do it directly from python.org, and there's a whole set of paragraphs there talking about it. And then a more advanced way, if you are a Docker user, is to use a slimmed-down Docker container with a version of Python in it that you can kind of set up, try your stuff out at it, and tear it down. That might be easier depending on your environment and how you set stuff up. And the last one was using your operating system's package manager, and you can kind of again dive into the article to learn a little more about it. So I just wanted to mention it as we're in kind of the season of lots of releases and ways that if you're interested in doing that testing stuff, this article addresses it pretty directly head-on. And some of these things aren't as obvious as you might expect. The pre-release version is not on the downloads page, and because of how Google works, if you Google it, you might get a link to the alpha or the beta rather than whatever is the most recent. Yeah, okay, and I ran into this when I was installing 3.11 in order to start writing the course for October, and it took me about five minutes of mucking around until I could actually find the release candidate, and I found plenty of links to the alpha and several links to the documentation, but it took me a little bit to find the actual thing. So I agree with the sentiment there. If you're a user of Python, it's a good habit to get into of testing these releases to make sure that everything's going to run smoothly for you when it does come out in October.\n\nWhat's your first article?\n\nI'm starting out today with the Understanding Async Python for the Web. This is by James Bennett. A couple weeks back, the 4.1 release of Django came out, and the Django core team has been busy over several releases adding more and more async capabilities to the framework. So the article, there's been a lot of articles kind of popping up around the concept. James's article isn't actually Django specific. He touches on it a little bit. It's more of an intro into async and why that concept is helpful for web applications. The Zen of Python has this line, \"There should be one and preferably only one obvious way to do it.\" Well, when it comes to running multi-threaded parallel code, there are a few more ways than one. So either the Zen was considered a suggestion in this case, or someone's definition of the word obvious didn't meet consensus. So async and await were keywords that were introduced in Python 3.7, so that's four years ago now. And these allow you to write what's called a coroutine, which is a way of writing multi-threaded programming. And the intention here was to make coding in parallel more explicit than in the past. So parallel coding has been in the libraries, but this is bringing it into the language rather than just in the support libraries. In theory, this can make it easier for the compiler and any tooling to constrain the behavior in ways that are actually good for your coding because you're making it part of the language. The article starts off by introducing the concept of a generator. Most let's use the word regular programming is linear, right? So if you have a function with 10 lines in it, the computer runs each line in succession and returns. And then the yield keyword's a little different. So when the computer hits the yield keyword, it suspends the function and returns a value. And then it can come back to the function after the yield statement and resume. So the most common use of this is, let's say you've got a function that is supposed to output a lot of sequential data. So if you didn't have generators, you would have to generate the entire chunk of data in a list and you'd return the list. But with a generator, what you can do instead is you can just keep yielding items in the list. So as your function is being iterated over, if you stop, say you break out of your loop, you don't have to generate the rest of the data. So this is a much more efficient way of doing things for large amounts of sequential data. So the async and await keywords build on top of this concept, and they allow you to suspend the execution of a function when you're waiting on some IO. There's a huge speed difference between your CPU and your RAM, and then there's another huge speed difference between your RAM and your disk. And it gets even worse between your disk and your network. So by the time you get between your CPU and your network, your computer is waiting a lot. Your software spends a lot of time just waiting for something to catch up. So what async and await do is they give you the ability to go somewhere else and run some other code while you're waiting for that IO. So this is called IO bound parallelism, and implementing it can give you a lot of speed up if your code happens to wait on IO a lot. If your code is mostly waiting on the CPU instead doing some fancy calculation, this will not help you at all. And you need a different set of tools, and Python has libraries for that. So IO bound stuff only. So let's say you know you were writing for the web. Well, the web is on the network, and guess what? You're doing a lot of IO waiting in this case, right? The ability to add async and await here can make a lot of performance improvements if you're building out web applications. Now, just because this parallelism is available doesn't mean you need to necessarily do anything about it. For example, the web server code might actually use these techniques, and you might not have to think about it at all. So just because it's there doesn't necessarily mean you've got to learn this stuff. But you could just implement something there that you build on top of things, right? Okay. And in fact, without async IO, what often happens in a lot of web servers is you just spawn a whole bunch of threads, and Apache takes care of it for you, and you just think about it in a synchronous fashion if you want. Now there are some cases where that becomes problematic, and one of the more common ones is web sockets. So vanilla web pages give you just one round trip, right? You hit the browser, browser hits the page, this spits back some HTML, and you view it. There might be some back and forth to get images or whatever, but once it's loaded, it's loaded. So if you wanted to build something like a chat client inside of JavaScript, you don't want to do it this way because otherwise every single time anybody sent anything, you'd have to connect again. And of course, if I don't have that connection open, I can't tell that you're trying to send me something. So web sockets is a tool that gets around this, and it opens up a network connection and keeps it open and goes back and forth. So the web server now has to be able to do some things in a more asynchronous fashion. And of course, async, the code keyword, can help you do all of this. So essentially, you get to this place where you're waiting and sleeping, and then the chat message wakes you up. This allows you to do this. At this point, the article, James, starts talking about Django and how Django's been slowly adding asynchronous features over the last few years. Django 3 introduced support for ASGI, which is the asynchronous protocol for integrating Python with web servers. This support means libraries like Channels and Daphne could take advantage of this, and you can start using web sockets in a Django world. And over the last four releases, Django's been adding more and more features. And 4.1 added asynchronous access to the ORM, so wrappers for talking to the database. Nice. James basically gives an overview of this and how it's changing in Django. Then gives an overview of libraries that are found with them. So like, if you're writing something in Flask, then you might be using, say, SQLAlchemy. And of course, if that doesn't support async, you're screwed. So you know how it's... It's not just, does the web application do it? Do all the companion libraries do it as well? And then he finishes up with a little bit of an opinion piece. He's a little bit skeptical about the rush to async, and I kind of agree with him. It's definitely a useful tool. It's a bit of a sharp tool, and somebody's going to be missing some digits at some point because the tool's a little sharp. Sure. So I'm a big fan of it being used to help support the libraries, but it's not something that I think web programmers have to rush out and learn immediately. So it's cool that it's out there, and the article gives you a nice sense of what that is and what it means. But you don't have to feel like you're not a web programmer if you don't know any of this stuff.\n\nYeah, it's interesting how async very often is portrayed as, at least over the last several years, like, \"Oh my God, everybody should be doing this.\" But it really depends on the project and maybe the scale of the project and so forth. Like, if you're not going to have... I don't know, thousands of connections or what have you, like, I don't know where the big performance boost is going to be. Like, what are the things that are waiting and so maybe that might get into some kind of profiling or whatever. I mean, I guess it's nice that we're building toward it, but... Yeah, I wonder about the rush.\n\nWell, I think it's because Python is popular and slow. Yeah, the most common thing Python programmers tend to be defensive about is how do we make it faster, sure. And better parallelism is one of the ways you can get some speed up, right?\n\nThe other aspect of it, I find as well, is, you know, I've done a fair amount of concurrent programming in my days. My grad studies were based on it. The one solid lesson to me is try not to do it. It immediately introduces race conditions and you think regular bugs are hard to find. Anything that is not deterministic becomes really brutal to find. So this to me is one of those great tools, but don't prematurely optimize, right? Like, if you, you know, if your program's taking two seconds and you want it to take one second, adding async isn't going to fix your problem, right? If you've got a six hour job that needs to run in 20 minutes, then you can start digging into this stuff. Yeah. So my next one is by Robert Ritz. He has a site called Data Fantic. But it's a tutorial about a feature that I was not aware of. When I kind of looked around and looked at data visualization libraries just a few minutes ago, I was like, okay, what is the popularity level in Python for this? And so I did like, you know, just a kind of cursory, not peer-reviewed study of like, okay, well, what are the popular libraries and at the top of every, of these top lists that I looked at of like what should you learn and what are people using and so forth, Matplotlib is always kind of up there. And we even talked offline before we started that there are some maybe some other reasons not coming from academia. It's got a real tight connection with pandas also. So my only problem with Matplotlib, and this is just an aesthetic thing that I've always felt about it is that it's kind of ugly out of the box. Like it doesn't have a whole lot of initial style. And this article gives you a really neat way to kind of update that and maybe even apply a consistent style across your stuff. Like if you're designing a website and you're going to use a lot of graphs and visualizations, it's nice to not have to repeat a lot of code. And it's about the magic of Matplotlib style sheets. I was impressed that this very, very short article took this very simple looking plot and turned it into something that you would see on some of these popular websites that show data visualizations. Like the one that he's trying to mirror in this particular article is a political site called 538. It's a particular blog that's out there and they have tons of graphs and so forth. So you wanted to kind of create something in that style. And by using this style sheet, he's able to kind of modify this very plain looking Matplotlib line graph and turn it into that. The style sheet just to kind of get that out of the way, it's saved as a text file. It will have an extension of MPL style and you load it in with just a single line. Plot.style.use and then you have in parentheses your file path. It looks kind of interesting, it has comments basically that you can use to divide up the sections and the standard pound sign kind of thing to basically, and you can either do them like topping the comments or you could do ones that are in line after it just to kind of indicate what you've set up inside there. But as you lay this out, you are things like modifying the grid style, modifying the DPI, the default DPI dots per inch for your graphs that are Matplotlib are 100 and even changing to like something 150 will make it look a lot better printed or even on screen. He suggests setting it up for 300 for printing. Figure spacing, which is like your aspect ratio, the default is a 4x3 and doesn't always look great depending on what you're trying to format and kind of put it on, especially things that are very phone based these days. Ticks, the tick labels, their font sizes, and there's a Matplotlib documentation page I'll link to also that covers this and has all of the parameters that you can kind of adjust or at least the majority of them at the moment with the style sheets. And then I also went and did a little kind of deep dive and said, well, what have people created out there already? And I found a couple sites, one that I'll link to that is a GitHub repository with some already existing style sheets, because I think it's handy to kind of see what other people have done with it to kind of get an idea like, oh, this could be handy. It's kind of like if you're, I think a really common thing as you learn web design is to really look at other sites and then open up what they've kind of created inside there and try",
    "yPL9Kla2dd8": "Welcome to the Real Python Podcast. This is episode 127. Have you ever used code to help explain a topic? How can Python scripts be used to understand the intricacies of Access Control? This week on the show, Christopher Trudeau is here bringing another batch of Pi coders weekly articles and projects. Christopher talks about our article exploring the evolution of Access Control by re-implementing the concepts with Python scripts. The experiment moves across the various access forms starting with control lists, roles, and attributes ending with purpose-based Access Control.\n\nWe also cover a post about how to create dangerous pickles. We discuss where malicious code can hide within the serialization process and decompiling code as an educational tool. We share several other articles and projects from the Python Community, including building command line interfaces with ARG parse, HTML and CSS for Python developers, a Python packaging user survey, a visual decanter GUI creator, a Pi script-based data visualization cookbook, and a project for writing functional test helpers in Django.\n\nThis episode is sponsored by InfluxDB. InfluxDB time series platform is built to handle the massive volumes of time series data produced by sensors, apps, and systems. Are you building real-time applications? Check it out at influxdata.com. Alright, let's get started. Thank you. The Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com. Hey, Christopher, welcome back.\n\nMatt: Good to hear you. So we were going to start with just a really tiny news thing. I don't know if you actually said a release date or about when we were thinking Python 3.11 was going to come out. It has moved a little bit. It turns out that there's been a lot of additional testing required. We actually mentioned that hey, test your stuff and there's a lot of reasons for that. I have an upcoming conversation with Pablo Galindo Salgado that's going to be coming in the feed actually before the release of 3.11 due to all the additional testing they have had to make lots of little tiny bug fixes to kind of get things working properly. A new release candidate, release candidate 2 came out. I guess this announcement was on September 12th, and I just want to make people aware of it. Please again test your stuff for it. There's been again a lot of little changes under the hood, a lot kind of doing to like the faster Python project, things that they're trying to do to speed stuff up has changed some functionality, and it's a really good idea to test your code. I'll include a link to this release candidate. Remember that to test pre-releases you have to look for the tag pre-release python.org if you're installing from there, and yeah so that's just a little news item. It looks like they're planned new release date will be Monday, October 24th right now, as long as everything goes smoothly from here, and we'll again have lots of stuff coming out that week.\n\nI wanted to start with articles this week and start with one that's kind of an interesting one. It's by Philipp Scani. He's one of our newer Core team members at Real Python. He decided to tackle HTML and CSS for Python developers. One of these things I wanted to get out of the way is just like who is this for? I would argue that it's really if you don't know the fundamentals of HTML and CSS, they're good to know. There's a handful of really interesting reasons and some actually brand new reasons. One of them would be this thing called Pi script that everybody's very interested as a potential distribution method. It still uses like HTML tagging and a lot of the conventions there, and if you're not familiar with like kind of how that stuff is structured, this is a great way to learn the fundamentals or brush up on that terminology. He actually provides a bunch of really great resources that go further beyond these topics. One of the topics that I got out of it that was really interesting was about image tags in the alternative text. There's actually a site that talks about that specifically like what should you put in it and typical gotchas like if you write image in it, it's actually going to say image image twice in a reader, which is kind of a strange thing. So you need to be aware of that. Anyway, the tutorial takes you through again structuring a basic HTML file kind of like the hello world of HTML and then how to view in an X inspect your HTML, use those tools inside your browser, which is actually a really nice good skill to have. Working with images and page links, how to then go into CSS and styling CSS formatting HTML with accessibility, keeping that stuff in mind. And then it has a nice little section at the end that involves tools that come with Python, kind of built-in Python tools that help you write or parse HTML code, and then a lot of links to take you further. Links to other frameworks like Jinja, which is a templating tool that you might have seen, especially if you use tools like Flask or Django tools like Flask and Django that are big, you know, or big or small types of web frameworks that go further, places to, you know, kind of tie in JavaScript and so forth. He also takes you through how you might programmatically write HTML by using Python, like building tables or the reverse, like parsing HTML with Python. And so again, I think it's a great resource for someone or maybe someone on your team that isn't that familiar with some of the structural basics of it. This is kind of one of the places when I got back into programming that I started. I wanted to make sure I at least understood kind of the basics of what's happening with it, and something I think that Chris and I have discussed is just the changes in CSS and understanding just the fundamentals there. There are some really interesting concepts with CSS that you should know about, like you go to explore the developer tool inside of like a pane inside the browser, you can see a lot of these tools that are in there and how they kind of work. He talks about like what a font stack is, which is really kind of neat, and how the sort of fallback happens if that font isn't available on someone's system, the idea of using classes to kind of structure and have better flexibility. So there's a lot of really, not only just the fundamentals, but a lot of nice little best practices to get you going. I think Philip has provided a kind of a neat resource there, and again, if you're interested in learning something like Pi script, again, it's just another sort of a tag that goes inside your HTML, and so it might be helpful to be familiar with some of the stuff happening there.\n\nOne of my favorite little built-ins that you almost never know is Python's got a web server built-in. Yeah, yeah, you can host something really quick, run a web server. I use it with a couple of my static websites, so I'll run the static generator and then just point it at the directory so that I can quickly check whether or not the last generation worked. Yeah, which, you know, it's a dash M command, it's a one-liner, and it's there, which is batteries are definitely included. Yeah, yeah, I learned about it really late. I think I was talking to Adam Johnson about some documentation things in a way to sort of stand up the documentation if it's all HTML and be able to read it right there and have it kind of live by using the built-in server, which really is kind of neat. So what do you got for us? What's your first article this week?\n\nSo this is a little different. Most of what we cover is learning something new about Python, either like a new feature of the language or a technique or a library you should use. This article's kind of different. It teaches you something that has nothing to do with Python, but it uses Python to explain it. It's kind of an inversion from the kind of things we normally talk about. The article is called \"The Evolution of Access Control Explained Through Python\" and it's by Adam Fugia. I think is how you say it. Apologize, Adam, if I've got that wrong. The concept the article is teaching is how a multi-user computer system determines who has access to what. So generally, once you start adding more than one user to a system, you have to assume one of them is going to do something nefarious. And as an operating system designer, you have to start thinking about how to keep this under control.\n\nSo our Adam's article talks about three different access control mechanisms. The first is called access control lists, which is shortened as ACLs. The second is role-based access, which is shortened as RBAC. And the last is attribute-based access, also known as ABAC. So the first piece of Python code shows some data classes defining the ideas of what you need to think about this. So there's a person who needs access, a record that's being accessed, and some sort of action that's being done, which is a reader or write. And what your access control system is supposed to do is decide whether or not a person should be allowed to form perform the action that they want on a given record. So with that as sort of the background, he quickly sketches together a class called a system, and it's really just a wrapper around the operations. It's got a get and an update method, and then you pass in a person and a record, and it's essentially supposed to say, \"Yes, this person can do what they're trying to do,\" or \"No, they're not supposed to do it.\" And so with that in place, you essentially have a framework to start talking about these things.\n\nOkay, so Adam sets up some tests and creates some people named Allison and Bob, which are good traditional crypto and access control example names, and then add some medical records and actions that Alice and Bob can do to each of these records. So with all that set up, he then introduces the first kind of authorization, which as I said was ACLs. These were first implemented in the Multix file system in 1965. That's even before my time, that's how far back we're going. And if I remember my history correctly, the Multix machine was made out of Stegosaurus bones, I think. Anyway, \"polish, uh, yes, highly processed Stegosaurus phones.\" So the... there's different ways of implementing ACLs, but the heart of the matter is really just sort of a table that maps people to records and actions. So when Bob attempts to do something to Ben's records, the table is consulted, and if there's an entry for Bob's action, he's allowed, and if not, he's denied. And in the Python example, they do this by adding an access data structure to the records themselves. And so, like I said, the neat thing about this article, although I'm learning something new about the history here, is you get this precision by seeing the actual Python code of how it would be implemented, which is far less wishy-washy than saying the English language.\n\nThe next step is to talk about the limitations of ACLs. You need a one-to-one mapping between people and records, and so you might want to say if you've got a lot of people, you might want to have groups of people. This department can do this rather than this person could do this, yeah. And then second, is the records are flat, which there's value in making them hierarchical. So if you can see this record, you can see all of the images that are attached to it, for example. So between those two concepts, you can start adding things like groups of people and hierarchies of hierarchies and all that kind of good stuff. So this allows you to do things like everyone at the company can see this drive, but only those in the IT office can see the settings folder. And that's just can't be done with regular ACLs. So this leads to role-based access or RBAC, and this adds a layer of extraction. So I had a problem to said the right answer to every problem in computer science is to add another layer of abstraction, and so this is essentially what's happening here, sure. So that new layer is a role data class, so we add a role object that has a membership list and a permission list and a list of records to which the role applies. This added complication means you need to be able to reference your records, and most databases and file systems have sort of some sort of unique ID, so this isn't usually a leak price, you're just essentially keeping track of this role is attached to these IDs. So RBAC solves some of the limitations of ACLs, but for large systems, they can get pretty hairy. The example that Adam uses in the article is Amazon's S3. There are over 240 possible actions allowed in that file system, so if you start trying to figure out how to capture all of that, that's a lot of permutations, yeah. So if Mr. Bailey and I are in the same department but one of us needs one of those 243 actions to be different, all of a sudden the permutations explode and you end up with a whole bunch of different roles just finding them, yes, yes, yeah. And even in real systems that control all these, you're often storing a lot of this information in things like LDAP servers and stuff like that, and it can be a beast trying to find the checkbox and does that changing that checkbox do what you want so, yeah, these things can be a bit of a challenge.\n\nSo the last one he talks about is a higher level, which is another degree of abstraction here, which is the attribute-based access control or ABAC, and it takes some of the ideas of the RBAC and adds conditional testing. So the conditions are based on attributes of the person or the system or the record itself, so ABAC is a subset of a broader concept called policy-based access control, and this allows you to get crazy and define conditions like Alice is able to access anything created before 2003 but not after, okay. Like logic in there, okay, yeah, exactly. So the conditions can apply to the person, to the system, to the data, and they can also check things like what department is by Alice, because she's,",
    "VCsj7ZdFpaM": "Welcome to the Real Python Podcast, episode 128. Have you used a memory profiler to gauge the performance of your Python application? Maybe you're using it to troubleshoot memory issues when loading a large data science project. What could running a profiler show you about a codebase you're learning? This week on the show, Pablo Galindo Salgado returns to talk about Memory, a powerful tracing memory profiler. Pablo developed Memory while working at Bloomberg to track memory allocations beyond Python code into native extensions and the interpreter itself. It's a compelling tool to help you understand where memory is used by providing fine-grained reports. Pablo discusses the different types of output memory provides, including live mode, flame graphs, and a Pytest plugin. \n\nWe also discussed how a tracing memory profiler can help you understand a new codebase. He walks us through how he developed the first prototype internally and eventually moved the project into open source. This is the first part of my conversation with Pablo. In a couple of weeks, I'll share the second part where we talk about Python guilds inside large companies and his work as the release manager for Python 3.10 and 3.11. \n\nThis episode is sponsored by DeepGram. DeepGram is the preferred speech-to-text API of Python developers. Get accurate transcripts from any audio with features for understanding. Try it by transcribing 200 hours free at deepgram.com/realpython. \n\nAlright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey Pablo, welcome back to the show.\n\nThank you very much for inviting me again. It's a pleasure always to be here.\n\nIt was really fun talking to you at PyCon, and you had mentioned to me as we were walking down the hall how you had just released this memory profiling tool, Memory. Would you want to come back on the show? I kind of never got back to you over the summer, sorry. But I am very excited to have you on to talk about Memory and maybe a bunch of other things at the end.\n\nYeah, that sounds good. I always have trouble sometimes talking about very specific tools. I kind of like to break it apart and generalize it, right? So I'll make sure I do a little bit of that. \n\nMaybe we could start there. Where does a memory profiler come into the workflow or the day-to-day of a developer? I think it's an excellent question. A memory profiler, like almost any profiler, is a tool that you will not use every single day. It's a tool that you can probably put into the bag of the baggers, the wireless and profilers. It's normally the kind of bag that one puts this tool into. \n\nIn particular, a memory profiler, you will use it when your program is using a lot of memory. It always depends on the system you are in. Maybe you are a super company and have one terabyte of RAM in every server. Maybe it's not the same kind of problem. Normally, if your program is using a lot of memory and you don't understand where that is coming from, or maybe you want to try to see how you could reduce that, then you will go and fetch one of the memory profilers.\n\nThat will tell you in different ways. We can cover what different profilers can give you. But a memory profiler will basically tell you where your program is allocating memory. Most of the profilers will actually focus on the moment your program consumes the most memory, so what is normally referred to as the high water mark. So basically, at the moment your program has more memory being consumed, at that point it will take kind of like a photograph of how the program's memory is laid out and it will tell you okay, this piece came from here, this piece came from here, this piece came from here. So you know what parts of your code were allocated memory at the time that happened. \n\nObviously, that is just one possible question that you may ask these tools. But normally all the questions and all the answers that these tools will give you are around how your program is using memory, right? That's what I was running about. There are going to be times when you're running a program, potentially one time, you're running a process, but I guess there'll also be times where you would have something that's kind of continually running, right? In either case, you're able to output because it outputs this like .bin file to sort of right compressed binary version of the thing that you can then use to do all these analysis processes, right? \n\nRight. For instance, memory being a tracing profiler and especially since we produce these files that have a lot of information, basically all the information is every single allocation, function call, etc. So these files, even if we have a lot of compressions, if you have a program that is running for half an hour or an hour, these files could be enormous. Not only enormous, but analyzing them, even if you have the hard drive, I mean, maybe they are not that big, but even if you have your hard drive to hold those files without a problem, analyzing them can be quite slow because there is gigabytes and gigabytes of information. So in this case, maybe a statistical profiler is not what you need. If you have a long-running application, maybe it's better to use a statistical profiler. For instance, another interesting profiler that is a statistical profiler that has some memory profiling as well is Scalene. I don't know how to pronounce it, okay, sorry. \n\nBut that's another example. In that case, a sampling profiler will be a bit better because maybe, in that case, you're not interested in absolutely everything that happened. If your program is regular enough, you will get a close enough snapshot of where you're searching for without having to record absolutely everything. So this is a good example of when you will go to a different kind of tool. But Memory, or other traditional profilers, will be able to do this kind of thing. Yeah, that is kind of a unique approach. We try to do one of the core things that our profiler does is that it records everything. So you can analyze the locations in different ways, and there are very interesting things you can do once you have that much information that you cannot do if you don't have that. \n\nFor instance, we have this kind of output when you can say, \"Okay, I'm interested in seeing, for instance, what we call temporary allocations.\" So temporary allocations are allocations that the next thing the program does",
    "XttkpzvsFvU": "Welcome to the Real Python Podcast. This is Episode 131. Python 3.11 is here. Regular guest Garana Yella and Christopher Trudeau return to talk about the new version. Garana wrote a series of preview articles earlier this year, and his annual piece was published on October 24th titled \"Python 3.11: Cool New Features for You to Try.\" Christopher's video course posted the next day covering the topics from the article with visual examples of Python 3.11 in action. Garana and Christopher collaborated to create code examples of the new features. We discuss better error messages, faster code execution, tasks and exception groups, typing features, and native TOML support. We dive into the updates and offer advice about ways to incorporate them into your projects. We also consider when usage should start running Python 3.11.\n\nThis episode is sponsored by DeepGram. DeepGram is the preferred speech-to-text API of Python developers. Get accurate transcripts from any audio with features for understanding. Try it by transcribing 200 hours free at deepgram.com.\n\nAll right, let's get started. The Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nSo joining me again, it seems like an annual event that we're having here with the newly annual release of Python, is Garana Yella. Hey, it's good to have you on the show again. And Christopher Trudeau, my common co-host here. It's been a long time. I think it's been three days.\n\nYeah, yeah, exactly. We're excited to talk about all the things that are coming in Python 3.11. Garana has actually been documenting a lot of these changes throughout the year at Real Python, which has been kind of interesting change for our publication schedule and let you kind of get a lot of your thoughts in. With not only the betas, but also the pre-releases. Do you want to talk a little bit about that, Garana?\n\nRight. So this has been like an experiment with it because the earlier years we just kind of loaded everything into one article for the release, and we're kind of doing that this year as well. So we have the big Python 3.11 article, but then I've also done three Python previews, essentially, where we focused mainly on one topic and then kind of threw in a little bit here and there. So first, we talked a little bit about the improved error messages in the first preview. The second one, we focused more on the new async features, the task groups and exception groups. And then the last one was about the TOML support that's added. All of those things will also cover now in the big article and then other stuff. That should be up on the site which should be able to check it out. This is going to come out just a little bit after the release week. Some travel and other things involved in my life right now. So sorry for the minor delay, but you know, keep the excitement going with the new release.\n\nYes, so great, do you want to start with some of the stuff that we're going to talk about? We have kind of like a little list that we were going to go back and forth with, but we were going to talk about initially one of the biggest changes and Christopher and I've been talking about it back and forth for the last several months about the faster CPython project and kind of what's going on to speed up Python, not only in previous releases, but you know, especially here with 3.11.\n\nYes, I think 3.11 is kind of going to be a great release kind of for developer experience, essentially. So we'll have the improved error messages that we'll talk more about later, but it's also going to be the fastest Python yet. And this is part of a huge effort by what's called the faster CPython project. And this kind of stems back to a post that I think is about two years old now that Mark Shannon did on the Python mailing lists where he said that he has ideas for how we can improve the speed of Python five times over several releases. It's a really ambitious plan kind of got tagged on the Shannon plan. And he kind of laid out a lot of ideas for how to improve the language, which is really impressive for a 30-year-old language that you can kind of come along with these thoughts. But also together with this was kind of okay, this is really ambitious and to be able to do this, we need a lot of funding. For a while, it kind of was hanging out there and saying, yeah, are we able to do this? Should we focus on this? But then Microsoft stepped up and they've been funding a team that then includes Mark Shannon. It got Guido out of retirement. And several other people. And I'm slightly scared just to try to list the people on the team because I don't have a full overview, but I know that Eric Snow has been on the team for more or less the whole time. And also a couple of other core developers like Brent Booker and Eric Catriel at least have been there. And there might be a few others as well that have been working on this project now for at least the last year or so. It's been really exciting to see all the things they've been able to do. They've also been able to contribute to things that are not purely performance. And then a lot of the other core developers also rallied around the project and helped out with different things. So it's really fun to see all the excitement around this, really. And yeah, one of the cool things is that it will happen without developers needing to do anything except upgrade to Python 3.11. It kind of doesn't rely on any code changes. It's just Python gets faster.\n\nIt's really kind of cool. Like I've been paying attention to this for a while now and I did talk about some of these interesting changes that are part of the faster CPython project. And one of them is this idea of sort of almost like JIT-like, you know, just-in-time compiling type of stuff for code that seems like it sort of repeats. And we've talked about it a little bit on the show, but we also, I had a chance to talk to Pablo Galindo Salgado about it. And that and causing him a bit of stress in releasing it in lots of kind of interesting if you will code paths that things kind of traveled that they haven't before and having to set up a whole new sort of testing regimen to think about that, which has been very interesting. But you want to talk a little bit about that adaptive interpreter?\n\nRight. So this, I guess, is the only big speedup feature that has its own PEP that kind of at least describes it. And I guess we should also just point out here that all the things we're talking about in terms of performance happens on the CPython interpreter. Kind of the whole Python 3.11, it is the CPython 3.11 release, although other interpreters like PyPy do tend to keep up with things that are happening there. But I think the speedups are kind of changing the architecture to some effect on CPython. So the specialized adaptive interpreter and the idea here is that, and I guess we need to be a little bit technical and kind of say that Python to some extent is compiled. Well, it kind of runs in an interpreter, but it's not the Python code that we write that runs. It's something called bytecode, which is a much more lower-level language. So typically, if you have a statement in Python, it's maybe three, four, five instructions of bytecode that it kind of split into. And one of these bytecode could be something like a binary operator, like addition or multiplication or things like this. And what the specialized adaptive interpreter does is that it kind of just keeps monitoring these bytecodes so that they're kind of tagged with the counter. And then when a certain code has been called several times, it's able to switch to a specialized instruction. So if it's kind of seen that, okay, this multiplication, this particular multiplication instruction has been called, I think the magic number is eight. At least in this implementation. So eight times with floats. So float times float, then it will specialize the instructions so that instead of your general multiplication that you have in Python, it will try to do a fast multiplication of floats. And then it kind of has to fall back so that if you, that ninth time happened to multiply an integer, everything will still work, but it will kind of then fall back to the slightly slower one. So for the happy path, essentially, where you keep doing using the same data types, then this will speed up things quite a lot, actually. So it is definitely noticeable if you cannot do some benchmarks on it. Yeah, that's the main idea, essentially, just that it's able to detect at runtime that this operation keeps happening with these particular things where we know that we can do stuff faster than the general operation.\n\nI'm glad you brought out the idea that this is also just one of the things that's kind of under the hood that they're trying inside of the Faster CPython project. And I also like that you mentioned the fact that there's sort of funding behind it because that's one of the things that has a little bit been missing in the development of it. And the fact that Microsoft's setting it up and again, I'm not even sure the size of the team. I know that they were hiring somebody to kind of help manage the people and some of the stuff going forward. I saw job postings from Guido earlier in the year about that. But yeah, great, great to see the fruits of it this year. All right.\n\nYeah, I think the funding part has been really important to get started on such a big rewrite of the internals, right? That they have changed a lot of how the bytecode works and things like this, which would be really hard to do just on a volunteer basis.\n\nTotally. So speaking about other performance stuff, do you want to dive in here, Christopher?\n\nWell, sure. And just to add on to what was just sort of talked about there, as well as the 3.12, which is coming, we spoke about in the last podcast, one of the things they're going to be doing is taking those bytecode pieces and shrinking them into little micro bytecodes. So this is the adaptive interpreter is the first step towards a bunch of things that they're going to be doing with that underlying bytecode to try and get a more performance boost out of it. So it keeps going. Nice. This isn't the only speed stuff that they've touched this time around. I'm going to talk about a few of them. The first one is what's called a zero cost exception. In Python 3.10, there's a bit of overhead code for any function that has a try-accept block inside of it. And that overhead includes a chunk",
    "mW3KRtLzibY": "Welcome to the Real Python Podcast. This is Episode 132. How do you create a computer opponent for a simple game within Python? Would you also like to learn how to adapt the game to run in a web browser or graphical user interface? This week on the show, Christopher Trudeau is here bringing another batch of PyCoder's Weekly articles and projects. Christopher shares a recent Real Python step-by-step project for creating a tic-tac-toe game engine. He talks about how to build the game engine and adapt it for different front ends. The tutorial also shows how to implement an unbeatable computer player using the Minimax algorithm.\n\nWe discussed an article about how to avoid repeating yourself when creating decorators with multiple parameters. We talk about how you can stop copying and pasting code several times by assigning the decorator to a new variable. We share several other articles and projects from the Python community, including a news roundup, a deep dive into Python stock tests, several Python command line tricks, type annotations via automated refactoring, a new way to draw boxes in the terminal, a collection of projects for beginners with source code, a minimalist PDF creation library, and a tool for sensible logging within Python.\n\nThis episode is sponsored by InfluxDB. InfluxDB's time series platform is built to handle the massive volumes of time series data produced by sensors, apps, and systems. Are you building real-time applications? Check it out at influxdata.com. All right, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey Christopher, welcome back.\n\nGood to be here again. We have a couple of news tidbits here, so I thought maybe we could hit them first. You want to start with them?\n\nSure. Right off the top, the first one is that, you know, in case you were tired of all that Python 3.11 news, we're on Python 3.12 already. Yeah, Alpha One is out, so if you're wanting to play with some of the new stuff, it's there. And the other one is just a quick reminder that the call for proposals for PyCon US 2023 is still open and will be for a week or two. So if you're interested in speaking there, then you should check that out.\n\nDefinitely. There's some internal conversations going on inside Real Python of people thinking about how they want to do different talks. Garon has done several over the years. He did a lightning talk, I think, last time. Are you planning on coming?\n\nProbably not.\n\nOkay. All right. We'll figure out a way to drag you out of there. Let's stay bunkered down in my Canadian Fortress of Solitude for a little longer. Sure, that's fine.\n\nWell, diving into articles and topics this week, I'm going to start with a Real Python one. It's from our favorite, Lay It On Sposa Lamos. It's a recent article he did, basically a tutorial diving really deep, as he likes to do, into Python's doc test. The subtitle is \"Document and test your code at once.\" The idea here, as we've talked about doc tests for a few episodes, I think episode 118, we talked about an article from Martin Bois, which was getting into MKDocs and generating documentation using docstrings and how that can be used. And MKDocs kind of just finding that information and building out your documentation from it, which is really nice. This covers a whole bunch of stuff. It covers the fundamentals of writing doc tests in your code's documentation and putting them inside the docstrings and then understanding how the doc tests actually work internally and then exploring some of the limitations, like where it kind of falls down. And I thought you had some input we were going to kind of talk a little bit about. You're like, \"Well, I don't know if I would use it for everything.\" And this definitely covers some of that. And then there's also a security implication that you might not think of right away, especially if you're looking at other people's code or code that you're not familiar with, and how maybe running the doc test might not be as secure. And then the last thing he gets into is a couple real deep dive things and strategies that I was not familiar with inside of playing inside there. But it starts out and he gives links to pep 257, which talks about docstring conventions. The most common way that I've seen doc tests use is to write it in that triple quoted docstring area. And what's interesting about them, if you need a little refresher on doc tests, is that you write them in this sort of special format that looks like you're running commands from the terminal. And so you have that triple greater than symbol. And as you're going through that, as you see that prompt like you would in a rebel, you'd type out your test. So maybe it's something like adding. And so you have, you know, call the function add parentheses four, comma, two. And then right below that, you'd have the line where the result was six. And in that, this is showing not only somebody who's reading your documentation what should happen, but you can then run a command from the command line to run the doc test across this. And that would be like, you know, Python dash M, the command is doc test, no spaces. And, and then the name of the file. And it goes through and runs it. And then there's a way to run it with a dash V flag that would give you a verbose output that actually tells you, you know, normally if you just run it and nothing happens, yay, nothing failed. And so you're all good. But if you want a more verbose thing where it actually shows you, it'll say like trying and it'll show each line trying, expecting, and then, okay, and so it goes through all that showing you the output. He talks about what sort of matches are expected and actual test output, some other kind of corner cases that you might run into there. He talks about how you could use it for catching exceptions and how you would write that and how that looks a little different inside there. And then as you go to build something a little more elaborate, it gets, it kind of starts to hit the limitations of what you can do in there. But I think one of my favorite things that I learned about by reading this is that you can create the doc tests as standalone files if you want also, which might be, you know, handy depending on how you're deploying the code or if you feel like the doc tests are potentially cluttering up the documentation. You can put the doc test inside of, just a text file or a markdown file so you can run them independently of that. He shows that as he goes along, he talks about a few more security limitations and things you might run into because it is running eval, which you've probably heard us even talk about that you may not want to run eval directly on code that you're not that familiar with because it's just, you know, literally running inside your machine. So it's a risky method that could allow execution of, you know, just arbitrary code. So something to keep in mind. And then he covers a little bit about test-driven development and how you could do that with doc tests and then really dives into like, okay, well the next level is pi test or unit test where the differences are there and what you would get into diving into the next level of that sort of stuff. So he covers how you can use unit test and pi test to run your existing doc tests and how to kind of integrate it. But one of the limitations that doc test has is it doesn't have the ability to, you know, use something like fixtures or set up and tear down mechanisms. It really is very specific about sort of exact matching for many, many of the things that you would be checking for. So it doesn't have a lot of flexibility, if you will, because it's really just sort of text strings that you're sort of checking about. And the funny thing that he mentioned, we had that article that was covering ellipsis recently. There's actually a way to use an ellipsis and using this technique inside of doc tests where you can sort of add like these little directives to say, hey, in this particular case, here's some potential flexibility I might be looking for. And you could say, you know, maybe it's looking for an object ID number or a memory location or something like that. You could actually have like a 0x dot, dot, dot. And so that's kind of like a wildcard allowing other options there. But again, this article really dives deep into this stuff. I think you may, if you're new to the subject, the first half of it really is going to get you going and working with it. And then as late as likes to do, he goes much deeper into all the corner cases and lots of other kinds of areas to kind of give you much more background and understanding on that. So I'm a fan, especially for smaller projects. I think it's a good way to set up tests and kind of get going on it. And I was going to ask you, you had said to me that you're not a huge fan of it. I'm not guessing it's just depending on the types of projects. Something like Django where you're going to maybe need fixtures or you need to kind of talk to databases. This really isn't going to work kind of the way that you want. Is that kind of your feelings?\n\nYou know, I like starting from having some tests is better than not having some tests. Okay. So if you're in a place where this gets you to write some tests quickly, go for it. What I find is it doesn't take long before you start running into those edge conditions. And so I wasn't aware of the addition of that ellipsis. Okay. Even with it, you're not fully testing it then. You're sort of saying output kind of looks like this, right? Right. And so I find it doesn't, it doesn't take much until you end up having to go into a unit test. Yeah. Yeah.\n\nI just really like that tie-in with the documentation part of it. Again, it depends on the complexity of what you're trying to show off. And so that idea of writing out and having it kind of create the markdown files and stuff like that that kind of reinvigorated my desire to like, well, this might be a really great way to go. But again, you're going to eventually maybe hit a point where you're like, okay, well, it's not going to be able to like kind of get you much past that as you start to get into much more elaborate types of setups and things where unit test and pi test and so forth kind of make more sense.\n\nYeah, and I kind of wonder whether there's some clever way of doing something to get around some of this stuff. Like whether somebody could write a library that you always use a function and because the function is doing the checking or whatever it from the doc test point of view, it's correct. Some way of sort of mixing in the idea of an assert from the unit test or something like that that there might be a way. If you could get around things, you know, the one I always run into and it's a pain with tests is things like dates, right? So you're digging, okay, you know, and you need to mock something up or you need to explicitly say, okay, the date is today or you're operating with this date. And if you make any call that goes and checks what date it is, then in doc test you're stuffed because it'll go off and figure out what date it is and it's no longer matching what's in the file, right? It doesn't help for variability like that. It just doesn't like that kind of stuff. Right. So if there were some tools out there that could handle some of those cases, I'd be all for it because it definitely is easier to read because it, like I said, it's just like looking at a rebel session and you know, that's kind of where we all start, right? You're used to experimenting in the rebels. So yeah, it just needs that extra thing before it convinces me that's fine.\n\nSo you had your first one was going to be a real Python one also, right?\n\nIt is, yeah. So this is a Bartash Zazinski article and it's called Build a Tic-Tac-Toe Game Engine with an AI player in Python. So I've heard tales of a chicken in New York City that plays Tic-Tac-Toe. So in case you don't have one of those chickens, you can write some code to be your own electronic chicken, right? And that sounds like a 70s funk band. And now coming to the stage, see Bailey and the electronic chickens. Where was I? Oh yeah, Python Tic-Tac-Toe. Crap. Anyways, so the article uses Tic-Tac-Toe to teach a couple of concepts. One, it uses a sort of a library-based structure so that your front end and the game engine are separated. And this kind of architecture allows you to build different front ends and say one for the web, or one for TK enter or something like that. And it keeps the game engine separate. And within the engine, it separates the game structure from the logic processing. So it, you know, and it includes the typical project Tamal and virtual M stuff as well. So if you're new to these kinds of mid-sized projects rather than say writing your first just a simple script, it walks you through all that stuff. And although Tic-Tac-Toe is a relatively simple game, by the time you're done, you'll have touched a lot of modules. You'll need some familiarity with object-oriented coding, data classes, regexes, and recursion. And so he helpfully provides a bunch of links to other articles in case you need to brush up on any of those topics. With the base structure in place, you start by writing code that describes the state of a game. And this includes an enum containing the Xs and Os, that's knots for British listeners, along with encoding the positions in the board. There's a little bit of regex use here to make sure that the board data only contains those Xs and Os, as well as some empty spaces. And then once you've got a board, the next step is to define a move. So you're going to need this in order to have the AI look into all the possible future moves as well as determine if a player is allowed to do an action. So you have to codify all of this. A game state object tracks all the possible states of the game, you know, not started, ongoing. And then the three possible finishing states, tie, X wins, O wins. And the game state code includes data about those winning boards and what they look like. And then the same idea is applied to valid and invalid board states. So you shouldn't have a board with, say, nine Xs, for example. The article walks you through how to take this logic and refactor it out into a place where it's more reusable. So because it's step by step, you're starting with like a little thing and you practice a bit and you get it and you test it. And then, oh, wait, maybe this should live somewhere else. So it's very much like how, well, at least how I code, actually. I shouldn't speak for everybody, but this is a common practice, right? You rethink things as you go along. Now that you know whether a state is valid, the next step is to figure out what are the allowed next steps in the game. So given any in-progress board state, what are the legal next steps? And being able to answer this is the first thing you need for that future prediction thing that I keep making references to. So once you've got the data models in place, you start putting all this together through a rough scaffold for the game. And that includes things like different renderers so that you can have like a command line versus a GUI renderer. And now we get to the interesting stuff, which is actually playing. So you build out your first little renderer and that's based on ANSI escape sequences that clear the screen and control where things are printed in the terminals. You've got your little XO board going on. And then it adds a bit of randomness and allows the computer to play itself. And the computer at this point isn't playing smartly, it's just randomly making valid moves. And then the last step, the article dives into is the AI. So greetings Professor Falcon, shall we play a game? Esoteric 80s movie reference that probably only you and I will get. The Minimax algorithm is a common AI tool for computer games. So how this works is it uses a tree representation of subsequent game states. So you start with the current state and then imagine all the possible next states. And those are put as leaves in the tree underneath that current state. Each of those leaves then does the same thing and you keep going and building this tree. And eventually you're going to get to some leaves that you can't get past because they're end states. And then you find all of those and you mark those with one, minus one, and zeros for winning, losing, and tying. And then you walk those backwards through the tree, annotating each of the branches to score the outcomes. So this allows you at the state you're in to say, \"Oh, I should take this branch or I shouldn't take this branch,\" maximizing the chance of winning and minimizing the chance of your opponent doing so. So basic things like chess engines and things like that do this, use this algorithm to play against computer users. The difference is in Tic-Tac-Toe, the board space is so small that the computer can see all the possible states. Something like chess or Go, the number of positions is huge and so they can't see completely into the future. And so then they start adding other algorithms to try and make guesswork. But for Tic-Tac-Toe, Python can just basically see the entire future, which means you really can't beat the chicken. I mean computer. And the article caps it off with writing a nice little wrapper that takes command line arguments to determine whether you're playing against another person or the random computer or the Minmax-based one. And like I said, there's no option for chickens, but you know, whatever. That's, uh, so deep article, lots of nifty little stuff here. Far more information than you would ever expect out of Tic-Tac-Toe.\n\nThere's actually a, I don't know the percentage of article that's covering the setup and getting it to be graphically",
    "rVEksrY9qNQ": "Welcome to the Real Python Podcast. This is Episode 138. It's the end of 2022, and it's been another year of changes at Real Python. The Real Python team has written, edited, curated, illustrated, and produced a mountain of Python material this year. We added some new members to the team, updated the site's features, and created new styles of tutorials and video courses. Three members of the Real Python team join me this week: Kate Finnegan, Garana Yella, and Leidanas Pozo Ramos. We wanted to share a year-end wrap-up with tutorials, step-by-step projects, and video courses that showcase what our team created this year. Kate and Garana helped to shepherd articles through the multi-stage editing process. Along with the rest of the team, they make sure these resources impart crucial Python knowledge and provide a thorough didactic experience.",
    "FjPHuqlnR_k": "Welcome to the Real Python Podcast. This is Episode 142. Have you worked on a project that needed an orchestration tool? How do you define the workflow of an entire data pipeline or a messaging system with Python? This week on the show, Calvin Hendricks Parker is back to talk about Apache Airflow and orchestrating Python projects. Calvin is the co-founder and CTO of Six Feet Up and the Python Web Conference co-organizer. He's recently been working on a massive project that requires thousands of jobs involving transferring and transforming data. Through his research into orchestration systems, he found Apache Airflow. Airflow is an open-source tool to define, schedule, and monitor workflows. The platform is pure Python and integrates with a wide variety of services. We discuss how workflows are defined by creating directed acyclic graphs (DAGs). Calvin talks about how a recent project outgrew the system and how his team built a clever solution using Python. We also discuss the upcoming Python Web Conference and what virtual attendees can expect. This episode is brought to you by CData Software, the easiest way to connect Python with data. SQL access to more than 250 cloud applications and data sources. Alright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey Calvin, welcome back.\n\nHey, it's great to be here, Christopher.\n\nI'm very excited to have you on the show again and talk about a couple of different things. It sounds like you've been working a lot on large projects and using some tools that I think we could use that might help our Python audience learn some new ways of doing things with these big projects.\n\nNo, definitely. Do you want to give a little background on maybe the project, then we could talk about some of the tools and define some terms?\n\nSure. We've historically been a Python shop since almost our inception 23 years ago. The most recent demand we've seen a lot of demand around Big Data pipelines. So whether you're going to be doing AIML or you've got a data lake or something like that or a data warehouse where you need to get data, you know, a lot of data, massive amounts of data into a single spot so that it can be then used for analytics or whatever questions that end users want to answer. Yeah, that's where a lot of these big data pipelines come into play. We recently did a large job. It's been about three years in the making for a local health system that they've been acquiring health system after health system. That's the trend, right?\n\nIt is absolutely, but you know, that produces new kinds of problems, right? Every health system that you acquire, they all had a different system for HR, they all had a different system for medical health records. They had, you know, you name the hundreds of systems that each health system is going to have, and you end up with a giant problem that you have to now pull all this data, normalize it in some way, or at least put it into an agreed upon format that the data scientists or the analytics team wants to use and get it over into your data warehouse and somewhat expedient fashion, because sometimes the data, they're trying to do these reports on, is time sensitive, especially when you're talking about healthcare. A lot of things they're doing right now, especially when it came to the pandemic, was the processing of COVID data. So they needed to be able to have certain service level agreements with their clients internally to make sure that the data got pulled in centrally, could be reported on, and then published back out inside the organization. Okay. And so you're talking about the potential for, you know, tens of thousands of tables across thousands of databases, you know, easily when you talk about a group scaling up this large, and that's just the kind of the numbers grow really, really quickly when you start thinking about the fact that you acquire 10 or 100 health systems, and each of those health systems has, you know, hundreds of databases internally that they all want to pull data from so they can now gather insights and answer questions.\n\nMaybe we could talk about just briefly the format that the data is in. I mean, this is as a general thing. Is it relational? Like are these systems that are like older SQL-based kind of things? Or are you looking at things like the NoSQL, the MongoDBs and such now?\n\nOh, it's all over the board. I mean, a lot traditionally, a lot of the data is going to be some kind of a relational database. But in their world, it could be flat files. It could be, you know, there's databases formats that I had never dealt with because I've just never been in the healthcare, you know, world. Yeah, and can be specific, yeah. There's some things that are, you know, predate SQL. So there's, you know, all kinds of crazy things. A lot of times those systems are leaving flat file dumps someplace for us to pick up, okay? Some of them are FTP. Some of them may be a REST API call to gather a dump of some kind of data out of a third-party system that they don't have control over the database of. So it really ranges. So those are like reports that were exported out and they run on a schedule or something. Yeah, or you've got specific kinds of queries where you know how to incrementally get data out of an API, okay, and bring it into the system. But by and large, most of it is SQL. There's lots of Oracle databases, lots of MySQL databases, Postgres databases. There's, you know, every kind of SQL database probably under the sun is in scope for this kind of a project.\n\nYeah, when you gather it all, are you using anything different? Like where are you placing it all? Are you keeping it relational there too?\n\nOh no, so in the end, like when you do something like these big data pipelines for these large enterprises, generally you're going to query the data in whatever format it lives in or wherever they've exported it to, okay? Pull that over into a central spot. So typically we have some kind of a landing zone where we will, you know, in this case, they started off or had an existing practice of bringing all the data into one spot as CSV files. So the first import or transformation is going to be extract the data, bring it into a CSV file, and put it into a storage container. In this case, they're using Azure, but you could use an S3, some kind of an object store in the cloud, okay? Where you now have the ability to have quick access to it. And then you're going to do more operations, transform, you know, fix data types. You know, there's lots of interesting things you'll have to do with the data because sometimes certain databases have certain constraints or limitations, and you need to work around those. Like maybe certain ones had limits on the column lengths that you may have be able to put data into. And so they've done workarounds by making multiple columns that are just continuations of the data. And so it's sometimes it's piecing that back together. Sometimes it's like splitting or reformatting or changing the column names. So that that's where the rest of the kind of big data pipeline really comes in is going to be that transformation. That's the T in the ETL of big data pipelines is going to be that transformation. And not all of them are in this project. Not many of them were very sophisticated or complicated. It's a lot of like joining stuff, splitting stuff, reforming stuff, naming stuff, uppercasing stuff, lowercasing stuff. You know, you think of any kind of string transformation or manipulation you would do to data passing through a pipeline. And that's kind of what they're doing here.\n\nThere wasn't a lot of like big calculations where they're pre-calculating a bunch of end results to save some time on the analytics side. That just wasn't the kind of data they were doing here. But you could imagine a system where you may want to save compute time on the analytics side by pre-computing additional columns, you know, using, you know, doing that inside your big data pipeline.\n\nYeah, it sounds like it's like normalizing can mean different things, but sort of standardizing the data, making it all kind of look the same so it's part of this new, like, family standard for this large organization.\n\nYeah, because if you've got 10 different HR systems and they've all got a different column name for first name, you somehow have to get them all to agree in the data warehouse so that you can query them from an analytic standpoint the same way.\n\nWhen I was working in sort of financial stuff, there were like these systems like cognos or some of these other kind of tools that were out there that could do this sort of pre-computing you were talking about that would sort of create somewhat transformed data that was ready, you know, for like a data scientist to go at it. But you really are just trying to make sure you have all the raw information ready to go and clean.\n\nOh yeah, totally. And what's interesting is because we've already talked about three or four big pieces of software. And just in the short description we talked about, for getting the data from someplace, putting the data in a spot, transforming the data, and then moving it into the data warehouse, a whole bunch of moving pieces are actually involved in the whole system.\n\nYeah, I had Carl Stratus on really early on. He's an author at Real Python, and he came on in episode 10. And we were talking about basically being a data engineering person in that role and how it's different from, you know, being a data scientist and the idea of like the whole ETL process. And so there's some more information there if you want to dig in a little bit about it. And we've had a few other kind of resources, but yeah, it is a unique set of skills and that almost communication is one of the biggest one.\n\nOh yeah, being able to talk to all these different teams and be able to translate, you know, what they know of their system and make it make sense to you guys who are doing a lot of the programming and building. Well, and that's what kind of led this group to what I refactor their existing data pipeline was that the backlog of importing new data sets into the system was just growing, growing, growing. They were never getting ahead of it because they couldn't get the new data sets onboarded fast enough. And some of that was just due to the technology they were using in the past to do this, the communication skills between the people, the formats of the data and fixing those kinds of things. But what we helped them build in the end was a way to describe their data, okay, and run it. And then take that description and it's technically we're just using like JSON files to describe the data. So they would have, in a case like a source, so as a source of the data, maybe it's an Oracle database someplace, they would describe in JSON files in like a folder, one per table that's in that source that they want to pull over. And that would have like the source columns and then the target columns and then have some information about the data types that would be in there and also potentially information about the types of transforms that would need to happen. So now a data engineer doesn't have to be necessarily a full-blown super senior Python developer to be able to import a new data set into the data warehouse. Right, you've got a lot of definitions, yeah, kind of ready to go, that's good, yeah. And so they could, they had, we helped them build some tooling to pointing at a database and build out a skeleton really quickly, then they can go and tweak a couple things. And then we built some more tooling around, and we'll talk a little bit about this too, which is Airflow, yeah. Airflow I definitely want to dive into, yeah. So Airflow is actually the main orchestrator of this whole big system. Airflow is telling the various other sub tools like what to go do. Now, Airflow can do a lot of these things, but we really felt like Airflow was an orchestrator first, and so we wanted to leverage it for that. Being that main power, and so building Airflow DAGs, which we'll talk about as well, which is like a directed acyclic graph, is really just a series of tasks, yeah, and these are, they describe how to get through that workflow from the ingest of the data to where it's going to live, you know, when it first enters the system to how it moves through the transforms, and then where it ends up ultimately in the data warehouse. And that's the Airflow's in charge of that from front to back. Yeah, so Airflow is an Apache product, Apache Airflow, yeah. It's open source, and I'll just read their little intro thing. It's for developing, scheduling, and monitoring batch-oriented workflows. It is an extensible Python framework, which is good for us and our audience here, and enables you to build workflows connecting with kind of any technology is what they're saying. And they use a couple like workflows as code dynamic. They're configured as Python code, allowing dynamic pipeline generation. It's extensible, and then it has a lot of flexibility and uses a built-in Jinja templating type of engine. So if you're familiar with Python, you're familiar with a lot of those technologies, this is maybe a good solution for creating large scale or even maybe small scale scheduling and monitoring batch-oriented workflows that they save as these DAGs, right? Right, right. And if you peek under the covers, it's Django, okay, interesting. So if you're that's one of the reasons why we picked it up and decided to actually help this project out and use Airflow is because we're and we've been Django developers for quite a while, yeah. And be able to leverage the understanding of the Django web framework,",
    "wQHeImWvYV0": "Welcome to the Real Python Podcast. This is Episode 146. Have you heard about a Python library with optimized data structures and built-in operations that can speed up your data science code? This week on the show, Jody Birchall, developer advocate for data science at JetBrains, returns to share secrets for harnessing linear algebra and NumPy for your projects. Jody details how most people begin their data science journey using loops to iterate over values and apply operations sequentially. We talk about how loops are friendly for beginners, being clear to read and easy to debug, but unfortunately don't scale well, especially with large amounts of data. Jody shares some of the basics of linear algebra and how to organize data into vectors. We talk about how the NumPy library leverages those concepts to improve processing data. We discuss how the library includes operations for vector and matrix addition and subtraction, and why these operations are more efficient than loops. We also cover how NumPy stores arrays in memory and when working with them is faster or when it's not.\n\nThis episode is brought to you by InfluxData. The InfluxDB time series platform empowers developers and organizations to build real-time IoT analytics and cloud applications with timestamped data. Learn more at influxdata.com. Alright, let's get started. Thank you.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com. Hey Jody, welcome back.\n\nHey, I am so happy to be here and the first episode of 2023.\n\nYeah, how are your holidays?\n\nThey were so lazy. I, that sounds great. Yeah, I did have to venture out once for a friend's birthday party, but honestly, it was just amazing. I slept so much, I ate so much.\n\nYeah, yeah, similar. Yeah, that and I played a bunch of video games, so it's perfect. I read a bunch of books. It was great.\n\nSo we're kind of in between conference seasons?\n\nYes, yes, yeah. And you had this talk that we're gonna kind of get into today. You've done a few times and I'll definitely link to one of the ones that you had done at what was it, PyCon UK?\n\nYeah, PyCon UK. Yeah, yeah. What's the title again? It is \"Vectorize All the Things.\" So basically the idea behind the talk and what we're going to be talking about in the episode today is how you can understand how these vectorized operations that you implement in NumPy, you know understand what's going on under the hood in terms of the math, but also understand why they're faster. And I actually was inspired to give this talk because like I came, I think I've talked about this, I came into tech, I came into Python like really just not understanding anything and I used to do everything with loops. And yeah, it was just so slow and I was like I know that it's faster, like I know there's a way to make this faster. So right, yeah. This is sort of a bit of a story of my journey of how I came to appreciate NumPy better, how I came to understand it, sort of wanting to demystify and break it down for people who might sort of be in the same situation and struggling a little bit.\n\nYeah, a very, a very pat answer is why aren't you doing, you know, vectorized operations and it's like, well, okay, I need to understand how those kind of work and you know, where to look to set up code and I'm comfortable doing loops already.\n\nExactly. So I'll just, you know, make coffee or whatever. We've joked about that before where, yeah, yeah. And so, yeah, but it's nice to kind of switch. And part of it is terminology. You in your talk talk a lot, a lot about kind of the concepts of just being comfortable with the fundamentals of linear algebraic terms, not necessarily, you know, needing to do a bunch of that stuff on paper, but just understanding kind of so that you could sort of visualize them and that makes it a little hard to do as a podcast form. And so if people would like supplemental information, the talk, I think, can help you add some a little bit of additional visuals if if you're still kind of a little stuck on it. But we'll do our best to try to make sure that that it's clear as we go and lots of questions. We were kind of joking about our mathematical backgrounds, if you will, like what we studied in school. And I, I had this kind of really bad experience. I was like a super a student all the way through high school. And then I got to my last, you know, year senior year in the States and we had this weird fiasco happen where my calculus teacher ended up being like removed from his position. Oh my God. And the person they replaced him with was my physics teacher and she was terrible at teaching calculus. She was a fantastic physics teacher and the person they brought in for the physics was really bad too. So it was like I'd, I'd never had this happen before, but I lost interest in both subjects. Oh, that's so sad. Yeah, yeah. And it like that went into, like, kind of my college experience and the college experience I had at Arizona State, which is now a fine university, but at the time late 80s was pretty lacking. And I just kind of burned out on all of it and got really into music and dropped out of school and did music. Yeah, so I only kind of came back to programming much later. And so it's kind of kind of a bummer for me, but you said that in Australia, you had an interesting sort of math journey. What was the term used? Um, there are two types of math. Oh, that's like advanced math and not so advanced math. Like it's obviously not called that, but right, right. So, um, it's kind of like interesting because I think I had maybe the opposite sort of journey to you. So, okay, I grew up in this quite small town and I wasn't really courage to pursue math even though I was good at it. Yeah. So I actually, like, I did a lot of humanity. So I studied art and I studied, I'm really bad at art, but I started, sure. I studied music actually. I used to play French horn. I studied history and I studied English literature. So I did math, but it wasn't really like, you know, advanced mathematics, right? And it meant that when I went to uni and then I had to do all these statistics, I didn't necessarily have like the formal linear algebra background. They did have calculus, but we didn't really do much linear algebra. And obviously this was kind of a problem when I started trying to learn machine learning, especially neural nets and deep learning because so much of it is based on linear algebra. So actually I got so frustrated. It was a few years back, I'm like, I'm so sick of like half understanding this. Like I just don't understand what they're talking about when they're talking about these like matrix and transformations and stuff. I sat down and there's this incredible series of lectures. It's a course from MIT and it's available in MIT open courseware. Okay. By this is this legendary professor called Gilbert Strang. I will share the, the link. Yeah. Yeah. And it's just this man is one of the most brilliant teachers I've ever seen and um, he actually has some more recent books, which are kind of more focused on linear algebra for machine learning and optimization and things like that. But the core kind of book that he has in the course that goes along with it are just, it's not even applied. It's not even something like except for maybe like principal components analysis, which is taught in the course. Okay. It's not even stuff that you would be able to apply directly to machine learning, but it's so fascinating. And yeah, like",
    "lao1z4uzTFU": "Welcome to the Real Python Podcast. This is episode 147. Have you decided how you're going to deploy your Django project? Should you use a virtual private server or a platform as a service? Christopher Trudeau is back this week bringing another batch of Pi coders weekly articles and projects. We also have organizers from Podcastades to share details about this year's hybrid in-person and virtual conference. Christopher shares an article about selecting an appropriate Django project deployment strategy. The guide compares virtual private server and platform as a service systems. He also covers hosting providers for each and highlights potential pitfalls. We share several other articles and projects from the Python Community, including a news update on what's new in SQLAlchemy 2.0, how to flush the output of the Python print function, the dangers behind image resizing for machine learning, a project that visualizes pathfinding algorithms, and a runtime executor project. We also have three special guests from Pie Cascades 2023 to dig into the details of the conference. Conference chair Eliza Serbaza is CTO at Women Who Drone and Leadership Fellow Python track and Python Developer Advocate at Women Who Code. Sprints chair Gopinath is a software engineer at realtor.com and a senior lead at Women Who Code Python. Speaker support chair Jolene Wong is a senior software engineer at Cisco based in Vancouver. We discuss hosting a hybrid conference, participating in open-source Sprints, and finding your local Python community. This episode is brought to you by Sneak. Sneak helps Python developers stay secure without slowing down by providing real-time code scanning and actionable fix advice right from their IDE. Alright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com. Hey, Christopher, welcome back!\n\nHey, hello from a very snowy Toronto. We finally got our winter. Oh my gosh, we've been holding it hostage here in Colorado, and it escaped. You can have it back. Oh, thanks. Yeah, so you found a little news thing just as we were going to begin. Just a quick one-liner: the 4.2 beta of Django has been released just a couple of days before we started recording. If you're playing around with the new thing, go check it out. Awesome. Your article is kind of related to a release also, right? Yeah, ish. Sure. So I'm starting out this week with something called what's new in SQLAlchemy 2.0. Then it's by Miguel Grinberg. In case you're not familiar, SQLAlchemy is a Python library that abstracts working with databases in SQL. It's been around for a while. Its first release was 2006. And if you've worked with the ORM and Django, parts of it are similar to that. The reason I say part of it is because SQLAlchemy is made up of two chunks. What it calls core and the ORM. The core part is a series of direct wrappers to SQL. So if you're doing an insert in SQL, you're going to be calling a statement builder that uses an insert function and then executing that statement. The ORM, well, ORMs are that's short for object-relational mapping and it's based on the idea of writing objects or classes that map to underlying database concepts. So I might describe a person with a first name and a last name and the ORM would map that to tables in the database. For example, SQLAlchemy has been going through a transition. The 2.0 release is recent, but the ideas behind it were introduced in 1.4 as to sort of ease people into",
    "nN7TV_A2hrs": "Welcome to the Real Python Podcast. This is episode 149. Have you explored Python's collection module? Within it, you'll find a powerful factory function called namedtuple, which provides multiple enhancements over the standard tuple for writing clearer and cleaner code.\n\nThis week on the show, Christopher Trudeau is here bringing another batch of PyCoders Weekly articles and projects. Christopher discusses his Real Python video course about writing more Pythonic code using namedtuple. With named tuples, you can create immutable sequence types that allow you to access their values using descriptive field names and dot notation instead of clunky integer indices.\n\nWe also discuss meta programming and the unique advantages of Python's dynamism. Christopher shares potential paths for this type of coding from web applications testing and AST techniques. We share several other articles and projects from the Python community, including a news update on the Aero Revolution happening in Pandas 2.0, a new PEP for inline comprehensions, tips and techniques for modern Flask, Cap, a Python helper tool for building and running a REPL with custom commands, and a project to turn a Pandas DataFrame into a Tableau-style UI.\n\nThis episode is brought to you by RevSys. RevSys is the leading Python consulting firm. They help organizations of all sizes build, scale, and improve their existing Python and Django-based web applications. Alright, let's get started.\n\n[Music]\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com. Hey, Christopher, welcome back.\n\nHey there. So we got a couple of news items you kind of grabbed here kind of quickly before we started. Just a couple quick announcements. The first one is the work on Python 3.12 continues, and Alpha 6 has just shown up. Lots of good stuff there, and in fact, they're still adding stuff to it. Spoiler alert, we're going to talk about a new PEP soon that's been slotted in there too. Okay, and then the second one I haven't had a chance to look at this yet, but the results from the Django Developers Survey in 2022 have been released. So go look at the data, and there were almost 5,000 respondents from 247 countries. It'll be interesting to see what the insights are there. Yeah, cool. It seems like Jetbrains is always the team that seems to help with these surveys. That's great. Yeah, it seems to be their go-to. Yeah, awesome. So, and then you wanted to go first here with your first, if you insist, sure, why not. Yeah, okay, great. So, starting out this week with one of my own courses. It's been a while since I've done the ego thing, so we'll do it again. This one's called Writing Clean Python Code with Named Tuples. And as with a lot of my projects, they're based on somebody else's work. So I don't have to do the heavy lifting. This one is Leo Danes Esposto Ramos, of course. And as the title probably captures, it's all about named tuples. Named tuples are found in the collections module, and they're kind of halfway between a tuple and a class. They predate the data class concept, and so they serve kind of a similar purpose. Oftentimes when you're using a tuple, it's helpful if you have some more context. So if I give you a tuple with three numbers in it, for example, what does that mean? The named tuple adds that extra context. So I can create one specifying that it takes three arguments, the x, y, and z. And the tuple itself is called 3D point, right? So that's a lot more meaningful than, say, just giving you something with three floats in it. You construct a named tuple using a factory function that is called named tuple, which is all lowercase. Nice and simple idea. And you give the factory the name of the class that you want to create and the arguments it should take. It returns a class, and then you can instantiate that class as many times as you like. The argument block can either be a string with spaces in it, so that x, y, z that I was talking about would be \"quote x space y space z\" or it can be an iterable. So you can give it like a list of strings, each being x, y, z. I tend to use the latter simply because it seems it looks more like keyword args to me. It just makes more sense, but they both work. And like with classes, the named tuple arguments can take default values. So you can construct instances without all of the arguments. And once you've got your instance, you can now use dot notation to access the members instead of just square brackets like you would within a tuple. This, to me, is one of the key advantages from a code readability point. So back to my 3D point example, in a normal tuple, I'd have to say point square bracket one. And whereas with my named tuple, I can say point dot y, right? And that's a lot clearer as to what that is. And this is particularly useful if the definition of the object is a fair ways away from the usage of it in your code where you can't, you know, you wouldn't see necessarily like a comment or something as to what is that second part about. Half the course is dedicated to sort of use cases for the named tuple. The first couple lessons are on how to build them and sort of where's and why's. A good example for code readability is using named tuples as return values from functions. So if you're writing a function that normally returns multiple things and you are going to use a regular tuple, it's not always clear what's inside of it. And by returning a named tuple instead, your code is somewhat self-documenting. And again, a lot of these ideas predate the typing mechanism. So this is trying to deal with some of the same kinds of problems that typing now handles instead. So the example in the course of this is you get to rewrite the divmod function. Divmod does division, returning both the quotient and the remainder. And the new version of it returns a named tuple called divmod. And inside of it, you can see that the quotient has one value and the remainder has the other. So it gives you the idea of what is actually coming back rather than just a tuple with two numbers in it. The course has a lesson on comparing named tuples to other data structures, including things like performance characteristics, as well as a lesson on extending the class to do your own funky stuff. So pretty much a classic Leodanis article and a course built on top of it, sort of taking something that everyone thinks is simple, \"Oh hey, I know what a named tuple is,\" and then going really deep on it and seeing all the stuff that you can do with it. So if you prefer the visual mode of reading, you've got the article, and if you want me to yammer at you, you can take the course instead. Yeah, this is a good one. I really enjoyed going through it and got a lot out of it. It's one of those things that I use a fair amount when I code, and there was still things in there I'm like, \"Oh hey, there's an idea I haven't tried before, right? Maybe I should try that.\" Cool. So my first one is an article by Mark Garcia, and it's on his own website, datapythonista.me. Mark is a core dev for the Pandas project, and his article is \"Pandas 2.0 and the Arrow Revolution.\" This came out about mid-February at this point, and I wasn't aware of some of these changes, but I also wasn't aware that Pandas 2 was out, and it kind of is and it kind of isn't. It's sort of in this sort of dev path as a bit of a release candidate. There aren't massive breaking changes, and that's actually one of the beginning parts of it. It's like, \"Okay, how are we going to grow and adapt and move this ecosystem that Pandas is the center of in many ways? How are we going to move that forward without breaking these changes for all the users?\" And so, how can we do that and do more subtle but really still more important things under the hood? One of the big things is this focus on Arrow, and the Arrow library. I've mentioned, I don't know, probably for a year and a half now off and on. And actually, I had a really good conversation when I was speaking about Polars a couple weeks back and how it uses that library also. It's not a data storage format. It's much more of an in-memory format, and how the data structures are sort of held in memory. You can kind of think of it as like NumPy's really a storage format. You're still organizing information. So there's things like Parquet that are potential things that go along with it. But what this thing did, this article for me took me on this interesting journey through not only what Mark's been doing, but what Wes McKinney, who is one of the key guys who created Pandas from the beginning, West McKinney has been on a real journey trying to get this Arrow format going. And I had no idea how deeply involved he was with it and kind of why he had a presentation in 2013 at PyData New York. And at about the same time, he wrote an article about the 10 things I hate about Pandas, which is very interesting. You know, coming from the creator of Pandas, but he's always been that way, I guess. He always has wanted to think about the future, think about what the stumbling blocks are and try to steer things toward where things are going. And he started to develop this Apache Arrow project in 2015. And since then, it's continued to build a developer community around it and sort of to achieve these dual goals of what it could do. And in 2017, he had an article basically as a follow-up of Hachi Arrow and the 10 things I hate about Pandas. And that kind of went a little further on it. And then there's a video that he, there's an organization called Two Sigma Investments, and he had a talk there at one of their conferences called \"Data Science Without Borders\" or, which I'll include a link with, which I watched and really epitomized a lot of this sort of forward thinking and how he was working with the creator and kind of champion behind Arrow in their teams. And he created this company called Ursa Labs. Get it? Pandas, Bears, right? And in 2021, he described how he was working really hard with all these other platforms and organizations to make sure there's this compatibility. Very often in data science, you're moving things kind of across different platforms, especially with like GPU accelerated stuff. There's this project called Rapids, CUDF, another project called Blazing SQL. And so he talks about a lot of these things. And in 2021, he has an article on his own blog called \"Joining Forces for an Arrow Native Future.\" And at that time, they renamed the Ursa Labs to Voltron Data, which he felt was a good name. If you're not familiar with the cartoon Voltron of like all these robots coming together to create the big large robot, which I think is again kind of a nice in joke there. So why all of this stuff and why the need for it? I had a recent episode where I talked with Jody about using NumPy and we talked about kind of the structure of NumPy and how it's been used in Pandas. And this sort of primary method in it, but that's kind of the problem and dilution for Pandas up to now. But it wasn't really designed to be a data frame supporting library. And the problem with NumPy is it is really, you know, it's in its name, it's designed for numbers and integers and floats and things like that. And for other types, things like strings, dates and times, categorical data, you have to make a bunch of decisions about how that stuff's going to be handled. And this kind of goes back to the original article before I went on my big Safari journey here. I found all these other articles and stuff. He talks about that. He talks about initially the problem with Python data structures themselves are really big. Something like an empty string is, I don't remember how many bytes it is, but just the fact that it's an object and it has all these methods and things that are attached to just an empty string in itself, let alone things like lists, dictionaries, you know, tuples and so forth. And so those data structures can be really slow because they have all that functionality built into them. And so NumPy helps with that. But if you're not working with purely numbers, which has always been one of these things that has been what I've done as far as data science goes has been like words or addresses or other kinds of things of kind of working with other data that's kind of working with other data that's in it. You have to do work and kind of get it going. And so Arrow has a lot of types in it. It has, there I'll include a link to this new documentation as far as what's happening in Pandas. And it's really impressive the amount of formats that are now sort of D types that will be available. And the article that he goes through in Mark's article, he goes through and it describes a handful of different examples of how this code will look and be a little different. He also gets into the problems that have always been there for Pandas as far as working with data that where there's nothing there, missing values that are in your data. And what has been workarounds. And then it gets into the speed of operations and stuff like that and a really great comparison chart of NumPy versus Arrow. The other thing he likes to focus on in this is this sort of interoperability, the idea that there are different libraries that have advantages one way or the other. And they may be written in Python or C plus plus or they might be GPU based or they might be something like Rust like what Polars is doing. And he talks about this example of like loading in the data from an S3 platform into a Pandas data frame and then exporting the data frame to a Parquet file and then loading the Parquet file from Polars and then making transformations within Polars because it's very quick. Exporting that Polars data frame into a second Parquet file and then loading them Parquet into Pandas and exporting the data. What he's saying is instead of having to do all that import/export, if we can keep it all in memory, it's going to be dramatically faster. And that's kind of what Arrow can provide is working with all that and just transferring the information, your data frames, if you will, in this in-memory format as Arrow. So I think it's a really nice article to get you going on a lot of these ideas. I again went on a big journey and was just fascinating to find out like how far and how long they've been working toward this thing. And I think it's important to pay attention to the space because it's definitely the direction, no pun intended, that Pandas is headed. They're going toward Arrow and not only in Pandas 2.0. You think about the direction of data science and what they're trying to do with it and Wes has been working long and hard on it. I guess Mark would be also on the team there. They've all been working toward making this. And so that was really my main takeaway. So I'll include lots of links on this and I think you might get a lot of it just kind of seeing some of the decisions and why in the background behind Arrow. Yeah, it's truly one of Python's superpowers that he can just plug in other stuff underneath it, right? And being able to take advantage of a solid library from something like the Apache Foundation and then build on top of that is, you know, it allows us the best of both worlds, right? I don't have to code anything in C and I can still take advantage of the speed. So, yeah, totally. Python is a crew of Python experts. Their team of senior developers, ops people, and consultants knows what works and what doesn't. They've been where you are before, probably many times. Let them draw on their deep well of experience and guide you to smooth waters. RevSys offers a variety of services customized to your client's needs, like code reviews, architecture design, embedding with your team to improve velocity, writing your first test, or doing your Python and Django upgrades for you. What you don't know can hurt you. Let us make suggestions to improve your code and processes. Learn more at revsys.com. Hello. The Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com. Hey, Christopher, welcome back.\n\nHey there. So we got a couple news items you kind of grabbed here kind of quickly before we started. Just a couple quick announcements. The first one is the work on Python 3.12 continues, and Alpha 6 has just shown up. Lots of good stuff there, and in fact, they're still adding stuff to it. Spoiler alert, we're going to talk about a new PEP soon that's been slotted in there too. Okay, and then the second one I haven't had a chance to look at this yet, but the results from the Django Developers Survey in 2022 have been released. So go look at the data, and there were almost 5,000 respondents from 247 countries. It'll be interesting to see what the insights are there. Yeah, cool. It seems like Jetbrains is always the team that seems to help with these surveys. That's great. Yeah, it seems to be their go-to. Yeah, awesome. So, and then you wanted to go first here with your first, if you insist, sure, why not. Yeah, okay, great. So, starting out this week with one of my own courses. It's been a while since I've done the ego thing, so we'll do it again. This one's called Writing Clean Python Code with Named Tuples. And as with a lot of my projects, they're based on somebody else's work. So I don't have to do the heavy lifting. This one is Leo Danes Esposto Ramos, of course. And as the title probably captures, it's all about named tuples. Named tuples are found in the collections module, and they're kind of halfway between a tuple and a class. They predate the data class concept, and so they serve kind of a similar purpose. Oftentimes when you're using a tuple, it's helpful if you have some more context. So if I give you a tuple with three numbers in it, for example, what does that mean? The named tuple adds that extra context.",
    "wgQ1PZxgE1Q": "Welcome to the Real Python Podcast. This is episode 152. Are you exploring automation of your repetitive business tasks with Python? How are you going to share these useful tools with coworkers? This week on the show, Sampo Ahokas from Robocore is here to discuss robotic process automation and distributing these robots. Sampo is a co-founder and VP of Engineering at Robocore. We talk about using Robot Framework, an open-source RPA tool, to develop bots that implement your existing Python skills. Sampo shares example projects and additional resources for new users. We discuss the typical difficulties of sharing automation tools with a team and trying to avoid the dreaded \"works on my machine\" problem. Sampo describes how their group worked to develop a Conda-based tool for creating shareable packages and environments.\n\nThis episode is brought to you by RevSys. RevSys is the leading Python consulting firm. They help organizations of all sizes build, scale, and improve their existing Python and Django-based web applications.\n\nAll right, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey, Sampo, thanks for coming on the show.\n\nHey, Christian, and thanks for having me. Pleasure to be here. Yeah, you reached out a while ago, and it took a while to kind of get things scheduled, but I'm excited to talk about it. This has been kind of an ongoing thread on the show, actually, multiple threads kind of tying together this idea of doing automation and scheduling tasks. We've been talking about Airflow and a couple of other kinds of tools that have to do with business processes, and this one seems to kind of tie a lot of that together. So maybe you can talk a little bit about what RPA, robotic process automation, is.\n\nAbsolutely. I've been actually listening to your podcast. Oh, great. So Airflow kind of touches these a little bit from different angles. Look into Airflow as a base for our product early on, but we ended up building our own automation. But that's another story. So onto the RPA. RPA is basically using software-based robots or bots to automate repetitive tasks, typically without altering or accessing systems. In a way, you often have systems that are not designed to be automated, especially not via API. So the bots can use the system exactly as a human would and get things done.\n\nTo kind of clarify, by saying \"kind of a non-modified thing,\" this could be like an individual worker's workstation at an office, something that's not specifically set up for this particular task. Is that what you mean?\n\nYes, absolutely. A lot of the systems we see are what I call legacy systems or some old-school Java applications, Windows MFC, basically any type of user interfaces where you don't have a programmatic interface. So that's the classic RPA.\n\nAutomation can sometimes be a little confusing as to what exactly it means. What do you mean in this particular case? What are we automating?\n\nThere are endless use cases, and like our CEO likes to say, in RPA, oftentimes the use cases are like snowflakes, meaning that each of them is unique to the company that wants to automate. But just a few samples, like concrete examples, maybe starting with a very simple one from our company. We are a young company, around four years old, a small company. In Finland, at least, companies are legally required to keep very detailed records of employees' working hours. That makes a lot of sense for some companies, but in companies like ours, we basically value results, not so much like how many hours in a given day. So one of our developers made a bot that will log into the HR system at the last day of a given month and just submit the hours for all the working days. So kind of a very simple example of how this can save the developer, let's say, 15 to 30 minutes a month, punching in the hours for each day.\n\nDefinitely, yeah. That's something that could be easy for someone to forget. So what sort of system would that be running on in your particular office?\n\nIn our case, this specific bot is running on everybody's own workstations. So the system that's being automated is a web-based system where you just need to input the hours, and the bot is running on your own machine.\n\nNice. I like that example. That's a pretty common one I can think of for a small office. Do you have some other common examples of these sorts of little tasks that people want to automate?\n\nOh, absolutely. So what we see in the customer maybe in the little world a bit more, one classic example is, let's say a company gets a new customer, and they might have 10 different systems where they need to input data about the customer--the name, status, that kind of thing. So you might just input the data once and kick off a bot that logs into each of these systems where this information needs to go and then types it in there with whatever means necessary for any given system. Some other examples that I can think of, something that we very recently worked on is, for instance, comparing two signatures. A company has a reference signature from the customer in their records, and then they get a new document sent by the customer containing a signature. So the bot will actually compare the signatures and try to determine if these are for the same person. This use case was built with artificial intelligence making the ultimate decision. But in this example, RPA is kind of the hands of the AI. RPA is the way to get the documents there and get the results where they need to go, etc.\n\nThe example you gave first of sort of onboarding a customer, I can kind of think of a reverse of that--how someone involved in maybe HR, the human resources part, of hiring someone and the very repetitive information that just gets filled in onto every single form.\n\nThat's a very common case, yeah. In this particular case, maybe we can get into what the system sort of looks like that is implementing that.\n\nOh, you mean the RPA platform? Yeah, kind of what's kind of underneath the hood there. It sounds like you're able to give this to a developer to create these tools, and maybe we could talk about deploying it if you will, sending it to these other machines to be able to run and be a bot by themselves.\n\nAbsolutely. So typically, if we didn't go for RPA deployment, the bot needs to be built on the developer's machine. So the developer has to teach how the bot will do what you need. For that, we have been using some open-source tooling as well as some free tooling that is not completely open-source. But that's the kind of the thing you see if you look at our company on GitHub. So there's a lot of libraries that you can utilize and build on top of, and our stack and diary are Python. The developer can basically use the Robot Framework or then some add-on libraries on top of that. So it's all up to the developer to choose. Then, let's say the bot is eventually built and it's working on the developer's machine. Then, the question is how to deploy it.\n\nThere are two main ways to deploy RPA bots, but we classify them both as attended and unattended. Attended would typically mean that it runs on a person's personal computer or workstation in a way that the person is always triggering it, essentially having a small application where they can press a button and say, \"All right, now I need you to do something.\" The other type of deployment is unattended, which is more like a back-office type of deployment where the bot can run in a virtual machine or a container or basically any type of compute that you have deployed on, and the operation is managed by what is in the RPA world called an orchestrating the work to the workers at.\n\nTo go back to kind of the developer story of working with this, is that where this Robot Framework kind of comes in and what is that?\n\nYes, definitely. It's actually an open-source automation framework that has been built and improved upon a lot. It's built on Python and provides a keyword-driven approach for defining automations. It's 100% open-source. It's roots are in test automation, so it is actually also from Finland. There's a guy, Pekka, who made it as his master's thesis back in 2008 or something like that. So it's already a mature project.\n\nDid you say testing automation?\n\nYes, test automation. Great, yeah. The roots are in test automation, and over the years, it has been adapted towards more to be more readable for any type of automation tasks. So this one, I understand the framework kind of being built using a lot of Python. There's still quite a bit of configuration that you're doing inside of it, also to provide the set of tasks and things that you wanted to do. And in that case, you're using a configuration file, and you chose YAML for this?\n\nYes, all of that is based on YAML. I don't know if you've heard recently, we've had a little back and forth about YAML, Christopher Trudeau and myself. Him spending a little more time on it than me, and we were talking about some of the quirkiness of it sometimes. Are you using a specific version of YAML?\n\nI know, I'll use it these pretty basically thinking between JSON and YAML, and YAML can have comments.\n\nYeah, that makes a big difference, right? That's great. Yeah, it looks like there's like a couple files you set up that are YAML. There's the robot one, and what are you configuring in there, the robot.yaml?\n\nSo we have those as a cornerstone. There's two YAMLs, and the robot is essentially defining what the robot is doing. It contains a list of tasks, so you can bundle multiple tasks in one bot, and then you can choose to run one after another. So it is just a simple definition that tells the bot kind of entry points you have into the bot that you are deploying there.\n\nOne of the things I really liked about the repository that you have is that if you were to search Robocore and just type in example, it'll definitely surface a lot of interesting examples. And then you could also maybe even narrow it to Python if you want to see ones that are implementing lots of Python-specific libraries or tasks. Any other suggestions on searching for examples?\n\nYes, so we have a whole website here. It's called the Robocore Portal that has tried to collect different technologies when you sometimes know that you want to indicate, let's say, Microsoft Excel or you want to indicate Salesforce or a certain type of system. So we have some examples centered around that. And some of the other examples are more towards use case. So this is how you would build, let's say, invoice processing, where you have a certain flow of the systems where the organization comes into more into play. So you might have, let's say, an Excel file coming in, and then you split that to do multiple subtasks. You might process them in parallel and ultimately combine or resize that kind of thing. So there's a huge bunch of examples we have tried to collect to make it easy to get started.\n\nNice. So when you kind of dig in, where does the Python part of it kind of come in as far as how it integrates with Python? Like, what are some examples of how that kind of ties into the Robot Framework?\n\nYes. So the integration is pretty seamless. It's a pretty thin layer on top of Python, and you can essentially implement user keywords in Python. So you'll just have a certain convention that you have a Python function called \"X,\" and you can invoke it from the keyword. So all in all, it's pretty seamless and a low barrier to jump between Python and Robot Framework.\n\nIn some ways, it feels like you're scripting out and kind of jumping past the having to build out a command-line interface. You're sort of defining all of it in the configuration files.\n\nOh, absolutely. That's one part of it. And what we feel that we're one of the big value quantum is actually the logging. So with Python, if you want to trace what the bot is doing, you need to essentially implement it yourself. I'm sure there are some packages, etc., so it's not rocket science. But with the Robot Framework, you will get by default a log that contains a lot of information on what was executed and what was the result of each keyword. And if something fails, you immediately can tell from the log that, \"Hey, this is where we went wrong.\" So we feel that that is one of the biggest value adds of the Robot Framework.\n\nSo kind of going beyond being a solo developer writing your own individual scripts to run little jobs here and there, this might be the graduation point where you're like, \"Okay, I do need it to do logs, I do need it to combine multiple script steps together, things like that.\" Is that kind of what we're talking about?\n\nYes, absolutely. And all these basically feed into the application level as well. So you can have a bit closer to human. So some companies even utilize these to, let's say, review the tasks or tests with sometimes even business people because they are a bit closer to human-readable in the sense that you can make sense out of that without understanding code. So there's a lot of benefits. But on the other hand, we are not too opinionated on that. So we have customers who are running just Python because they have the confidence for that. They have maybe invested in building their own frameworks that facilitate and provide the standard structure for Python. So that's also totally fine. So everything built on Python, regardless.\n\nRevSys is a crew of Python experts. Their team of senior developers, Ops people, and consultants knows what works and what doesn't. They've been where you are before, probably many times. Let them draw on their deep well of experience and guide you to smoother waters. RevSys offers a variety of services customized to your client's needs, like code reviews, architecture design, embedding with your team to improve velocity, writing your first test, or doing your Python and Django upgrades for you. What you don't know can hurt you. Let us make suggestions to improve your code and processes. Learn more at revsys.com. Hello.\n\nOne of the other potential issues that someone could run into if they aren't the developer or even if they are the developer is then sort of sharing this tool and sending it to another machine. In the case of Python libraries and other things that may not be on that machine, maybe it's a brand new user and you need to set up the logging of hours. Is that the way that you have for sharing those things, those environments, if you will?\n\nSure. So these, first of all, I have to say that when we were starting the company four years ago, I would never believe it's this difficult. So we have invested way more time and resources into building this than I would have originally thought. But I think it has been all worth it. So yes, ultimately to pick up challenges, we divide them into two. It's easy. You easily end up in a situation where it works on your machine, but maybe you have a certain version of Python that came with your operating system. Then you try things out, you install dependencies, pip install, all very easy, convenient, nice. But soon you are in a situation where the environment has kind of organically happened and you don't really know exactly what is there. And that's cool when it's on your machine, but when you need to deploy Python in production, it gets a bit more tricky. And of course, still, if you can build a Conda script that handles library installation and run everything in a container, it's still pretty easy. But when it gets complicated, in our experience, when you need to ship it to somebody's desktop, and more precisely, if you cannot use container technologies, and this is the case with RPA typically, when you need to interact with, let's say, Windows desktop application, yeah, if you run your bot in a container, it's not gonna work. So you need to be able to deploy it to the end user's computer.\n\nIt sounds like kind of combining a bunch of common issues that we've been talking about on the show of getting things set up correctly. It's interesting that you're leaning on Conda environments. That's not something that we've talked about a ton on the show. Is there a particular reason that you've chosen that over other potential ways of doing it?\n\nSure. So the Conda was chosen ultimately because we wanted to first of all deploy the Python along with our stack. So you don't need to have Python there, and this is a big enabler for systematically maintaining Python versions. So you can have a project that you are now building with Python 3.9, and then you have another project that's using Python 3.10, whatever version you have chosen. And if you want to reuse the same virtual machine for running these bots, then it gets tough unless you can manage the Python version in a Conda fashion. So this was ultimately the reason we went with a Conda-based solution because Conda works very well. It already has Python available, so you can just say that I want this version of Python, and it has Conda out of the box. It also works for reporting other binaries, yes, like you are not even restricted to Python. So yeah, so it is in that sense it's more robust and more flexible. I think it is the reason that it's as popular as it is in the data science communities because very often they are leveraging those C libraries and other kinds of resources that you can't really necessarily do easily with pip by itself. You might need to have a little more overarching environment, exactly. As well, and then we partnered with a company called Quansdac, and they were building an open-source tool called MicroMamba, which is a tiny C++ executable, and it is like a very self-contained small executable, and yet it is able to kind of bootstrap a full Conda environment. And that's actually what we use under the hood in our stack as well.\n\nI actually went ahead and played with this tool, and the tool is that you have for doing this is called RCC. Like, what does that stand for?\n\nWe don't have an answer for that.\n\nOh, okay. I like these days. I like to use the definition given by one community member. He's not even our customer, one guy from the community, and he called it a really cool command. All right.\n\nSo to set up RCC on the machine is really the key thing.\n\nOne of the things that you have in a lot of the documentation that I was kind of going through is that in the past, if you are a Python developer, let's say, and you want to share this tool with Joe or Jane down the hall and set it up on their machine, you may have printed out three pages of instructions for them to follow to get it all set up. And that might be, you know, hey, you need to install this particular version of Python and then you need to do this and so forth. So installing RCC, in the case of my Mac, it used Homebrew, which",
    "XTGvrVeamkg": "Welcome to the Real Python Podcast. This is Episode 153. What can you do if your text manipulation in",
    "Zex1ESo6ASQ": "Welcome to the Real Python Podcast. This is Episode 167. What are the new ways to describe your data in Pandas 2.0? Will the addition of Apache Arrow to the data backend foster the growth of data interoperability? This week on the show, we talked with Pandas core developer Mark Garcia about the release of Pandas 2.0. Mark shares his background and work on Pandas. We discussed the history of data representation in Pandas and the need to move beyond NumPy. We also talk about how Apache Arrow only solves some of the issues. We dig into the potential of an Arrow backend and how it could offer interoperability between data platforms. We also cover the many impediments of adoption and backward compatibility. Mark also shares his thoughts on making Pandas more extensible.\n\nMark was traveling when we recorded this episode, so please excuse",
    "TtAAer_2Jw4": "Welcome to the Real Python Podcast. This is episode 170. What should you consider for picking a font for coding in Python? What characters and their respective glyphs should you check before making your decision? This week on the show, we talk with Real Python author and core team member Philip Xeni about his recent article choosing the best coding font for programming. Philip shares some of his background as a font engineer and graphic designer. We talk about how font design tools were his introduction to programming in Python. We discuss how frequent Python syntax of underscores, @ signs, parentheses, and asterisks should affect your decision. Philip's tutorial provides several resources to help you find a monospace font that fits your coding requirements.\n\nAll right, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com.\n\nHey, Philip, welcome to the show.\n\nHello, hello. I'm super happy to be back.\n\nYeah, we had you on, gosh, maybe a year ago. You came out with Christopher and myself and we talked about your Flask sort of series, I guess it was.\n\nExactly, yeah. I remember it like it was yesterday. No, it was November last year when I was creating the series about Flask. And yeah, I had the honor of joining the two Christophers on the show. Yeah, that was fun.\n\nWell, and you're back to discuss something that is maybe a little closer to your history in programming and previous career path to talk about fonts. And you wrote this article titled \"Choosing the Best Coding Font for Programming.\" It came out about a month or so ago, and I have to admit that I sort of glossed over it because I was like, \"Oh, I got my font selected. I'm good.\" But then you actually went on another podcast to talk about it, Engineering Kiosk Number 79, which is a German podcast. Maybe tell me a little bit about that show. Had you been listening to it or how did those guys find you?\n\nWell, I mean, to be honest, I would love to say that I was a long-time listener and was invited to the show finally, but this only holds true to the Red Heisman podcast, not the other one. They stumbled over my tutorial, which was super cool, and they were happy that it was a German speaker writing it. So they invited me to their tech podcast, and we were talking a little bit about programming fonts and all of this.\n\nSo then you came along and be like, \"Hey, it can't just be your German podcast.\"\n\nActually, when I dug into the article, I got kind of fascinated due to the sort of digging into different areas, and we'll talk about it partly. Just there's a lot of really interesting kind of fascinating angles beyond what I might call the fussiness of setting up things. I used to listen pretty regularly to a productivity podcast. It was called Back to Work. The host is this guy Merlin Mann. He's kind of famous for different things, but one of the things he coined the phrase \"inbox zero\" that a lot of people use for kind of managing your email and stuff like that. But anyway, he likes to use this term of productivity porn. This idea that you spend all this time and effort of like getting things perfectly right, and it's gonna really make you so much more productive if I just got some better pens, a new quality notebook. Man, I'm really going to get stuff done. And so I feel like I lived that for a little bit. And so, and I also have a different relationship with fonts. I was in a band, a lot of people know that I'm kind of a music guy, and I spent, I don't know, countless days that Kinko's making copies, if people are familiar with that place, of making copies and things like that. So I was selecting fonts and making jackets for cassette tapes that we were selling or CDs or flyers or so. Fonts were a big part of my life back, you know. Actually, one of the bigger revolutions that computers provided individuals was, \"Hey, you could print stuff at home.\" And so in the '90s, that was like a huge thing. So yeah, I've kind of a mixed background on fonts. So then as I dug into this, I was like, \"Oh wait, I never really thought about it in a programming sense outside of the general idea.\" Like when you pick a font for programming, most people kind of steer toward, or actually most environments steer toward a monospace font, and maybe you could describe that in case somebody's not familiar with it. And so what's a monospace font?\n\nYeah, so maybe let me start off with that. I totally know what you're saying about this that you can dive into creating your perfect programming environment and choosing a color theme and stuff like this. Sure, and I think it's good to do it because you want to be in a room that's well-decorated where you're happy to work. And I think the computer should be one of those places. But I totally see it that you can overdo it and it can be kind of like an excuse to not doing the actual work. But it looks really pretty, right? And here I come along and be like, \"Let me add one tool to your tool set where you need to choose the best thing for, and this is fonts.\" I wanted to create this tutorial because fonts are close to my art. And we can talk a little bit more about this in a moment. But I didn't just want to create a tutorial like there are so many of them. Like the 10 best fonts that you can use for programming. But I wanted to give it a different take and dive a little bit deeper and also explain a little bit why it might make sense to look a little bit closer and why it might make sense to actually change the font that you're having in the editor. And yeah, you were mentioning monospace. That's kind of the general thing. Usually it's monospace fonts, but that's also where it stops. And monospace means every character has the same space and not, for example, like in a proportional font where an \"i,\" which is a very narrow character, only gets the space it needs, right? In the monospace font, it has the same space like an uppercase \"W,\" right? Which then in the end results in sometimes weird designs because you need to do something with the space that the character now has. And so, and if you dive in there, you can see that different fonts choose the different font designers or type designers choose different ways of solving this problem. And yeah, that's where you can go into the rabbit hole and really find out where programming fonts perform or not perform for your own taste.\n\nThe other differentiation I felt like works really well is this set that you have that I think really dives into the programming language part of it, which is, and I've had this problem, I think other people probably had this problem of differentiating a comma and a period. And then that leads right into colon or semicolon. And then you had this whole set that went there from there. I won't dive into it, but when you're thinking about a programming font, like comma and period and knowing the difference between the two makes a huge difference when you're programming. As far as, like, how it's going to behave. So, and forgetting one is going to be a mess. So that is so true. And that was also a little bit when I was getting annoyed at some design solutions that some of those fonts had. And I mean, granted, some of them might not have started as programming fonts, yeah, but the more I looked at some of those details and you were mentioning the comma and the dot, it's so important that you can see the difference. And yeah, in some fonts, you have like this comma is kind of like a little bit longer than a dot. And in small sizes, it's really hard to differentiate. And so that is something which, which I think as a programmer really makes sense to have a closer look depending on the font size you're using, the font with it, obviously, and how well your eyesight is, but it really makes sense to choose a font where you can differentiate it, because it's, I mean, on the keyboard, they are next to each other as well. So it's really easy to have a typo here using the wrong one. And if you're working with numbers or currency or stuff like this, you don't want to put the comma or the dot in the wrong spot. So it makes sense to have a font where you can really differentiate them. Yeah, and again, looking at the design, how some type designers chose to solve this problem, you can really find really nice ways how they did it. For example, in the Mononoke, the comma is really excessive. And if you're just looking at it, as it is, it looks weird, but it makes so much sense as a programming font that you can really see, okay, so this is a comma compared to the dot, which is like a surplish thing. And so this was, was the moment pretty accentuated. Yeah, exactly. So, so this was, was a very common thing that's, for example, there's a little dot inside of the zero or there is a slash in the zero. So you really make sure that this is not an uppercase O, but a zero. And that's, that's a very common thing. And luckily, and that's a nice thing, many of those fonts provide different styles of the a zero. And when you download, sometimes you can configure your own font that you're saying, like, hey, I like the dotted zero more than a slashed one. So please put the dotted zero as the standard zero into my font or you can use Python tools to, to put them into the fonts. And, uh, so they are, it's, it's nice to see that the type designers who make the fonts are aware of the different tastes that their users have.\n\nI haven't seen the dotted zero as much. That seems to be a little less common one. The slash zero is something I'd seen pretty commonly, you know, coming into fonts in the 90s and so forth. But yeah, that's, I don't know if that's like a different",
    "Ul63xzOdZ8U": "Welcome to the Real Python Podcast. This is episode 175. Python 3.12 is here. Regular guests G. Helle and Christopher Trudeau return to discuss the new version. Gana coordinated a series of preview articles with several members of the Real Python team this year. His annual piece was published on Monday, October 2nd titled \"Python 3.12: Cool New Features for You to Try.\" Christopher's video course posts the next day, covering the topics from the article with visual examples of Python 3.12 in action. G and Christopher collaborated to create code examples of the new features. They discuss better error messaging, more intuitive F strings, sub interpreters, the Linux perf profiler, improved typing syntax, and more. They dig into the updates and offer advice on incorporating them into your projects. They also consider when you should start running Python 3.12. \n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at Real Python. After the podcast, join us and learn real-world Python skills with the community of experts at Real Python. It's Python 3.12 week here at Real Python, and as has been an annual tradition, we have GNA Helle and Christopher Trudeau back on the show. Welcome back, GNA. Thank you, Chris. This transition is fun to hang out. It's very cool. Christopher Trudeau is back again. I try not to stress the again in that. Let's get started. \n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at Real Python. After the podcast, join us and learn real-world Python skills with the community of experts at Real Python. All right. It's Python 3.12 week here at Real Python, and as has been an annual tradition, we have GNA Helle and Christopher Trudeau back on the show. So welcome back, GNA. Thank you, Chris. This transition is fun to hang out. It's very cool. Christopher Trudeau is back again. I try not to stress the again in that. \n\nWe've divided up some of the features that are part of Python 3.12 and are going to go through them back and forth. Gana has worked on a preview article that came out earlier this week. It's been an annual tradition, previewing a lot of the features that are in it. Along with that, Christopher just finished his video course that covers a lot of the same features. Those are both available on the site. One thing that is a little bit different this year is that Gana continued the tradition of having preview articles, getting people prepped to understand what's coming out with 3.12. \n\nWe did three in-depth articles about certain features last year. For 3.11, we started doing a few in-depth articles about certain features. This year, we actually did five of these preview tutorials about the different features. We'll add some links to all of those as well, where we kind of go really deep about the new features. In this week's tutorial, we kind of show the highlights of each other features. We'll get a chance to drill in a little bit into them and also add our commentary on the different features as we go. Those are nice deep dives. \n\nWe'll also get a chance to highlight some of the additional authors there. So generally, that worked well. Do you feel like you're going to do that for the next release? We haven't talked about it within the team, but my feeling is that it was very successful and I think it was fun to involve the whole team in this. We kind of got to play off each other a little bit more. The preview articles are good for me as sort of like research into the full article. I think it's good for all the readers as well for kind of having the option to go in-depth for the features they are interested in. \n\nThere's much to dig into about the new features. Python 3.12 includes improved error messages, more intuitive F strings, subinterpreters, the Linux perf profiler, improved typing syntax, and more. We dig into the updates and offer advice on incorporating them into your projects. We also consider when you should start running Python 3.12. Let's get started. The Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at Real Python. \n\nAfter the podcast, join us and learn real-world Python skills with the community of experts at Real Python. Alright, it's Python 3.12 week here at Real Python and, as has been an annual tradition, we have GNA Helle and Christopher Trudeau back on the show. So, welcome back, GNA. Thank you, Chris. I like this transition. It's fun to hang out. Yeah, it's very cool. Christopher Trudeau is back again. I try not to stress the 'again' in that. Let's get started. \n\n[Music]\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at Real Python. After the podcast, join us and learn real-world Python skills with the community of experts at Real Python. Alright, it's Python 3.12 week here at Real Python and, as has been an annual tradition, we have GNA Helle and Christopher Trudeau back on the show. So, welcome back, GNA. Thank you, Chris. This transition is fun to hang out. It's very cool. Christopher Trudeau is back again. I try not to stress the 'again' in that. \n\nWe've divided up some of the features that are part of Python 3.12 and going to go through them back and forth. Gana has worked on a preview article that came out earlier this week. It's been an annual tradition, previewing a lot of the features that are in it. Along with that, Christopher just finished his video course that covers a lot of the same features. Those are both available on the site. One thing that is a little bit different this year is that Gana continued the tradition of having preview articles, getting people prepped to understand what's coming out with 3.12. \n\nWe did three in-depth articles about certain features last year. For 3.11, we started doing a few in-depth articles about certain features. This year, we actually did",
    "lDyONuinUW4": "Welcome to the Real Python Podcast. This is Episode 176. What fundamental developer skills are new Python users missing and what best practices are developers from outside of Computer Science Background lacking? Christopher Trudeau is back on the show this week, bringing another batch of PyCoder's Weekly articles and projects. Christopher opens up our discussion by sharing a recent social media thread about teaching software engineering best practices to scientists and others without a computer science background. We talk about software design philosophy and sharing knowledge within an organization. We cover the results from the sixth annual official Python developer survey. The survey covers Python usage, language versions, frameworks, libraries, and various demographics. We dig into details and share our insights. We also share several other articles and projects from the Python community, including a couple of release announcements. So many Python data frames, speeding up your code when multiple cores aren't an option, Python syntactic sugar, a computer algebra system named simai, building a blog in Django, code metrics in Python with radon, and a tool for daily writing. This episode is brought to you by Sneak. Sneak helps Python developers stay secure without slowing down by providing real-time code scanning and actionable fix advice right from their IDE. All right, let's get started. \n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. Hey, Christopher, welcome back. \n\nHey there. We're here to dig into some more articles and projects and a couple of pieces of news and the results of a survey. So do you want to dig into some of that stuff?\n\nYeah, okay, for sure. So first chunk, both of our news bits are released things. Django 5 is now in alpha, which is their feature freeze. A couple of interesting little things in there. So fields in forms are now built using a template, which means you can overwrite it. This clears the way for better reuse with heavy styling frameworks like Bootstrap. They added a couple of new database features. You can now tie the generation of data like defaults and virtual columns into your models. This kind of pushes the ability of filling information into the database side. This is useful for folks who are using Django to wrap existing tables rather than, you know, straight Django stuff or if they're sharing them with folks who are, say, doing reporting or something along those lines. So it essentially gives you a little more flexibility along those lines. And then the big, there's a bunch of internal things going on as well. They've bumped the major number because they're dropping a bunch of Python support so that they can clean up old code and dependencies. You know what version it starts with?\n\nDjango 5 drops everything before 3.9, so it starts with 3.10, 3.11, and 3.12, okay. So 4.2 is going to be the last series that supports 3.8 and 3.9, and of course there's an LTS in there as well, so you can stick around if you want. The other release is the official announcement of Mojo on Linux. So you might recall us talking about Mojo back in episode 157, which was way back in the spring. It's a superset of Python with a focus on compute performance. They're rolling this out in stages. There was an early access program for a while, but now it's actually out for Linux. Yeah, there are releases for other operating systems coming, but if you don't want to use their online playground and you've got Linux, you can now muck around locally. And I'm starting to see, I was starting to curate next week's newsletter and I'm starting to see articles on, is it faster? What if you use number and there's stuff like that coming very quickly as people are digging into it. So it's interesting to see. Yeah, getting a chance to play. The one article that's going to be in a future issue actually, if they use number one way without a certain flag, Mojo was faster. But if they used it the other way, number was faster. So it kind of falls out in the wash. That was kind of interesting to read about. So maybe we'll talk about that a little more in another episode. Yeah. And then not quite news, but something that's been around for a bit. So for the last six years, there's been an annual survey of Python programmers. The results for 2022 have just been published. It takes them a while to get all the data massaged and out into the world. Yeah, the survey asks questions about how we use the language, how often we write in other languages, the tools we use, and that kind of stuff. So there's as usual, there's some very predictable things and there's some surprises. For example, the first question asked about primary and secondary languages. 85% of respondents said Python was their primary language. Of course, it's a Python survey, so you would expect that. The three most common languages after as the secondary language were JavaScript, HTML, and SQL, and all were very close in results around 36-37% kind of thing. Interesting twist on the same question was what happens if you categorize it by data science folks and web folks. So for data science folks, SQL becomes the number one secondary language with 45%, so it pops up a lot more. And similar for within the web folk world, JavaScript becomes the secondary language of 66%, which kind of just makes sense. And I guess that means 66% of Python web developers are frustrated. Sorry, I can't help but poke at JavaScript. Have I mentioned how much I love HTML? It means I write less JavaScript. There you go. Anyways. So that's what we write along with our Python. But how about what we do with it? A whopping 51% of respondents said they do data analysis, while 43% said web dev, 36% machine learning, 34% said DevOps. Thing I found most interesting about that 51% saying data analysis response was only 34% of folks said they considered themselves data scientists. Yeah, yeah. So there's a whole bunch of us that are doing data analysis without either being our real job or we don't feel like we're worthy of the title or something along those lines. It's not sciencey enough. It's not sciency enough. It's right. Summing a column is not does not make you a data scientist, I guess is what it comes down to. So all right. There was a question about Python 2 versus Python 3. For the last three years, the answer has been pretty consistent, hovering around 5% of folks doing Python 2. My condolences. Number is slightly higher this year, but likely due to variation in respondents rather than an actual uptick in usage. Of the Python 3 folks, 45% were using Python 3.10, and that was the latest interpreter at the time of the survey. So almost half of folks are basically using the latest and greatest. Next question is on where you go to get your Python. 37% get it from python.org. That number goes up to 52% amongst Windows users. So yeah, yeah, it's primary source. About a quarter are getting it from an operating system tool like YUM or, you know, AppG, Homebrew, those kinds of things. For some of those secondary sources, it's 17% for Anaconda, 17% for Docker, 16% for PM, which statistically is basically the same, and a poultry 6% of folks build it themselves. Virtual environments. 49% are on virtual M, 31 on Docker, 22 conda, 16 pipm, and 14 on Poetry. Poetry's been growing over the last couple of years, so that's actually been sweeping upwards. Yeah, interestingly, 23% said they aren't using any. Which means none as an answer beats everything but Virtual and Docker. So there's more people not using it than using Poetry, almost more than Poetry and pipm combined. Not quite, but almost there. Yeah. We talked about that, how a lot of people are just they have their main environment and that's where they do everything. So yeah, well, and if you know, like I find when I'm coding things for Real Python, I have one virtual M for all of it. I very seldom run into where I'm duplicating anything. And so, you know, I don't have to keep creating all of them. And if so, if that were my only job, yeah, I probably could get away with not having it. So yeah, we'll probably talk more about that. Except I code on a Mac, so I'd have to have it in order to get out of Python 2 world. But that's reason. There were some other questions about frameworks. On the web, Flask and Django were both at 39% and followed closely by FastAPI at 25%. So there's almost a three-way horse race there",
    "fhJ7y6si0P8": "Welcome to the Real Python Podcast. This is Episode 177. You may remember a recent Python Package Index announcement about hiring a full-time security engineer. We've also mentioned several current security initiatives by PyPI. This week on the show, we talk with Mike Feedler about accepting this new role and securing accounts on PyPI. Mike talks about how he started as a contributor to PyPI and eventually became a maintainer. We talk about why he fits this new role well and his responsibilities. We discussed the initiative to secure accounts using two-factor authentication methods. Mike also explains how package maintainers can adopt a new, more secure publishing method called Trusted Publishing that doesn't require long-lived passwords. We also discuss Mike's recent talk titled \"How to Give Back to Open Source Without Losing Your Mind.\" Mike shares advice and resources for finding your own contribution entry points.\n\nAll right, let's get started. The Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at Real Python. After the podcast, join us and learn real-world Python skills with a community of experts at Real Python. Hey Mike, welcome to the podcast.\n\nHey, glad to be here. We're here to talk about, well, partly your new role with PyPI and then also to get people even more informed about the changes to adding 2FA to all the PyPI contributions. We've mentioned it a couple of times in news articles across here, but it's nice to have somebody who's in an official capacity come on and discuss it with us. Official, yeah exactly. So maybe we start with your role as PyPI Safety and Security Engineer. Maybe you could tell us a little bit about what that role entails.\n\nAbsolutely. For some background, PyPI is the Python Package Index, which is maintained by a small group of volunteers and a lot of contributors. It is managed, hosted, and funded by the Python Software Foundation (PSF), a nonprofit that works on establishing the best possible way to use Python and the ecosystem around it, including the packaging ecosystem. It's a relatively small nonprofit. I know that you've had Seth Larson on the show, he's the PSF's overall Python security developer in residence, and then we also have Lukasz Langa, who's the developer in residence for Python, yeah. Yeah, those folks are kind of the broader ecosystem or the Python language runtime. When some funding came around, thank you to Amazon Web Services, to invest in making PyPI a safer place to both upload and use packages, I threw my hat in the ring. Having been a PyPI volunteer maintainer for a couple of years, a lot of other great folks put their names in but went through the process and got hired to focus predominantly on the impact of PyPI in the packaging ecosystem and how to make it more secure, how to make it safe for all of the users, both corporations, individuals, scientific researchers, anybody on the planet and beyond.\n\nYeah, we always talk about the mass amounts of resources there at PyPI, and so it's nice to have someone else who's in a full-time paid role to sort of watch over the security of it. That's fantastic. Up until now, it's been pretty much a small group of maintainers handling all of the different feature requests. I came on as the first new PyPI full-time maintainer a couple of years ago, but it's largely been just three folks over the last decade or so who have been at the forefront of handling all of the different feature requests. I mean, yes, there have been different funded contract work by different parties to get specific features, but there's been very much a really small core maintainer volunteer group. E Durbin, the director of infrastructure, yes, is an employee of the PSF but has only been dedicating a portion of their time to PyPI because they have to worry about all of the things. So when AWS and some other funders came up with some funds to say we'd like to put some more power behind PyPI safety, it was great. We can take these funds, we can run with them, we can focus on other parts that aren't just volunteer contributions as it were.\n\nWhat made you decide you wanted to initially contribute to PyPI? What was something that was a deciding factor or oh, I want to get involved in this?\n\nIt's a fun story. I've been in software development and engineering and systems and management and everything for roughly 30 years or so, and I've done it across a couple of continents, a bunch of different startups and enterprises. I had always been exposed to Python as of, I guess, 2007, 2008 was when I started actually using it for kind of work things. It's a very pleasant language to work in once you kind of figure out some of the quirks. Back then, it was Python 2 and then progressively over the course of the 20 years since, I've been contributing to open source in a variety of different ways. I worked a lot on the Chef community and wrote a lot of Ruby and cookbooks over there, and starting to dig into the different tools that I was using, which are mostly open source, right? We use a lot of open source. I started to see that, hey, I can do this too. I can create packages, I can create things that are useful to me and share them with others. That kind of fed this desire to produce more utility, to produce more valuable things, and just having open source as the forefront of here's something that we all rely on, now it's time to give it back, right? Like every company I've worked for has used piles and piles of open source. Not every company is dedicating engineers to work on it, but it's a great opportunity for engineers to kind of pick up new and interesting parts of their career because it's like, all right, well, it's not this is not for work. I could do this for fun. And that's also a great way to do it, and when it came to PyPI and why I got involved there, well, I had Python a lot, right? Over the course of different companies, I've moved off of Ruby predominantly into Python land and I moved more into management. As a manager, you do less and less hands-on development, right? At a certain scale, right? I was a senior director of engineering at one startup, I was a VP over at another enterprise, and you know, I always like to solve puzzles and open source is a great way to solve puzzles. It's a way to stay involved and stay empathetic with the engineers who work for me to say, you know what, I know your pain, I know what you're feeling. If you're telling me this is going to take a lot longer, it's not you're complaining and you're trying to beat the clock or be lazy, it's no, this is actually really hard. So as a way to continue to build that empathy, I just kept contributing to open source in my spare time and with PyPI specifically, there was this one little feature that I wanted. There was one feature, it always starts with like one little thing.\n\nSure, sure, and it was I wanted the on the main page of PyPI, there's a search bar at the top and through quirks and other websites, you kind of learn keyboard shortcuts, right? If you've ever turned on keyboard shortcuts for Gmail, then you learn those. If you've ever used Vim, you kind of need to know all of your keyboard shortcuts, you'll never exit. But if you pick up a VS Code or PyCharm, right, I'm a big PyCharm user now, then you need to kind of learn these keyboard shortcuts because they will make you more effective. You can live without them, but they will make you more effective. And going to the pypi.org website, there's a search bar. I naturally just hit the slash key to focus the search bar to hop there, right? And that's a behavior I don't know who came up with it, but somebody came up with it and now it's like, oh, I do that too. So focus search bar. I think even Google does it now, which is great. But PyPI didn't have it. And it was like, all right, well, that's something that I think I can figure out, okay? So I spent some time, I checked out the code, I read the dev docs, I figured out how some stuff was broken and fixed the dev environment. Like there was a bunch of stuff that I was like, okay, this needs to be brushed up and then I got my feature and sent it up there and got some good feedback from the existing maintainers. And after I finished that, one of them was like, hey, what do you think about this, right? You want to try this one, I like, oh, okay, I'll try and figure that one out because like the maintainers that, you know, they obviously have a better idea of what's in the issue backlog and kind of where to point people's efforts. So it was like, right, right, I think you might be good for this thing.\n\nOh yeah, and like what's crazy is that feature was very much JavaScript and that's not my strongest language, sure. And I was like, I can do this. I can figure this out. And since then, it's been, you know, I took the time to revamp the entire JavaScript stack and asset building for PyPI so that way it's a lot nicer for developers, contributors who want to work on it, and then got more into the Python side of PyPI. So it was really just an excellent way of like, oh, I want this thing, I think this thing should exist, I could ask for it, no one's going to do it, right? Because like then it's not their priority, right? And if it was, they would have, right? So if you're not willing to put in the time to give back, then like, all right, you're just kind of asking for somebody to do free work for you, whereas here it was like, no, I will put in the time and effort to figure this out, yeah.\n\nIn the new role that you're taking on here, what are you most excited about?\n\nIn this role, I think the important parts are really focusing on the security aspects because again, it's an ecosystem of packaging and there's any number of things that one could do, but by having some focus on safety, security, it helps kind of narrow my focus onto, well, I could do a thousand things, here are the three that I should do right now, okay? And that kind of helps anybody very clearly define what it is they're going to do next, yeah, okay. And so is there a background you have in securing things like this or you talked about a variety of different ecosystems and then I guess maybe related to that, what are the concerns that PyPI has towards security, maybe we can talk some history there.\n\nYeah, I mean, some folks might say, okay, Mike doesn't have a pure security background, and it's like, you're right. I'm not a network security engineer. That's something that exists, but I have been a part and a leader for a bunch of security initiatives and platforms throughout my tenure as an engineering manager. That kind of positions me in a spot where it's like, okay, I'm not just worried about the security finding, I'm also worried about Sustainable Building of a secure outcome. So it's not always that I have to be the expert, but I have to be the knowledgeable generalist who can pull in expertise or rely on expertise of others in order to achieve the desired outcome. For instance, I did a blog on blog.pypi.org on just measuring our inbound malware reporting. So what happens a lot is people will put together a malicious package with some garbage name and they'll sign up for an account on PyPI because it's a free service and they will upload a package that has some malicious intent, right? Very often, it's, you know, when the user installs it, look for any kind of environment variables that look interesting and then post them to some harvester. So we partner with a bunch of different volunteer security research teams that will report those to us. And today, the reporting process is very much email us to a security inbox, and we then analyze their report and then we take a look at what the indicators are and make an informed decision as a maintainer, as an admin of the service, what to do next.\n\nWhen it came time to say, \"All right, well, how bad is this? How often does this happen?\" I sat down and said, \"Okay, let's analyze the data,\" right? You know, I can come up with some ideas, but doing the data analysis is not necessarily a security competency, if you will, right? But like building a tool to scrape through Google email messages and look for the particulars and then produce results and do some data analysis and graphing, like that's not a security role, but it is very much a comprehensive analysis role for how we're doing on a security front, yeah, yeah. And you can read that on blog.pypi.org. We love digging into those kinds of things and keeping people aware of, \"Hey, this is what's happening out there, and you know you need to be aware of it.\"\n\nI see that your role is a lot of troubleshooting and problem-solving, and do you feel like you're going to be pivoting a lot and using lots of different skills that you've developed across the spectrum?\n\nI mean, I certainly hope so, right? Like right now, some of my focus is very much on malware, and this topic of malware and malicious package reporting. There's an enormous amount of focus in the industry around a software package repository security and dealing with malware and reducing the time malware is potentially out there, reporting vulnerabilities, and that's very much where I'm focused right now is how do we optimize this process, how do we make it easier for folks to report to us, and with the structured information that we want, as well as what do we do as admins, how can we reduce the burden on admins and get to the point where we're almost semi-automated in our reaction so that we can reduce the amount of human oversight that's absolutely necessary. Obviously, there's still plenty that's going to require human intervention and analysis, but okay, the more we can automate, the better, right? Then we can do more with our time, yeah, yeah. There's a variety of ways to do the two factors. I've had a conversation about some of the more modern ones that are slowly rolling out, things like pass keys. And then I know we mentioned in our news articles, the announcement of doing this program where the top 1% of packages were given like a hardware version of a key. Maybe you can talk a little bit about that and the ways that you guys are looking at doing TFA.\n\nAbsolutely. So we added the second factor or TFA ability to PyPI two to three years ago, I don't remember the exact date, okay, and it was an option, right? You could use this to secure your account, it's great, you know anyone who wants to secure their account can. And as a feature, that's great. And as we progress, we started to see increasing discussion on the internet around like, okay, well, here are other vulnerable areas. So we followed patterns that other folks have done and implemented to start somewhere, right? So we started with the just top 1% by download, which is not a trivial amount of packages, right? PyPI currently hosts roughly about half a million different packages, a lot of those are quite popular because they're used in different ecosystems or SDKs that are widely used across the internet. So they get a lot of traffic and if one of those got compromised, the impact to the world would be quite catastrophic, it could be, right? Yeah, yeah, and so it was just an arbitrary selection of, okay, 1%, let's start there. Well, that makes sense because even when you were talking about your own contributions and We've mentioned a handful of other people that have their own small projects where they're literally scratching their own itch and it's not going to become part of a build of materials potentially of other large corporations and so forth and where it's going to affect it, so that totally makes sense. I mean, if you were to do the number of downloads, I'm sure the top 1% is the thing that's getting downloaded the most, right? And again, like this was only as a starting point, it wasn't like these are the ones that we deem are necessary, it was like, no, let's just start here. We also had calculated, got a really nice donation from Google to give out two Titan Keys, these are hardware keys as a second factor that work with our authentication scheme to anybody in the top 1% who wanted them for free, right? Now there were obviously some restrictions, they couldn't be shipped to every country, but generally speaking, that's a lot of hardware keys that Google put up and gave out, and we were happy to just give them here's the link and just go buy it from Google, they will send it to you, nice, we're just trying to help here, right? Yeah,",
    "2ayHxAkvNi4": "Welcome to the Real Python Podcast. This is Episode 180. Have you moved through the fundamentals of Python and are now considering building a more extensive project or complete application? Where can you study the architecture of existing Python projects and learn best practices? Christopher Trudeau is back on the show this week, bringing another batch of PyCoder's Weekly articles and projects. We discuss a set of resources developers can study to learn how to structure projects. The Collection was shared in a blog post titled \"Great Resources a Beginner Might Not Find So Easily.\" It includes a pair of books on the architecture of large software applications and another aimed at more modest projects. We consider when you should use Lambda expressions in your Python code. These one-line expressions create anonymous functions. How do they differ from standard functions and where is it appropriate to use them? We also share several other articles and projects from the Python community, including a couple of release announcements, how Python is a compiled language, a discussion covering the controversy about the recent release of Flask, a project for writing less Selenium code, and a project to create ASCII art with Python. This episode is brought to you by Site 24/7. Site 24/7 is an AI-powered full-stack monitoring platform by Zoho Corp. Site 24/7 helps developers optimize their application performance and deliver a smooth digital experience. Check out site247.com. That's sit 24x7.\n\n[Music]\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with the community of experts at Real Python.\n\nHey Christopher, welcome back on the show. Happy November. I can't believe it's already November.\n\nYeah, we're racing full speed ahead. You got a few pieces of news though that we can start with.\n\nYeah, yep. You did such a good job last time. Good job last time. I'm taking it over. Yeah, well, I mean the amount of applause I got, I've never had applause. It's my button, but I've never used it for myself. Anyway, yeah, we got a few things. The first is a call for papers for PyCon US 2024. The conference next year is in Pittsburgh from May 15th to the 23rd, and there are some travel grants available for speakers. If you're thinking about that, I couldn't find a due date on the site, so it probably depends on how quickly they get responses. But if you're interested in talking next year, that's what you need. Go click the link and fill in those forms. Yeah, got two bits of Django news, both release announcements. First off, Django 5 has gone to beta. They were in alpha, now they're in beta. That's how it works. Just the other day, they released a security release. That's 3.2.23, 4.1.13, and 4.2.7. The fix has to do with a potential denial of service vulnerability in the username field on Windows. So if you're running Django, particularly in a Windows environment, go patch. And then finally, it's sort of news, maybe just news to me, I don't know. For those who've been using PyTest, the linter code formatting has been added to its capabilities. So now it lints and reformats code. The current style is mostly adherent with the black formatter, but it does have the added goodness that you can configure whether or not to use single quotes or not. So the tab versus spaces war can continue. And as it is, PyTest is built in Rust, which means it's pretty snappy. Yeah, I came across this info on Mike Driscoll's site where he's got a short post with some examples, including how to configure that single quote thing in case you want to.\n\nOkay, which is why I'm looking forward to it because I've always thought, hey, the REPL uses single quotes, they're good enough for anybody, right? I don't have to hit shift. Exactly.\nExactly. Okay. All right. Well, a quick news roundup that takes us right into our topics this week. My first one is from Trey Hunter, who we've mentioned several times on the show. He has a blog and sort of training site called Python Morsels. This one is titled, \"What are Lambda Expressions?\" Some real quick terminology. A Lambda expression defines a Lambda function, which sounds kind of weird. You might hear one thing called the other. What the Python docs actually do, and I'll include a link to that, they have a very short entry about lambdas. It's in the expression section of the docs. I'll just read it. Lambda expressions, sometimes called Lambda forms, are used to create anonymous functions. The expression, and this is how they're usually written, is you write the word Lambda, L-A-M-B-D-A, and then space. The parameters you want, a colon, and then an expression. And in the expression, you'd use those parameters. This is going to yield a function object that returns what comes out of that expression. The unnamed object behaves like a function object defined using the def keyword, in that case, def, and then Lambda, and then the parameters, you know, in parentheses. And then you would have colon, and on the next line, you'd have return expression. Whereas a Lambda is all in line together. What I thought was interesting about it, you get a couple things from that whole thing there. These are nameless functions. They're anonymous. They're defined on a single line. They mentioned a couple things there that you can't have any statements inside this function, so you can't define additional things or any kind of annotations. We have a really long detailed Real Python style article on lambdas, and in this case, that one is by Andre Bugar, and he has like this Wikipedia link, you know, mentioning that it goes back to the 1930s, this sort of mathematical concept of lambdas and where the symbol comes from and how it all kind of ties in there. Kind of going back to Trey's post, he initially shows how Lambda expressions define functions, and then what's really interesting is that he does that by assigning it to a variable's name. So he creates one just called square. Square equals Lambda n colon, and then n star star two in this case. So that's basically squaring the value n in that case. So if you then were to type the word square inside of a REPL, it would actually return saying this is a function, a function Lambda. Or if you were to type and use the built-in type function and put type and then in parentheses, square, it would actually return class as a function. They're definitely functions, why writing this form and how do you want to use it. The most common use I've seen is using it in something like a built-in function like there's one called sorted and the sorted function allows you to sort iterables and it has a default way of doing that. It does it in an ascending order, but there is a key argument that you can have and the key actually allows you to put in a function or if you will a cable. So we've talked about cables and functions and kind of the two between each other. So you could use like the built-in len function. So maybe you're sorting a set of words and instead of having it sort them in an alphabetical fashion, you could say, \"Oh, I wanted to do it by the length of the strings.\" He kind of goes into that a little bit and in that key, you could actually put in a lambda that he uses an example of a dictionary and he wants to not sort by the key, but instead by the value. And so in that particular one, the lambda looks like lambda item colon item and then in square brackets one. And so in this case, it's then going to be sorting by the value as opposed to the key, which is kind of interesting. There's limitations to them. He adds a whole sort of pros and cons list. Nice things that they're very quick to do. You don't need to create a separate variable for them. Problems, they can't have a name. They don't have a doc string. You're using different syntax from the usual def syntax. And where do I see lambdas being used? These sort of short anonymous functions. I see them used a lot in data science, especially Jupiter notebooks, things like wrangling pandas data frames, like applying a function to a specific column or something like that. I think it's an interesting, again, quick tour of what lambdas are. I'll include links to the expressions section of the Python documentation that gives that short call out there. And then we have a really deep dive, of course, Real Python here about how to use them again from Andre. If you're interested in digging into them. Do you have other uses for lambdas, Chris? Do you use them in other places?\n\nIt's funny, I was just gonna ask you the same thing. I find I use them occasionally with a little bit of this sort of the functional programming corner of Python. So like the sorted example is kind of the primary one where it happens. Every once in a while, I'll have that, oh, that'll be a perfect lambda. And then like an hour later, I've gone, oh, that lambda needs a conditional in it and therefore it's now a function. I find they're not very long lived in my code unless it's something like a sort key. I think that's the intent behind them. It's not a criticism, but yeah, that's about the only place that I tend to use them commonly. But I'm not a data science guy, right? I don't spend as much time in that space and could see particularly if you're doing functional pieces with things like reduce where they'd be very, very useful.\n\nThe idea that you're not wanting sort of side effects, you're just applying these things and going into it. So yeah, I was going to say that the filter map reduce, those are really common places you'll see it, especially again in data sciencey kind of stuff, a lot of cleaning and sort of wrangling data is where I see it used a lot. In almost every other circumstance, it just kind of makes sense to maybe fully flush it out because you may reuse it. I also, I'm left with the impression and I could be wrong about this, but I think lambdas tend to be far more efficient, like there's a lot less overhead than functions. So if you are doing something that's small, like passing it into sort, even though sort will support a function, there can be a big performance gain in some cases by using it. But that's one of those statements you should always put asterisks beside because your situation might be different. So yeah, exactly, yeah, mileage may vary.\n\nExactly. Are you a developer striving for top-notch application performance? Meet your new ally, Site24/7 from Zoho Corp. With Site24/7, you get real-time insights into critical performance metrics like AppDeck scores, response times, and throughput. It's your secret weapon to swiftly identify performance bottlenecks and issues that can slow down your applications and affect the digital experience for your customers. Optimize your application's performance like a pro with Site24/7's AI-powered full-stack monitoring platform. For more information, visit site24/7.com. Don't forget to try their 30-day free trial. That's sit247.com.\n\n[Music]\n\nAn article called \"Python is a Compiled Language\" by Eddie Antonio. Eddie is a researcher at University College Dublin, but by the looks of his doca extension on the blog, he's a fellow Canuck. So he teaches programming languages and that's what led him to the post. He starts by talking about how he was putting together examples of errors in C Python and Java and using them to teach students how the different languages turn code into something that can run. So when you think of a traditional compiled language like C, you break the compilation into a series of steps. There's pre-processing, lexical analysis, syntactic analysis, semantic analysis, and then linking. And each stage has its own kinds of errors, and typically encountering an error at any one of those stages stops the process from continuing to the following stage. So while adapting the lesson for Python and Java, it became a little more aware of how these languages are different. So neither Python nor Java have a pre-processing stage, and linking is sort of there, but sort of not, depending on how you hold your head and squint, because it's different in a dynamic language. The key premise of the blog post is that error messages in a language can help reveal the stages in this process, because certain kinds of errors stop the process from happening at a different step. Compiling code with the right set of errors gives you hints about how the process works. So he goes on to use this sort of game show voice or as seen as it's an article, I'm guessing it's a game show voice by the number of exclamation marks he's got in the title. And he introduces a very broken program with four different errors in it, and your task is to guess which problem will trigger an error in what order, what stops where, exactly. So before getting into the answer, there's a deeper conversation in the article about what it means to be a compiled language. So Python gets compiled into bytecode, which then gets interpreted. As such, you could argue that it's a compiled language, but we usually reserve the term compiled language for something like C that actually builds a machine code executable. By contrast, there's versions of BASIC that don't have the compilation step at all, they interpret directly. So Python's kind of halfway between the two. And that's kind of the argument he's making. So I'm not going to get into the actual programming errors because it's kind of fun to go through and, you know, take a guess and see if you understand.\n\nI like the little drum roll icon and then scroll exactly, you know, play the game. And it sort of helps you learn the truth about some of the deeper insights into how Python works and how the compilation process goes. Pretty decent article. I'm looking forward to more stuff from Eddie. And hey, man, if you're listening, good luck on that PhD, pile higher and deeper.\n\nNice. Okay. So that brings me to my next topic, which this topic I've talked about a handful of times and it maybe it's it is time to dig it up again and dive into it. I think it's fairly timeless to think about, but the title of it is \"Great Resources a Beginner Might Not Find So Easily.\" Something that actually Christopher and I have talked a little bit about. I feel that this article is hitting close to what I think is the core part of our audience. And I feel like the core part of our audience is advanced beginners, I like to call them intermediate developers. I think in some ways you would hope for larger, more like experts kind of following along and so forth, but I feel like a lot of people that listen to podcasts are interested and definitely the way that I kind of gear the conversations and kind of ask lots of questions, I really want to lift people up who might be in that middle stage where they're still kind of learning what the next step is. This is an article, it's a very short read with a bunch of links to useful resources, and it comes from a blog called Death and Gravity. It's by Adrian, the last name's not provided, and Death and Gravity is a really nice blog. I'm really kind of enjoying stuff that's in it. The goal of it is that you've learned the basics and you've solved some of your own problems and maybe you've written some scripts and maybe you've kind of started to think about, okay, I really would like to make a larger project. Oh, well, how do you structure a project? Maybe you get halfway through and then you kind of think, okay, well, where, what, what do I do? Like, how do I structure modules? How do, what code goes where, you know, should this thing be laid out in an entire package? How things should be organized, let alone more advanced things like documentation or just even generally like sharing this stuff later. So it gets into architecture and design patterns, which I feel like Christopher has definitely shared a bunch of stuff on over the last several of our shows. And this one really is focusing not only on that, but more on architecturally, you might think, well, how did other people solve this before you tried to? The suggestion that a lot of people follow is just, okay, go read some code. And I've talked about this on the show and again was a focus very early on in the show like episode nine. I had this whole thing about leveling up your Python literacy. I was talking to CES Philip and let's find some Python projects to study and look at. I also, this particular pair of books is something that David Amos and I linked to back in episode 62 when we talked about something very similar. It's a link to a set of books called \"The Architecture of Open Source Applications.\" It's a pair of books. They're free and they really dig into this concept. They do that by showing you how these projects are organized. About a quarter of them are literally about Python projects. You may remember some of these or have heard these names: SQLAlchemy, PiPi, Twisted, Matplotlib, Mercurial, and so even though this book has been written a little while ago, I don't feel like architecturally these things have gone out of style. There's still a lot of really great stuff you can learn by studying people's code and how they're organizing it and the architecture. And that's really what this blog post is kind of diving into. And then what's kind of cool is he digs into a couple additional things at the end. Another book that is, I guess, kind of considered inside that series, which is titled \"500 Lines or Less.\" And the idea of that book is that it addresses the sort of smaller, purpose-made projects, things that are maybe not as big as SQLAlchemy, and then their design philosophy. And half of that book is in Python. One other very interesting project that's included in his set of links is a set of stuff about Jinja. He mentions that the \"500 Lines or Less\" book has stuff about template engines. And so he decided to include this stuff about Jinja, which is probably the most used template engine, especially for Python. It's used both in Flask and Django. If you're not familiar with it, it's part of the Pallets project. We're going to mention Armin Ronacher's name a little bit more here in a minute. He links to not only the project and all the Pallets projects, but Armin actually, I had him on the show very early on the show, episode 18. We talked about the sort of 10-year anniversary of Flask, even though he sort of moved on from Python a bit and doing stuff in Rust. He mentions a set of recordings of videos that Armin did. One's called \"Dismantling Jinja.\" And let's talk about templates. Some of these are from PyCon presentations, this whole sort of series. And it's definitely a person who",
    "BDxpZ1WUUPQ": "Welcome to the Real Python Podcast. This is Episode 181. Have you wondered what the future holds as a Python developer with the current growth of artificial intelligence systems? What are the hidden benefits of learning to program in Python and practicing computational thinking? This week on the show, we speak with author Lawrence Gray about his upcoming book, \"Mastering Python: A Problem-Solving Approach.\" Lawrence shares how learning Python helped him through a dark and trying time. He developed lifelong skills that he wants to pass along through teaching and authoring a book. We discuss what you can do to prepare for a future where coding jobs are automated through AI. He shares ways that Python can help build higher-order thinking skills required by these future careers. We also talk about how Python can help with computational thinking and promote cognitive development.\n\nThis episode is brought to you by Site 24/7. Site 24/7 is an AI-powered full-stack monitoring platform by Zoho Corp. Site 24/7 helps developers optimize their application performance and deliver a smooth digital experience. Check out site247.com. That's S2X7.com. Alright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at Real Python.\n\nHey Larry, welcome to the show. Thanks for having me. I got excited by this email you sent to me. You reached out to me on LinkedIn that you're an acquaintance of Matt Harrison or I guess maybe a colleague. You've done some work with him in the past and you said that you're writing a book. I was very intrigued by the first chapter that you sent to me. The book is titled \"Mastering Python: A Problem-Solving Approach\" and you're kind of in the process of writing it, but you wanted to come on and talk about this first chapter that you've written. Maybe you can tell the audience why you thought the topic of the first chapter is kind of unusual in this case and wanted to come in and talk about it. Yeah, so this chapter really was like a culmination of what I experienced when learning Python. I thought that this experience wasn't just unique to me, but unique to a lot of people that come from different points of origins and getting into Python. My story is a little bit dark, okay, and so I thought I could share that and people would connect. Plus, I add in this element of changing the way that we think, right? We bring in the idea of we're entering into a world now in which a lot of work is being automated and it's been automated by AI. So what does that leave for us as humans? Well, we have human intelligence and we have creativity and that's going to be what saves us, right? I wanted to put that forth and help people realize that Python could be that tool that allows you to change the way that you think about problems. Cool, yeah. I think the focus that I have for many of the conversations on the show is why am I excited about Python and what you can do with it. It always comes down to I'm not super interested in showing how smart I am, but I'm interested in solving problems, helping you, and getting things done. That's what excites me and kind of moves me forward to want to continue learning and creativity is a big part of it too, like the idea of building things and making new things. So that's the one kind of scary thing I think about some of the things that are happening in the AI world is that there's a lot of writing that people are experimenting with doing and I have maybe been this sort of sour note on that. I don't like getting into things like creating images or writing and so forth and so I'm kind of excited by what you're saying and this idea of like, hey, what can this do for us? Like how can we think about it in a different way if these, you know, if it's coming to take our jobs, like what, how can we move beyond that and above it? And so that's partly what I thought might be kind of a fun conversation, kind of a positive outlook on it. So is that the goal of your book or what's the primary purpose of your book? Well, I would say it's two to threefold. So the main thing is to help people become Python programmers. I think at a very basic level, this is what you need in order to do this along that way where you're saying about problem solving, Python is a really good tool for solving problems. Yeah, and I realized that you can actually learn how to solve problems a lot more efficiently, think a little bit differently and do that. And so the book is to help you along this route of learning how to program, elevating your cognitive abilities along the same way. That's overarching and things that we're going to change the way that you think about solving problems. Right, right. Okay. So you mentioned that you had this unique background of getting into Python. I think people have heard my story several times on the show, so I won't cover it, but it is a unique path and it definitely kind of involves creativity and coming back and getting involved kind of late in life to programming. And that's why I'm excited to share it with other people and get other people involved, and definitely people who have had other careers. I want them to be aware that, hey, Python could be a big part of that for you, and that's something that I always want to champion on the show. Tell us a little bit about your background. It's not again something we usually do a ton of on the show. We don't usually do histories of people, but I think this is kind of a unique one that kind of covers in and then also what you mentioned there of helping you get through some struggles in your life. Yeah, so I will begin here. I was a PhD student at John's Hopkins University School of Medicine in my mid-20s. I was harboring dreams of winning a Nobel Prize. I was doing some very exciting work. However, when I turned 30, I received the life-changing diagnosis. I was bipolar, and I found myself in the severe depressive state that incapacitated my ability to read, to write. During this period, I'm trying to finish my dissertation. My wife becomes a crucial role in that part. She records my dissertation on the computer as I spoke it aloud because that's the only way that I can actually get my dissertation out because I couldn't do it myself. So despite these challenges, two significant positive things emerged. First, I was fortunate. I was at Hopkins, highly regarded as the top hospital in the world. Second, I discovered Python, and this programming language profoundly impacted what I would call the dorsal lateral prefrontal cortex for me. This is the brain area responsible for cognitive flexibility because that's what I lost. I struggled with simple cognitive tasks for over a decade, but coding in Python was a different story. Between Python's structure, this experience led me to believe that there's a unique connection between Python's structure and human cognition because it was the only thing that I could do and I was getting progressively better the more and more I did Python. So over the years, I just practiced Python and those simple abilities to do abstract thinking again were coming back. In essence, I relearned how to think through Python and it was a lifeline for me. That's amazing. What were the kinds of things that you were creating along the line? What were your experiments there? One of the things that I was creating or ended up creating is simple tools like e-commerce tools. So I built this system to actually peg Amazon for prices of toys. I would scrape Walmart, Target, all their stuff and look for arbitrage. There's a difference between the prices of what something is selling in the store and what's selling on Amazon. And then I could find that difference and I figured out how to do that. I was running a Flask frontend to actually display everything. I later went on to start doing things as far as doing predictions for foodborne illness outbreaks, doing predictions for that for the CDC in which we were trying to predict what would be the next spot that would experience a foodborne illness outbreak. And so those were the type of things I was slowly contributing to Yellow Brick, the open-source package, while I was during this period because that's one of the things that I could focus easily with and that helped me also just being able to contribute during the time that I have to a project like that helped out tremendously. What do you think that is unique about Python in the sense that in this case helped you move into this sort of programming mindset? What were you much of a programmer before this? The only programming language that I had in exposure, and some people won't even say HTML, even though the L stands for language, it would be too much of a language. But I started writing code when I was five years old on Apple Basic, doing basic, right? And I didn't know at the time what I was doing, but I knew if I type in these lines of code, there would be graphics on the screen. And so I would spend all day in front of this computer just trying to create graphics. Going back to your other question of why Python, it is definitely the simplicity of the language. Whenever I tried to learn JavaScript before, I would just get lost in all the brackets and everything else that were there that just made it visually hard to understand. And with Python, it separated all of that and there was clean spacing. And my brain, for some reason, could understand that a lot better. The syntax seemed to be able to stream into my brain a lot easier than other languages and I needed that simplicity at that time in my life. Were you reading a lot of other people's code? Was that part of it then? Yeah, to learn, I spent all my time in other people's code. That's how I ended up learning. Maybe a tutorial here and there, but it was basically reading thousands of lines of code. That's one unique thing about Python is it is very parsable for most humans. You can kind of at least see the intent and get an idea and kind of understand it. It's pretty cool. In the article, you mentioned doing a little bit of teaching of Python also. How did you get into doing that? It's through my link with Matt Harrison and owning the Yellow Brick project. One of the founders of Yellow Brick was teaching at Georgetown University and he begged me to teach. I told him, \"I'm self-taught Python. I contribute to it, but there's no way in the world you should sit me in front of people to teach them this.\" But he was relentless for like two years. Every time I would see him, he was like, \"You need to come teach.\" Finally, I was like, \"You know what?\" He told me how much I would get paid and I was like, \"Oh, maybe that sounds very interesting now.\" So I got into it and I realized I love it. I absolutely love it. It works for me because I connect to beginners. One of the comments that I get from a lot of people is they feel like I know exactly where they're coming from. Like, you teach like you're a beginner. Like, you give me that level and I love that. I connect with people. I absolutely prefer teaching beginners than any other level of learners. Sort of a beginner mindset empathy or what? That's pretty cool. I enjoy those moments of light bulbs turning on and sharing the early wins and stuff like that. It's been an interesting project. We've been converting all this stuff at Real Python. There's a Python Basics books that we have and we've been converting it into video chapters. It's been kind of fun going back into those areas and delving into them and, you know, sharing some of the basics and developing exercises and things like that. You mentioned that in that process that you were teaching some students that were artists also and kind of talking a little bit about creative thinking. One of the questions I had about that is like you mentioned that they had clever solutions to problems. What were some of these solutions that they had and how do you think that people that have this sort of artistic background approach programming differently? Let me give you an example that my friend reminded me of the other day about the types of questions that I would get. My friend was telling me the story that he was doing for-loop loops. In the for-loops, he basically was doing this little game where the first letter, he would cycle through boy names and girl names and if the first letter of each name matched when you go through a for-loop, then they were a couple and they get married. Lucy and Lawrence have L's and so they would match up. Then he was wondering, well, what if I want to connect more than just the first letters? Like, how do you do that? What do you do with this? I don't know. I only know for-loops. I don't know how to do for-loops. He went to go talk to a friend and the friend told him, you can put for-loops inside of for-loops and that was like the moment that his head exploded. These are the types of things that they would come to and for a beginner student, that's like, for them to realize that you could actually put a for-loop inside of a for-loop, these are the types of things that they're thinking a little bit more differently than your average student does. I've taught hundreds of students and none of them ever, and I go to the art school, these are the types of things that they're coming to on their own of simple things of, oh, I can do nested for-loops. I'm looking and I'm thinking, this is crazy. Where do you get? No one's ever taught you this, but you've come up with it on your own. Those types of things, they're simple. They're not major discoveries, but they're simple enough that they're thinking a little bit more differently than your average student does. I feel there's been a very interesting way of teaching also that I've had a few people on lately talking about teaching beginners and kind of different approaches of that, of maybe not trying to explain everything to them of like giving them enough information that maybe then they come back with the question they go, wait, wait, wait, can I do this or whatever, and I think that's such a form of discovery creates this buy-in that isn't there in a lot of other types of educational things where it's like, nope, just memorize these things and it's like very, very different. It's much more exploratory. So I can kind of see what you're coming from. What were some of the projects and things that they were creating in these classes? Very, very simple things. We did a lot of pair programming, which I think is essential. But we would do card games. We would do some data analysis stuff. The program that I taught was for data analysis and data visualization at our art school because one of the things that they're really good at is the visualization part. So they're skilled at that, make the data look pretty. Make it look pretty. But they struggled with the data analysis and they wanted to learn Python in order to get a grasp of that aspect. So we did some pandas and matplotlib, and those libraries and things like that. Are you a developer striving for top-notch application performance? Meet your new ally, Site 24/7 from Zoho Corp. With Site 24/7, you get real-time insights into critical performance metrics like app deck scores, response times, and throughput. It's your secret weapon to swiftly identify performance bottlenecks and issues that can slow down your applications and affect the digital experience for your customers. Optimize your application's performance like a pro with Site 24/7's AI-powered full-stack monitoring platform. For more information, visit site247.com. Don't forget to try their 30-day free trial. That's sit24x7.com. Kind of going back to the book and kind of turning it back around, you write this first chapter that isn't per se about Python specifically, but more about how Python is related to higher-order thinking. What prompted you to write a chapter that's focused on that at the beginning of your book? Whenever I decided to write the book, this wasn't the book that I planned on writing. I wanted to do a straight-up technical book. These are the basics of Python. I've taught this course forever. I did I have a Udemy course centered around this and I know how to teach this and it's successful, right? That was my approach. And I go to an acquisition editor and he sits me down and said, \"We're just going to have a conversation, right?\" \"Okay.\" And it's like, \"I see this book and it sounds good. This is the type of book we would publish, but I want to know what book lives inside of you. Like, this has become like a very different conversation than me just saying I want to publish this purely beginner's textbook, right? Sure.\" And we started talking and it just emerged from me that the reason that I enjoy Python is because I enjoy the way it makes me feel when I'm thinking about it, okay? I'm more focused. All these other cognitive things are happening within me and I experienced this real life. It changed the way that I thought and he's like, \"That's the story we want to tell.\" Right? That's, we have plenty of Python books, right? Yeah, even at Manning itself, beyond that, yeah. And especially beginner books, there's lots of those out there. So, yeah, yeah, totally. Yeah, especially beginner books, there's lots of those out there. Again, kind of tying it back to stuff that we kind of began with a little bit here, why do you think that this higher-order thinking is crucial for an AI-focused society or where things are headed as far as the job market? So, and I give some statistics in the chapter, like there are certain areas of work that are going to be just decimated by AI. But the one thing, like I mentioned earlier, the things that you can't do that's uniquely human is human intelligence and human creativity, yeah, right? That's something you just can't manufacture. And so, and a part of that creativity and human intelligence aspects, you start thinking about critical thinking, analytical thinking, computational thinking, all these other elements that are really our savior in us to function in this new world that we're going into. The idea of amplifying those skills or finding a way to amplify them, like your everyday person, like I'm a trained scientist, right? I've been trained to think this way for over 20-some odd years, sure, right? The normal person doesn't have to do analytical thinking. That's just, and so how do you get them to the point of being able to do analytical thinking? I think that tool to do that or that path is Python. How do you feel Python helps in this goal? Well, I think the idea of problem solving, we get back to problem solving, right? And having, and the fact that it's a great tool for problem solving, you have to employ a lot of these thinking techniques in order to solve problems. So, they force you to think a",
    "R3hb0c-WHZQ": "Welcome to the Real Python Podcast. This is Episode 182. Have you thought of a way to improve the Python language? How do you share your idea with core developers and start a discussion in the Python community? Christopher Trudeau is back on the show this week, bringing another batch of PyCoders Weekly articles and projects. We consider a couple of Python syntax and functional ideas posted to the discussions on python.org. The first idea is for simplifying the syntax of a function's keyword arguments, and the second is for the ability to return a named tuple from a function. These threads reveal steps within the Python Enhancement Proposal process and the goal of finding a sponsor. Christopher covers a tutorial on building a JSON-like parser in Python. The project is a solid place to start if you want to learn about parsing and developing rules for recognizing syntax and extracting data. We also share several other articles and projects from the Python community, including a couple of release announcements, and news items. How to build a Hangman game for the command line in Python, why the Django admin is ugly and how to customize it to differentiate admin environments, clearing up confusing Git terminology, a project to extract links from a remote HTML resource, and a regex crossword game. All right, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at Real Python. After the podcast, join us and learn real-world Python skills with the community of experts at Real Python. Hey Christopher, welcome back.\n\nHey, the penultimate episode this year. Yeah, actually we're gonna have kind of a fun episode where we haven't done this on the PyCoders version of the show, but we're talking about doing a bit of a wrap-up episode heading into the end of the year here. I think that might be fun to do because it's slightly different content that we'll be sharing and highlighting is super popular stuff this year, so excited to wrap up the year. Yep, I got the Real Python statistics on click-throughs for PyCoders, so we even know what's most popular, and there's a few in there that I was surprised by. So that's what is that, stay tuned, there's your hook, there you go. Yeah, yeah, yeah.\n\nSo we got some news to dig into here, a few odds and ends. Okay, the first one is, I didn't even know what was happening, but PSF has completed its first security audit. This was done by a company called Trail of Bits, and they're a cybersecurity firm. They did a code review of Warehouse, which is the PSF site itself, and Kuvote. Yeah, beats me whether that's a clever name or a typo, I'm not sure which. So overall, the results were quite good. There were zero high severity advisories found altogether, and the lower severity ones that they have found have actually already been addressed in the code. So that's great, we've got a safer PSF now for all of us. A lot of effort happening there at security stuff. Oh yeah, they're definitely digging in, and I guess that's where the sponsorships here are helping, right? The fact that companies are putting money into developers being able to work on these things makes a big difference. The second bit of news is the annual Python Developers Survey is ready for your input. We discussed the 2022 survey results not that long ago, I think it was episode 176. So you fill in this year's and if I do the math right, that means we'll be talking about the results in episode 224. Okay, don't hold me to that. So surveys like this do help groups like the Python Software Foundation to consider where to focus efforts, so the information is valuable, so take a few minutes and go fill that in. One quick note on that, it seems to be a little picky about your browser, so you might want to do a Firefox or a Chrome thing. It didn't like Safari. I filled it in yesterday using Firefox and didn't have any problems.\n\nAnd then that last little bit of news here is a release announcement. Wagtail 5.2 is out, that's an LTS release so it's going to be sticking around for a while. So if you're a Wagtail person, go upgrade. And in fact, they already did a security patch, so technically that's 5.2.1. Anyways, before handing the mic back here, I've got one non-news item that I came across this morning that I just kind of wanted to share. It's a bit too short for its own segment, but I liked it enough just to bring it up. It's an article by Graham Voronov and it's titled \"How Many Python Core Devs Use Typing?\" What he's done is gone through a list of past and present core Python developers, looked up their other projects, places like GitHub, and then tallied up how many involve Python typing. So the numbers are kind of surprising. Of all the core devs he could find, about half of them actually have separate open source projects they maintain. That number actually seems lower to me than I expected. I figured if you're giving your time to the Python community, you'd probably be doing others. But maybe they're too busy giving their time to core, so they don't have others. Of those projects that he found, less than 40% used typing. Interestingly, if you only look at the subset of core devs who joined in the last three years, that number goes up to 76%. So there's a fairly strong correlation there between being a more recent dev and the desire to use typing. It's not that I'm not a fan, it's that I'm too old.\n\nSo the article goes over the methodology he used and has some decent insights if you're interested. But I just thought the information itself was kind of interesting and thought I'd share it. Yeah, it kind of makes me think a little bit. A lot of this is the personal projects and looking at them, and then I wonder, you know, like are those... Yes, they're on GitHub, but are they quote-unquote for public consumption? And like that, which is hard to factor. And you're never going to get a really good statistical piece here as well, right? So, you know, if you look at when I look at my repos on GitHub, a significant percentage of them are just me storing my code there. No one else is using them, right? And if they're tiny little one-off scripts, you're not going to bother writing typing. And then the flip side of it happens as well. I've got a script that I would not... I've got a repo that I would not put typing on that has typing because one of my colleagues went, \"Oh, this is a great tool, but it needs typing.\" And he did a PR, so I'd get a checkbox for that one, even though technically if it wasn't for him committing it, it never would have had typing.\n\nThe data is going to be messy, but there are some patterns there. It was kind of interesting. So that's the news there. We've got a bunch of other stuff to dig into. Okay, so the first one is... I didn't even know what was happening, but PSF has completed its first security audit. This was done by a company called Trail of Bits, and they're a cybersecurity firm. They did a code review of Warehouse, which is the PSF site itself, and Kavote. Yeah, beats me whether that's a clever name or a typo, I'm not sure which. So overall, the results were quite good. There were zero high severity advisories found altogether, and the lower severity ones that they have found have actually already been addressed in the code. So that's great, we've got a safer PSF now for all of us. A lot of effort happening there at security stuff.\n\nOh, yeah. Yes, they're definitely digging in, and I guess, you know, that's where the sponsorships here are helping, right? The fact that companies are putting money into developers being able to work on these things makes a big difference. The second bit of news is the annual Python Developers Survey is ready for your input. We discussed the 2022 survey results not that long ago. I think it was Episode 176, so you fill in this year's, and if I do the math right, that means we'll be talking about the results in Episode 224. Alright, don't hold me to that. So surveys like this do help groups like The Python Software Foundation to consider where to focus efforts, so the information is valuable. So take a few minutes and go fill that in. One quick note on that, it seems to be a little picky about your browser, so you might want to do a Firefox or a Chrome thing. It didn't like Safari. I filled it in yesterday using Firefox and didn't have any problems.\n\nAnd then that last little bit of news here is a release announcement. Wagtail 5.2 is out. That's an LTS release, so it's gonna be sticking around for a while. So if you're a Wagtail person, go upgrade. And in fact, they already did a security patch, so technically that's 5.2.1. Anyways, before handing the mic back here, I've got one non-news item that I came across this morning that I just kind of wanted to share. It's a bit too short for its own segment, but I liked it enough just to bring it up. It's an article by Graham Voronov, and it's titled \"How Many Python Core Devs Use Typing?\" What he's done is gone through a list of past and present core Python developers, looked up their other projects, places like GitHub, and then tallied up how many involve Python typing. So the numbers are kind of surprising. Of all the core devs he could find, about half of them actually have separate open source projects they maintain. That number actually seems lower to me than I expected. I figured if you're giving your time to the Python community, you'd probably be doing others. But maybe they're too busy giving their time to core, so they don't have others. Of those projects that he found, less than 40% used typing. Interestingly, if you only look at the subset of core devs who joined in the last three years, that number goes up to 76%. So there's a fairly strong correlation there between being a more recent dev and the desire to use typing. It's not that I'm not a fan, it's that I'm too old.\n\nSo the article goes over the methodology he used and has some decent insights if you're interested. But I just thought the information itself was kind of interesting and thought I'd share it. Yeah, it kind of makes me think a little bit. A lot of this is the personal projects and looking at them, and then I wonder, you know, like are those... Yes, they're on GitHub, but are they quote-unquote for public consumption? And like that, which is hard to factor. And you're never going to get a really good statistical piece here as well, right? So, you know, if you look at when I look at my repos on GitHub, a significant percentage of them are just me storing my code there. No one else is using them, right? And if they're tiny little one-off scripts, you're not going to bother writing typing. And then the flip side of it happens as well. I've got a script that I would not... I've got a repo that I would not put typing on that has typing because one of my colleagues went, \"Oh, this is a great tool, but it needs typing.\" And he did a PR, so I'd get a checkbox for that one, even though technically if it wasn't for him committing it, it never would have had typing.\n\nThe data is going to be messy, but there are some patterns there. It was kind of interesting. So that's the news there. We've got a bunch of other stuff to dig into. Okay, so the first one is... I didn't even know what was happening, but PSF has completed its first security audit. This was done by a company called Trail of Bits, and they're a cybersecurity firm. They did a code review of Warehouse, which is the PSF site itself, and Kavote. Yeah, beats me whether that's a clever name or a typo, I'm not sure which. So overall, the results were quite good. There were zero high severity advisories found altogether, and the lower severity ones that they have found have actually already been addressed in the code. So that's great, we've got a safer PSF now for all of us. A lot of effort happening there at security stuff.\n\nOh, yeah. Yes, they're definitely digging in, and I guess, you know, that's where the sponsorships here are helping, right? The fact that companies are putting money into developers being able to work on these things makes a big difference. The second bit of news is the annual Python Developers Survey is ready for your input. We discussed the 2022 survey results not that long ago, I think it was Episode 176, so you fill in this year's, and if I do the math right, that means we'll be talking about the results in Episode 224. Alright, don't hold me to that. So surveys like this do help groups like The Python Software Foundation to consider where to focus efforts, so the information is valuable. So take a few minutes and go fill that in. One quick note on that, it seems to be a little picky about your browser, so you might want to do a Firefox or a Chrome thing. It didn't like Safari. I filled it in yesterday using Firefox and didn't have any problems.\n\nAnd then that last little bit of news here is a release announcement. Wagtail 5.2 is out. That's an LTS release, so it's gonna be sticking around for a while. So if you're a Wagtail person, go upgrade. And in fact, they already did a security patch, so technically that's 5.2.1. Anyways, before handing the mic back here, I've got one non-news item that I came across this morning that I just kind of wanted to share. It's a bit too short for its own segment, but I liked it enough just to bring it up. It's an article by Graham Voronov, and it's titled \"How Many Python Core Devs Use Typing?\" What he's done is gone through a list of past and present core Python developers, looked up their other projects, places like GitHub, and then tallied up how many involve Python typing. So the numbers are kind of surprising. Of all the core devs he could find, about half of them actually have separate open source projects they maintain. That number actually seems lower to me than I expected. I figured if you're giving your time to the Python community, you'd probably be doing others. But maybe they're too busy giving their time to core, so they don't have others. Of those projects that he found, less than 40% used typing. Interestingly, if you only look at the subset of core devs who joined in the last three years, that number goes up to 76%. So there's a fairly strong correlation there between being a more recent dev and the desire to use typing. It's not that I'm not a fan",
    "lN8EKFMkDfI": "Welcome to the Real Python Podcast. This is Episode 183. What goes into a code review in Python? Is there a difference in how a large organization practices code review compared to a smaller one? And what do you do if you're a solo developer? This week on the show, Brendan McGinness and Nick Thepen from Sorcery return to talk about code review and automating code assistance. Nick and Brendan discussed their personal experiences with code reviews, from working together at a large company to starting Sorcery as a pair of developers to growing a team. They've experienced how various organizations review code. We discuss the importance of keeping code reviews positive and maintaining developer momentum. Nick and Brandon share techniques for automating organizational code rules and retaining institutional developer knowledge. They've been busy developing new features for Sorcery, moving beyond the current refactoring features. Their team is leveraging LLMS to build an automated code assistant that can perform code reviews, write tests, and answer questions about your code base. The goal is for it to act as a personalized computer pair programmer. All right, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at Real Python. After the podcast, join us and learn real-world Python skills with the community of experts at Real Python. Well, I want to welcome back Brendan and Nick from Sorcery. It's fun to talk to you guys again. Hello, it's a pleasure to be back. Hey, it's great to be here. We met up at PyCon this last year briefly. I came by the booth, and you were showing me some fun stuff that you were working on inside of Sorcery. I think we'll probably dig into quite a bit of that today, talking about how you guys are bringing more AI to the platform. And specifically LLMS stuff. Then we happened upon a good source of questions, which is code review. When we first talked almost three years ago, we were talking mostly about refactoring and using Sorcery as a tool to help in that process, giving you suggestions and improving your code. Maybe you haven't thought of this, and so forth. Is this a new angle or has this been a shift that I haven't been aware of for a while for Sorcery? Definitely a new angle. Over the past year, we've been kind of seeing how powerful LLMS have become. Lots of people using Copilot, lots of people using all these different tools. It kind of started to dawn on us that maybe we can make really powerful use of it for certain parts of the code development process. Maybe it was back in June or July we started really leaning into it and trying out different things. It sort of dawned on us that code review is a nice discrete piece of the software development workflow where it can provide real value. Now we're super focused on code reviews in GitHub, and we're using it ourselves to review all of our PRs. It's early days, but it's already really useful. I can't wait to see where it's going to go. \n\nI have always been a fan of AI developments. I've been a fan ever since AlphaGo came out all those years ago and defeated Lee Se-dol at Go. I just was fascinated from then and I just can't believe the progress. I just can't believe how rapidly it's all happening and how powerful LLMS are now. The progress is astonishing. It's kind of like you're not completely on the sidelines. You can kind of go and look at the code and see some of what's actually happening, as opposed to just watching technology advance. \n\nYou can follow us on Sorcery at sorcery AI on Twitter or our changelog, all sorts of things in our blog. We're going to start producing a bit more blog content on code review and kind of how we're approaching it and the best way of doing it. Our website is https://sorcery AI with a \"u.\" We also have GitHub. We are the most focused team on using LLMS for code reviews. Our tool is available in closed Alpha, but it will be released more broadly soon. \n\nI'd like to thank Brendan and Nick for coming back on the show this week, and I'd like to thank you for listening to the Real Python Podcast. Make sure you click that follow button in your podcast player. And if you see a subscribe button somewhere, remember that the Real Python Podcast is free. If you like the show, please leave us a review. You can find show notes with links to all the topics we spoke about inside your podcast player or at realpython.com/podcast. While you're there, you can leave us a question or a topic idea. I've been your host, Christopher Bailey, and I look forward to talking to you soon.",
    "rwql5rWoFoI": "Welcome to the Real Python Podcast. This is Episode 184. It's been a fascinating year for the Python language and community. PyCoders Weekly included over 1500 links to articles, blog posts, tutorials, and projects in 2023. Christopher Trudeau is back on the show this week to help wrap up everything by sharing some highlights and Python trends from across the year.\n\nChristopher shares the top five links explored by PyCoders readers. We also dig into trends we noticed across all the articles and stories this year, including removing dead batteries from the standard library, ongoing work to speed up Python using Rust code in libraries, and moving away from microservices. We hope you enjoy this review. We look forward to bringing you an upcoming year full of great Python news, articles, topics, and projects. \n\nAlright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at Real Python. After the podcast, join us and learn real-world Python skills with a community of experts at Real Python.\n\nHey Christopher, welcome back. The last episode of 2023. I'm excited to do a PyCoders wrap-up. We've never done it before, and I think this will be interesting. Let us know what you guys think. I'm interested in covering things like trends and so forth. It was weird looking at the numbers of how many links that you guys publish every year. When it got into the thousands, I was like, \"Okay, a lot of information goes out every week.\" Yeah, well, we usually do about 20 links a week, which is pretty typical. And 52 weeks a year, so it adds up. Cool, so we are going to start with some news though. Some things have been happening still here at the end of the year.\n\nThe march towards Python 3.3 steadily carries on. It feels like only a few weeks ago we were announcing 3.12. But that's how it goes. Python 3.13 Alpha 2 is now out. This is the second in seven planned alpha releases. So yeah, progress happens. Another chunk of news also from the Python Software Foundation is they've hired a supporting developer in residence. This was almost accidental. You might recall there was an announcement a while back about the position for the deputy developer in residence. Well, they got a bit more funding than they expected for the role, so they were able to hire their second choice for that job as well. Seri Storczak is now getting paid to write code for the PSF. Good welcome, and although it sounds like he's been a longtime contributor, so that's nice that people are getting paid to do this. WS has a little team now. That's right. And then a couple quick release announcements. Django 5 has gone gold, so it's time to upgrade there. Get off your release candidate if you're playing around there. And one of my favorite Django third-party libraries, which is Ninja, it's a fast API-like tool for writing APIs. They just released their first 1.0 version. Congrats to both groups for finishing their big releases. Is there much change from the versions or just kind of solidifying and making it version one? I didn't see anything massively changed. They've been on 0.9 for quite some time, so I think it's probably just been bug fixes and things.\n\nMaybe I'll include a link to your course you did on that. That's right. Yep, we can go learn more about Ninja. One of the things that we thought of featuring is out of all those links that were shared of the year, we keep metrics of how many people click on the different things and can get an idea of what is the most popular of all the different links from PyCoders across the year. So it looks like you compiled the top five here, and we can kind of go through them and cover them quickly. I have the top 1500, but we'll stick with the top five. Our illustrious editor and chief at Real Python ran set up a query for me, and it almost knocked the Heroku server over. It took a little bit, but that's fine. So I figured folks might be curious about it. With apologies to David Letterman, here is the PyCoders top five.\n\nNumber five was a Real Python article by Garnella called \"Python 3.12: Cool New Features for You to Try.\" This isn't terribly surprising. Lots of our coverage was on Python 3.12, and there was a fair amount of interest. And if you somehow missed it, there is both a tutorial article and a video course version of this content. So if you want to go back and learn more about 3.12, that's there. And a podcast episode about it. That's right. Right. And number four, a free link, in Mr. Turner T. R. Rings article, \"Speeding Up Your Code When Multiple Cores Aren't an Option.\" This article covered ways of improving your code speed without touching parallelism. We actually talked about this in Episode 176.\n\nNumber three was actually a fairly recent article. This one was by Mike Driscoll called \"Learning About Code Metrics in Python with Radon.\" This article covered different ways of measuring your code for quality using the Radon library. Interestingly enough, this one was also covered in Episode 176, so we must have done something right that day. I don't know how that worked out. Number two is another Python 3.12 article. This one is \"Python 3.12: More Intuitive and Consistent F-Strings\" and it's by Leonos Porramos. As the title implies, it's all about the changes introduced with the new F-String Parser.\n\nAnd finally, I don't have a drum roll sound effect, so you just have to imagine it. Okay, \"Design and Guidance: Object-Oriented Programming in Python.\" This was actually one of my courses based on a tutorial also by Leonos. It was the third part in a three-part course all about OOP coding with part three focusing on the SOLID principles. It's always nice to know that some of the content I'm creating is getting viewed. So where we go, I don't know. I get my little gold star for number one, I guess. Yeah, good job. Yeah, yeah, that whole series was really great, and it was fun working with you to turn it into a set of video courses. And yeah, it's been very popular. We joked around in the Real Python meetings and so forth that it was sort of the autumn of OOP at Real Python. There was so many object-oriented kind of diving into that area of Python, and that was neat kind of coverage this year.\n\nSo great. All right, I think that takes us into what I'm going to talk about: trends across a handful of different articles and include a bunch of links. Some of these we might have touched on, and some of them we haven't. And also mentioned sort of trends in some new people posting that we featured a lot this year. The first one, the trend I wanted to talk about, is about batteries. I know that may sound strange, but batteries are definitely one of those things that we talk a lot about in Python. This idea that Python has batteries included, but the trends I kind of noticed is this trend toward deprecating these batteries and the idea that there are dead batteries. And then there's a couple of articles that talk about there's sort of missing batteries or maybe they, like, want more batteries. It's kind of an interesting idea of these libraries that are additions to Python that can help out in ways that people would love if it was even included by default as part of a built-in thing. The first article I want to feature is actually an article about Python 3.12, and it's by our newish friend, Bite Code, from October 3rd. It's \"Python 3.12: What Didn't Make the Headlines.\" I'll just kind of cover what's in the article briefly. They wanted to feature a handful of things that didn't quite get the high points that were covered in maybe some of Real Python's coverage or other people's coverage. The first one is there was a lot of hay being made about increasing the performance of Python over the last couple of versions, and it was noted that there was a 5% gain in general as far as what was officially shared, and that maybe that was a bit of a letdown. They also ran tests that showed that between 3.11 and 3.12, it showed only 14 of the tests that they ran being faster and 79 running slower. So in this test suite that they ran, it was not really much of a gain, and maybe in some cases might have been slower. So kind of a mixed story on performance, which is kind of interesting. They also talked about pathlib improvements, which I think we talked a little bit about. Pathlib added a walk feature, which is very handy. Better debugging experiences, not only were the better error messages that we talked about in detail, but there's some new ways that PDB functions, and the article kind of digs into that a little bit. Some new command-line interfaces, things that you might not be aware of - there's this HTTP server built into Python. Or you maybe aren't aware of it, but you can just type `python -m http.server`, and boom, you've got an HTTP server set up, which is really handy for doing different things. 3.12 added a SQLite shell that does something similar, and then it also added a UUID. Does it stand for Universal? I forget what the extra U is in UUID, but you can just generate one. It stands for very long, very long ID, exactly, and unique. And then at the very end of it is where I wanted to get to, which was headline, which was deprecations. Deprecation, deprecations, and things that they call out is `tnetlib` two to three being deprecated, `datetime` UTC now. So these are things that are noted as deprecations. Their joke is, you know, maybe don't update to the new version on a Friday, so there's lots of these little things that are kind of happening, and they link to the doc section of the 3.12 release notes which digs into this whole deprecated section. What's interesting is just kind of going through the list and kind of seeing, okay, what is that going to affect your code, and these things that are being removed, these older things that maybe there's new ways that they're being approached. And the other thing that I thought was interesting is the next section kind of goes into this pending removal for 3.13, and that leads me into the next article which Python 3.13 removes 20 standard library modules. Again, coming up here in 3.13, hence why you may want to pay attention to the upcoming alpha releases. Core developers are busy working on PEP 594, which is sort of known as the removing dead batteries PEP. It was approved, kind of a long post that goes into the discussion forums. There's also this link, the first post kicking off this thread from Victor Stinner. He's a core dev, and it runs through the highlights. But I thought this section on advice was kind of interesting. If your project is affected, you have some different solutions. First one is do nothing for now, only remain compatible with 3.11 and older. In his opinion, it's a dangerous long-term choice that the technical debt only becomes more expensive over time, but maybe someone will come with a solution for you in the meanwhile. Next one is attempt to propose recipes and alternatives in the \"What's New\" documents and create a group of volunteers and give a new life to the removed module by maintaining them on PyPI. You will be able to use \"pip install\" then, Linux distributions should package it and add it as a new dependency to your projects. And the last advice is copy the remove module inside your project and maintain it there. Usually, it's a single short `.py` file. If you choose to skip documentation and test just be careful about the license and copyright. You're now on your own to maintain it, but this solution is quick and simple. So, a handful of approaches. I think all of them have their own baggage potentially that you need to pay attention to. His next post is thanking Christian Hees and Brett Cannon for being stubborn and getting this PEP 594 accepted and implemented. So, digging into the batteries being removed, and then what I thought was interesting is this trend across PyCoders over the year of including links that talked about either missing batteries or maybe the desire for other things that are like this. The first one is \"Missing Batteries: Essential Libraries You're Missing Out On.\" Even though Python's standard library comes with batteries included, it's still missing some essentials. This article is from Martin Hines, who we feature pretty often. It's from May 1st. Again, kind of digging into that idea that batteries are included. Thanks to its extensive library, in Python, many modules and functions that you would not expect to be there are there, which is really kind of nice. However, there are more that he feels are essential, and he just goes through and lists a whole bunch of them and kind of digs into them in detail. One is a set called \"Bolt-ons\" which includes JsonUtils, TimeUtils, and IterUtils. The JsonUtils adds a lot of tools for working with JSON. One that's really unique that I haven't seen before is called JsonLines, which deals with the JSON lines format. There's a DateRange in the TimeUtils that he highlights that creates date ranges that can be iterated over, which is really kind of a neat functionality. IterUtils, not to be confused with itertools, which we'll talk about. The IterUtils has a bunch of really interesting remapping sort of functions for iterators. He talks about a library called SH that looks for shell commands and binary packages in your path. It can use pseudo commands. It has a bunch of stuff under data validation, a validator library that instead of creating your own regex formats for things like email addresses or credit cards or IP addresses, that has that stuff kind of built into it, which is nice. There's a library that originally was called FuzzyWuzzy, that's how I had heard of it originally. A coworker that I had back in Hawaii, shout out to TJ, he loved that package. He would use it all the time. We worked in the marketing department, and so finding close or close enough matches in text strings and things like that was really important. They've renamed it to Fuzz. It has functions and modules, things like a ratio function, get close matches, sequence matchers, really handy for again that kind of fuzzy, close enough matching in text. A couple others that are nice, Freezegun, which can freeze time when you're doing testing, and then kind of similar to the Fuzz, there's a thing called Dirty Unkore Equals that has like is A, is now is JSON, is positive, and has all these kind of interesting little different sort of functionality in the library. He also links out to an earlier post where he talks about in 2020, he had one about itertools and the more itertools library. And then the other one I want to mention is a post from Carlton Gibson that's called \"More Batteries, Please.\" He's kind of in the hashtag more batteries camp as opposed to the remove the dead batteries camp, which I think is kind of interesting. More than just including the link, I want to mention that he refers to the series by Doug Hellman that started in the Python 2 era that was called the \"Module of the Week\" and it got updated to the Python 3 \"Module of the Week,\" which I'll include a link to that also. And it's just a great way to study like what is all inside of Python as far as like looking at the batteries and the things that are there and all the different modules. I can't think of a better way to kind of learn some of the deeper areas of Python than to kind of look at each one, you know, maybe one a week as a way of practicing and learning a little bit more about it. And then Christopher and I, we covered in some detail, we had a discussion in episode 171, the title of the episode was \"Making Each Line of Code Efficient,\" and we discussed itertools, we discussed more itertools, we talked about enumerate and functions like all and any, and stuff like that, ways that you can kind of write code. How there's lots of built-in kind of functionality that you're not having to recreate this functionality yourself, that a lot of that's built into Python, and you can write efficient Python with very few lines of code. So kind of a trend across a variety of articles there. I don't know if you'd heard of any of those other libraries. I've come across a couple of them, but none of them are common in my toolkit for sure.\n\nYeah, I think they're, you know, it kind of depends on the way that you work. It sounds like a lot of them would be handy in the testing environment, those things like the dirty equals and that freeze gun I thought was interesting as far as freezing time. And I think that's sort of always the debate with the should it be included as a battery or not, right? Like I've seen a couple of conversations particularly about the requests library. Yeah, everyone's like, everyone uses it. Why isn't it just part of the standard library? And the counterargument is because then we can control the release path. It isn't tied to a Python release. And so even if everybody is using it, there's an argument to keep it out, right? So yeah, I think that's anytime you have these kinds of things, it's always a trade-off. That one's a hybrid in a way that it, I don't want to call it abandoned, but it kind of got taken over, and I think the Python Packaging Authority is in charge of requests now. Oh really? I didn't know. I hadn't heard that. Okay, yeah, like it shifted ownership in some way. I'd have to maybe do the research again. But it's definitely under a different GitHub than originally as far as the path of it and its development. But yeah, it is crucial, but should it be built in? Yeah, and then that gets into a whole other debate that we talked about with the YWM and even these other embedded tools where like, can't we just get Python down to its core as opposed to everything else added? So yeah. What was your trend or area that you wanted to talk about?\n\nSo I've got an article actually on trends. It's called \"Three Python Trends in 2023,\" and it's from the site Jerry Co. I assume that's not his real name. Okay, Jerry might be, but I'm suspicious when the last name's codes for a programmer. This article was highlighted way back in issue 563, which is at the beginning of the year. Hadn't highlighted it in one of the podcasts before, but I thought it would be kind of interesting. He talks about three different things, and they're sort of predictions, or you could kind of",
    "DwKUeba10u8": "Welcome to the Real Python Podcast. This is Episode 185. Thank you for joining us for the 2023 Real Python Tutorial and Video Course wrap-up. Three members of the Real Python team are joining us this week: Kate Finnegan, Tapen Moore, and Philip Xeni. We wanted to share a year-end wrap-up with tutorials, step-by-step projects, code conversations, and video courses that showcase what our team created this year.\n\nKate helps to shepherd articles through the multi-stage editing process. She and the rest of the team ensure that these resources impart crucial Python knowledge and provide a thorough didactic experience. Kate was also instrumental in helping introduce a new group of tutorial authors to the Real Python editorial process and house style.\n\nPhilip returns to the podcast after our conversation earlier this year, and it was great to talk to him about onboarding new video instructors. Tapen edits all our video courses and ensures the sound, picture, and animations are just right. He also helped provide feedback to the new instructors on our video creation process.\n\nWe hope you enjoy this review. We look forward to bringing you another year full of great guests, articles, and topics. All right, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at Real Python.\n\nAfter the podcast, join us and learn real-world Python skills with the community of experts at Real Python. I want to welcome everybody to the 2023 Real Python Tutorial and Video Course wrap-up, and we might actually mention several other things this year. I got several guests, a few that you may have met if you've been listening to the show for a little while.\n\nKate Finnegan is back this year. Welcome, Kate.\n\nPhilip Xeni has been on the show a couple of times. Welcome back, Philip.\n\nNew this year, somebody's been working in the background at Real Python for as long as I've been at Real Python, Tapen Moore, who does a lot of the video editing and helps on the video course pipeline. Works directly with me all the time. Hi, Tapen. Good to be here.\n\nWe wanted to discuss a little bit about what happened this year for 2023 here at Real Python and some of the changes. One of the big things we did this year was try to bring on some new video course instructors, and Philip, you were really involved deeply with that this year. Do you want to talk a little bit about that process?\n\nYes, that process was my highlight of the year. We onboarded a few new video course instructors, namely, Nigar Vahit, Alexis Drapos, Arian D., Alexandra Davis, Timberly Fessel, and Sebastian Oliver. I will talk a bit more about their content in a moment. New voices in the team brought their own styles and ways of delivering things, and it was super fun working together with them.\n\nTapen was a great help with this process. He listened to the sound and always sent over the files to me to make sure it sounded good. It was great to make everything sound good in the end.\n\nAlong with that, we also made an outreach for new authors, so we brought on a whole bunch of new writers this year. It's exciting to talk a little bit about them.\n\nKate, do you want to discuss a little bit about that process?\n\nYes, we had a lot of discussions about making sure it was a friendly onboarding process and that we made everything straightforward. We put everything on a need-to-know basis to make sure everyone understood our style and processes.\n\nWe welcomed a few pilot authors who hit the ground running and produced really incredible content across a diversity of subjects. It's fantastic to bring in people with different expertise and different interests.\n\nWe welcomed Ian, Vincent, Matind, Harrison, Hoffman, Robert, Alfred, Claudia, and Sarah Hack this year. That's great. It's nice to see these new profiles and see some new talent hit the Real Python front page.\n\nWe also want to give a quick shout out to our artist in residence, Aldrin. He does so much of the work that you see, creating engaging and colorful artwork. It's unique and handcrafted for every tutorial, which is something very special about Real Python.\n\nI remember we had someone ask, \"What program do you use?\" The response was, \"It's not a program, it's an incredibly talented and hardworking person.\"\n\nHe makes such neat and iconic looking artwork, and it's so unique. I love that. Big props to him.\n\nHe's sent over a couple of time-lapse videos of doing the work, and the details that go into it are pretty amazing to watch. It brought everybody together to highlight a bunch of work this year. This is not everything that came out, but we wanted to showcase some of the favorite things that we wanted to wrap up this year with.\n\nPhilip, do you want to go first?\n\nYes, I want to highlight the \"Build a Wordle Clone in Python with Rich\" tutorial by Gerard. It's a step-by-step tutorial where you build your own Wordle game for the terminal. Wordle is a game where you have six attempts to guess a secret five-letter word. It's not only fun to follow this tutorial and learn about Rich, but you also have a little working program at the end.\n\nKate, what's your next one?\n\nI want to talk about Ian's tutorial called \"Using the NumPy Random Number Generator.\" Ian does a great job of grounding all this information in a real-world example. The tutorial walks you through how to use NumPy's random number generator to solve a practical problem. For example, if you're on a school board and want to improve the safety of pick-up and drop-off, you can use NumPy's random number generator to solve that problem.\n\nChristopher, what's your next one?\n\nMy next one is a pair of tutorials by Leodan Pou Ramos. The first one is called \"Python Classes: The Power of Object-Oriented Programming,\" and the second one is \"Solid Principles: Improve Object-Oriented Design in Python.\" Leodan takes you to the next level of object-oriented programming in Python and dives deep into design principles that work across any object-oriented programming language.\n\nTapen, what's your first one?\n\nMy first course is \"An Introduction to Recursion\" by Christopher Trudeau. Recursion is a function that calls itself, and you learn how to implement recursion for various use cases in Python. Christopher does a great job of explaining recursion and how it can be used for tasks like implementing tree traversal or the quick sort algorithm.\n\nPhilip, what's your next one?\n\nMy next content piece is \"Filtering Iterables with Python,\" a video course by Nigar. Nigar teaches you how to use Python's filter function to extract needed values from iterables and combine filter with other functional tools. It's aimed at intermediate Python developers, but Nigar does a great job explaining everything from the ground up.\n\nKate, what's your second one?\n\nI want to highlight Ian's tutorial called \"Using the NumPy Random Number Generator.\" Ian does a great job of grounding all this information in a real-world example. The tutorial walks you through how to use NumPy's random number generator to solve a practical problem. For example, if you're on a school board and want to improve the safety of pick-up and drop-off, you can use NumPy's random number generator to solve that problem.\n\nChristopher, what's your second one?\n\nMy second one is a video course on creating web maps from your data with Python and Folium by Kimberly Fessel. Folium is based on a JavaScript library called Leaflet and allows you to create interactive geographic visualizations that you can share as a website. It's a great resource for adding cartography to your Python projects.\n\nTapen, what's your second one?\n\nMy second course is \"How to Process Images Using the Pillow Library\" by Darren Jones. Pillow is a fork of the Python Imaging Library and allows you to perform Photoshop-like manipulations of photos. Darren teaches you how to crop, resize, rotate, blur, and manipulate images with Pillow. It's a satisfying way to modify images with just some text programming.\n\nPhilip, what's your next one?\n\nMy next content piece is \"Filtering Iterables with Python,\" a video course by Nigar. Nigar teaches you how to use Python's filter function to extract needed values from iterables and combine filter with other functional tools. It's aimed at intermediate Python developers, but Nigar does a great job explaining everything from the ground up.\n\nKate, what's your last one?\n\nMy last one is a showcase on the Real Python website about the Python Rich package. Rich is a package that can help you create text-based user interfaces and prettify your console output with color formatting, text design, and layout features. It's a great resource for making your projects look good and stand out.\n\nTapen, what's your last one?\n\nMy last one is a code conversation on Advent of Code by Philip Xeni and Garna. They focused on a challenge that involved helping the elves tune their communication system by finding the start of a packet in a string of data. It's a fun way to practice Python skills and save Christmas.\n\nThat wraps up our review of the 2023 Real Python Tutorial and Video Course wrap-up. Thank you to all our guests for joining us. We hope you enjoyed this review and look forward to bringing you another year full of great guests, articles, and topics. Happy New Year and Happy Holidays from the Real Python team!",
    "MhBlbx923vo": "Welcome to the Real Python Podcast. This is Episode 187. Do you need to transfer an extensive data collection for a science project? What's the best way to send executable code over the wire for distributed processing? What are the different ways to serialize data in Python? Christopher Trudeau is back on the show this week, bringing another batch of PyCoder's Weekly articles and projects. Christopher shares a tutorial by Real Python author BTO Jinsky titled \"Serialize Your Data with Python.\" This comprehensive guide moves beyond XML and JSON to explore multiple data formats and their potential use cases. It's a deep dive into the topic and provides a thorough resource for future reference. We also discuss a Real Python tutorial about naming conventions in Python that use single and double underscores. The piece covers differentiating between public and non-public names and APIs, writing safe classes for subclassing purposes, and avoiding name clashes with keywords. We also share several other articles and projects from the Python community, including a couple of release announcements and news items, a discussion about never being taught how to construct quality software, building a small REPL in Python using the key parameter in Python functions and methods, a framework for RESTful APIs using Flask and SQLAlchemy, and a Rust-based HTML sanitizer for your Python projects. Alright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at Real Python. After the podcast, join us and learn real-world Python skills with the community of experts at realpython.com. Hey, Christopher, happy New Year. Welcome back.\n\nYes, happy arbitrary calendar demarcation to you as well. We have a collection of stuff that kind of happened over this break that we took. We got a few news items and then some kind of fun topics. There's a bit of a theme going on with topics for me, at least, best practices and things that happen inside of Python that I think are kind of interesting. We again have a discussion, which I'm excited to dig into, so I guess we should start with the news. Do you want to get going with that?\n\nSure. Over the holidays, a big commit was made to The CPython Interpreter, and that is the JIT compiler. If you're new to this idea, JIT stands for Just-In-Time, and it's a process that dynamically writes machine code to optimize your software on the fly. Other Python interpreters have JITs, but this is new to the CPython version, and we're going to be linking to both the commit itself and a set of slides that talk about what's in it. The commit's kind of a fun read. Brent Butcher, who's the committer, he got a little creative and wrote a poem in the vein of the night before Christmas. So even if you're not interested in the code, the commit's worth reading. If you're digging into the slides, they're posted on GitHub, which does this weird thing with PDFs. There's this little \"more pages\" button buried at the bottom every few slides that loads the next chunk. I missed it the first time, and I was kind of confused as to why the whole thing was rather short. So I'm sure if you all go back in there and see that, you'll immediately laugh at me and go, \"Well, but the button's right there. What's wrong with you? It's in front of your face.\" Have a good laugh. The other chunk of news, for any Django nuts out there, yeah, that's what they call themselves. I don't, but bug fixes dropped for 4.2.9 and 5.0.1. If you're playing with 5.0, which was recently released in December, you definitely want this one. It's got about a half-dozen regression fixes in it. Yeah, that's a fun read from BRT Booker.\n\nYeah, that was very Christmassy themed, so definitely check it out. Alright, let's dig into topics here. My first one is from our friend Leodas Poramos, who's having a nice little break right now. I'm hoping he's enjoying his extended holiday break. This tutorial is about naming conventions in Python, specifically ones that involve the underscore character. For a beginner, I think this is really illuminating. You look at other people's code and you go, \"Boy, that's an interesting way to name things. Why add this sort of arbitrary at the time as you look at it underscore character in different places?\" There's a lot of conventions that were built up and you can learn a lot by just digging through this article. I think definitely for a beginner, it's like I said, illuminating, but for someone coming from another language, it's going to help explain some of these concepts and the ways that Python does it. Python is a very dynamic language. We talk about that a lot here. If you're coming from something, I'll call it more rigid like Java, there's different ways of handling these sorts of concepts and so forth. So there's five of them that are discussed, five different ways that the underscore is discussed in this article. The first that he covers in a lot of detail is the single leading underscore. It indicates that it's meant for internal use only, as opposed to outside use. It's sort of this idea of public versus non-public methods and attributes. There's another one that's at the tail of something. In naming things, the single trailing underscore is used to avoid naming conflicts with Python keywords or built-in names. In case you have names that only make sense to match up with what a keyword is. I think there's lots of other ways around this, but this is something you may see out there. The third one was about the double leading underscore. This one is sometimes called name mangling and it triggers this feature in this context of Python classes. If you're having things that inherit, it can help with sort of auto-naming things for you by creating this way. He digs into that. The most common one that we've talked about in the show, which is the double leading and trailing underscore, sometimes called the dunder methods with, again, two underscores before the name and two underscores after. That would indicate that it's a special attribute and/or method. What's interesting is right, I think this week, Lea Doss had another article that came out that's talking about Python's sort of magic methods or dunder methods, special methods, different names for the same thing, and leveraging them. The last is sort of interesting uses for a single underscore by itself, and it indicates a temporary or throwaway variable. There's an interesting way that that works. To kind of dig into the heart of this thing, he spends the most time talking about this public and non-public methods and attributes and how this works. A public attribute or method, you can use them in your own code or the client's code, whereas something that's private or in this case non-public for the use as we're describing it here, you would use them only from within the defining class and its subclasses. He gives three major reasons for doing this. The first is preventing incorrect usage of your code. To be able to mark internal parts of your code with non-public names allows you to guide users through the correct usage of your code, like what should be considered use for non-public or public use. It improves the readability of your code. If you're doing this thing of creating non-public stuff, it definitely identifies them easily. And then it avoids name clashes using non-public names can help you avoid collisions in packages and modules and classes. He describes how wild card imports work with that and how non-public names using, you know, the import star thing, Python enforces a behavior about how things would not be imported by a wild card import that have that. And then it goes into these other uses a little bit more name mangling, again, another convention that's using the two leading underscores in an attribute or method names. And when you name an attribute or method with using this Python will automatically rename it by prefixing its name with the class name and it'll have like a single underscore after it. This is something that will make a lot more sense visually as you kind of go through the article. The goal is to prevent name clashes in inheritance and again to define non-public members, you always want to use the single leading underscore, the trailing underscore in Python names. This is kind of an odd use case in my opinion. It's like something if you wanted to use, you really wanted to use the variable name list, so like list equals square brackets one, two, three. Well, now you've rewritten over the list callable function that is built into Python that you can create lists with. And if you were to try to create a list using list parentheses and have it turn something into a list, it basically would say this is no longer a callable function. And so it's kind of an interesting thing. I would definitely avoid renaming keywords if you can, but this is a way that you can do it by just adding an underscore after it. It's an interesting convention. And then he digs into the dunder name special methods, how they're used. But again, this other article digs way deeper into that. The last one again was this idea of the underscore just by itself. I haven't used this a ton, but this is a common practice. And one of the interesting things that always kind of surprised me is that if you're working in a REPL session, it's a special variable that will contain the result of whatever you just evaluated. So like if you typed three plus 12, 15 will show in there. You can actually type the underscore hit return and it will return that as this sort of variable as a special return value. So it's sort of assigned as the last thing you evaluate, which is interesting. I've seen it commonly used in loops and other constructs. This is a convention that people do. I would prefer naming something explicitly, but again, it's common that you may see somebody use underscore in this as it's going through and iterating through like a for loop or something. I use it a fair amount actually. It's typically when you've got a tuple that you're trying to unpack and you're not interested in one part of the tuple. It's just an easy way to see it rather than naming it because then you're producing a variable that you're never going to use. It's kind of a signal to the developer that that third thing in the tuple, I want the first and second thing. You know, like say we've got first, middle, and last name in a tuple and I don't want the middle name. I'm going to say first, comma, underscore, comma, last. And that tells the programmer I'm not going to use the middle name. It's potentially going to be just tossed as it goes. Okay. Essentially, yeah. Okay. Yeah. Okay. So that kind of, then is an indication, a convention of like temporary. Exactly. Probably using it. Okay. And that's why it tends to show up in loops a lot because you're doing that on the iterator out of your, you know, what you're looping on. Yeah. A lot of these conventions are described in PEP 8. If you haven't dug deep into PEP 8 and read through it, definitely as a beginner, that is useful because those are the unique things that are happening inside of Python as far as how you should name things. The way things could be used. And he provides links and quotes to those sections of that. And I was going to ask you, Chris, like, not only the underscore one, do you use some of these other ones? Is it, are they common practices for you?\n\nSome I do, some I don't. A lot of it depends on the code. A couple of libraries that I've contributed to, people are like hardcore about it, that like if this isn't a variable that I expect people to use, then I'm going to put the underscore on front of it. And I've even seen people get to the point of where they're like using the underscore internally and then the property smells a little like Java to me at that point. So like, right, right, right, I will use it when I tend to use it a lot. If I'm using a property where the property has to have a side effect, so there'll be the internal version of it, which has the underscore, and then the actual property method that causes the side effect to happen. So if you're getting into properties and descriptors, that's that's a place where I'll use it. Okay. Deep into OOP stuff, essentially. Yeah, back in the days when I was a Java programmer, I was hardcore about like, this should be private, this should be protected, and I'm trying to save the next developer from themselves. And honestly, as I picked up Python, I kind of gave a lot of it up. I'm sort of like, you know, what if you want access to that variable, use it. Why, why am I trying to protect you? Like, who am I trying to protect and from what? Particularly considering 90% of the time, I'm the one maintaining my code, right? Like, I've become a lot less vigilant about it. Now to me, it's, I tend to use it for something that is like, this really is supposed to be hidden for a reason. Okay. I've seen a wide spectrum of it in code, other people's code that I've helped contribute to. What about the after variable name? I almost never bother. Yeah. I would, I would come up with like maybe a two-word name or something, you know, like, I'm not, um, I, I try not to reuse soft keywords. I try not to rename functions. I find it just confusing. Yeah. Um, and most of the time, you know, the example you used where like list underscore, well, it's going to be a list of something. There's going to be a better name for it. So, you know, that tends to be my, uh, I, I'm picky about my variable names. So, yeah, yeah, I'm super picky about it. You know, even in teaching it, I want to have something that is something beyond the foo and bar and things like that. So, yep, there's a, there's a funny, uh, well, I think it's funny because it's like kind of over the top comment at the end of this. It's the only comment that's there, but, and he's like, great article and why I never want to go near Python. And it's like, okay, you know, great article, you explain it well, but craziness of Python. That's like, I don't know if it's craziness, but it is a dynamic language. And so these were conventions that kind of came up, you know, in naming things and having to kind of plan stuff as opposed to having dedicated private and public and so forth. Yeah, if special symbols bother you, stay away from Perl. That's all I have to say there. You go. All right. Well, thanks again, Lea Doss. This was a great tutorial. And if you're learning Python, it's one of these sort of additional reads that can help with the naming conventions, especially if you're doing the thing that we often suggest, which is reading other people's code and you look at the code and kind of scratch your head and it's like, those are lots of interesting underscores and weird places. This might help you with that. So, so what's your first one?\n\nMy first article of 2024 is from Max Bernstein and his site is bernsteinbear.com, which is funny if you're familiar with that particular Mandela effect. The article is on building a small REPL in Python. And like all good titles, that pretty much sums it up. So if you've ever played with a command line tool that was REPL-like, well, Python allows you to override the behavior of the REPL, making it your own. An example of this is inside of Django. There's a management command called shell, which when you run it, you just get a Python REPL, but it's loaded all of the Django configuration bits inside already. I've never looked at the code for it, but I suspect it's using the same kind of techniques that Max is talking about in this post. There's a module in Python called code that has a class called interactive console, and you can instantiate that and then call its interact method. And that runs the REPL. So essentially, you can write a script that invokes the interactive session with an import in two lines of code, and you're running the REPL inside of something you control. The interactive console object allows you to configure the REPL's title banner as well as an exit message. So those are two easy things to make it look like it's your own thing. And then the heart of it is a method called run_source, which gets called each time somebody presses enter in the REPL. And this is how you can start writing your own stuff, adding commands or whatever. Overriding run_source has some consequences though, and it can muck with your access to the inline editing features. The article goes on to show you how to use the readline module to put this functionality back in. And as an example project, he shows you how to build tab completion for anything in Python's built-in dictionary, which includes things like the built-in functions, those things you probably shouldn't be renaming that we just talked about. Max appears to have been building something on his own while he was writing this post, because near the end, he goes, \"Wait, there's this thing called the CMD module, the command module, which isn't as low level, and maybe I should have been using that instead.\" It also allows you to customize the REPL. So the last chunk of the article",
    "bloZciD8oCE": "Welcome to the Real Python Podcast. This is episode 188. How can you measure the quality of a large language model? What tools can measure bias, toxicity, and truthfulness levels in a model using Python? This week on the show, Jod Burchell, developer advocate for data science at JetBrains, returns to discuss techniques and tools for evaluating large language models with Python. Jod provides some background on large language models and how they can absorb vast amounts of information about the relationship between words using a type of neural network called a Transformer. \n\nWe discussed training data sets and the potential quality issues with crawling uncurated sources. Then we dig into ways to measure levels of bias, toxicity, and hallucinations using Python. Jod shares three benchmarking data sets and links to resources to get you started. We also discuss ways to augment models using agents or plugins, which can access search engine results or other authoritative sources. \n\nThis episode is sponsored by Intel, providing Edge AI reference kits. Are you building AI apps with popular models like YOLO V8 or PADN? If so, check out intel.com/edge to get open-source code snippets and helpful guides. Just go to intel.com/edgeai. \n\nAll right, let's get started. \n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython. After the podcast, join us and learn real-world Python skills with the community of experts at realpython.com. \n\nHey, Jody, welcome back to the show. I know it's been a while. Yeah, I'm excited to have you back on the show and start the new year on this subject that has been, uh, gosh, what a wild 2023 as far as this topic goes. Yeah, when you sent me this title, \"Testing Bias, Toxicity, and Truthfulness in Large Language Models with Python,\" I was like, \"Oh yeah, I'm in. Let's do it.\" And I think it's very timely in a way because I feel that we just, as an industry, you know, and people working inside of Python and working in data science, we kind of see some of the way the sausage is being made and never really get to talk about some of the underlying stuff where in the quote-unquote tech sphere, it's all this black box in this magic that's happening. And it's like, \"No, actually, there's ways to look at this information.\" And so that's what we're going to dig into today, which I'm very excited about. \n\nYeah, and I kind of got into this topic over the last year or so. We were talking before we started recording the episode because both of us are a bit disillusioned with the hype around this area. Yeah, my background is ology, so we used to measure stuff like this all the time. So I was like, \"Okay, as soon as I realized there are actual ways to measure this, I'm like, this is totally in my wheelhouse. I am very excited about it.\" \n\nYeah, we kind of left off, gosh, I guess 2022 with a series that led up to large language models and the idea of sort of generation of text, kind of building off NLP initially, which is a great series. If you haven't heard it, go back and check it out. It's a great way to get your feet, you know, sort of situated before you dive into what's happening with this sort of stuff. \n\nI guess maybe we can start there and that might help build our conversation again. What are these large language models and how we can kind of define them a little more? Yeah, and I think for a lot of people, these models feel like they came out of nowhere. But if",
    "_9Ih1GnY0MU": "Welcome to the Real Python Podcast. This is episode 189, \"How Does a Debugger Work? What Can You Learn About Python By Building One From Scratch?\" Christopher Trudeau is back on the show this week, bringing another batch of Pyers weekly articles and projects. Christopher shares a two-part tutorial on building a debugger in Python. Creating a simple one requires less code than you might think. We also talk about an article from Edmar Turner Trow about how to prepare for the upcoming changes to NumPy. The new version is not backward compatible and will require some inspection of your project dependencies. Edmar includes advice, techniques, and tools for updating your code. We also share several other articles and projects from the Python community, including a couple of news items, a discussion about managing advice as a new developer moving to Python as a former R developer, building a Markov chain to generate readable nonsense, optimizing fonts to individual glyphs on your website, and a project for working with units of measurement in Python. \n\nThis episode is brought to you by posit connect. Posit is dedicated to open-source data science tools, and Connect helps teams manage all their data science publishing. Learn more at POS. IT'S REAL PYTHON. Alright, let's get started. The Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython. After the podcast, join us and learn real-world Python skills with a community of experts at realpython. \n\nHey Christopher, welcome back. \n\nHey there. So we are starting with some news this week. We also have a discussion, which I'm excited to talk about. Let's go ahead and start with the news this week. \n\nSure, so we've got a couple of quick items. The first is a call for papers for DjangoCon Europe. The call's open until the end of February, so you've got some time to procrastinate. The conference this year is in Vigo, Spain, which seems like a much sunnier place than the winter misery both you and I are experiencing right now, so I'm jealous. \n\nYeah, the second chunk is Python 3.13 Alpha, and this is Alpha 3 this time. We're getting to the point where almost every single episode I'm announcing another Python coup. So they're obviously very hard at work getting that stuff going. So if you're playing with the alphas, go get the latest one. \n\nThere's a lot of code that's getting updated these days, and the one that I wanted to cover actually, I've got kind of a data science-centric episode this week. In some ways, some of the topics that I got interested in this first one is from our friend Edmar Turner Trow, who we've mentioned multiple times on the show. The title of it is \"NumPy 2 is Coming,\" and the subtitle is \"Preventing Breakage, Updating Your Code.\" It digs into multiple pieces of advice here. The first is ways that the new release might break your application, then the importance of pinning your packages, which we've talked about in the past but we'll dig into a little bit more here, and then ensuring your application doesn't install NumPy 2 until you're ready. \n\nHe kind of ends with some really great advice about upgrading your code to support NumPy 2 and has actual suggestions on tools and techniques for doing that. So the whole NumPy 2 could break your code. They're directly changing the way things are named and very specific APIs, so ways that it could affect your code is that you're addressing those APIs directly and you might need to look through your code and look at that. \n\nAnother way that it can break your code is, of course, direct dependencies. These are things like Pandas using it and so forth, libraries that use it becoming incompatible with your code. And then there's sort of that third layer of indirect dependencies, dependencies of your dependencies, sort of turtles all the way down of where NumPy could be in your stack. He gives an example of PyImage which currently is incompatible, has a packaging metadata declaration in it talking about pinning again of NumPy greater than or equal to 1.22, so that would mean it would go right ahead and install NumPy 2, then realizing that the pinning and that kind of idea of how to organize it. \n\nHe suggests adding like a little hashtag comment there for now, comma, make sure NumPy 2 is not installed, and then NumPy less than 2. That's step one, he's suggesting for ways to approach this. Step two, he talks a little bit about waiting for your dependencies to support NumPy 2, and then step three, upgrading your code in your dependency. He includes a link to NumPy's migration guide for NumPy 2, and there are a lot of changes of fundamental types inside there, C float is now a NumPy complex 128, and then there's a float, which is now the NumPy float 64, so very much specifying like 32-bit, 64-bit, 128-bit things like that inside there. \n\nSo definitely look at it if there are types that you've been using NumPy-wise, there's potential change, and then there's a lot of sort of deprecation of things that I think were, you know, NumPy's been around, so you know, it was maybe Python 2 and other things like that that could have been happening there. The nice piece at the end of it is he suggests using the popular linter of choice today, Ruff, to check your code, and we've mentioned Ruff multiple times. It's a Rust-based linter that's a faster alternative to Flake 8 and PyLint, and it also includes features like Black and iSort and stuff like that. He gives advice and shows examples of how to check your code with it. It has a dash Das preview flag that you can use for checking for incompatibilities, and he walks you through doing that and even has a feature where it can actually give you suggestions on how to rewrite it or fix it for you, which is pretty cool. So thanks again, Edmar. \n\nAlright, so what's your first one starting this week with uh something called using a Markov chain to generate readable nonsense and it's by Ben Hoit. Ben's been featured in PyCoder's before, but I think this is the first time we've actually highlighted one of his articles in the podcast. Let me break the title down a little bit first off a Markov chain. I'm going to quote from Wikipedia, which isn't going to help but we'll start a Markov chain. A Markov chain or a Markov process is a stochastic model describing a sequence of possible events in which the probability of each event depends only on the state attained in the previous event. That's a mouthful and it boils down to essentially a state diagram where deciding on what the next state is is based on a probability and the current state. So you're not allowed to use any past state information that influence the decision. \n\nThese kinds of models come up in probability theory. A fair amount what the article describes is using this kind of state machine to generate text that is readable. Readable doesn't necessarily mean sensible. It ends up being a bit of a word salad thing right but with the right set of tokens, it's a lot closer to readable than say randomly picking words out of a dictionary. This might sound like a strange exercise but it's related to things like simple text prediction on your phone. There are a couple different ways of doing that but this is one of them. \n\nThe program that he talks about takes a chunk of text, finds pairs of words known as bigrams, and then calculates the probability of all possible words that follow the pair based on some input text or training data. You can also do this with trigrams and other things but adding length doesn't actually make things better necessarily so bigrams are often good enough. \n\nAs the first example in the article that Ben uses is actually the five of The Ten Commandments from Abrahamic religions and the input here starts with things like \"Thou shalt not kill,\" \"Thou shalt not commit adultery,\" \"Thou shalt not steal,\" etc. A lot of \"Thou shalt nots\" here, so you end up with \"thou shalt\" being one of the bigrams, and of course, every word after it actually is \"not.\" So that ends up being a 100% probability. Whereas a bigram of \"shall\" and \"not\" so after \"thou,\" is followed by different kinds of words, \"kill,\" \"Thou shalt not steal,\" \"Thou shalt not commit,\" as in commit adultery, bear as in bear false witness, and a couple instances of coveting. Everybody loves to covet. \n\nThe frequency of those words is then used to calculate the probabilities in the Markov chain. So if you start with a random bigram and then get the next word, then you use that next word to select another bigram, and you keep going until you've got some stopping condition. And if your input text is small like say five of The Ten Commandments, your output is going to look an awful lot like your input. So this is, you know, it's kind of interesting when you look at the example. Almost every sentence starts with the \"thou shalt\" and then you feed things together, and it almost looks like what went in. But of course, that's not where the fun is. The fun is in starting to train it with larger datasets. \n\nFor example, Ben ran the algorithm on his own blog posts and generated the following, especially if you need to return a value but are now very flag almost five times as fast. So that's like I said, that's nonsense, but it's almost there. It's almost readable, and so you can see how this can be useful in things like text prediction. And it's very small. It doesn't require a large training set. It doesn't require a lot of processing power, and this is why it's still used in things like your phones. \n\nThe problem itself actually comes up in computing a little bit. He gets into the article as well because there are a couple of well-known books that use the algorithm as a basis to teach different things like optimization or whatever else because the algorithm itself is relatively small but large enough that you can play with it, right? So this is why you tend to see it in a few different places. If you're interested in probabilities, this is a neat little experiment or like I said, if you just want to have a little bit of Mad Libs fun, a way of winging away your afternoon, particularly if you're stuck in snowbanks like we are, you know, go generate some nonsense. \n\nYeah, essentially that would be, you'd be continuing the Markov chain, yes if you're playing that little game to see what happens with your autocomplete, that's the same kind of thing, right? It's a mad libs kind of exercise, yeah, okay. \n\nThe problem itself actually comes up in computing a little bit. He gets into the article as well because there are a couple of well-known books that use the algorithm as a basis to teach different things like optimization or whatever else because the algorithm itself is relatively small but large enough that you can play with it, right? So this is why you tend to see it in a few different places. \n\nIf you're interested in probabilities, this is a neat little experiment or like I said, if you just want to have a little bit of Mad Libs fun, a way of winging away your afternoon, particularly if you're stuck in snowbanks like we are, you know, go generate some nonsense. Yeah, the implementation is like what is it 24 lines with comments, so that's a pretty quick implementation to get you going and checking it out. \n\nAlright, so what's your next one? Starting this week with something called using a Markov chain to generate readable nonsense and it's by Ben Hoit. Ben's been featured in PyCoder's before, but I think this is the first time we've actually highlighted one of his articles in the podcast. Let me break the title down a little bit first off a Markov chain. I'm going to quote from Wikipedia, which isn't going to help but we'll start a Markov chain. A Markov chain or a Markov process is a stochastic model describing a sequence of possible events in which the probability of each event depends only on the state attained in the previous event. That's a mouthful and it boils down to essentially a state diagram where deciding on what the next state is is based on a probability and the current state. So you're not allowed to use any past state information that influence the decision. \n\nThese kinds of models come up in probability theory. A fair amount what the article describes is using this kind of state machine to generate text that is readable. Readable doesn't necessarily mean sensible. It ends up being a bit of a word salad thing right but with the right set of tokens, it's a lot closer to readable than say randomly picking words out of a dictionary. This might sound like a strange exercise but it's related to things like simple text prediction on your phone. There are a couple different ways of doing that but this is one of them. \n\nThe program that he talks about takes a chunk of text, finds pairs of words known as bigrams, and then calculates the probability of all possible words that follow the pair based on some input text or training data. You can also do this with trigrams and other things but adding length doesn't actually make things better necessarily so bigrams are often good enough. \n\nAs the first example in the article that Ben uses is actually the five of The Ten Commandments from Abrahamic religions and the input here starts with things like \"Thou shalt not kill,\" \"Thou shalt not commit adultery,\" \"Thou shalt not steal,\" etc. A lot of \"Thou shalt nots\" here, so you end up with \"thou shalt\" being one of the bigrams, and of course, every word after it actually is \"not.\" So that ends up being a 100% probability. Whereas a bigram of \"shall\" and \"not\" so after \"thou,\" is followed by different kinds of words, \"kill,\" \"Thou shalt not steal,\" \"Thou shalt not commit,\" as in commit adultery, bear as in bear false witness, and a couple instances of coveting. \n\nThe frequency of those words is then used to calculate the probabilities in the Markov chain. So if you start with a random bigram and then get the next word, then you use that next word to select another bigram, and you keep going until you've got some stopping condition. And if your input text is small like say five of The Ten Commandments, your output is going to look an awful lot like your input. So this is, you know, it's kind of interesting when you look at the example. Almost every sentence starts with the \"thou shalt\" and then you feed things together, and it almost looks like what went in. But of course, that's not where the fun is. The fun is in starting to train it with larger datasets. \n\nFor example, Ben ran the algorithm on his own blog posts and generated the following, especially if you need to return a value but are now very flag almost five times as fast. So that's like I said, that's nonsense, but it's almost there. It's almost readable, and so you can see how this can be useful in things like text prediction. And it's very small. It doesn't require a large training set. It doesn't require a lot of processing power, and this is why it's still used in things like your phones. \n\nThe problem itself actually comes up in computing a little bit. He gets into the article as well because there are a couple of well-known books that use the algorithm as a basis to teach different things like optimization or whatever else because the algorithm itself is relatively small but large enough that you can play with it, right? So this is why you tend to see it in a few different places. If you're interested in probabilities, this is a neat little experiment or like I said, if you just want to have a little bit of Mad Libs fun, a way of winging away your afternoon, particularly if you're stuck in snowbanks like we are, you know, go generate some nonsense. \n\nYeah, essentially that would be, you'd be continuing the Markov chain, yes if you're playing that little game to see what happens with your autocomplete, that's the same kind of thing, right? It's a mad libs kind of exercise, yeah, okay. \n\nThe problem itself actually comes up in computing a little bit. He gets into the article as well because there are a couple of well-known books that use the algorithm as a basis to teach different things like optimization or whatever else because the algorithm itself is relatively small but large enough that you can play with it, right? So this is why you tend to see it in a few different places. \n\nIf you're interested in probabilities, this is a neat little experiment or like I said, if you just want to have a little bit of Mad Libs fun, a way of winging away your afternoon, particularly if you're stuck in snowbanks like we are, you know, go generate some nonsense. \n\nThe implementation is like what is it 24 lines with comments, so that's a pretty quick implementation to get you going and checking it out. \n\nAlright, so what's your next one? Starting this week with something called using a Markov chain to generate readable nonsense and it's by Ben Hoit. Ben's been featured in PyCoder's before, but I think this is the first time we've actually highlighted one of his articles in the podcast. Let me break the title down a little bit first off a Markov chain. I'm going to quote from Wikipedia, which isn't going to help but we'll start a Markov chain. A Markov chain or a Markov process is a stochastic model describing a sequence of possible events in which the probability of each event depends only on the state attained in the previous event. That's a mouthful and it boils down to essentially a state diagram where deciding on what the next state is is based on a probability and the current state. So you're not allowed to use any past state information that influence the decision. \n\nThese kinds of models come up in probability theory. A fair amount what the article describes is using this kind of state machine to generate text that is readable. Readable doesn't necessarily mean sensible. It ends up being a bit of a word salad thing right but with the right set of tokens, it's a lot closer to readable than say randomly picking words out of a dictionary. This might sound like a strange exercise but it's related to things like simple text prediction on your phone. There are a couple different ways of doing that but this is one of them. \n\nThe program that he talks about takes a chunk of text, finds pairs of words known as bigrams, and then calculates the probability of all possible words that follow the pair based on some input text or training data. You can also do this with trigrams and other things but adding length doesn't actually make things better necessarily so bigrams are often good enough. \n\nAs the first example in the article that Ben uses is actually the five of The Ten Commandments from Abrahamic religions and the input here starts with things like \"Thou shalt not",
    "PrA2JoDvgGQ": "Welcome to the Real Python Podcast. This is Episode 191. How do you manage the dependencies of a large-scale data science project? How do you migrate that project from a laptop to Cloud infrastructure or utilize GPUs in multiple instances in parallel? This week on the show, Savin Goyle returns to discuss the updates to the open-source framework Metaflow. Savin briefly describes the Metaflow platform and the goal of simplifying engineering overhead for data scientists and programmers.\n\nWe discuss how the platform captures snapshots of a project as you work, allowing you to go back in time or share the state of your project with another team member. We dig into the complicated process of managing dependencies for machine learning and data science projects. Savin describes how the required external libraries can be specified within a flow with the new @pii or @cond decorators. This allows a project to scale from a local machine to the cloud or multiple instances with all dependencies included.\n\nHe talks about starting a new company, Out of Bounds, with fellow co-workers from Netflix. Their vision is to continue to build the Metaflow open-source platform and offer customers scalable Enterprise-grade infrastructure.\n\nThis episode is sponsored by Intel, providing Edge AI reference kits. Are you building AI apps with popular models like YOLO V8 or PADM? If so, check out intel.com/sledge to get open-source code snippets and helpful guides. Just go to intel.com/sledgeai.\n\nAll right, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with the community of experts at realpython.com.\n\nHey, Savin, welcome back to the show. Thanks for having me back, Christopher. Yeah, I'm excited to talk to you about lots of little changes and updates to Metaflow. I thought maybe we could start talking a little bit about what's been happening with you. You were working at Netflix when we talked last, and it sounds like you've been able to take advantage of some of this work that you're doing with Metaflow and expand a little bit here. Do you want to talk about that a little bit? Yeah, sure. I think when we last spoke about Metaflow, we had recently open-sourced the project at that particular moment. As you can imagine, throughout the early innings of the pandemic, there's considerable digitization that happened all across the board. Organizations' appetite to invest in data efforts or ML efforts increased substantially, and that naturally led to an uptick in the take rate for our project as well. We had plenty of companies that started using Metaflow in non-trivial use cases, and that presented itself as an opportunity to make it something bigger than what it was. So then me, alongside a few of my colleagues at Netflix, we decided that right now is a good time to spin out of Netflix, start a company that's focused on the development and continuation of Metaflow, and here we are. That's great. Netflix is still involved, they're still using a lot of the stuff that happens inside there. It seems to be a prized project within that organization. Yeah, definitely seems to be the case. The team that's responsible for Metaflow internally at Netflix has only grown ever since my departure here. We collaborate very closely with them. Any of the features that you see getting shipped out in open-source good work from the team back there. So yeah, happy and excellent partners for us. Oh, that's great. Awesome. Do you want to talk a little bit about what Out of Bounds does? Yeah, at Out of Bounds, our vision is to build a platform that can take care of all your data science, ML, and AI needs. In many ways, that was the charter that we had back at Netflix as well. But now you can imagine in any large company, you are basically standing on the shoulders of giants. Of course, we were responsible for building ML infrastructure for Netflix, but we were standing on top of all the good work that other platform engineering teams at Netflix were doing. Teams that were responsible for provisioning the data platform, the compute platform, teams that were managing the workflow orchestrators, teams focused on observability, and so on and so forth. And you can imagine now, if you look at other companies outside of, let's say, the Fang ecosystem as well, what's common between Netflix and all of these other companies is that predominantly all of these companies also run similarish infrastructure. Thanks to the fact that Netflix is on the public cloud. I think that was one of the big reasons why Metaflow has seen a lot of successful adoption in all of these rather scaled-out companies. But that also presented an interesting challenge because then many of these companies, many of these organizations are also trying to figure out how do we create a compute platform for machine learning? How do we think about data platform for ML? And with Out of Bounds, we are trying to solve all of those problems as well. So Out of Bounds, the product that we are building, basically provisions a compute platform, a data platform, workflow orchestrators, a full observability stack for an organization that's interested in investing in the latest and greatest ML tooling. All of that is then bundled with Metaflow as sort of the user experience layer that data scientists interact with. I could see the having talked about all of the different components involved in this process, how having the ability to get them under one shingle would be advantageous to somebody looking at it. I've been talking a lot about the compliance in some organizations. We talked about that when we talked about Python inside of Excel and how Microsoft, the compliance is already sort of done in a lot of cases for these big organizations and so forth. So I can kind of see some advantages there. That's really cool. Do you want to talk about what Out of Bounds does? Yeah, at Out of Bounds, our vision is to build a platform that can take care of all your data science, ML, and AI needs. In many ways, that was the charter that we had back at Netflix as well. But now you can imagine in any large company, you are basically standing on the shoulders of giants. Of course, we were responsible for building ML infrastructure for Netflix, but we were standing on top of all the good work that other platform engineering teams at Netflix were doing. Teams that were responsible for provisioning the data platform, the compute platform, teams that were managing the workflow orchestrators, teams focused on observability, and so on and so forth. And you can imagine now, if you look at other companies outside of, let's say, the Fang ecosystem as well, what's common between Netflix and all of these other companies is that predominantly all of these companies also run similarish infrastructure. Thanks to the fact that Netflix is on the public cloud. I think that was one of the big reasons why Metaflow has seen a lot of successful adoption in all of these rather scaled-out companies. But that also presented an interesting challenge because then many of these companies, many of these organizations are also trying to figure out how do we create a compute platform for machine learning? How do we think about data platform for ML? And with Out of Bounds, we are trying to solve all of those problems as well. So Out of Bounds, the product that we are building, basically provisions a compute platform, a data platform, workflow orchestrators, a full observability stack for an organization that's interested in investing in the latest and greatest ML tooling. All of that is then bundled with Metaflow as sort of the user experience layer that data scientists interact with. I could see the having talked about all of the different components involved in this process, how having the ability to get them under one shingle would be advantageous to somebody looking at it. I've been talking a lot about the compliance in some organizations. We talked about that when we talked about Python inside of Excel and how Microsoft, the compliance is already sort of done in a lot of cases for these big organizations and so forth. So I can kind of see some advantages there. That's really cool. Do you want to talk about what Out of Bounds does? Yeah, at Out of Bounds, our vision is to build a platform that can take care of all your data science, ML, and AI needs. In many ways, that was the charter that we had back at Netflix as well. But now you can imagine in any large company, you are basically standing on the shoulders of giants. Of course, we were responsible for building ML infrastructure for Netflix, but we were standing on top of all the good work that other platform engineering teams at Netflix were doing. Teams that were responsible for provisioning the data platform, the compute platform, teams that were managing the workflow orchestrators, teams focused on observability, and so on and so forth. And you can imagine now, if you look at other companies outside of, let's say, the Fang ecosystem as well, what's common between Netflix and all of these other companies is that predominantly all of these companies also run similarish infrastructure. Thanks to the fact that Netflix is on the public cloud. I think that was one of the big reasons why Metaflow has seen a lot of successful adoption in all of these rather scaled-out companies. But that also presented an interesting challenge because then many of these companies, many of these organizations are also trying to figure out how do we create a compute platform for machine learning? How do we think about data platform for ML? And with Out of Bounds, we are trying to solve all of those problems as well. So Out of Bounds, the product that we are building, basically provisions a compute platform, a data platform, workflow orchestrators, a full observability stack for an organization that's interested in investing in the latest and greatest ML tooling. All of that is then bundled with Metaflow as sort of the user experience layer that data scientists interact with. I could see the having talked about all of the different components involved in this process, how having the ability to get them under one shingle would be advantageous to somebody looking at it. I've been talking a lot about the compliance in some organizations. We talked about that when we talked about Python inside of Excel and how Microsoft, the compliance is already sort of done in a lot of cases for these big organizations and so forth. So I can kind of see some advantages there. That's really cool. Do you want to talk about what Out of Bounds does? Yeah, at Out of Bounds, our vision is to build a platform that can take care of all your data science, ML, and AI needs. In many ways, that was the charter that we had back at Netflix as well. But now you can imagine in any large company, you are basically standing on the shoulders of giants. Of course, we were responsible for building ML infrastructure for Netflix, but we were standing on top of all the good work that other platform engineering teams at Netflix were doing. Teams that were responsible for provisioning the data platform, the compute platform, teams that were managing the workflow orchestrators, teams focused on observability, and so on and so forth. And you can imagine now, if you look at other companies outside of, let's say, the Fang ecosystem as well, what's common between Netflix and all of these other companies is that predominantly all of these companies also run similarish infrastructure. Thanks to the fact that Netflix is on the public cloud. I think that was one of the big reasons why Metaflow has seen a lot of successful adoption in all of these rather scaled-out companies. But that also presented an interesting challenge because then many of these companies, many of these organizations are also trying to figure out how do we create a compute platform for machine learning? How do we think about data platform for ML? And with Out of Bounds, we are trying to solve all of those problems as well. So Out of Bounds, the product that we are building, basically provisions a compute platform, a data platform, workflow orchestrators, a full observability stack for an organization that's interested in investing in the latest and greatest ML tooling. All of that is then bundled with Metaflow as sort of the user experience layer that data scientists interact with. I could see the having talked about all of the different components involved in this process, how having the ability to get them under one shingle would be advantageous to somebody looking at it. I've been talking a lot about the compliance in some organizations. We talked about that when we talked about Python inside of Excel and how Microsoft, the compliance is already sort of done in a lot of cases for these big organizations and so forth. So I can kind of see some advantages there. That's really cool. Do you want to talk about what Out of Bounds does? Yeah, at Out of Bounds, our vision is to build a platform that can take care of all your data science, ML, and AI needs. In many ways, that was the charter that we had back at Netflix as well. But now you can imagine in any large company, you are basically standing on the shoulders of giants. Of course, we were responsible for building ML infrastructure for Netflix, but we were standing on top of all the good work that other platform engineering teams at Netflix were doing. Teams that were responsible for provisioning the data platform, the compute platform, teams that were managing the workflow orchestrators, teams focused on observability, and so on and so forth. And you can imagine now, if you look at other companies outside of, let's say, the Fang ecosystem as well, what's common between Netflix and all of these other companies is that",
    "VCk-HQoPsMo": "Welcome to the Real Python Podcast. This is Episode 192. What are real-life examples of using Python decorators and how can you harness their power in your code? Christopher Trudeau is back on the show this week, bringing another batch of PyCoder's Weekly articles and projects. We discuss a recent article series that digs into Python decorators. The first two articles discuss the basics of constructing decorators, and the third part describes how popular Python libraries use decorators with call interception, function registration, and enriching the behavior of a function. Christopher shares a piece about the common pitfalls of working with the Python datetime library. The article considers how current third-party libraries don't address most of these quirks and offers a potential solution with a new library. We also share several other articles and projects from the Python community, including a couple of news items, a discussion about the popularity of the Rust language, handling unset values in FastAPI with Pantic, working with Python's mini-language for formatting strings, mocking Django queryset functions, and a modern replacement for the request library. \n\nThis episode is sponsored by Sentry. Learn about the upcoming workshop \"Taming the Kraken\" about managing a Python monolith with Sentry or find out more now at sentry.io/resources to register. \n\nAlright, let's get started. The Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at Real Python. After the podcast, join us and learn real-world Python skills with the community of experts at Real Python. \n\nHey, Christopher, welcome back to the show. \n\nHey there. \n\nAlright, so we have some news to start with, a couple of topics each, and a discussion. This one actually kind of predicated by somebody sending in an email to podcast@realpython.com. We'll talk a little bit more about submitting your own questions or potential discussion topics later. Are you ready to go? \n\nYou want to start with the news? \n\nSure. I think our listeners should send us something that makes you and I argue. Could be their challenge. Find something we don't agree on. \n\nAlright, so the news. We've got a couple of releases or a couple of series of releases. There's been a security fix for Django having to do with a denial of service vulnerability in the int comma filter. So go get your 5.0.24, 2.2.10, or 3.2.4 if you want to fix that. And second, also a bugfix release is for Python 3.11 and 3.12, which brings us to 3.12.2 and 3.11.8 if you're counting. And the final piece of news is the Python Software Foundation's Grants Program has announced that they're going to start holding office hours. There was a bit of a fuss a few months back having to do with a bumpy grant process for DjangoCon Africa. And to help prevent future communication challenges, they're going to start holding office hours. The hours will be on the PSF's Discord at 2:00 PM UTC and that's on the third Tuesday of every month. Links to this announcement are in the show notes. So if you're involved with conferences or want to better understand how grants work connected to that, this would be a great place to get quick feedback. \n\nYeah, it's been actually we've been talking about the communication channels with the PSF have been sort of opening up, especially with them bringing on all these additional sort of in-residence roles and so forth. And it's good to see that happening here with the grants program. Communication is great. I like this direction. \n\nOkay, my first tutorial is by our friend Leontas Ramos and it's titled \"Python's Format Mini-Language for Tidy Strings.\" This is a very detailed tutorial about string interpolation and the formatting of those interpolated values. It's intended or directed toward intermediate Python developers, but if you're a beginner and you're interested in printing strings and formatting the outputs of F strings, I think you might find this of interest. You may not be able to dive through it all in one sitting, but it's a really great reference. Lots of areas that could be referenced later and come back to. Leontas starts out by briefly covering the three popular ways of doing strings and the interpolation of them, kind of in reverse order, I feel, like for popularity, but historically they were the ways they were originally laid out. The first was the modulo percent operator, then came the string.format method, and then the one that's in my opinion the most popular today is the F string and FST string literals. And so he talks a little bit about that and then he actually kind of does a lot of explanation through discussing how the Python docs show this stuff. And so that gets him into briefly discussing this idea of Backus-Naur form or BNF notation. And I'll include a link to the Wikipedia article about that, which gives a good example of how you can look at that syntax. It's something that's, I guess, popular in explaining rules inside of a language. They use an example of how addresses might look in the Wikipedia article and how even though you don't necessarily use all of these components in every single address, this is where these things go and in what order they should be and kind of the rules there. And that's kind of the idea here, this grammar, if you will, gives you an idea of it. So he's using that to kind of give you an idea because this formatting has a very specific grammar. In the case of string.format, you end up with opening with your curly braces and then from there you can have an optional field name. It's not a required thing, but after that you can have an exclamation point, which is called sort of a conversion field. It's used most commonly when you're doing like object-oriented types of things to be able to call out these couple Dunder methods that we've discussed before on the show, the Dunder str, str or Dunder string and Dunder repper, the R E P P E R, the string one is sort of the user-friendly readable to an end user way of showing what an object is printing out in that way, and then the repper one being a lot more developer-friendly, it usually includes the details for recreating an object. So if you're not familiar with that, he's got a link to a previous tutorial that digs into Dunder string and Dunder repper and can kind of explain some of that there. There's this exclamation point S, would be to call it as a string or exclamation R to call the repper on it. To me, those were a side note, but this is again going systematically through everything. In my opinion, more interesting part of it is when you get to the part where there would be a colon, which is for this formatting spec. From there, that's where you start to learn about the ways that the content that could be included within those curly braces can be formatted out. And so this is where he digs into the next one, which is for FST strings, which for the BNF grammar for that actually has five different things. So if you're familiar with F strings, at the beginning of this string literal, you type F and then you open your quotation marks and as you type out your string, you can put in curly braces inside the curly braces. You could put the name of an object to have it be replaced and formatted literally right inside the string, which is very nice. And so that's the first thing that can be part of that. The expression that can be put inside of it there is an optional equal sign that can come next if you want, which is something that was put in for troubleshooting. It allows you to very quickly show the value of something inside side of an F string. If you're not familiar with that, there's a link kind of explaining that concept. And then the two other things that we covered before, the exclamation point for conversion so you can do exclamation point S or exclamation point R, all these things are little optional things you can put in outside of the F expression at the beginning of it. Then you get to the part that you may have seen before, which is a colon and then your formatting spec. And so this is where you dig into the part where it's like a really good reference. So repeating the BNF grammar here, he's actually getting into like, okay, what are all the different types of things you can do when printing out these strings? So you can have a fill, you can choose what character is going to fill in the blank space when working with another optional thing, which is the width. You can choose to align left or right. So as you're printing out something, you could say, I want everything to be filling out a column that's 10 characters wide, but I want everything centered or I want it pushed to the right and left using your greater than, less than, or carrot symbols for those. You can have if it's numbers, you can have the sign on it. Again, you can choose the width of that column. You can choose grouping and then precision of decimals. You may have seen like colon 2F for indicating that you want to have two decimal places for your floating points. And then at the end of it, you can have a type which includes binary character like Unicode decimal octal. So it digs into all that stuff. So again, a really great reference piece letting you see all those things, lots of examples showing off the techniques being printed. And then he talks a little bit about some other things that sort of fit in here, thousand separators. You may have seen using a comma or an underscore. There's an interesting way to plan in advance that he covers, which is formatting the fields dynamically and then a couple more practical examples like how this might look if you're wanting to print out receipts. Again, using something like the fill and the width and the alignment, working with dates and their different sort of symbols that are in there. So it's a great guide for this literal string formatting thing. If you've worked with F strings before and maybe seen that colon in there or that exclamation point in there and kind of wonder what's going on with that, well, that's all part of this grammar for working with these string formatting.\n\nSo that's the first one here. My first article is by Ari Bovenberg and it's called \"10 Python DateTime Pitfalls and What Libraries Are Not Doing About It.\" The \"not\" in the title is in brackets, so it's implying the libraries are and aren't dealing with the pitfalls. Ari starts out by explaining what he considers a pitfall. These are behavior issues, not bugs. Behaviors that are surprising or confusing and mostly caused by the fact that we're dealing with designs from 20 years ago when computing didn't worry so much about the wider world. For each pitfall in the Python built-in module, Ari also covers whether the same pitfall exists in some of the more popular third-party datetime libraries like Helicockter, Arrow, DateType, and Pendulum. The first pitfall discussed is the fact that datetime has two incompatible concepts squeezed into the same class. A datetime instance can either be naive or timezone aware, and this results in the problem that you can accidentally mix the two, ending up with bugs. And as it's just one class, you can't use type checking to figure out whether or not this solves the problem. Because it's either of the datetime type or it's not. You can't tell whether it's datetime and naive or datetime and aware. Helicockter and DateType both use separate classes for naive and aware situations, but Pendulum and Arrow don't. So this is a mix all the way down. Pitfall number two is the fact that the plus and minus operators on a datetime object don't take into account daylight savings time. This one surprised me. I wasn't aware of this one. So if your addition or subtraction is over a daylight savings boundary, you're going to get the wrong answer. So, midnight the night before daylight savings time plus four hours will give you the wrong time because you lose your hour at the daylight boundary. Pitfall number three is the fact that the plus and minus operators on a datetime object don't take into account daylight savings time. This one surprised me. I wasn't aware of this one. So if your addition or subtraction is over a daylight savings boundary, you're going to get the wrong answer. So, midnight the night before daylight savings time plus four hours will give you the wrong time because you lose your hour at the daylight boundary. So, what the article goes on, it's got seven more pitfalls on top of that. I'm just going to put this out there. We missed an opportunity in the Python community. We could have fixed this when we did the big breaking changes from 2 to 3. DateTime could have been made backwards incompatible for the same reasons that strings were. You get rid of ASCII, you can get rid of single time zones, and you have a little more perspective on the rest of the world. But alas, it wasn't done, and so we're still dealing with this historical mess. Maybe changing this library would have caused a fuss with the 2 to 3 switch, but I'm sure it went so smoothly otherwise that no one would have noticed. This article is a good reminder about how messy dates and times are, and finishes up with a nice summary table showing you the 10 pitfalls and for each how the four third-party libraries deal with them. The article reminds me of another one called \"Falsehood Programmers Believe About Time\", which really should be seminal reading for all coders everywhere. And we'll link to that in the show notes. \n\nThe next one we have is from our friend ByteCode, spelled BTC. This is a three-part series about decorators. He kind of cleverly calls it \"Ex Machina: Decorations Part 1\" in the first part, and with a little subtitle \"Binary Trees or Trees 2\", and that one came out on December 24th. What's kind of funny is it's stretched out now all the way into late January, so it's not quite so much the Christmas season anymore, but he still kind of kept the theme at least. Decorators. I've said I don't know how many times now that this was an area of Python that I feel a lot of beginners and definitely myself, I would see the at symbol that would indicate that something is a decorated function and scratch my head, what is going on here, what's happening with this, and I feel like a lot of people go through that moment, and his first line of the article is \"Every Python dev will go through the moment where they need to learn about those darn decorators\", and I'm like, yeah, it's a very common thing, and hopefully through me describing it here and you kind of digging through the articles, if you're interested, you can learn a bit more about what's happening with them. And I like that he's divided it up. The first part is an introduction to it and gives you an idea of like, well, what's the key idea of a decorator? One of the things that I need to get a bell maybe on the side of my desk here that allows me to just ring it every time we say \"everything in Python is an object\". Ding, a function is an object, and what's interesting about that is a function can be passed as a parameter inside of another function. Wrong button, I was trying for there. There's our new sound effect, the angelic everything in Python is an object. The other thing about functions is that you can define them dynamically, and another interesting thing is that you can return a function from a function. So, lots of interesting kind of ideas that are a little advanced if you're not familiar with that, and so this first one gets you up to speed, shows some examples. GNA, who I've talked about multiple times on the show and was our first guest on the podcast, we talked about decorators in our first episode, and I made a video course based upon his really great, very detailed primer on Python decorators, so I'll include a link to that also in case you'd like an additional resource there. He loves those every time we do the Python updates, he's always like, \"I'm taking the decorator stuff, I'm taking the decorator stuff. I have to. I wouldn't even try to win that fight. It's always him. He's a big fan.\" Yeah, through the piece you get the idea of, okay, a function can be wrapped around by another function. It can have code that runs sort of before the original function, then runs the original function, then has code that runs after it, and gives you this idea of how that kind of works. The idea that a function, again, can take a function into it as a parameter, and the first part ends with adding the syntactic sugar of the at symbol there. You might have been left with a bunch of questions, so part two digs into what if? The first one is, well, what if you got parameters and you want a return value, and how do you pass parameters into that decorator, and what happens to the repr and the help? If why do they stop working with the decorated function? So this second one really digs into that stuff, lots of examples in code showing you how to send not only parameters, but keyword arguments inside of it, shows you how to do that with the star and the double star. A lot of these ideas may seem really interesting, but you might have this last question that's what part three is about, what do you actually do with this stuff, what's the point of it, and how are they useful, or where have they been used? Again, this one came out January 21st, part three, titled \"Ex Machina: Decorations Part Three\". The title is aging so well. He",
    "QTkwgsMFq9E": "Welcome to the Real Python Podcast. This is Episode 193. How do you avoid the bottlenecks of data processing systems? Is it possible to build tools that decouple storage and computation? This week on the show, creator of the Pandas Library, Wes McKinney, is here to discuss Apache Arrow, composable Data Systems, and Community collaboration. Wes briefly describes the humble beginnings of the Pandas project in 2008 and moving the project to open source in 2011. Since then, he's been thinking about improvements across the data processing ecosystem. Wes collaborated with members of the broader data science community to build the in-memory analytics infrastructure of Apache Arrow. Arrow avoids the bottlenecks of repeated data serialization and format conversion. He shares examples of Arrow's use across the spectrum in tools like Polars and DuckDB. Wes advocates moving from vertically integrated tools toward composable Data Systems. We discuss work on Ibis, a portable data frame API for data manipulation and exploration in Python. Ibis supports multiple backends by decoupling the API from the execution engine. This episode is brought to you by Posit Connect. Posit is dedicated to open-source data science tools, and Connect helps teams manage all their data science publishing. Learn more at posit.it/realpython.\n\nAlright, let's get started. The Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com. Hey Wes, welcome to the show. Thanks for having me. Yeah, I'm very excited to talk to you. There's just a variety of things I'd like to talk about. One of the major ones is going back to this theme that I see in a lot of the talks that you do about how when you created Pandas back in 2008, that you were kind of dealing with the state of the industry at the time, the state of the hardware that people had at the time, and what data maybe looked like at the time. Maybe we could talk about what were some of the limitations you were facing back then when you originally started the project and why it's led to you having to really think about what we're doing today and where things need to go. Sure, yeah. Happy to talk all about that. I mean, it's been almost 16 years now, and so obviously a lot has changed not only in the world of computer programming and data science. There was barely what we called statistics and statistical computing and just data analysis back then. But I think at that time, I was really concerned with just making Python a language where you could succeed at doing really basic data work. So a lot of the themes of the recent decade have been around how do we make it interoperable, scalable, performance, and if you go back 16 years ago, those things like performance and scalability and interoperability and all those things, those were kind of pipe dreams at that point in time, just things that we might have dreamt about but getting to the point where we could read CSV files and do basic stuff that you might do in Excel or that you could do in R in Python with a reasonable API, yeah, like that was already a lot of work. And so it's just taken a long time to get to the point where we can start thinking about some of these higher order concerns. But it's been a very interesting process to not only build the software but then build the open-source communities around the software and basically scale the community around these projects. It's been an incremental thing, but already, you know, the passion of my career, so I've really enjoyed the work, and it's given me a lot of satisfaction to have the opportunity to be involved in these projects and to do things that have an impact in the open-source world.\n\nYou led the project till 2013 and then turned it over to the open-source community. What was some of your thinking behind that or maybe what factored into your decision there? Yeah, I've definitely spoken about my history with the Pandas project and how I was working for a Quant hedge fund and I convinced them, AQR, to let me open source it at the end of 2009. Then I started giving talks in the Python community and I dropped out of grad school to work on Pandas in 2011. I wrote my book Python for Data Analysis, and then in late 2012, I teamed up with my colleague from AQR, Chang, to found Data",
    "YL-m7K8WkNY": "Welcome to the Real Python Podcast. This is episode 194. What are the typical computer tasks you do manually every week? Could you automate those tasks with a Python script? Christopher Trudeau is back on the show this week, bringing another batch of PyCoder's weekly articles and projects. We discuss a recent Hacker News thread about frequently used automation scripts. We share the kinds of tasks we've automated with Python in our work and personal lives. Christopher shares a tutorial about building a micro search engine from scratch using Python. The post takes you through coding the components of a crawler, index, and ranker. The finished engine is designed to search the posts of the blogs you follow. We also share several other articles and projects from the Python community, including a news roundup, how a polar's query works under the hood, using Python for data analysis, understanding open-source licensing, summarizing the significant changes between Python versions, a robust 2E hex editor, and a lightweight data frame library with a universal interface for data wrangling. This episode is brought to you by Intel. Get open-source snippets and sample AI apps to build and deploy faster. Visit intel.com/edge. All right, let's get started. The Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython. After the podcast, join us and learn real-world Python skills with the community of experts at realpython.com. Hey, Christopher, welcome back to the show. Hey there. All right, so we have a couple of news items. Following our Rust discussion, it just keeps going. So maybe we'll start there. Yes, with some news. It's a conspiracy. We're all going to be Rust programmers. Just give it time. If you've been following any of the Python news, there was an announcement of a tool called UV. This is a replacement for pip and pip tools brought to you by the creators of the Ruff linter. Like with Ruff, and as you might guess by his comment there, it's written in Rust and by all accounts is quite speedy. At about the same time, it was also announced that the folks who are bringing you UV, a group called Astral, are also taking stewardship of the Rye tool. So we'll provide you some links to the blog posts both for the announcement and the stewardship stuff, as well as a link to the news thread where people argue about UV and whether they like it or hate it and all the rest of that kind of fun stuff. The packaging space in Python keeps being flexed. We're all going to be Rust programmers. Just give it time. Yeah. Yeah, and now we're gonna get angry notes about the fact that that quote's wrong. The second bit of news is something that seems to be coming a regular feature of the show. So much so that I've automated the announcement. Ion 313 Alpha 4 is now ready for your consumption and you can drop in a different sound like that two weeks from now when it becomes Alpha 5. Yeah, we're moving right along. So betas should be shortly after that. Topics wise, I have a lot of data science stuff. I'm kind of following my conversation with Wes McKin and ended up looking at a lot of different tools over the last week. The first one I have is kind of a little bit of a survey of a couple posts from the Polars blog. We've talked about Polars multiple times on here. Polars is a replacement for pandas in some cases and a lot of people enjoy it. It is, again, maybe we have a special sound effect for this, written in Rust, has a lot of the same kind of tooling as far as a data frame library. In this particular blog post, the creators of Polars talk about, they titled it, \"A Bird's Eye View of Polars\" and this one's by Gel Peters. It really digs deep into how it works. It shows the steps from how queries are done, how it optimizes them, and then the final execution. It has an initial introduction to the whole thing. A good library abstracts away many complexities from its users. Polars is no different in this regard as it maintains a philosophy that queries you write should be performant by default without knowing any of the internals, which is great. This idea that it's doing all this optimizing underneath the hood for you to make this happen. So this is letting you peek under the hood a little bit and see what's happening. They give a little bit of a flowchart. You write a query, it's parsed into what's called a logical plan, that's optimized into an optimized logical plan, which is transformed into the physical plan, and then it's executed. And then they kind of go through that in the article and describe what's happening. They provide an example query, which is really nice. This one uses multiple data sources that need to be joined together. Then they go through the process. Very common in data analysis of like, okay, I want to group that, aggregate it, and in this case, they're using a total amount divided by the difference. It's a taxi data set. So there's a difference in the pickup and drop-off times, and then they do an averaging. And so it's kind of like looking at the average rate that is charged for taxis and so forth. And then they do a sorting of it. All of this is a lazy frame. It returns instantly, even though this data set is over 3 million rows. And so they kind of talk about, well, how does that happen? And this sort of lazy evaluation, this idea of how things are changed from a query itself and parsed into this plan and executed. And then they dig into the code, and if you've never looked at Rust code, this gives you an opportunity to look a little bit at what Rust code looks like. It gives a nice overview of in this particular type of application, data structures, structs, enums. There is some private kind of stuff happening, declarations there, which is interesting. And then it shows these steps of the query again, written in Python as that example, the whole thing written out, optimizing into the logical plan, and then the query execution. And two of the important optimizations, the projection pushdown and predicate pushdown. And if you wonder what those are, I'm not going to dig it to them. They're pretty detailed in this post. I think it's a great overview for anybody who's interested in that stuff. It's nice to see a library and now a company showing their work, if you will, and being open to what are the complexities there, and I think that's really neat. And then the second post is related to that. It came about the same time on their blog. This one is from the original author of Polars, Richie Vin. It is titled, \"Why We Have Rewritten the String Data Type,\" and it shares how Polars, they've gone through and rewritten this whole string data type. Strings are kind of a messy data type. They're one of the reasons that Pandas has had performance issues in some ways with the NumPy data type of trying to figure out, like, what do we do with that? And it has always kind of been a Python object until recent days. They talk about their relationship with Aero, and they've been a consumer of the Aero to Native Rust implementation, and they had forked it and made this thing called Polars Aero, and trimmed down the implementation to what they felt was tuned for Polars' needs. They had more control that way and looked to refactor, and at the same time, it seemed like the Aero spec was also moving in a similar direction, and they both kind of now are a little more similar, which is great. So they could keep using a lot of the Aero spec there. It talks about what is called a German-style string type. You can learn a little bit more about what that is by reading into this. Other things that are covered, they get into the good and the bad of what's involved in encoding strings. They cover hyper-slash Umbra-style string storage. They dig into details on changes and some of the benchmarks, which is nice. They can kind of show you what these changes have done across not only the two versions that they're showing, but also small, medium, and large strings. So again, if you're interested in data types, optimizing of these kind of systems and platforms, these changes are not so much user-facing. The only thing you got to worry about is just updating to the latest version of Polars to get the benefits of them. But I'm a fan of this stuff. I think it's really cool to see this. I like that they write these up in posts, and I hope they continue it in the future. All right, so what's your first one, Chris? I'm starting with an article by Alex Mullis, and it's titled, \"A Search Engine in 80 Lines of Python.\" Alex had recently started a new job and had to learn Solr, which is an open source search engine based on Lucene. To better understand the ins and outs of search, he decided to write his own engine, and this article is about the design and structure of that engine that he built. His first goal with it was to help him find sites that are smaller and don't tend to surface on Google, addressing what's sometimes called the small discoverability crisis. And the code going with the article is available on GitHub, so you can follow along with the whole thing along with the blog post, if you like. Before digging in, he does admit that the 80 lines in the title is an oversimplification. He did write some companion libraries that he's calling into, but the way he puts it, the interesting part is the 80 lines. The first step in making a search engine is creating a crawler. A crawler's job is to wander around and collect data. For Google, the crawler is crawling the web. For other tools, it might be crawling internal sites at a company or different sources of data. Alex's crawler uses a list of RSS feeds from smaller sites that he has frequented, a little over 600 of them, if I remember correctly. Once you've got the data, you've got to do something with it. The next part is an inverted index. This is a data structure that maps keywords to documents. So if you think about what you're searching on, it needs to figure out which documents have those words in it. Alex's engine uses a Python nested default dict to store keywords mapping to the URLs of the corresponding doc, as well as a count on how many times those words show up in the doc. When the crawler finds a doc, it parses all the words in it and constructs the corresponding index structure, which he's then wrapped in a class because, you know, objects with the index ready, now you want to figure out how to sort the matching responses for a given query, and this is the ranker's job. Alex goes into detail here with some math that gives me flashbacks to engineering school that I'd really rather not relive, and then shows you how to create a score for a document, and that score then results in the rank, and that's how you end up deciding which articles to show in what order in your results. With all those core parts in place, the final step is then to create an interface. Alex chose FastAPI to build a front end for his query system, and then he finishes off the post talking about features that aren't there but could be added, and summarizes what he's learned. So all in all, if you're interested in how that tool you probably use every day of your life works, search engines, then this is a good intro with Python as the basis for the examples. Yeah, I explored this topic briefly when I was starting to learn Python, and one of the resources that I looked at was Udacity. Couldn't think of the name the other day when I was talking to you, and they had, you know, kind of a basics of Python course, and that was what they had you kind of build as you work through the fundamentals of Python, which is kind of interesting. This looks way more organized and curated in a way and definitely way more structured. It's a little bit more of an intermediate project, but I think it's cool that he's giving you a jumping off point for customizing and also for some of your needs. But yeah, it's a neat project. And the fact that it's only 80 lines is something that's comprehensible. So it gives you an idea how it works, and it's some interesting code to read if nothing else. All right, so what's your next one, Chris? I'm starting with an article called \"Understanding Open Source Licensing.\" It does a deep dive on the different kinds of open source licenses, why as a developer you might care, why the company you might work for might care, why those two things might be different. The article talks about the two common categories of open source licenses, permissive and copyleft. Permissive are things like the MIT license that more or less say you can do whatever you like, typically with some limitations on liability. That tends to be MIT and BSD are the ones that are the most popular in the Python ecosystem. And then the copyleft group, by contrast, are things like the GPL family of licenses. They have conditions on using or modifying the software, such as making the software and your changes available to others. There's a deep dive on each of the popular types and their consequences. And if you're new to this topic, the article gives you a good overview, rather than just sort of clicking in GitHub and picking one randomly. Maybe you can understand what your choice is a little bit. You might be surprised at how often you might run into this in your career. A few years back, I was at a medium-sized organization that got bought by a very large organization, I won't say who. But the first version of their mascot recently became public domain. That large organization didn't want any GPL in the org at all. So we ended up having to do a massive audit on all our code and replacing a whole bunch of libraries because as a big lawyer-driven organization, they were worried about the consequences of the GPL. So as a developer who works in these spaces and you're using libraries all the time, you don't have to understand all the ins and outs, but getting the basics can be helpful. If you really want to dig into this topic and the article is not enough, I can also recommend there's an O'Reilly book, it's a few years old, but I still think it's still kicking around. It's by Lawrence Rosen and it's called Open Source Licensing. We'll include a link directly to it in the show notes. All right, and onto the second one, again, another resource kind of link. This is called Summary of Major Changes Between Python Versions. It's by Nicholas Hares. And as you might guess by the title, it covers the big things that happen in each Python version. So if you're trying to remember whether you can use the walrus operator, depending on what version your client's using, this is the page for you. As someone who writes Python educational content occasionally, I find myself going, \"Oh, I need to make a feature. What can I do that I need to make a note?\" As an example, I just finished building out a course on exceptions. I talked about the ad note feature, and I needed to be able to tell the people taking the course that, \"Hey, you need Python 3.11 to use this or newer.\" So this kind of article is really helpful if you're having to dig into that. I've also used a similar article by Ned Belder that covers more or less the same topic. But if the info you're looking for isn't in one of them, it's probably in the other. So we'll link to both of them in the show notes. Yeah, and in the spirit of the show that inspired the name of your favorite programming language, I think we should rename our discussion segment to the argument room. How do you feel about that? I guess we're gonna have an actual argument. We tend to agree with each other a lot, but I can pretend. Okay, all right, yeah, I guess I can be combative if that's what we're doing here. All right, yeah, so that's leading into our discussion or argument. This one, I guess there's actually a little bit more of a showcase or at least a talk about our history with it. We found a thread on Hacker News that talked about actually asked the question, \"What Python automation scripts do you reuse frequently at work?\" For me, I wanted to talk about this partly because that was the title of the first Python job I had. Was automation engineer, and so I was writing scripts for a marketing department at a bank, and these were big, long, multi-step processes, not like the data analysis article that I talked about earlier, where I was grabbing data sets, connecting other data sets to it, adding fields, cleaning, cleaning, and more cleaning, and then narrowing the scope of that, and then finally sending this out to various destinations, depending on who was requesting this data set and so forth. There were weekly jobs and monthly jobs. Yeah, it was really data analysis kind of stuff, and these were typically done in a Jupiter notebook kind of situation. That's what other coworkers were using. And slowly but surely, I thought about, well, maybe I want to switch these to being something I would run in the terminal. So I started to experiment there, but it was one of these things that it was a lot of text and a lot of messy data. And so by me running it through Jupiter and doing it as a multi-step kind of thing, it ended up allowing me to see what was happening. And sometimes, you know, depending on the changes to the job, it was something that I would very often run manually. And then, after that was working well, I could then go ahead and set it to automate it. On a personal thing, there's a lot of stuff that I do for Real Python. I do a lot of the video courses here. And so I've had the need to know, like, generally, if I look at an entire folder filled with video files, could it just give me the total, like, how many minutes is that or hours and minutes? That was actually a handy script that I created, which you should have told me you had, because I would wrote the same thing myself. The same thing, all right, we can compare. I have, you know, other things that rename files and push things into different folders. I'm trying to work toward automating a few other things that I do often, which is, like, backing up stuff and pushing stuff to different repos and so forth. We do a lot of stuff through Google, and so I'm trying to find some things there. But I'm interested in this topic, like, in finding other tools. I'm interested in making things a little more CLI friendly and maybe get advice on, you know, what do you think is a great tool for here? So you had a couple notes here you wanted to mention. Maybe what was your first Python program? Yeah, the, you know, Python's one of languages where, like, you've got people who are writing the little 10 line script because it's the solution. It often",
    "ZEWDGuKOkI8": "Welcome to the Real Python Podcast. This is episode 195. How do you get yourself unstuck when facing a programming problem? How do you develop a positive developer mindset while learning Python? This week on the show, Bob Belderbos from PyBites is here to talk about learning Python and building healthy developer habits. Bob created The PyBites Learning platform with his friend Julian Sequeira. They initially focused on exercises and coding challenges to motivate new Python students. As they grew their community, they created a podcast and moved into coaching. They noticed that most new developers share common struggles of tutorial paralysis, imposter syndrome, and motivation. Bob discusses techniques for developing a positive mindset, overcoming coding blocks, and delivering projects. \n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at Real Python. After the podcast, join us and learn real-world Python skills with a community of experts at Real Python.\n\nHey Bob, welcome to the show.\n\nThanks for having me, Christopher. Glad to be here.\n\nI'm excited to talk to you. We have been having this interesting back and forth since before the beginning of the year, and I'm intrigued to learn about PyBites. I'm intrigued to learn about how your podcast is going, and we're really here to focus on learning and learning Python and tips and tricks for helping people get into what you guys like to call a mindset for learning. I'm fascinated to learn about that. \n\nLet's start with telling me about PyBites and how you guys started that with you and Julian, right?\n\nYes, it's me and Julian, and now we also have a team. But back in the day, that was not the case. This was literally me, myself, and I. We're best friends as well, and we were early on the Tim Ferris 4-hour workweek. We were always geeking out on doing something on the side, starting a business. We're also into tech and programming because Julian was working in the data center, and he's a hardware guy originally. I was already doing software development, and over the Christmas of 2016, we decided, let's start, let's do something more serious with Python because he was getting into it, okay, fairly newbie, and I was already coding in it and I just wanted to get much better. We started a tech log, like one in a gazillion, right? But we just wanted to have an outlet to start teaching, start documenting, not even teaching, but really documenting our learning, which is kind of a cool way of learning, which I'm sure we'll talk about. \n\nThat actually led to a lot of things. Right from the start, we started to write articles, and pretty soon we came up with the concept of code challenges because we kind of found that all the materials were quite passive, right? And how we really learned was by building projects and scripts. So we would go on the blog and on Monday we would have a code challenge, and by Friday we would have the solution. Then we would try to involve people and have them share their solutions and really learn that way. \n\nThat kind of became our niche of being practical, of always doing this by building and challenging. From there on, we did the 100 days of code, and we got in touch with Michael Kennedy, which of course you know. Oh yeah, have him on the show. I got on his show after a year or so. Then we built out a couple of hundred days courses with him as well. We built our coding platform, which now hosts like 400 exercises. Starting in 2020, we went into one-to-one coaching because we wanted to help people in a more effective way, and that turned out to be coaching. \n\nI have a question on the coding challenge. I think that's a powerful way to build a community, sort of to almost bootstrap it because people are eager to share their solutions. It's a positive environment as far as the commentary, I guess you've got to foster that a little bit. But I wonder about that. Do you feel that's what kind of happened with you guys, that it helped really foster and bootstrap this community around what you were doing?\n\nI think the whole code challenge and involving people and comparing solutions, that was really, as you said, bootstrapping the community, which we then, I think after six months, we launched our Slack, and we got up to 3,000 people over the years. But recently, we ditched the Slack in favor of Circle because Circle is more like a forum, and it has retention, and Slack kind of felt more like a work tool. Circle is that something you host yourself, or is that a service again?\n\nThat's funny. People think that because one of the nice features is that Circle makes it look like your own instance, like you have your logo, and it feels very PyBites-style. But no, it's a solution out there, and you just pay for it. \n\nYeah, it's nice. That whole code challenge concept really, and also the 100 days of code, because that's also often done in a community sense that people do that together, they hold each other accountable, share solutions. So I think that was instrumental. \n\nThat's awesome. When did you start your podcast, and why did you start it?\n\nGreat question. I think it was two or three years ago. I think if we go by one episode a week, it's three years because we just passed 150. Yeah, so three years and two months, I guess. It was at the end of some year, so that must have been at the end of 2020 then. \n\nYeah, what was the reasoning for starting that?\n\nThat was funny. We almost put it on hold again, and I think it was Jason Batty in our community who really had a pike on challenges. I think he just made a random comment like, \"Why don't you guys have a podcast? Like it's the obvious thing to have or do, right?\" Yeah, and we like teaching, and we had already done a couple of courses at that point, so we were kind of used to getting on video and explaining things. But it's kind of fun. Now it seems so obvious, but back then, somebody had to push us, and now we're doing it. \n\nThat's funny. I'm the reverse. I'm the one who walked up to Dan and said, \"Why don't we have a podcast?\" while I was working at Real Python, and it was more like, \"Do you want to do it?\" I was like, \"Sure.\" Yeah, you guys also had a relatively late start in the game.\n\nYeah, only four years now. It'll be four years shortly. Yeah, we're in episode 195 or something like that. \n\nEpisode 194, 195. Yeah, so it's great work. I enjoy doing it. It's fun to meet people and talk to people and learn new things. I won't say that it hasn't had its challenges, and definitely across the pandemic has been one of the larger challenges of finding people that are ready and wanting to share, and so forth. So we kind of split it up, we do these separate episodes that are more newsy and more about articles and about teaching. David Amos was my other host early, and then now Christopher Trudeau, who I've got a good rapport with, which has been fun. \n\nNice. Yeah, the reason I mentioned the podcast, partly, was because a common topic that I see almost sort of tagged on the end of the titles of a lot of them is mindset. Oh yeah, and I'm intrigued by that. Like, number one, what is your feeling as to what is a coding mindset, and then how does that relate to those particular PyBites episodes?\n\nWe actually learned that through the coaching, right? That people often come to us for the Python and stay for the mindset and community. Then when we started working with people, we just got a bigger insight into what drives people and where they get stuck. We learned that some of the biggest pains are tutorial paralysis, imposter syndrome, perfectionism, shiny new object syndrome, lack of persistence, right? And then we did the math, and it's like, \"Oh, these are all mindset things.\" Usually, people do figure out the tech sooner or later, but it's more like that consistency, pushing through, putting your work out there, and maybe being able to be vulnerable or even subject yourself to a code review or apply for that job. \n\nYeah, there's a lot of psychology involved in that, and a lot of fear, and that's what became one of the main things we help people with. I mean, we do have a lot of PyBites content. We're definitely technical, but it's often the mindset that completes the whole path that people need to succeed.\n\nI think about someone signing up or literally being put into a school in whatever context that is, and the requirements of this is on the calendar. I'm required to be here for whatever reason or I'm paying to be here, and it's a very different thing as a person who maybe is coming from a different language or is trying to pick up Python or a language from scratch in their spare time, and the requirement for something like a mindset, there's so many additional obstacles that kind of get in the way. Is that something you feel that maps to what you're talking about?\n\nI also think that programming inherently is just complex, right? At a certain point, you can confidently write code and know the tools, but it takes a long time to get there. It's when I started to code back in 2005, 2006, and sometimes I forget this, right? I felt pretty dumb, and I would make a lot of mistakes, and I couldn't follow the tutorials, and I ran into all kinds of side issues that were not related to the tutorial. It took a lot of persistence to get over that phase and to get to a certain level that you are confident and can manage. \n\nBut I'm not sure if that was the key to your question, sorry. \n\nNo, it's close. I wonder if you had the experience of learning Python outside of a school or university-type of context and if that's partly what helped you start to think about this mindset stuff also. Like, not having an initial tech background and getting into Python, right?\n\nYeah, totally. I studied business economics back in Holland or finance. It did have to do with numbers and calculations, but I was using Excel for years. So, I guess that's a form of programming. My first foray was into VBA scripting. So, it was some, you know, but it's not like your CS degree and algorithms, that kind of stuff I didn't get from the uni or where I studied. So, I did have to learn it myself and with mentors and with resources, luckily. When I moved to Spain in '04, I had to find a job obviously to stay, right, to pass the proof of concept phase, and I landed a support job for Unix servers. That initial exposure to the command line and Unix definitely boosted my coding skills and just how you think about machines and systems. So, that did help, but yeah, it was definitely a transition. \n\nWas that an introduction to Python then there in like ways to make that job easier that came later? So, it was shell scripting and then I saw an itch in web development to build tools on the job and I got into MySQL and PHP and just web design and stuff. Then Perl and that got a mess and then okay, shopped around, found Python and life was beautiful even after.\n\nDid you have experience in teaching before all this?\n\nGood question. I not really. I did enjoy in every job sharing knowledge and teaching in a sense, but never really crossed my mind that I would be doing this almost full-time, right? Yeah, yeah. I don't know if you feel comfortable speaking for Julian, but does he have a teaching background too? I don't think he has, but I think he's a great communicator, so that really helps him, right? When he was working in the data center and swapping server components and stuff, and that's how we connected at some point back in Sun Microsystems. But yeah, teaching is a lot of communication, right? So, it comes in so many forms, and obviously you find across these different things that you've done and you're right, it's like this huge, I don't know, it's like an elevated form of communication in a way, right? You need to find someone who's willing to learn and share what you're finding, but I've been passionate about it my whole life. I just love sharing the things that I've learned, how to do and making sure people understand things. \n\nThat's beautiful, right? When you see that light bulb moment, like, \"Ah, now I get it,\" right? You can make it more accessible, right?\n\nYeah, I got into it probably through consulting. I was working at a music store, and people would come in and I love gadgets and love technology and would learn how to use these very advanced synthesizers and sequencers and other tools from their front panel. Every model was like learning this math tricks, you know, and I liked sharing that. So that was really fun. The thing that was the light bulb moment for that was these musicians had bought very expensive equipment and they weren't able to make music, and they needed that help to get over just that little point. So that was like that light bulb moment where they're like, \"Ah, yes, finally, I can make music.\" You unlock them, right? \n\nYeah, exactly. So when you have a mindset tag on your podcast episode, what does that mean?\n\nIt means that we talk a lot of mindset. No, so going back to what people really struggle with, we found that the mindset. We also found, okay, so we do YouTube videos, well, that came a bit later, but that",
    "cgaezNwrKUs": "Welcome to the Real Python Podcast. This is episode 196. What are the advantages of determining the type of an object by how it behaves? What coding circumstances are not a good fit for duck typing? Christopher Trudeau is back on the show this week, bringing another batch of Python Coders Weekly articles and projects. Christopher covers a recent Real Python tutorial by Leanas Boor Ramos titled \"Duck Typing in Python: Writing Flexible and Decoupled Code\". The tutorial explains the concepts of duck typing within object-oriented programming and its use within Python's built-in tools. We discussed a recent article on monkey patching in Python. This practice of dynamically modifying a class or module's behavior at runtime allows for testing, debugging, and experimentation. We also share several other articles and projects from the Python community, including a news roundup. My names are not the same as objects in Python. Using IPython Jupiter magic commands. A discussion about becoming a senior developer. A data exploration challenge. A Python evaluation game. And a terminal UI for regex testing. This episode is sponsored by Sentry. Fix application issues before they become downtime with Sentry error and performance monitoring for Python. All right, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at Real Python. After the podcast, join us and learn real-world Python skills with the community of experts at Real Python. Hey Christopher, welcome back.\n\nHey there. All right, well, I wanted to mention that we got some feedback from a recent episode and I know we were kind of reaching out and saying, please let us know what you think of the show. Leave ratings and reviews on your podcast platform of choice. We also have a voicemail link where you can leave us story ideas, topic ideas, or guest ideas, and that's available at realpython.com/podcast. And we got some recent listener feedback, and I'll play the recording.\n\nHey, man, this is really cool, this voicemail thing you have here. I really appreciate your podcast. I've been listening for quite a while, but this last episode, \"Practical Python Decorator Uses and Avoiding Datetime Pitfalls,\" from beginning to end, is hands down the best for me episode, maybe of any podcast I've heard, and I've been a fan of podcasts since we were putting them on CDs. So well done, and just absolutely perfect timing in my project. So thanks a lot. Keep up the good work.\n\nThat was kind of fun. I think it's cool that people can leave the feedback on the tool, and we can put this recording in if you're interested in leaving feedback that way. You're welcome to. We also take it in email form at podcast@realpython.com. Find us on the socials that we mentioned before. Yeah, thanks, Todd, for your kind words. We're both very curious as to what kind of date function you're decorating. How that worked out perfectly.\n\nYeah, yeah, some kind of decoration of dates of some sorts. You know, it wasn't, you know, just after the holidays, right? So we could have been, yes. There, there you go. Insert your own Christmas pun here. Yes. Yeah. Well, this week we have our usual set of topics and discussions and projects, but we also have a few pieces of news to get started. Yeah, sure. First bit is the DjangoCon US call for papers is out. This year's DjangoCon in the States is in Durham, North Carolina from September 22nd to September 27th. The accepted presenters get free entry to the conference and up to $500 travel cost reimbursement. Nice. They're looking for 25-minute, 45-minute sessions, as well as three-hour tutorials and there's a couple of other things like lightning talks. And I think they've got a small number of slots for virtual and a few other things if you're interested. Details will be linked in the show notes. All right, the second bit of news is actually news news as in something that went out across news wires. The White House has issued a report from the Cybersecurity and Infrastructure Security Agency Department of Redundancy Department making recommendations about programming languages. Large software producers such as Google and Microsoft are currently estimated that 70% of all software vulnerabilities are due to memory safety issues, which can of course be avoided by using a memory-safe programming language. The report then proceeds to list recommended languages, and as you're hearing it here, you've probably already guessed that Python made the list. The link that we'll provide is the PSF's response to it, and it's kind of interesting because they're sort of humble about it. They're like, \"We're happy to be on the list, and by the way, we talked to C, so there's some places where we're not memory safe, so we're still improving.\" Kind of things, so kind of an interesting read. Kind of goes into our Rust thing there a little bit too, H, that, well, they mentioned it explicitly trying to replace some things with Rust in order to try and solve these kinds of problems. For sure, yeah. And then the final bit of news is release news. Jupiter Lab 4.1 and Notebook 7.1 have been released. The Jupiter Lab release includes over 100 bug fixes and is their largest minor release ever. So if you're a Jupiter Lab person, go grab the latest copy. Yeah, I'll be digging into a little bit of Jupiter stuff a little later for one of my topics. Awesome. So that takes us into our main topics this week. My first one is from, well, let's just call him a friend of the show, Steven Ketta. He's also a Real Python contributor, and he's actually got a kind of a neat tutorial coming up, so be on the lookout for that. This is from his site, which is called The Python Coding Stack, which you've mentioned before. I feel like this article's geared towards beginners or intermediate devs, and I think I say this pretty often. Useful for people coming from another language, as it covers several Python quirks that are well, especially unique in how it handles objects and pointers and reference counting, and kind of ways to explain those concepts, plus a couple of wrinkles, which I think is kind of a fun way that he digs into this. There's several themes: names are not the same as objects, reference counting, is one of the themes. He gets a little bit into scope and namespaces. He talks a little bit about removing those things, removing labels, deleting names, and then garbage collection there. And then a couple of the references go into deeper dives and how things can be a little bit odd with certain objects that have to do with the differences in mutability and immutability. I.e. interning and immortal objects, which is very recent. And he gives you more references as to where to dig into that stuff. I like how Steven writes. He changes his style depending on who he thinks the intended audience is for this particular piece. So this one's really friendly, very approachable. It's kind of like he's coaching you as you go along. Personally provides code snippets as you go and a collection of all of them at the bottom of the piece, which I think is neat. And I really like the use of graphics that he has to kind of throw metaphors in, kind of give you an idea what's happening with objects and naming things. He starts out with a bit of a curveball to start right away in his first example, which has a little bit to do with Python 3.12 and how it handles immutable objects and their reference counts. And we've talked about it, you know, a little bit of a spoiler here, immortal objects. And so this is a chance maybe to kind of see that stuff in action if you just heard us just talk about it a little bit. His example in that case uses strings. He switches into Python 3.11 and shows how that, it's been up to now, you know, up to recent days in 3.12. He dives into an example right after that using lists. So into more of a mutable object. He uses tools from the sys module called sys.getrefcount, no underscores there. And what that will do is if you put an object's name into that, it will show you what the reference count is at that time when, say, you print it out. And so he goes through a script showing the number change as he's assigned things. So he starts with assigning a list to a name. So he gives it mycore numbers equals square brackets, 7, 19, 51. And then he shows how assigning that a new object to that name of that existing object in my numbers. So he says like, okay, cool numbers equals now my numbers. So now there's two references to the same object there. And so the reference count shows that. Continues to get into other relationships where what if those two were embedded in another list. So kind of two references in one list to two separate lists. What does that do to the ref count and so forth. He shows about deleting objects and what that does to your ref count. Continues to show a little bit about if that goes to zero, what happens in the garbage collection that's happening there. He gets a little bit into namespaces, an area of confusion for a lot of early developers. This idea that if you name something outside of a function versus if you name something inside of a function, and how those two names are not connected or related inside those two namespaces. So it's possible to use the exact same name of something inside there and have different reference, but that's not true in a for loop versus, well, it is true in a list comprehension. And so there's kind of some interesting things there. He digs into sort of edge cases that you might run into a little bit about immutable objects and how they handle references differently. Again, I mentioned this idea of interred values. I think we brought it up in the show before how there's a set of integers that are referencing always the same object. There's basically going to be one reference to them in a similar way to something like none only has a single reference. And then he talks a little bit about the mystery from the beginning and how immortal objects are working with 3.12. Just briefly describing it to kind of give you an idea how that's unique and how that might show a very different number when you use the get ref count. So really good stuff. I don't know if I even mentioned the name of it, which is kind of funny because it's what's in a name. So again, naming objects, talking about references and digging into all that stuff. So again, great stuff for beginners or intermediates who maybe are a little scratching their head or again, how does a language like Python deal with this stuff? If you are interested in digging deeper into this type of topic, we have an article titled \"Pointers in Python: What's the Point?\" I think this is a good leaping off point for you there if you want to understand a little bit about how what is happening with memory, I guess. This is related to our White House news story a little bit too, in the sense that things are done slightly differently inside of Python and has its own method for managing these things. So thanks, Steven. \n\nSo what's your first one here?\n\nWell, it's been a while since I've covered a Leodis P.O.R.O.'s article, so I guess we're overdue. This one is called \"Duck Typing in Python: Writing Flexible and Decoupled Code.\" If you've not come across the idea before, duck typing is the programming concept that interfaces are based on whether an object responds to some set of calls. The name comes from the old saying, \"If it walks like a duck, and talks like a duck, it must be a mazda.\" I think I missed that up. Anyhow, quack. If Python's your first language, this might seem a little obvious, but in most compiled languages, you have to be explicit about a class's interface before passing it around. A lot of Python's flexibility is born out of the fact that it is duck typing by design, but that also has drawbacks. It's sort of associated with the dynamic nature of the language. Technically, you can create a duck typing language without it being a dynamic language, but the two concepts tend to coincide in the sphere of programming. Anyhow, Leodis starts out with an example consisting of three classes: a duck, a swan, and an albatross. Each class has swim and fly methods. All three have the same swim and fly methods, so you can do general bird things with the classes, not caring which underlying class is actually being referenced. In this case, the Swan and the albatross classes are quacking just like the Mazda. I'll stop with that. With the basics out of the way, the next part of the article talks about the pros and cons of duck typing. On the pros side, you get greater flexibility, simplicity, you don't have to do explicit type interfaces, and easier reuse. On the con side, certain kinds of errors have to wait until runtime, and the lack of explicitness can mean for some tricky debugging and maintenance issues. All things in software are trade-offs. As with all Leodis articles, this one is a deep dive. I've only covered the first quarter so far. He goes into places where duck typing gets used in the built-in libraries, how to support duck typing in your own classes, some code approaches that are alternatives to duck typing if you're trying to solve the same kinds of problems, and how duck typing interacts with the Python typing system. So if you're exploring object-oriented programming in Python, this article is definitely something you'd want to check out. Nice.\n\nAs a sister thing, if you haven't listened back to episode 88, I had Luciano Ramal on, and we discussed type hints, protocols, and ducks in Python. Kind of dug into a little bit of duck typing there and some of the concepts, and how it really helped him fall in love with the language a little more in some ways, which I thought was kind of interesting. Yeah, I can see it coming from Java and trying to do something similar in Java. It's always, you built an interface and you had to include the interface everywhere, and coming to Python, it was sort of a, \"Hey, you mean I can just use it? I don't have to go back and change what that class inherits from. I just call it, and it works.\" And yep, it compensated for the lack of brace brackets and how creepy that made me feel when I started coding Python. Semicolon, what do you mean? I want my semicolons in my brace brackets. Give them back to me. What is this white space? 20 years of being a C programmer does to your brain. It's, uh, fix application issues before they become downtime with Sentry. Error and performance monitoring for Python. Whether you're taming Python's processing power or controlling JavaScript's flow through Node.js backend infrastructures, applications are as complex as they are valuable. With Sentry, you can trace issues from the front end to the back end, detecting slow and broken code to fix what's broken faster. Within minutes after installing Sentry, software teams are able to trace Python performance issues back to poor performing API calls as well as surface all-rated code errors to fix what's broken faster. As one engineering leader said when starting to use Sentry, the time to resolve errors went from days to minutes. Installing is easy and new users get three full months of the team plan free when you use the code \"realpython\" on signup. You can find a link in the show notes or visit sentry.io. All right, well, as I mentioned before, I was going to dig into a little bit about the Jupiter world and IPython, and I have an article on the Towards Data Science blog that's on Medium. It's titled \"Using IPython Jupiter Magic Commands.\" And it's a little bit of a misnomer. It's interesting because it does have a first quarter of it that is talking about generally, you know, what are magic commands and how they work. And it made me think of an article that I covered recently. It was from Vincent Mendy. It was titled \"Unlock IPython's Magical Toolbox for Your Coding Journey.\" And that one was really more about IPython. And I think I focused on that IPython being our great alternative repple, re-evaluate print loop tool that's, you know, similar to stuff that I've used like BPython and, and if you want to go beyond the standard built-in repple that you get when you type just Python in a terminal or Python 3. When I had talked about that article, I think I neglected to point out that yes, IPython's this great repple, and you can kind of do a lot of interesting stuff inside of it, but all of the magic stuff that I covered in that one is also available. It's the same engine. In Jupiter notebooks and Jupiter Lab, and actually other things like Databricks and a few other platforms that use IPython as their basis. And all the magic generally translates there. And in that piece, we talked about some of the magic commands, like things that you can do for navigating the file system. You might have seen this stuff appear in notebooks before and kind of wondered what the percent signs in front of all this stuff is doing. So the navigating file system stuff, some stuff I might have mentioned was percent PWD to see what your working directory is, percent CD to change directory or LS to list. There's a bookmarking thing where you can kind of save all those locations, tools for loading data in, looking at your code history, and there's a reference sheet that's in Vincent's article. I also learned a new command as I went through this and it's a built-in command, another magic command that's just percent quick ref, no spaces or underscore. And that one actually brings up a nice quick reference to all these types of commands. So I found that by really digging into the IPython docs, which have a really good page on magic commands alphabetically listing them and going through it. You might have seen in the wild the one I would see the most common is like percent time it. But there are ones that like you can do percent debug or if you don't want to use their debugger, you can use pdb. So you can do percent pdb. Another file one that was kind of cool that went beyond the stuff I was talking about for is percent dir, which will give you like your current directory sort of stack, which is neat. A percent edit opens an editor, which I think is, you know, maybe you like working inside Vim. If you want to work with a file specifically, or Emacs, or VS Code, or what have you, you want to get outside of this simpler environment that's there and you want to go to an editor. And then one I wasn't expecting was, uh, present GUI, which enables a GUI event loop integration. So that works with WX, Qt, or QT, TK, and I guess even COCO if you're doing some old Mac stuff. And then there's some fun ones that go a little further like percent macro, where you can define a macro for future re-execution",
    "zAdDxibgiqM": "Welcome to the Real Python Podcast. This is episode 197. How is Python being used to automate processes in the laboratory? How can it speed up scientific work with DNA sequencing? This week on the show, Chemical Engineering PhD student Parza Gazi is here to discuss Python in bioinformatics. Parza provides background on his research and the bioinformatic techniques used to discover gut microbes' role in human health and diseases. We talk about automating lab experiments with liquid handling robots and Python. We dig into libraries to shatter and reassemble DNA sequences. Parza also shares current projects from the Chan Lab at Colorado State University and his GitHub repository. All right, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with the community of experts at realpython.com.\n\nHey, Parza, welcome to the show.\n\nHi, Christopher, thanks for having me on the show.\n\nI'm really excited to talk to you. You reached out and had a bunch of interesting things that you wanted to talk about, and a lot of them have to do with real-world applications of Python in the laboratory and experiments. So maybe you could give me a little background on where you're at. You're currently in your PhD program, and maybe you could explain a little bit about what you're currently doing.\n\nYeah, so right now, I'm in my PhD program, fifth year at Colorado State University, and I'm in the Chemical and Biological Engineering department. So my background, I'm coming from an engineering background, and honestly, for my undergraduate studies, I never did any biology. And in my doctoral studies, I got interested in biological systems, and somehow they're very similar. The systems that we study right now, they are maybe more complex, but the concepts behind them are very similar to classical chemical engineering. Like factories, we actually treat the cells like factories, and the analogy goes beyond that, even like we have, for example, piping systems, they have some sort of analogs in the cellular and biological space. I find this system really interesting, and a lot of programming is also involved in this process.\n\nThat's really cool that you kind of almost shifted direction into your PhD program. That's pretty cool. Were you doing any programming before that in your other engineering courses before that?\n\nYes, so mainly we were using MATLAB for anything, and it was mostly computer simulations. The fun part is that in my first year in the PhD, everything was in MATLAB. But maybe over a year here, everything in our lab just shifted to Python, because we soon realized that Python offers one thing: it's the package. Like, there are so many good packages that we can use in Python, and also how easy it is for someone to get started with Python and become better soon. That's why we shifted to Python, I think after the first year, and we've been using Python for maybe four years and something like that.\n\nYeah, I would imagine that a lot of the tooling in these last four years has been extremely productive as far as the scientific community and the adoption of Python. I'm not saying that wasn't before that, but I feel like the tooling has gotten easier and like you said, there's the ability to kind of build on top of other people's work as opposed to having to build everything from scratch. Has that been your experience?\n\nYes, and one funny thing: I'm coming back from a seminar today and these seminars happen weekly, and it's been four weeks in a row that everybody's saying, \"We were using MATLAB and suddenly we shifted to Python.\" It seems like it's something that's really happening, especially more recently.\n\nThat's interesting because I think a lot of universities, I mean, it depends on the professor's background and the tooling that they've been using and maybe the funding. MATLAB is a thing where it's, you know, they have to purchase right seats for it and things like that. So I think that might be an attractive thing for universities too.\n\nYeah, exactly. I know that some of the programs are thinking about replacing this entirely. So one issue is that the courses are based on MATLAB and already there's a lot of syllabus development and you need to prepare new materials. And that's why maybe in the education part we still have MATLAB, but I think that will also change. Even the freshman and undergraduate students will be trained on Python instead of MATLAB. That's just my guess.\n\nThat's kind of the pattern that I'm seeing right now. One of the areas that you said that you wanted to speak about when you sent me the email was you wanted to talk about using Python in the lab and then how Python's being used in the field of bioinformatics. And I immediately had to go online and go, \"What is bioinformatics?\" So I don't know if you're comfortable, could you explain to the audience generally what is bioinformatics?\n\nYeah, sure. I think it's a very general term. And the way I use it is it's just like procedures to process biological data, the data that relates to biological systems. This could go even to hospitals, and it could be as broad as that. Like data from hospitals could be in this realm as well. But what I'm working on is specifically data from microbial systems. So these cells are living organisms, and we kind of get information, different types of information. The way we process that, the science that is behind processing this information into useful information that could be used for next step actions, all of that falls into informatics for me.\n\nYeah, it could be looking at sequences of DNA, or it might be looking at the information that you're doing through repeated studies, just sort of managing the information about the biology field. Yeah, exactly. Because DNA sequences are really like a big amount of data is being generated that are DNA sequences, and it goes from how do we store this data, how do we use databases, how do we use different algorithms, how we can actually process this information into useful outputs. All of that requires computer knowledge from software engineering, algorithms, and it goes even beyond these topics.\n\nThat's a lot of data to manage. It's kind of one of these areas you always hear of, the world of big data, and you think of banks and financial data and lots of documentation, and so forth. But you're dealing with just raw, huge amounts of data, looking at like, you said, the genomes and things like that, which is a pretty intense amount of data. So a couple things that we wanted to dig into based upon our back and forth through email was to kind of think about like what are the different places where Python fits into your role as a researcher. And I thought one of the cool ones was this idea of how Python has helped you in the lab itself and doing your experiments. You sent me a video about how you would manually dilute a bacterial sample, was the example they gave there, and how was like, okay, at the beginning of the day, wipe down this surface, okay, start here, and it was just like so much manual stuff. And then literally the next day, you were only like maybe five steps into the process. It was kind of wild. And so you sent me a link to a company, Optron, this manufacturer who was creating a liquid handling robot. Do you want to talk a little bit about that and then how Python intersects with that as far as helping you in the lab?\n\nYeah, sure. So as a researcher, my work splits into two parts. One is the wet lab projects, which we actually go to the lab and plan and do experiments in the lab. And the other part is more like computational work, where we develop algorithms, do data analysis, and that kind of stuff. So yeah, that robot is really something that has changed the way we do experiments and it falls into the wet lab part. So we used to do things by hand, like hand pipettes, and it becomes really hard because in many of the experiments that we do, you have to go manually. Some of these plates that we work with, they have like 96 very similar wells that you need to pipette something from one of them and drop it into the other one. And it becomes really confusing and very error prone, I guess, maybe very, very error prone, and also tedious because you have to do something repetitious and it's just like, if that part could be automated, it saves a lot of time and probably a lot of error and in the long term, maybe money for the lab. And for this reason, we use these machines in the lab to automate the process. Do you know, like the age of the use of those types of machines in the lab, is it recent development in our lab or in general?\n\nMaybe your lab or just generally. So we started about, I think, five years ago in the lab with these robots, but I think at that point, this company was very new. So things were already at the second generation, but we were one of the first labs on our campus to use such robotics. So I think it wasn't that common, even if it was like, that the company existed before, it wasn't that common. But after some time, right now, I know at least four labs in our department that use such robotics. So I think like people are moving towards that point.\n\nYeah, actually the fun fact is for we, we used to perform a lot of COVID tests on campus during the COVID years. And because the numbers were huge, what campus did was they used these machines to speed up the process and make the testing part really fast. So we could get back our results from our tests very soon and they could soon isolate potential people with the virus and potentially avoid spreading it. This is one of the places that it was used.\n\nNice. So how is Python used in there? I was able to go to the site. I don't know if that is the company, OpenTrons. Is that name? So I kind of dug into a little bit and found the Python protocol API and started looking at it. What where does it fit in? What are the controls that it's allowing you to do with Python?\n\nRight now, you can go to the website, build a protocol just using the graphical user interface and without any knowledge of Python. But what goes on behind the scene is a Python code is generated and it's given to a computer that is inside the robot, which is a Raspberry Pi, I think. And then this code gets executed and it gets transformed into robot actions like go up this much and pick up that much liquid from this coordinate and move it to that coordinate. So as I said, right now there is a great graphical user interface that they provided. But for more advanced protocols, we usually have to write the protocol ourselves. So it okay would become a Python script that you have to write. And you know, for that example that I said, like you have wells that are, let's say you have 96-well plates that are like 12 different columns and you have to do repetitious things. These concepts fit really nicely with something like loops in programming.\n\nSo instead of doing it yourself, just a simple for loop can do that and avoid possible mistakes. And one other interesting programming concept that comes here are the exceptions and errors. Okay, so it can run a simulation of the experiment, the protocol that you give it, and it raises exceptions based on if there is some sort of logical issues in your code. For example, this well has 200 microliters in it, but if you're pipetting more than that, then that doesn't mean anything because there's not that much liquid in that well. So it's really good to know these upfront because if you are doing those by hand in a lab notebook, you might not notice some of the miscalculations that you might have for your experiment, which is really great.\n\nYeah, it's sort of pre-checking your work before you run it. It's like almost like running a test run.\n\nYes, yeah. It's kind of like its own simulation when you're developing the code for that.\n\nYeah, it sounds like there are stock tools that are built into the graphical user interface. Are you able to take what one of those would generate as a script and just modify the existing script and add the additional kind of controls you want or the exceptions you're mentioning?\n\nYes, exactly. Finally, I think it just gives you a Python file. Okay, the interface. So if you don't want to change it, just import it in the desktop computer, which is connected to the robot. Finally, that Python code gets interpreted and if you go to that Python, you can make any change that you want. But again, before running anything, even if you change that code before running it, it will run a test to make sure that nothing is going on and it's bad with the protocol.\n\nNice. Yeah, it's sort of a running almost like a test run.\n\nYes, yeah. So it sounds like there are stock tools that are built into the graphical user interface. Are you able to take what one of those would generate as a script and just modify the existing script and add the additional kind of controls you want or the exceptions you're mentioning?\n\nYes, exactly. Finally, I think it just gives you a Python file. Okay, the interface. So if you don't want to change it, just import it in the desktop computer and which is connected to the robot. Finally, that Python code gets interpreted and if you go to that Python, you can make any change that you want. But again, before running anything, even if you change that code before running it, it will run a test to make sure that nothing is going on and it's bad with the protocol.\n\nNice. Yeah, it's sort of a running almost like a test run.\n\nYes, yeah. So it sounds like there are stock tools that are built into the graphical user interface. Are you able to take what one of those would generate as a script and just modify the existing script and add the additional kind of controls you want or the exceptions you're mentioning?\n\nYes, exactly. Finally, I think it just gives you a Python file. Okay, the interface. So if you don't want to change it, just import it in the desktop computer, which is connected to the robot. Finally, that Python code gets interpreted and if you go to that Python, you can make any change that you want. But again, before running anything, even if you change that code before running it, it will run a test to make sure that nothing is going on and it's bad with the protocol.\n\nNice. Yeah, it's sort of a running almost like a test run. \n\nYes, yeah.",
    "96_jJqBE5fI": "Welcome to the Real Python Podcast. This is episode 200. What is error culture and how do you avoid it within your organization? How do you navigate alert and notification fatigue? It's episode 200. Real Python's Editor-in-Chief, Dan Bader, joins us this week to celebrate. Christopher Trudeau also returns to bring another batch of PyCoder's weekly articles and projects. We discuss an article series about error culture, digging into false positives, hero culture, and the tendency to start ignoring alerts. We contrast our personal experiences and propose possible remedies. Dan describes configuring Real Python's alert system. We also share several other articles and projects from the Python community, including a news roundup, reading and writing wave files in Python, moving beyond flat files towards SQLite and SQLAlchemy, getting help in Python, exploring four kinds of optimization, a framework for building web scrapers, and a project to simplify subprocesses. This episode is brought to you by Sentry. Fix application issues before they become downtime with Sentry error and performance monitoring for Python. Alright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at Real Python. After the podcast, join us and learn real-world Python skills with the community of experts at Real Python. Hey, Christopher, welcome back.\n\nHey there, alright, welcome to episode 200. Yes, it's been interesting. I got invited to be on the PyBites podcast, kind of trading with Bob Belderbos, who was on the show a couple of weeks ago. That should maybe have come out just before this one comes out, so if you want to learn a little more about me and my coding journey, hopefully there's some new stuff in there. But yeah, this week we've got a bunch of articles and projects for you and discussion this week. But we have some news, some of it may seem a little out of date because a lot has happened in the last couple of weeks, but I thought we could at least provide some resources for people that want to do a deeper dive. Yes, for sure. So, first little bit of news involves PyPI. On March 27th, PyPI temporarily halted the creation of new projects and new signups in order to stave off a supply chain attack. There was an automated process attempting to create malicious typo-squatting packages and to stave it off, new accounts and projects were halted for about eight hours. There was a banner on the site to tell people what was going on. On one hand, it sucks that this is now the world we live in. On the other hand, kudos to the folks at PyPI for protecting the rest of us by being on top of this stuff. It's kind of wild with the mentions in the article about the automated tools that allow for this to happen and then having to combat that, which is definitely going to be this cat-and-mouse thing. But it's nice that we have people in these positions now to really help us in informing us with what's going on.\n\nWe're seeing it everywhere, right? It isn't just Python. The XZ exploit that's been in the tech news a lot shows you just how far people are willing to go to do nefarious things. For anyone who isn't aware, XZ is a compression library in most Linux distributions and an individual or a group acting through a single account spent a lot of time putting a backdoor into the library. This was a multi-year endeavor where they sort of gained trust as the library's used in things like SSH and this would pretty much be a backdoor through any SSH connection. The perpetrator was very patient. They took over the maintenance of the library and slowly made modifications without being detected. Thankfully, it did get detected and that's great, but it's got a lot of people nervous. You were mentioning there's an off-show you were mentioning that there was some sort of situation with building Python yourself.\n\nYes, we're going to include a link to a pretty good explainer article by Ars Technica. They always do a good job of wrapping a lot of these resources together to explain it. I remember during the Easter weekend following threads and things that were happening on PyPI and it was definitely a place to be in the tech world, especially for people that are involved in open source, which Python has a lot of people. I did see a CPython announcement and this is from Seth Michael Larson who I think he's the security developer in residence and he typically posts these types of things. He posted on there that CPython, PyPI, and many Python packages are not affected by the backdoor and has an explainer post taking people into that. Then there's a nice thread beyond it so the malicious backdoor was committed in versions 5.6 and 5.6.1 of XZ and so they were talking about that and then the top comment right below it is somebody talking about it's becoming a bit of a challenge to download 5.2.5 of XZ if one is building Python from source as the current GitHub repo has been made offline and so this is again during a lot of this, several days ago. I know that there was a little bit of struggle there. This might give you some details as to what's happening behind it but again, if you're not building from source, you're probably fine and your versions of Python should be all good to go. If you're involved in open source development or you're doing your own kind of packaging stuff where you need to build from source, this might be a good resource for you to learn a little bit more about what's happening.\n\nI've got one other thing I want to talk about. You took the wind out of my sails a little bit up top by announcing that it was episode 200. Okay, I want to spend",
    "ITUSeoFbvyg": "Welcome to the Real Python podcast. This is episode 2011. What are the benefits of using a decoupled data processing system and how do you write reusable queries for a variety of backend data platforms? This week on the show, Philip Cloud, the lead maintainer of Ibis, will discuss this portable Python data frame library. Philip contrasts Ibis workflow with other Python dataframe libraries. We discuss how getting close to the data speeds things up and conserves memory. He describes the different approaches Ibis provides for querying data and how to select a specific backend. We discuss ways to get started with the library and how to access example datasets to experiment with the platform. Philip discovered Ibis while looking for a tool that allowed him to reuse SQL queries written for a specific data platform on a different one. He also recounts how he got involved with the Ibis project, sharing his background in open source and learning how to contribute to a first project. This episode is sponsored by Mailtrap, an email delivery platform that developers love. Try for free at mailtrap.io. \n\nThe Real Python podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at Real Python. After the podcast, join us and learn real-world Python skills with the community of experts at Real Python. \n\nHey, Philip, welcome to the show.\n\nHey, hey, Chris. Great to be here.\n\nWes McKinney hooked us up to talk a little deeper about Ibis. I mentioned multiple times that I'm very interested in that project, and we had so much other things to talk about when he came on.\n\nYeah, so Wes gave me your name and kind of showed me what's happening with the project, but you have a detailed YouTube channel going there, which I think is nice. But maybe we could start with this. How did you get involved with Ibis to begin with?\n\nIn 2016, I was working at Meta Facebook, and I was in data engineering. The job there is writing a lot of SQL code. Facebook has a dizzying array of infrastructure data engineering deals mostly with Hive, or at least at the time it was mostly Hive. Presto was the new kit on the block and was getting a lot of internal hype and use. Hive was super hard to use for building a pipeline because when you're working with a data engineering pipeline, you often are iterating. You don't necessarily know exactly what your code's going to look like right away. So you need something that's going to give you a somewhat reasonable feedback loop. Like you're not going to be waiting 30 seconds to run a count star query or something like that. Hive is built on this idea of turning SQL statements into MapReduce jobs. Presto was designed to minimize that trade-off and being able to scale to Facebook scale as well as give you back interactive queries where possible. The dialects were not the same. Hive has its own SQL dialect, and then Presto has its own SQL dialect. I wanted a way to write something some code in Python that I could write sort of once and then I could when I wanted it to go to production, I could just say, \"Hey, give me the Hive SQL for that.\" And when I'm iterating on analysis, run it against Presto. I saw what Wes was doing with Ibis, and I thought, \"This looks like the thing that I kind of want.\"\n\nThat's interesting. It sounds like you found the tool that met your needs and your experience already working with data and SQL. That's a great story. I like how you got involved with the project and how it aligned with your background.\n\nYeah, it was a good fit for what I was looking for at the time.\n\nSo, Philip,",
    "vFRkOk3NYLg": "Welcome to the Real Python Podcast. This is episode 202. How do you verify and validate the data coming into your Python web application? What tools and security practices should you consider as a developer? Christopher Trudeau is back on the show this week, bringing another batch of PyCoders Weekly articles and projects.\n\nWe discussed the recent Real Python tutorial \"Pantic: Simplifying Data Validation in Python.\" The piece covers installing the library with optional dependencies, working with base models, validating functions, and managing environment variables. We continue our conversation about web development with another article about Python security best practices. This article covers several Python libraries and crucial steps you can take to help make your web-based applications more secure. We also share several other articles and projects from the Python community, including a news roundup, \"Why Python Lists Multiply Oddly,\" inline run dependencies, and Pipex, a discussion about open-source contribution assignments, playing sounds in Python, and a Python library to access ISO country definitions.\n\nThis episode is sponsored by Mailtrap, an email delivery platform that developers love. Try it for free at mailtrap.\n\nAlright, let's get started. The Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at Real Python.\n\nAfter the podcast, join us and learn real-world Python skills with the community of experts at Real Python. Hey Chris, welcome back to the show.\n\nHey there, this week we have our kind of a large collection of small news items and then our typical topics, a couple of different things that we're going to put into a discussion, and then of course our projects ready to dig in. Post-episode 200, yes, 202 somehow, meaningless. Let's move on. It's a real shame you're not special for another 98 episodes. Sorry to break it to you, you can't do it on the 50. Alright, so what do we got for news?\n\nI've got a large steaming pile of news this week. English is funny. Steaming on its own has positive connotations, a steaming broth, a chilly day, pile is more or less neutral, that pile of rocks, but steaming and pile together and it evokes exactly one thing, which has nothing to do with our news this week, and I apologize for that little twisted insight into the inner workings of my mind. Anyhow, starting out with the Python releases, there were two announcements separated by a day, I assume having something to do with how the releases got signed off. Between the two announcements, there were three releases, 3.1.9 and 3.12.3, which are both bug releases, and then of course, it's been a while since I've said \"Alpha\". So 3.13 Alpha 6, which is supposed to be the last Alpha before the feature freeze, which is less than a month away. So just after PyCon, we're going to be seeing a feature freeze, and I think that's usually when they do it. Next bit of release news is Django 5.0.4 came out. It's also a bug fix, it's got five or six little bugs in it, and as of the beginning of April, 3.2 has officially reached its end of long-term support, which means the only pre-five release that's still out there being supported is the 4.2 LTS, which still has two more years to go. For those of us who maintain third-party Django libraries, 3.2 being gone is great because that shrinks the test matrix nicely. Just a note on that, your book, which version is it addressing?\n\nIt's five, yes, it was five was in beta when I was digging in, and five Django doesn't really care very much about large version numbers. There are changes, there are new features in five, but it's not like five is a breaking change against four. So honestly, it was like add a few paragraphs in the book, there was a bit I covered a couple of the new features in the appropriate places and there wasn't much else to do from there. Good up until now. The PyCoders newsletter has tracked PEP stuff kind of arbitrarily, we sorted depending on what popped up and what was getting traction on the interwebs. Moving forward, we're going to try to be a little more explicit about our coverage. Any PEP added to the PEP repo and any PEP marked as approved is going to get called out in the news section. This will be in addition to the arbitrary coverage. So if there's a lot of discussion for a certain PEP or there have been wider appeal or some deep info or something, they'll still be in say the articles or other parts of the newsletter. But as part of this, two PEPs recently got approved. The first one was PEP 738, which is about adding Android as a supported platform, and the second is PEP 742, which is about typing mechanism for narrowing down a type's classification. So that's cool, we got both iOS and Android both as supported platforms now.\n\nYeah, and I think that's kind of what was driving it. I think iOS has been there a while and so I think they just sort of said, hey, we should step up and get it on both kinds of platforms. Yeah, cool. So what's that? You want even more news? And like I said, it's a pile. So two conference refs that I want to talk about quickly. The first is EuroPython, whose tickets are now on sale. EuroPython is from July 8th to the 14th, and it's in Prague this year, as well as being available virtually. Prague's a beautiful city, one of my favorites in Europe. Although it was occupied in World War II, it is far enough East that very few of the bombers made it there, so it's really got a wide variety of original examples of European architecture. By contrast, most of Western Europe is kind of Disney World. It all got demolished and then they pretended and rebuilt it, and it's fake. So Prague's a great place to sort of see the historic stuff. It's a beautiful city. The OG. Yeah, and the other conference is PyCon Portugal, has been announced. It's going to be from October 17th to the 19th, and they currently have a call for papers out. Nice, if you want to speak at a conference, go submit. I can't say for this one in particular, but oftentimes the smaller regional conferences are a little easier to get into. So if you're new to the speaking circuit, this is probably a good place to start. So if you're based in Europe already and Portugal is a nice little hop, and it's a nice country, you know, go get your talkie on.\n\nThat was a lot. What's in your pile, Mr. Bailey?\n\nI have a Real Python tutorial. This one is by Harrison Hofman. Harrison's kind of a newer author for us, and he likes to focus on a lot of stuff in the data science world. I think we featured a couple things from him before, but this one is about Pantic, which is actually going to come up several times, I think, throughout the rest of this episode. I think Pantic is a great name for this library. I think it's pretty perfect. The title is \"Pantic: Simplifying Data Validation in Python.\" This one digs into not only data validation and making sure that that stuff is set up properly going into your different fields and projects and stuff like that, but it also has a little bit to do with managing settings. The first line of the whole thing is Pantic is a powerful data validation and settings management library for Python, engineered to enhance the robustness and reliability of your codebase. I know that this library has come up many times on the show because it's kind of a thing that's tied into a lot of other libraries. We also, I think, mentioned recently their move to Rust. We celebrate many times the advantages to dynamic typing that Python provides, but there are a lot of circumstances where, when and where you need it, you need to be sure of like what you're dealing with as far as data goes. So robust type checking and data validation are handy tools that this thing provides. The tutorial digs in initially with a section titled \"Getting Familiar\" and a list of overall features customization where you can start with really basic primitives and move into really highly nested data structures that maybe suit your particular project. A lot of flexibility as far as how strict or lax you want to be and the ability that you can course things, move them in. Say you have an int and you want to make sure that everything that is an int is turned into a float or whatever in the particular field. Conversions to and from various formats, you know things like dictionaries and other data structures you're familiar with. You know there's going to be some JSON in there and performance, as I mentioned just a second ago, Rust is at the core of it for validation. And then as far as an ecosystem in industry adoption, it is pretty widely accepted and especially if you've heard of any recent API libraries. FastAPI being the first one I can think of, and we were talking offline just before we began, you mentioned Ninja uses this also, or Django Ninja uses Pantic also. Lang chain polers, a few other tools. It's very popular in the community for these types of tools. The tutorial digs into installation. I think the interesting part to mention in there is that it can include optional dependencies, and so you can kind of customize it as you're pip installing it. In this case, they give an example of adding email validation, which is not something that comes by default, but you can add a custom thing that comes in with it that helps with validating that. And then you really start off to the races practicing a lot of things if you've never worked with the library like this and worked on validating input and making sure things are set right. There's base models, and so you start talking about how to use those. There are lots of code examples for you to follow along with. I really like that it shows not only things working correctly and correctly validating, but also lots of failures and very descriptive output that you get from that. You get into using fields for customization and metadata, that's where you start to work with this sort of idea of a validator and validating models and fields and creating your own custom validation logic, making sure, like somebody's age is at the right level that you want them, you can say this is an application for a job and they need to be at least 18 years old. You can set up custom fields that are validated in that kind of way. There's also a way to use a validation decorator that can validate functions and it talks about how to write custom validation logic for that. And then at the end of it, it digs into an area that I wasn't aware of, and maybe a lot of people aren't as aware of that this is available from the library, but it has a whole thing for managing and working with settings for different projects that you're working on. Very often, again, this type of tool is useful when you're working with databases, you're working with web type of stuff, you're working with other people entering things that are going to go into your program. It's really good that you aren't sharing your settings, sharing your environment variables, making those things private and public, and so forth, and making sure that stuff is again validated and proper. And so there's a whole section on that, which I thought was really great. There's a base settings model for that that'll parse and validate the environment variables, and again, lots of code examples there at the end of proper and improper use, along with all the kind of communication that you get back when there are validation errors. So thanks, Harrison. I think it's a really great tutorial and a great introduction to anyone, and also again, if you haven't played around with the settings features that are available in it, I think this is a good add-on. Also, if you've been working with anything like APIs, you should have a look at it.\n\nI was wondering, Chris, if you were using a validator type of tool like this. I mentioned Ninja because we were talking about that before we began, but what types of things were you using for like projects where, again, human beings are going to be entering data into your Django and so forth?\n\nSo I've used Pantic indirectly through Ninja because Ninja essentially just subclasses the Pantic classes, and it's used to validate Ninja's a library for doing REST, and so you're getting JSON fields going back and forth between client and server, and you want to make sure that the client isn't sending you the wrong one. They're using Pantic to manage all of that. In fact, they've got decorators on their decorators, essentially. So you can say,",
    "Hj5iT98_yY4": "Welcome to the Real Python Podcast. This is Episode 203. Do you get stressed while trying to learn Python? Do you prefer to build small programs or projects as you continue your coding journey? This week on the show, Real Python author Steven Gretta is here to talk about his new book, \"The Python Coding Book.\" Steven has been teaching Python to adults and children for many years. With his new book, he wants to share the relaxed and friendly learning environment he's developed. \n\nWe discuss using analogies to explain programming concepts and constructing complete programs as chapter goals. Over the last year, Steven focused on writing. He started his newsletter, \"The Python Coding Stack,\" wrote more tutorials for Real Python, and authored the book. \n\nThis episode is sponsored by Mailtrap, an email delivery platform that developers love. Try it for free at mailtrap.io. \n\nAll right, let's get started. The Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. \n\nHey, Steven, welcome to the show. \n\nThank you. Thanks, Christopher. It's really great to finally get to talk to you in sort of virtual person here and have you on the show. I've been reading your stuff on Real Python for quite a while. I think you joined writing right about the time I started doing video courses, possibly. \n\nI think it's been three or four years since my first article now. \n\nAnd I've been a bit on and off. There were times when I didn't publish much, but I think recently I've got back to publishing a few articles. \n\nYeah, yeah, we featured a few of your things on the show. Christopher and I wanted to have you on the show partly because we were trying to help promote your book a little bit. We're excited another team member sending out a book. \n\nThank you. And so we wanted to talk a little bit about your shift to author of a book as opposed to articles. But maybe we can start talking a little bit about your background. Where did you go to school? \n\nYes, so I did my undergrad back in Malta, which is where I'm from. I'm from the tiny island of Malta in the middle of the Mediterranean. So yeah, I started physics and maths there, but then I moved to the UK to pursue a PhD. \n\nSo I focused on physics and for a good 10 years or more, actually 11 or 12 years, I was a scientist. I was a proper scientist, not a lab coat. I never wore a lab coat because in my field, you didn't have to. \n\nYou know, working in a lab, doing physics stuff. Okay. And that's where I learned programming actually because I had never done programming before. I was a reluctant programmer when I tried in the past as a teenager and during",
    "tHKKzs_xWQ0": "Welcome to the Real Python Podcast. This is episode 204. Would you like to get more practice working with APIs in Python? How about exploring the globe using data from OpenStreetMap? Christopher Trudeau is back on the show this week, bringing another batch of PyCoder's Weekly articles and projects.\n\nWe share an article from the PyCoders blog about building queries using the Overpass API for OpenStreetMap. The post explores the data structures, tags, query formats, and how to use Overpass in Python.\n\nChristopher discusses a Real Python article by recent guest Stephen Greta about lazy evaluation in Python. The piece covers the advantages of generator expressions or functions and the potential disadvantages of using lazy versus eager evaluation methods.\n\nWe also share several other articles and projects from the Python community, including a news roundup, handling control C and async IO, preventing data leakage in pandas, and PyIt Learn discussing the Django Developer Survey results, asking developers why they aren't shipping faster, using UV to install into isolated environments, and a couple of tools for retrying in Python.\n\nThis episode is brought to you by Sentry. Fix application issues before they become downtime with Sentry error and performance monitoring for Python. All right, let's get started.\n\n[Music]\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week we feature interviews with experts in the community and discussions about the topics, articles, and courses found at Real Python. After the podcast, join us and learn real-world Python skills with the community of experts at Real Python.com.\n\nHey, Christopher, welcome back.\n\nHey there, so we have a full slate this week. We got a few news items, a set of articles to cover, and then a couple of discussion things that we're kind of squishing together, which I think will be fun to discuss in relation to what's happening in the world of Python. And then, of course, Project. Who doesn't like squishy discussions?\n\nExactly. All right, so you ready to start it off with the news?\n\nSure. The first bit is PyPy. The alternate Python interpreter has released version 7.3.6. This one includes Python compatibility for 2.7, 3.9, and 3.10. So if you're into PyPy, go check that out.\n\nThe next piece is PEP 745. This is an informational PEP announcing the schedule for Python 3.14. Yes, that's right. They're already thinking about 3.14. I doubt I'll be the first to point this out, but that's Pi, the number, which is just going to be so fun because we'll have Pi Pi or Pi Pi to get the Pi version of Python. Anyways, I might be the first to point out the obvious, but I'm pretty sure between now and Wednesday, October 1st, 2025, which is when it comes out, I won't be the last.\n\nAnd then finally, a little bit of not Python but programming history news. The Basic programming language just turned 60. Basic was my first programming language. You are not going to catch me waxing nostalgic about a lack of functions, required line numbers, and a need for go-to because, yeah, I started Basic before subroutines. I'm happy to see that Python is a lot of people's first language now, not just because I like Python, but because it isn't a toy. That's kind of what Basic was considered way back in the day. How about you? Is that where you started as well?\n\nYeah, I'm one of those people that coded from the back of a magazine a little text adventure into a friend's Apple 2, and then I eventually got my Adam computer, which was an Apple 2. So yeah, I got to play and side Basic quite a bit. Did lots of looping around Choose Your Own Adventure style.\n\nI remember both Donkey on the PCJ, which was hit the space bar and move the donkey from the left lane to the right lane so it doesn't get hit by a car. That code you could actually read and understand. And I remember magazine articles for the Commodore 64, which essentially was just sprite-based Peek and Poke, which is like settings and removing, and it was just gibberish. Like you typed it in, but I don't know what it's supposed to do. Oh, is it doing the right thing? I have no idea. I learned no coding from Peek and Poke, but yeah, you could make pretty sounds and make pretty pictures.\n\nThe most recent time I've heard about that was they were fixing a Voyager and they were, they have a bad chip. I don't know if you heard about that whole story, but they were doing something similar, moving all the information over and literally Peek and Poke.\n\nYeah, to make it work across how many billion miles or whatever it is. Yeah, it's pretty crazy. What's your first topic this week?\n\nI've got an article by Jason Brownlee, who writes for Superfast Python, which focuses on concurrent programming and optimization of your favorite language, that's Python, not Basic, just to keep the thing going here. The article is called \"Async IO Handle Control C.\" Now, you're probably familiar with the fact that hitting Control C on your keyboard usually stops your program. What you might not know is that this is part of a family of signals in Unix. Windows kind of copies some of it, but when you hit Control C in a terminal on Unix, the interrupt signal gets sent to your program. This signal is often shortened to the name SIGINT, not to be confused with signal intelligence for anybody who's a big Tom Clancy fan or has a military background, so your program is actually able to trap SIGINT. So the stopping of your program only happens if your program doesn't trap the signal. This is done on purpose so that you can gracefully shut your program down if you need to, say you've got to write out a file or need to do a database commit, you can trap the signal and make sure that those things happen before your program actually exits. SIGINT isn't the only signal on Unix, there's a signal for backgrounding a process and a kill signal that isn't trappable so that if your signal for trapping signals goes awry, you can still kill the program. Anyway, so as you might infer from the article's title, Async IO muddies the signal trapping waters. When you've got multiple threads or coroutines running, the main process is what gets the interrupt signal from the OS. If you do have concurrent things going on, that means you now have to decide how to handle the signal and what to do with all those concurrent activities. What the article does is walk you through step by step as to how to build a custom signal handler where in your coroutines to trap it and how to deal with such a graceful shutdown to make sure that all the coroutines finish doing what they're needed doing and receive what's called a cancel inside of Python to handle all this. So if you're doing some Async IO, this article is definitely worth a read so that you don't leave little orphan processes happening and have weird stuff going on in your system.\n\nThe next one's about APIs, actually a very specific API for OpenStreetMaps. It's called Overpass API, and this is on the PyCoders blog. I was on their podcast recently, and so we've been following their blog, and this one is from Judith Vonroth. It's a kind of a tour of what this API can do. We talk a lot about tools that can create an API fast, like FastAPI, Django DRF, and Django Ninja, which we may talk about a little bit more later. But often people are interested in consuming the data and pulling it out of an API. Maybe you're interested in exploring that or practicing that, and I think this is a really good overview, not only of how this particular API works, but generally how they might be organized. Data structures they have and so forth. One of the best ways to get familiar with it is to play around with going to the website, which I think it's just OpenStreetMap.org. As you bring up the map, you're looking around, and you can right-click on any particular element or node, and you can see the information about it. The article has some visuals there, kind of indicating that stuff. So, like, she clicked on a particular bus stop, and there's a bunch of tags that are associated with that, so you can kind of see the structure there. Does it have a bench? Does it have a trash can? Is it lit? Does it have a shelter? Stuff like that. Then it says things like, \"Oh, it's part of this way.\" And this connection of nodes and how they're connected, the node, the way, and the relations, and all these sort of tags that are connected there. You also kind of get an insight of how this information is sort of crowd-sourced. You can actually see the people that contributed, which I think is really interesting. I brought up my own personal neighborhood, and there's a lot of bike paths, walking paths around, and somebody is really into doing that stuff, which I think is kind of cool. I guess they want that information from themselves, and so they've added all those around the particular area I live. Using, I guess, satellite imagery or other things like that to kind of get an idea of it. How do you get into consuming this? Well, you can play around with it directly in the UR, if you've ever done that before, you might have seen the question mark and built a query string out to kind of see the different elements that are in there. She describes that process, but also then describes using WG and the type of output that you would get in that particular case. And then it's an intriguing list of like how the tags kind of connect, and there's a lot of really deep information that I wasn't expecting. Like tourism amenities, historic stuff. One of the fun things that she found is a public oven. I'm kind of intrigued by that idea. Actually, a little more intrigued by the idea of listings for public bookcases, but this is probably Europe and not so much us kind of stuff. The rest of the article digs into using this thing called Overpass, which is the API sort of connection to it, and then a Python wrapper for that. I think this is a really good resource. She talks about using that API Overpass API first with using requests, and then using the Overpass API Python wrapper. And I found it a good resource. Like I said, if you're into consuming APIs, it's nice to have building from OK, show you what it looks like as far as the web URLs, you know, then manually building on a query, and then sort of graduating into using Python in a library. She shares another Python-based tutorial that is a medium one that actually continues on this idea of using the Overpass API in Python. So if you want to continue on that, you can. And then we at Real Python have another, if you are looking for even more sort of general ideas on how to use APIs, that's called Python and APIs: A Winning Combo for Reading Public Data, and has a variety of other types of things that you might explore, like GitHub, you can kind of practice using these public data resources. Something to check out.\n\nStephen writes great stuff. He's got a very approachable article style, and this one is no different. It's an easy read. So if you're interested in this kind of stuff, it's a good place to start.\n\nJust had him on the show. That was very fun to talk to him, and we talked about his book. I titled the episode about it being like friendly and approachable, and you know that's definitely his style. And then what's funny is that this, I feel, is very related to the article that just came out this week, just after the lazy evaluation one, which is about sequences, which kind of makes sense. And if you've dug at all into generators, I think this is a really good build on top of that, like kind of what's happening and how they work with this lazy evaluation one so more resources for you to dive in deeper.\n\nThis week, I want to shine a spotlight on another Real Python video course. It's connected to one of our discussions this week. When you start building any new Django web application, there's a fundamental step you need to tackle first. The course is titled \"How to Set Up a Django Project\" and it's based on an article by former guest and Real Python team member Martin Bryce. In the video course, Martin takes you through setting up a virtual environment, installing Django, pinning your project dependencies, setting up that Django project, and starting your first Django app. It also covers techniques to manage a slimmer structure for your Django project. I think it's a worthwhile investment of your time to learn the fundamental steps to properly set up a Django project and to get a solid understanding of the structure of a Django application. Like most video courses on Real Python, the course is broken into easily consumable sections, and all Real Python courses have a transcript, including closed captions. Check out the video course. You can find a link in the show notes or you can find it using the enhanced search tool on Real Python. \n\nFix application issues before they become downtime with Sentry. Error and performance monitoring for Python. One engineering leader that used Sentry said the time to resolve errors went from days to minutes. Whether you're taming Python's processing power or controlling JavaScript's flow through Node.js backend infrastructures, they're as complex as they are valuable. With Sentry, you can trace issues from the front end to the back end, detecting slow and broken code to fix what's broken faster. Within minutes after installing Sentry, software teams are able to trace Python performance issues back to poor performing API calls, as well as surface all related code errors to fix what's broken faster. Installing is just five lines of code, and Real Python listeners get three full months of the team plan free with the code \"realpython\" on signup. Check it out at sentry.io. \n\nAll right, let's move on to topic two. \n\nAnother survey of sorts, sort of. Our next source of discussion is an article by Dakes Gupta, and it's titled, \"I Asked 100 Devs Why They Aren't Shipping Faster.\" Dakes is the founder of GrepTile, which is an AI coding tool, so I suspect he talks to devs all the time as part of that whole sales process. The article name-checks a couple dozen companies, almost all of which are household names, or would be household names for houses containing programmers. The article goes into detail about these kinds of conversations he's had, but I'll start out with the two things that surprised him. First, nobody had to pause for an answer. You ask them, you know, why aren't you shipping faster, and everybody immediately went, \"Oh yeah, off the top of my head, here are our reasons.\" Yeah, the reason this is a bit of a surprise to him was that there's sort of this aspect of, \"Well, if you know that, why wouldn't you be fixing it?\" Well, and as we'll get into in a minute, sometimes it's out of our control to fix. And then the second surprise he had was how many of the answers were actually, you know, toolchain answers. So, you know, slow to build, slow to compile, slow deploy times. I find it interesting because the rest of the article spends very little time there, but it's definitely one of the topics that comes up. And I think it comes up because it's sort of the immediate thing that annoys us code junkies, right? So, what stood out for you here?\n\nOh, it started with some of the stuff that's really hard to solve, in my opinion, like dependency bugs. Like, you know, hitting random, mysterious bugs with libraries and reading into Stack Overflow to try to find out what's happening, and high issues and so forth. And that rolls into this next one of a complicated code base, you know, where they're not updating their documentation, and it becomes like a vicious cycle of, like, shipping features versus, like, keeping the docs up to date and so forth. I wonder about that. Like, this idea of cross languages, we just mentioned, you know, that idea of using JavaScript with Django and so forth, and how that isn't, like, doubling the complexity. It's sometimes multiplying it in a much larger fashion. So, but the really interesting stuff is, like, as you get further and further into it, it becomes more about the people and less about the technology, yeah. And so, you know, stuff like the QA loops, you know, meetings, reviews, weird stuff like developers having too much free time and personal vendettas and prejudice, and it's just like, I have only been in corporated America for a short period of time here and there, and so I kept saying this to people at different jobs I had that were inside large buildings that had lots of offices where I would say, \"Is this normal?\" And I guess every family is broken in its own way or whatever. I don't know the quote as well as I wanted to, but, you know, and I think that's it. Like, you know, every unhappy family is unhappy in its own way. And so it just makes me kind of like, I don't have a lot of ideas of like how you would solve these things. Mostly, I think about like, man, I would not be interested in them. I thought of some things that I've talked to people in the industry about, at least increasing communication and sort of, you know, making sure the engineering teams can potentially work together. And that was like the conversations I had with Pablo about Bloomberg. We talked about guilds and this idea that they have internal guilds. This is where a bunch of people that are interested in Python can go and learn more about that. And so people came from other teams and then that kind of spawned conversations across different silos, if you will. And I thought that was interesting. And yeah, I don't know if it solves that well. So the next thing I'm about to say, with a grain of salt, because of course, this is how I make my money, I have found that consulting can help in this. And the reason for that is kind of counterintuitive. Oftentimes what consultants are doing is they're being paid an awful lot of money. And because of that, they're listened to. So I can't tell you how often, yeah, I could tell you that how often they listen to them and not the people that are there. Yeah, yeah. So I can't tell you how often my job has been go in, talk to everybody, write down what they say the problems are, and then report those problems to management. And you know, and stupid, right? Because if I wasn't there, yeah, if I wasn't there, they definitely could have still solved the problem, right? Just by listening to their own people. But coming in as an outsider and providing a little bit of guidance and you know, massaging a little bit of data together, magically, all of a sudden, management listens. So that can actually make a bit of a difference. I would almost like it if the world didn't work that way, but you know, it's something you can almost take",
    "arnR3B_JDGg": "Welcome to the Real Python Podcast. This is Episode 205. What's it like to learn Python as a visually impaired or blind developer? How can you improve the accessibility of your Python web applications and learn current guidelines? This week on the show, Real Python Community member Audrey van Breed discusses her programming journey, web accessibility, and assistive technology. Audrey shares a background as a system administrator and instructor. While learning Python, she discovered the Real Python website. Audrey provided some feedback about the built-in video player's accessibility, and Dan reached out and worked with Audrey on some website improvements for the visually impaired. We discuss navigating modern websites and using assistive technology. Audrey also provides resources Python developers can use to improve the accessibility of their applications. \n\nAll right, let's get started. \n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at Real Python. After the podcast, join us and learn real-world Python skills with a community of experts at realpython.com. \n\nHey Audrey, welcome to the show. \n\nThank you, Christopher. Nice to be here. \n\nYeah, I'm very excited to talk to you about assistive technology and learning Python, and how developers can learn how to use this stuff a little bit better and add some resources. Those who are listening probably noticed that we had a little bit of an interesting intro there. What you heard is the voice of the Jaws reader, which we'll talk a lot about as we move along today, reading my intro text for me. Thanks for generating that for me, Audrey. \n\nYou're welcome. To be honest, I had to slow it down to about half the speed that I normally listen to. But I'm used to it and I can listen at very high speeds. But for other people, I think this is probably challenging enough already. \n\nYeah, you gave me quite the tour of how your setup works, and we did a Zoom meeting to discuss what we were going to talk about. That was a way for you to demonstrate what it's like to navigate a system with that. Maybe this is something we can discuss later, or maybe you can send me a link. I was hoping to find a good video that we could share that somebody could see someone using it. I think the Jaws people have a couple of intro videos that have a little bit of that stuff. It is interesting to watch on things you don't think about as far as navigating using a tool like that. \n\nYou're sure, and we'll see if you can find something nice. But yeah, good. I guess what we might start with, I don't usually do lots of background intro things, but I think in this case it really makes sense because you kind of have come to Python a little later in life after having a career and then sort of this big change in your life as far as your vision goes. Would you mind sharing a little bit about your background, not only as far as technologically in your career, but also the change that happened to you a few years ago? \n\nSure, happy to explain a little bit about my background. I was born in the early 60s, and in the 80s, I had an electronics education. In the last year, we did some digital electronics, and we started to play with some computers, and suddenly I realized, \"Wow, this is what I want to be. I never understood electronics that well, but digital computers, that made me tick.\" So I worked for five years for a field service organization servicing Digital Equipment Corporation PDP 11s. Okay, all the people know what I'm talking about. Then in 1993, I joined Oracle Corporation as a UNIX system admin because I learned about the UNIX operating system, and I've been using it ever since. After five years of doing lots of interesting UNIX system administration and a little bit of programming in shell scripting and Perl, I wanted to learn more about our own products, so I became an instructor. To be more specific, I delivered operating system courses for Oracle, as well as database administration. In the early 2000s, I lost my sight. I was born nearsighted and had lots of retina detachments. If it detaches enough, then it stops functioning. So I lost one eye maybe 25 years ago, and 20 years ago or slightly more, the other eye did the same thing, and then I had no sight whatsoever. So I had to relearn everything from scratch. I started using a screen reader, and the dominant screen reader at the time was Jaws, which is an acronym for Job Access With Speech. So I had to learn that a screen reader is basically grabbing the info from the screen and sending it to a Braille display so you can read with your finger. So I had to learn Braille and also the speech synthesizer, and the speech synthesizer is the one that did your intro for today's episode. In the beginning, you listen at a very low speed rate, and then after a week, you talk a bit faster, and you get used to it and you have to learn a lot of keystrokes. Of course, I was still teaching and had to reinvent everything because you can't easily draw things on the whiteboard anymore. But it never became a problem as long as you know your stuff and you are able to explain the technology and help people, they're okay with it. That was nice. \n\nDid you have some assistance with that, like creating maybe slide decks and things like that? No, PowerPoint was quite accessible. By accessible, I mean that you can drive the application with your eyes closed with the screen reader. So that wasn't a big problem. I did some curriculum development work and course reviews. The funny thing is that because I had to listen to the information in the courseware, I found lots and lots of typos. Listening to a word that is then mispronounced, you check it, and, \"Oh, the spelling is wrong.\" So that was a nice benefit. \n\nYeah, you can still teach, no problem at all. I think it's funny because I would imagine the same thing happens with repeated words. It's very easy to type those, but you hear it, and it's like, \"Wow, okay, got to fix that.\" \n\nIf you write Python and you swap the H and the T, your brain still reads \"Pyon.\" \n\nYeah, with the speech synthesizer said \"Py,\" and then you said, \"What?\" \n\nWhat was that? \n\nYeah, what does that mean? \n\nBecause it doesn't know how to pronounce it, so that really helps. After 20 years of teaching, I went to another role, and I'm now again a database and system administration for an internal development team. So that is basically my career so far, and I'm now in my early 60s. Hopefully, in a couple more years, it's time for me to retire. \n\nI was wondering about the settings that you use for Jaws. Maybe just generally, are you using that in English, or are you using it in your native language? \n\nNo, we didn't mention it, but I'm from the Netherlands. So my native language is Dutch, but working for an American company, I do everything in English. So my speech synthesizer is in English. If I have to read something in Dutch, I switch my speech synthesizer to a Dutch one, and then I can do my stuff in Dutch. But I think 95% of my communication is in English. \n\nI was thinking that was another potential barrier for technology sometimes, but you found a way around it. Generally, most programming seems to have centered around English. I don't know if that's a purposeful thing or it's just kind of what's resulted. \n\nI grew up with it, and of course, the keywords in Python are all English. It would be very confusing if you would write them in your own language because you wouldn't be able to read somebody else's code. Somehow, the standard is English, and well, that's fine for me. What makes it difficult is if you write something in English but you put your comments in Dutch, because then every time you have to switch the synthesizer. If you have an English text read by a Dutch synthesizer, it becomes very funny and difficult to understand. The same is true if you have an English text with a Dutch synthesizer. It sounds very strange. \n\nI guess that leads us into one of the things I wanted to ask you, which is you were not really doing much programming per se. You were doing systems administration and a lot of teaching and managing things behind the scenes at Oracle. What led you into learning Python and programming? \n\nYou're absolutely right. I've never been a programmer, and for me, there's a big difference between writing a script. For me, a script is maybe up to a couple of hundred lines of code. It's mostly straightforward, just one flow, maybe one or two functions but not too many. It's small, and you write it for your own and you maintain it. That's something completely different, in my opinion, from being a programmer working on a somewhat more complex application. As a system admin, you are doing a lot of that, then writing some scripts. I try to automate as many things as I could. I hate doing repeated work. If you have to do it two or three times, it's about time that you automate things. In my current role, of course, Oracle is doing a lot of business in the cloud world, so our own development environments are all in the cloud, and you have to change your procedure in order to do, for example, if you need to fire up a new machine or a new database or something, you can do it in a GUI console. But of course, you do want to automate things, and there's a very nice item software development kit for it. So you can talk to the cloud infrastructure. I had to write some things for automating stuff in our cloud for our own department. I heard about Python and I never looked at it. So I just said, \"Oh, let's see if that's something that I like.\" I had to get used a little bit to the way that you write Python because I did things in C and Perl where you have all these curly braces and semicolons and dollars in front of variables and stuff like that. Somehow, Python doesn't have all the clutter, so it fits better in my brain. I immediately liked the language and the cleanliness of the code. Keep in mind that if you're blind, you can't oversee your code. You can maybe have one line of code, and the screen reader will announce it to you, or you can read it with your fingers, but your focus is only just one line. Somehow, you have to keep the whole code or at least the routine or the piece of code that you're working on in your mind, and that is something that is quite difficult and it takes time in order to get used to this way of working. So far, so good.\n\nThat's really great. I wonder about, I mean, this is kind of a nitty-gritty thing, but kind of related to what you're saying of whitespace, a screen reader isn't necessarily going to announce the tabs and the spaces and things like that. Is that something that you can tell? Oh, this is indented here? \n\nJaws has over a dozen settings, and one of the settings is for because it has its own scripting language, and there is a setting where it announces the number of spaces on the left. If you then move your cursor one line up, it says four spaces. If you then move your cursor one line down, it says eight spaces. But it's a lot of information to consume, and if you have a Braille display, then with one hand, you can arrow up or down, and then with your left fingers, you have it on the Braille display, and you can feel that the code is indenting a bit more or a bit less. So having a Braille display is absolutely a pro if you want to do some more serious development work. \n\nHow large is a Braille display, like how big is that? \n\nIt depends. One Braille cell is eight dots, and a Braille display is either 20, 40, or 80 cells. I think an 80-cell Braille display is between 50 and 60 centimeters. It's slightly wider than a full-size keyboard. \n\nDoes that make sense to you? Is that something that fits nicely in your brain? \n\nI started using computers when you had no personal computers or laptops or tablets or stuff like that. So I grew up with a VT100 terminal. It's very old, people know. Just a dumb terminal, and it had either 80 or 132 characters, but 80 is still, for me, the default size for a terminal emulator. And it's nice for Python because it says a line should never be longer than 76 or something. Here's another reason. \n\nYou mentioned this idea of having scripts and working in this admin environment and firing off things, and then this idea of, well, I want to move into actually programming and writing complete applications. When was that switch for you? \n\nIt happened maybe two, three years ago. I did a little bit of scripting in Python, also a little bit at home for some home automation, but I really discovered that it was about time to learn programming because the projects that I'm working on tend to grow and grow, and I need to do this with my colleague. It was about time that I needed to get up to speed in real programming instead of writing an easy script. I attended a Python course, which wasn't a great success because we ran into some accessibility issues. So I started to do some research on my own, and I was Googling around, and then I joined this site, you probably have heard of Real Python. I wanted to know a bit more, so I found an article on Real Python about the REPL, and it was quite a long article, and I was reading and reading, and how far am I? Just kept going. It was about 50%, and I learned a lot, and there's still 50% to go. It learned me a lot about the REPL, so I like this thing. Then the site was pretty good accessible. Okay, there were some videos, and there was this video player which was a little bit difficult to navigate because the video player was in a frame, and it has buttons and not accessible. If I was inside the frame, I could move around, I could find the buttons and could do the pause and play. But if I wanted to read at the same time, the transcript to maybe look up a word or something, then you want to pause the video player, but I had to do a lot of moving around to find the pause button and then move back to the transcript to do some spelling, and this wasn't a very pleasant experience. So I sent a message to info at Real Python, and I got a really nice reply from Dan Bader. There you go. How in the world are you using our site with your eyes closed? I said, \"There's a thing called a screen reader.\" I was just wondering, can we maybe add a hotkey to make it easy to start and stop the video player? He said, \"But if you're interested, I can give you a screen reader 101 so that you know how blind people use a computer in the first place.\" Then maybe we can have a look at Real Python. He gladly accepted. So within a couple of days, there was this Control-Shift-P hotkey so I could start and play the video, which was really nice. In the session with Dan, he said, \"Are you using the search thing?\" I said, \"No, should I?\" He said, \"Well, it's very convenient.\" I said, \"Okay, let me give it a try.\" I moved to the search field and I entered a search term. I think \"dictionary\" or something. He said, \"Did you notice that there is a counter that's telling you how many hits you have?\" I said, \"No.\" He said, \"This is a poor experience. It's not sharing that stuff with you.\" So there is a search counter, but it wasn't picked up by the screen reader. We made that accessible so that if I now search something, it says, \"Well, I have 589 search results.\" Then you have all these checkboxes where you can narrow things down, like \"I want a video course or an article.\" Every time you select or deselect something, the counter is announced again. So that was a big improvement for me. \n\nThat's kind of cool to have a feedback loop like that. I mean I'm guessing for both sides, you know. \n\nIt's something that I really want to use and it's not accessible. I try to get in contact with the developers, and nine out of 10, you send an email and you never hear something back. With Real Python, within a couple of days, we started improving things. That was a very warm welcome for Real Python. \n\nNice. Yeah, I was going to ask you about kind of taking a step back. You had been using the screen reader technology for a while, and I would guess across how the web has changed over the years. One question would be how long did it take you to get comfortable reading web pages and navigating with the screen reader? Are there things that have been in the way of making it accessible, like new things that have been added to websites that are a bit frustrating to use? \n\nThat's an interesting topic. Generally speaking, HTML is very accessible with a screen reader if it's been written correctly. I will ask you to put a link in the show notes. There is an organization that performs every two years a survey among screen reader users on how they use their screen reader on the web. The nice thing is that it can teach you as a developer how we are using your website. The most common way we navigate a web page is by moving by heading. So in the web world, for the screen reader, there's something known as quick navigation, and you can quickly navigate to HTML elements. The H is from heading, and every time you press the letter H, you will move to the next heading. If you do Shift, okay, you go back, and if you do the B, you jump from button to button, and the E from edit field and the X for checkbox, and stuff like that. If you have the correct HTML elements, it's probably pretty good accessible. But if you make a graphic that looks like a button, but it isn't an HTML button, for me, it isn't a button. The same is, for example, if you program an input field, you can associate a label to that edit field so I know what the purpose of the edit field is. But sometimes people visually put on the left side \"first name: colon\" and then an edit field, but it's not an attribute of the edit field itself. Then for me, it's just an edit field, and I have no idea what I need to put in. \n\nThings that are difficult are if you move around things every time you visit the same website because I have to reinvent where everything is. Or if things are changing dynamically without telling the screen reader, that's a new thing that I think happens a lot. I don't know if you often go to,",
    "lJGSKb9AuGg": "Welcome to the Real Python Podcast. This is Episode 206. How do you start adding unit tests to your Python code? Christopher Trudeau is back on the show this week, bringing another batch of PyCoder's Weekly articles and projects.\n\nWe dig into a recent tutorial by Leodis Foon Ramos about writing unit tests using Python's unit test framework. The tutorial covers organizing your tests, exploring assert methods, creating test fixtures, and debugging failing tests. We explore a collection of Python data visualizations and tutorials from the Python Graph Gallery. The website features hundreds of charts and graphs built using popular plotting libraries. Each chart type features a foundational tutorial that introduces the structure and application.\n\nWe also share several other articles and projects from the Python community, including a news roundup, the new REPL coming in Python 3.13, a Pacemaker to 10x test iteration speed, a discussion about software friction, a Raspberry Pi document scanner, and a project for controlling time per iteration.\n\nAlright, let's get started. The Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at Real Python.\n\nAfter the podcast, join us and learn real-world Python skills with the community of experts at Real Python. Hey Christopher, welcome back.\n\nHey there. Alright, so we have our typical lineup this week: a few news items, a handful of articles, a discussion, and some fun projects for people to try out. You ready to dig in?\n\nYeah, sure. The two pieces of news are both from the Python Software Foundation. First up, there are three seats coming available on the PSF Board of Directors. Nominations open up on Tuesday, June 11th, and run until the 25th. Voting starts on July 2nd and runs until July 16th. So if you're interested or you know somebody you think should be nominated, you've got some time to get that happening. And if you want to know a little bit more about the board or the PSF itself, a good way to do that is through the PSF Annual Impact Report. The 2023 version has just been released. The report covers highlights from the foundation in 2023, financial reporting info on what's intended in 2024, and we'll link to the report and instructions on how to run for the board in the show notes.\n\nSo my first one is a Real Python one, and it's from our friend Leodis Foon Ramos. It's about using Python's unit test and the subtitle is \"Writing Unit Test for Your Code.\" It is a deep dive into everything you can think of here, which is great if you don't have a background in testing. Little bit of suggestions here for using unit test: you should have some background in object-oriented programming as far as how this framework works, a little bit about inheritance, and definitely lots of assertions going on. It may help if you have a little bit of background in testing, even maybe using doc test, for example. Otherwise, this article is very comprehensive. It goes through all sorts of different layers of what you can do and sort of expect as you work with it.\n\nIt starts with organizing your tests using the test class, and he takes you through setting up a test for a particular function. In this one, it's one that categorizes ages, and so that's his example there, creating a sub-class or test case and then using the assert equal and then kind of using different input values with how they would correspond to different results. He shows you how to create a test not only for equals very specific values, but also how to create tests that would cover the edge cases or boundary cases. You know what, in this case, this age classification thing, there's a cut off between age nine and ten, and so he has a couple examples of showing like how you could test for both of those. He covers the pros and cons of this idea of having lots and lots of assertions going beyond that, giving you kind of this background. He also dives into how to run the tests properly, setting them up and then running them in the command line and the types of flags you would use for like verbosity and things like that.\n\nI really liked how detailed it is in the article, not only showing you creating these tests and running them, but again with the expected output either simplified or verbose. His next section is on how to skip tests. The framework has a set of decorators for that. At unit test.skip, there's a at unit test.skip if you want to make sure it's running a particular version of Python or higher, maybe it's not on the right platform. Then he digs into unit test subtest. There's an exploration into the available different assert methods. There's lots of them. So everything from again, assert that something's equal, assert something's true or false, there's the identity stuff, assert is, is not, is none, is not none. And then remember, MHP tests, so like you're checking to see if something's within some type of collection, like assert in a dictionary or assert as an instance of something. Then there are testing to make sure that your exceptions are running correctly, assert that it raises. There's also kind of an advanced one, assert raises regex, a couple things for warnings, and how you can create a custom assert method. This is about the halfway point of this very, very detailed thing, so I'll kind of just gloss over some of the rest of it, but it's a powerful library for testing that's built into Python. He covers from then on grouping tests and creating a test suite class, there's test fixtures, so the idea of having your test have a setup phase and a sort of a tear down phase, and making sure that there's the proper data or collections that you need to be testing inside of that to make sure that that setup, even, you know, standing up a database or something like that. Tips on debugging tests that are failing and then some details on mocking. So there's a bunch of reasons why you may want to learn unit tests. The most popular thing that you hear in the Python community is about a library called Pytest. In fact, we might talk about it a little bit later, but unit test, again, there are great reasons for using it. You don't need to add any additional library to what you're working on. It comes with Python, it's built into the library. It's very well documented and integrated into a lot of the IDEs because it's again part of the language, which is nice. And it's the default testing framework for lots of different projects like one of the ones we talk about a lot, which is Django. It definitely builds from unit test, which is nice, and it features a shiny new quiz to go along with the tutorial so you can test yourself about the knowledge you've learned about testing your code. Thanks, Leodis.\n\nThe unit test help file on the web for Python has one of my favorite little bits of Python in it, which is a link at the top which says, \"If you are already familiar with the basic concepts of testing, you might want to skip to the list of assert methods.\" So they kind of know that the reason you're going to this page is actually for this table that's buried about a third of the way down. There's a lot of them. Yeah, there's a quick link at the top basically saying, \"Hey, yeah, and if you're here just to look up which one of these is and how it's spelled, I find the assertion methods are frustrating because they're older and so they don't use snake case. So there's always that, \"How is it? How where is there a space in this? Isn't there a space in this? How am I supposed to do this?\" right? Yeah, they're all sort of camel or whatever the case. Yeah, they're that sort of mixed camel case kind of thing going on. If you're interested in test articles as well, the gentleman at Bike Code has been writing a series. He's now up to part five, I think, and he also covers unit tests as well as sort of the bigger picture pieces as well. I'm planning on linking to his latest post in the next PyCoder's Weekly, which will have been the previous PyCoder's Weekly by the time this is posted. I'm from the future, however that works. And he gets into things like the difference between unit and integration and the fact that there's people out there that say this is that and it's not this and he's like, \"Yeah, except then you can always find someone else who contradicts that.\" So he's got a great beyond just the libraries, but also sort of the concepts of testing and how to think about it. And of course, because it's a Python site, all the examples are in Python. So yeah, we'll link to that one as well. So okay, great. So what's your first one here?\n\nI've got a combo, and it starts out kind of from the fact that Python 3.13 has just gone into its first beta release. The beta is where feature lockdown starts, so to go along with it is sort of a mostly finalized version of the official \"What's New in Python 3.13\" doc. Between now and the release in October, I'm sure you're going to see plenty of articles, but here, so you can hear it here first, a quick set of summaries. An experimental JIT compiler has been added, which will be off by default, hence experimental. There are a few new additions to the typing system, experimental support for removing the GIL, Apple iOS has officially been added as a platform, and Android is in the works. Unclear as to whether that'll be a 3.13 thing or not. I'm not 100% sure. A bunch of the remaining 19 dead batteries that were scheduled to be removed have been removed. And then the last one, which I'm going to spend a little more time talking about is a bunch of new features have been added to the REPL. And that leads me to the second part of my combo, which is Trey Hunter's article, \"The New REPL in Python 3.13.\" Where Trey gives an overview of all those features that are included. For those of you who use alternate REPLs like IPython or PT Python or one of those, a lot of this is going to seem like, \"So what?\" For folks like myself who just never got around to switching, a lot of the features are very IPython, be Python-like, and they're now going to be in the default REPL, which is a big win for those of us who don't install the alternatives. So for example, colorization has been added for those terminals that support it, making it clearer what's prompt and what's code. If you ever typed \"exit\" in the REPL, only to get a message telling you knew you were bad and you should type \"Ctrl + D\" instead. If that caused you to scratch your head and wonder if they knew what you meant, why couldn't they just do it? Well, in 3.13, it just will. It will exit. And the big one, which I think is going to make a big difference for me personally, is block-level history. So in the current REPL, you can only go back line by line. If you want to make an edit or something like that, that can be quite painful if you've made a mistake like halfway between a for loop. Now it will allow you to do this at the block level, and that's a big win.\n\nThis feature is in several of the alternatives, so like I said, so what? But for those of us who aren't, if you were in the eventually, I'll install an alternate, well maybe now you don't have to. Quick note is that the changes are based on the curses library, and curses has not yet been ported to Windows, and so it's up in the air as to whether or not this is going to make it into the release for the Windows version of the REPL. There is some discussion about how they're going to do this, but no promises have been made yet. There's even a rumor somebody might actually try to properly port the curses library to Windows so that they could do it, and then you get two wins. But that's still a rumor. Curses is good on Linux, Mac, and so forth, so it could work for the subsystem. It should work on the subsystem. I believe it's based on the ANSI terminal sequences, so like anything that's the old VT100 forward stuff should work. But the little DOS box that Windows, what do they call the command prompt? The little bit of history built into the middle of your operating system doesn't support it properly.\n\nOkay, there are libraries out there for trying to get curses-like things working in Windows. In fact, we've come across a couple of them in some of our courses, but they're not part of the standard the way curses is. Alright, well excited to check it out, and of course Real Python's going to be covering 3.13 in more detail. So if any of those things pique your interest, I'm sure there are going to be several articles rounding out the summer into the fall. And maybe a few guests again this year, along with our annual podcast episode and video course. So my next one came across as a singular article that was called \"Best Python Chart Examples.\" And I decided to dig deeper beyond just these sort of chart examples and look at the underlying site. The underlying site is called the Python Graph Gallery, and it's managed by Yan Holtz. Yan is a big fan of data visualizations and has been gathering all of these different examples of graphs and charts. These are all ones made with Python and use a variety of the libraries that we've talked about on the show. Things like Matplotlib, Seaborn, and so forth. What's cool is each of the examples has corresponding reproducible code, along with sort of deep explanations to what's happening. If you're interested in getting into data visualizations or you want examples that you can kind of take and jump off of, this is a really great site. Most of the examples are not the super vanilla types of stuff. They're much more advanced and have very pretty examples. Stuff that you would see on very fancy websites. Things like the New York Times or other places like that, and then also things that you might have seen in print. I'm very impressed by them. They also have a set of tutorials to get beginners started, and they work from the basics up to the very advanced data visualizations.\n\nI mentioned a couple of the libraries, but Matplotlib is one very heavily covered. Seaborn, the Matplotlib types of features that are built into Pandas already, Plotly, which I've mentioned a few times in here, which is a nice hosting platform along with the features of charts and graphs inside of it, and then Plot9 that I've mentioned a couple times. I want to mention two just briefly that grabbed my attention and I thought were really kind of interesting and I don't see covered very often. The first one was animation being done in Matplotlib using something called FuncAnimation. This one has an animation with text that highlights these important events as the stacked area chart moves along. It also has persistent text and underscores like these sort of pivotal moments with these lollipop little things appearing. The plot is an animation that displays the evolution of objects launched into outer space by the USA and Russia between 1958 and 2023. There's something I've mentioned a couple times on the show as a data kind of like a data meetup type of thing. It's called Tidy Tuesday, and I'll try to provide a link for that also, but that's a common thing between the R and Python communities. So this was one of the ones that was made for a Tidy Tuesday challenge. Lots of steps, it's very detailed. I think it's a really effective way of sharing this information.\n\nIt uses Pandas, NumPy, and then a little bit of Pillow for this thing called Image Sequence, and then again uses the FuncAnimation thing that's part of Matplotlib animation. The other one that I thought was really interesting is a Sankey diagram, which I'm not that familiar with, but when I saw it right away, I was like, \"Oh, this is really interesting way to show information.\" I think these are really cool, but I feel like they could get really noisy depending on how much information. And I guess that's true of any chart or graph or data visualization. You have to be really careful how you want to do that. I added a link that you can check out for Sankey-diagram.com, which has lots of examples. It doesn't look like it's been updated a lot since 2021, but I grabbed a couple of definitions they gathered on the site. The first is that sort of a subheading, a Sankey diagram says more than a thousand pie charts. The Wikipedia definition of it is, \"A Sankey diagram is a specific type of flow diagram in which the width of arrows shown is proportionally to the flow quantity. They are typically used to visualize energy or material transfers between processes.\" And then from the chemical engineering blog, \"A Sankey diagram is a directional flowchart where the width of the streams is proportional to the quantity of flow, where the flows can be combined, split, and traced through series of events and stages.\" So this one is a Plotly documentation. It seems like Plotly maybe has the best library for doing Sankey stuff. It has a function for that and handles lots of the business logic that you would need there. It includes a very detailed blog post linked with not only the data and describes all the customization code and so forth. This one is an energy forecast for 2050 from the Department of Energy and Climate Change. Very cool chart, lots of neat examples there. I was just impressed by the collection again. If you're interested in data visualizations and want to play around with some different tutorials, the Python Graph Gallery, and for the anal retentive or if you're Googling this, it's S-N-K-E-Y-S. Yeah, is that how you pronounce it? I'm guessing. Yeah, it's it just it sounds like there might be a D in there. It's actually named after an engineer who came up with it back in the 1880s or something like that. So yeah, it could be like Sankey. Yeah, it could be the other way. You might pronounce it. Yeah, it's it's it just it sounds like there might be a D in there. It's actually named after an engineer who came up with it back in the 1880s or something like that. So yeah, it could be like Sankey. Yeah, it could be the other way. You might pronounce it. Yeah, it's it just it sounds like there might be a D in there. It's actually named after an engineer who came up with it back in the 1880s or something like that. So yeah, it could be like Sankey. Yeah, it could be the other way. You might pronounce it. Yeah, it's it just it sounds like there might be a D in there. It's actually named after an engineer who came up with it back in the 1880s or something like that. So yeah, it could be like Sankey. Yeah, it could be the other way.",
    "QZp7BPcYXmY": "Welcome to the Real Python Podcast. This is episode 207. How do you effectively break a software problem into individual steps? What are signs you're writing overly clever code? Christopher Trudeau is back on the show this week, bringing another batch of Python's weekly articles and projects. We discussed an article about dewarping images of book pages. We both found the piece a good study on decomposing a complex software problem. Christopher discusses an article titled \"Clever Code is Probably the Worst Code You Could Write.\" Early in a programming career, it's easier to write complex and difficult-to-read code. The real challenge is progressing towards writing cleaner and readable code. We also share several other articles and projects from the Python community, including a news roundup, what the \"dunder py cach\" folder is for in Python, what's new in Django 5.1, a discussion about software engineering hiring and firing, and a simple way to create reusable template components in Django.\n\nThis episode is brought to you by Sentry. Fix application issues before they become downtime with Sentry error and performance monitoring for Python. Alright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at Real Python. After the podcast, join us and learn real-world Python skills with the community of experts at Real Python. Hey Christopher, welcome back.\n\nHey there. It's a very short break here. We had an extra week of articles, and so I felt like, well, let's go ahead and talk about Python a little bit more. We have some news, kind of post-PyCon news stuff, and then our typical topics and discussion and projects as usual this week. So I'm excited to dig in. What do we got for news?\n\nStarting out, a couple of pieces of news around PEPs. The first one is PEP 667, which got marked as accepted and is targeted for Python 3.13. 667 is titled \"consistent views of namespaces\" and this has to do with how namespaces are stored in Python. Evidently, in early versions, everything was in a namespace dictionary, whether it was a function, class, or module. Everything was in the same space. Over time, for performance reasons, this kind of got changed. Right now, if you call locals and compare that to frame.f_locals, you may not actually get the same answers. This inconsistency is both confusing and has caused some bugs. So 667 essentially aims to fix this. The other PEP change was 649, which is deferred evaluation of annotations using descriptors. This one has to do with how and when type annotations get calculated and the timing of this process deals with forward references and circular reference type problems. Currently, annotations get stringified to essentially get around these circular reference issues, but this PEP proposes a new on-demand lazy evaluation mechanism. It's gone through the cycles a few times and this is now being punted forward to Python 3.14, PII. We're starting already. And the last little bit I want to mention isn't quite news, but isn't quite a full article, so I'm going to stick it here. The closing keynote speaker for PyCon US was Suwanna Hary, Haris Suara, who tackled the rather large topic of packaging in Python. I don't know if her talk is live yet. I haven't found it, but in connection to the talk, she created a big list of links having to do with the history of packaging in Python and a bunch of other good stuff. So if you're looking for things to read, there's a whole bunch of diving off points here. And of course, we'll link to the collection in the show notes. Yeah, there's a bunch of previous talks on the topic. Looking forward to watching it. And I was just checking YouTube, so maybe by the time this comes out, they'll be live, but not currently at recording time. So soon. All right. Well, that gets me into my first topic. This is from previous guest and Real Python team member Bartag Jinsky. And it's kind of a funny one. If you're new to Python, then you might have this question. You might run your code once and go, \"Hey, why are there new files here?\" Depending on what you're working on, some IDEs actually hide this from you, so you may not ever see them at all. But often, if you're just running it and you look at the folder, suddenly there's this \"Dunder\" or \"double underscore\" \"pyc\" folder, along with that inside that folder will be these named \"pyc\" files. And you might think, \"Well, why did this happen? What's going on here?\" If you've been around in Python for a long time, then you are probably familiar with this, and you might have actually had to create a \"git ignore\" file to make sure that these things don't get added to your git repository. This article goes into to explain that answer that question, what is the \"Dunder pyc\" folder for in Python? It actually works in a set of these things. What causes the \"Dunder pyc\" folder to appear and for what purpose? He has a heading, literally that's titled, \"In short, it makes importing Python modules faster.\" So Python, as we've talked about often, is an interpreted language, so the interpreter doesn't directly operate on your Python code when it runs your script for the first time or it imports a Python module. The interpreter compiles the high-level Python source code, the stuff that you actually wrote, and makes it into bytecode, which is an intermediate binary representation of your code. Bytecode enables the interpreter to skip redoing that process again and again, processes like lexing and parsing the code into an abstract syntax tree, validating that it's correct every time that you run the program. So if you've made no changes to your code, this process doesn't have to happen again and again, and so it kind of speeds it up a little bit. He then has a little heading on there, which is like, \"Well, how much faster is loading modules from the cache?\" And it's kind of interesting. There is a Python function you can run when you run your code, and it's got a interesting name, \"import time,\" all one word. The first run he was able to show that it's like two orders of magnitude slower. Now this is on a very small program, like only a handful of lines, so I think it might vary on that. Your mileage may vary depending on your program. The difference might be then, \"Okay, that was like how long it took to import.\" His other time measurement that he does is the total execution. It's kind of nominal. It's not a huge change. Realize that this is done again in the process of parsing and lexing the code and creating it. He digs into a whole bunch more details underneath that. If you are interested in this topic and want to know what's happening under the hood, he's got headings for, we mentioned already kind of what's inside the \"pyc\" folder. That's one of the headings. The \"pyc\" files and what they kind of stand for in this idea of the compiled Python module. When does Python create the cache folder? He has questions here about what actions invalidate the cache, like again, changing your code or maybe try and reproduce it. Is it safe to remove these cache folders? Short answer: yes, generally. How you can recursively remove all cache folders and then prevent Python from ever creating them. How to read and execute the cached bytecode itself. And then he wraps up with \"Do a disassembly of that cached bytecode.\" So it's a real deep dive onto a question that a lot of beginners would have when they look at Python as they run it and wonder what's happening under the hood. It's definitely instructive on all those levels. And then again, if you are really interested in language-wise of what's happening here, I don't know if you had that experience at all when you ran Python code for the first time and said, \"What is this stuff?\" Well, I've come from other interpreted languages, so I was expecting something somewhere. And in fact, so \"Dunder pyc\" was introduced in 3.2, and before that, they just littered your same directory with pyc files. And so \"Dunder pyc\" was nice because it cleaned up your directory. You don't have two of everything. And I have in the past accidentally deleted code because I was trying to delete the object file and tab completed the wrong thing. So having all of that in a directory where you can just blow the directory away is convenient. So yeah, again, you can generally ignore the folder. Yeah, pretty much as far as what's happening with it. It's just stuff that's happening behind the scenes. It's funny that the IDEs and such automatically hide them for you.\n\nFix application issues before they become downtime with Sentry error and performance monitoring for Python. One engineering leader that used Sentry said the time to resolve errors went from days to minutes. Whether you're taming Python's processing power or controlling JavaScript's flow through Node.js backend infrastructures, they're as complex as they are valuable. With Sentry, you can trace issues from the front end to the back end, detecting slow and broken code to fix what's broken faster. Within minutes after installing Sentry, software teams are able to trace Python performance issues back to poor performing API calls, as well as surface all related code errors to fix what's broken faster. Installing is just five lines of code, and Real Python listeners get three full months of the team plan for free with the code \"realpython\" on sign up. Check it out at sentry.io.\n\nSo what do you got next?\n\nWell, software just keeps rolling along, and one piece included in that is the next version of Django, 5.1. The alpha for this release just came out, and I've got a good summary article from Jeff Triplett on what is included in this new release. Although Django uses release numbers that look like major minor, they're actually closer to a calendar pattern, so what goes in the next release is mostly what's ready and time for that release. 5.1 doesn't really have any huge changes, but there is some good stuff in here to look forward to. A big selling point of Django is its ORM, which is a class-based abstraction for databases. It's kind of like SQLAlchemy, but Django's got its own. So let's say you've got a person class with a first and last name that gets mapped to a table in the database with three columns, one for the first, one for the last, and then a numeric primary key for a unique ID. To go along with this ORM is the Django admin, which is a web-based tool that is built using Django to administer these kinds of ORM classes. So if you want your person class to be in the admin, you create another class, which would be the person admin class, and you set up a few attributes to indicate how the class shows up in the web page. One of these attributes is called list display, which takes a tuple, and that tuple determines what columns show up in the listing on the page. So if I go to the person page, I see all of my people, and if I don't define list display, I just get what comes out of dunder string. If I do define list display, then I can have the attributes like first name and last name showing up on the page. The new feature is that this attribute is now going to support dereferencing. So say you've got a person class that has a foreign key to the person's father. With the new feature, you can now reference the relationship to populate columns. So you could have the person's father's first name in a column on the person page. This kind of dereferencing is actually supported in a whole bunch of places in Django. Just up until 5.1, it wasn't supported here, and a lot of people who were writing Django admin classes had to sort of do little hackish extra stuff or do it manually. And now it's going to be built in. So that's nice. I find I use this. I do the manual version of this all the time. So having it built in is going to save me code, which is always what you're looking for with features, right? Another key part of Django is the template engine. The engine supports tags that perform actions or that get replaced with information. 5.1 has introduced a new tag that is going to make it easier to deal with URLs that have query parameters in them. So if you've got the little question mark, view equals bar kind of thing, this tag will help you deal with that and it allows you to treat those parameters as sort of an object. So if you need to take those parameters and pass them to a URL or read them or change them in a new URL, this little tag will help you do that. Essentially, what it's going to do is save a whole bunch of the parse this and then redisplay it kind of stuff. So again, nice little shortcut. And then the last feature that Jeff talks about is the login required middleware. When you visit a URL handled by Django, Django maps that to a function or class which outputs the resulting content. Typically a web page, if you're doing an API, it might be something else, but typically a web page. So these functions and classes are called views, and if you want to put a view behind an authentication wall, the default way to do this is you decorate it with the login required decorator, and then Django takes care of forcing to check whether or not the person is authenticated. For a lot of sites, more pages have to be behind the authentication wall than aren't, and so there's always this potential flaw of having to remember to decorate every single view. Otherwise, you might accidentally not put it behind the off wall. So the idea behind login required middleware is it sits in front of a view, and as its name implies, it basically turns it so that all views now must be logged in. So to go along with this new middleware, there's also a new decorator that's called login not required. So essentially, this puts it on its head. So if your site should be behind the off wall, using this middleware and then marking things that aren't needing login is the safer approach. So security by default essentially. Okay, so there's lots of other bits and pieces, and Jeff closes out by linking to the Django 5.1 release notes. So you can go in there and go spunking for some of the smaller stuff as well. But 5.1 is an intermediary release, so it won't be part of the long term support package. So they just don't tend to have a lot of changes in it, but there's some neat little stuff in here that it'll make worth upgrading. Do you feel that that would save some effort on your part, that the public usually only needs like two or three of these pages viewable versus like the organization should be able to have more? I'm more concerned with the developer mistake. Them not adding, required, yeah. Forgetting to put the login decorator on it, right? I've built unit tests in the past where... where it was essentially... there was a list of the views that were public. And... and... and the unit test would check, \"Is this required?\" And if it didn't trigger a login page, it had to be in the green list. And if it wasn't in the green list, then the test failed. Right? To... because I was worried of exactly this, that one of my programmers was going to forget to decorate something and then the next thing you know, you're exposing stuff that's not supposed to be, right? And in fact, this is... you know, one of my complaints... I haven't played with it in a while, so I'm... I should be careful with this... it may have been fixed, but one of my complaints with some of the permission stuff in the DRF is the same kind of thing, that it's sort of this... the... the default is allow. And I would much rather the other way around, the default should be not allowed and then you should have to go through hoops to say this is public. The consequence of accidentally not making it public is you piss off a couple users. The consequence of making something private that shouldn't be is lawsuit and all sorts of other, you know, nasty stuff. The reverse, yeah, exactly. So, secure by default is my preference architecturally. So this to me is a step in the right direction. Yeah, that's good. Yeah, hopefully we'll save a lot of effort and maybe make the testing slightly easier. Some ways cool. Alright, well, my next one is by Matt Zucker. It's an article that's titled \"Page Dewarping\" and I want to mention two things right out. This is from 2016. I didn't notice this until I went to the main page for the blog. Some of the libraries and potential computer vision tech and techniques probably have moved forward. The second is that the blog is kind of hilariously called \"Needlessly Complex\". The subtitle for the site is \"Why do it by hand if you can code it in just quadruple the time?\" So the story that kind of precedes the whole article is his wife came back from the library with a number of images where she was taking pictures of books and the images were significantly warped due to the curling of pages. You know, like if you laid out a book on a table, which I think a lot of us have done to just take a picture of something, if you don't have help with that, you end up rarely getting them to be flat. And so",
    "e1P7q-YKt-I": "Welcome to the Real Python Podcast. This is Episode 208. How do you find the most interesting or suspicious points within your data? What libraries and techniques can you use to detect these anomalies with Python? This week on the show, we speak with author Brett Kennedy about his book, Outlier Detection in Python. Brett describes initially getting involved with detecting outliers in financial data. He discusses various applications and techniques in security, manufacturing, quality assurance, and fraud. We also dig into the concept of explainable AI and the differences between supervised and unsupervised learning. Today's episode is brought to you by apilayer.com, your go-to API Marketplace for seamless integration and reliable APIs. Alright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at Real Python. After the podcast, join us and learn real-world Python skills with the community of experts at Real Python. Hey, Brett, welcome to the show.\n\nHi, thank you for having me.\n\nChristopher Trudeau, who's writing a book for Manning, also reached out and said that you might be interested in coming on the show to discuss outlier detection in Python. I thought that would be fun to have you come on the show and discuss it. Maybe you could describe a little bit about the book that you're writing.\n\nSure, yeah. It is a book about outlier detection, kind of generally. The focus of the book is on tabular data. So we get a little bit into time series data, image data, tax data, some other modalities a little bit. But the focus of it is working with tables of data and trying to find the interesting records in there, the nuggets, the values that are interesting for one reason or another. They might indicate an error, they might indicate fraud, or just something new and interesting in the data.\n\nHas this been a long process? Like, why did you get interested in writing the book?\n\nWell, my working with outlier detection has certainly been a long process. I've probably been about seven or eight years working with that. The book itself is probably about a year. I mean, it is a major commitment just the amount of time you spend thinking about outlier detection and coming up with good examples of everything. And, you know, I reread, I don't know, dozens probably over a hundred papers just to make sure I wasn't saying anything incorrect in",
    "WHavH1bkgkw": "Welcome to the Real Python Podcast. This is Episode 209. What are the built-in Python modules that can work as useful command line tools and how can some of these tools add more functionality to Windows machines? Christopher Trudeau is back on the show this week bringing another batch of PyCoders Weekly articles and projects. Christopher shares an article by Trey Hunter about Python's extensive collection of command line utilities. The piece digs into general purpose tools that format JSON data or start a simple web server, and additional utilities for working with your Python code from the terminal. \n\nWe cover a set of Jupyter notebooks for teaching and learning the art of music processing and music information retrieval. The notebooks are resources for working through the textbook \"Fundamentals of Music Processing\" which covers audio analysis algorithms and applications. We also share several other articles and projects from the Python community, including a news roundup, a discussion of CRUD operations, a description of Python's built-in byte sequence, favorite essays on development and programming, Python resources for working with Excel, and a project for creating finite state machines in Python.\n\nToday's episode is brought to you by apilayer.com, your go-to API marketplace for seamless integration and reliable APIs. Let's get started. \n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at Real Python. After the podcast, join us and learn real-world Python skills with the community of experts at Real Python. \n\nHey Christopher, welcome back. \n\nHey there, all right. So we have our typical lineup. We've got a few news items, obviously about releases and things like that, and then a set of articles, discussion, and projects as usual this week. So I'm ready to dig in. You ready to go? \n\nYeah, sure, like you said, it's another week and more release news. \n\nSo it starts off with Python 3.12.4, which includes over 250 bug fixes. I never know what to do with that number. Should I be impressed that much work was done? Should I be disappointed that that much work needed to be done? I don't know. Yay software. Forget death and taxes. The one certainty in life is finding bugs and new releases. \n\nFrom our good friends at the PSF is Python 3.13 beta 2. The endless march towards October continues. Alright, the other piece of news also from the PSF, but not a release, is they rejected PEP 712. This PEP had proposed adding a new way of telling third-party libraries that we're converting a data class into some other kind of object what to do during this conversion. The primary reason given by the steering council for rejecting it was they couldn't come to a consensus as to whether or not the feature was needed in the standard library. I don't have a in this fight. I kind of got what it was for. \n\nThere's a drive towards using data classes and interacting with things like pandas and Django where they have data class-like things and could we unify all of this? There seems to be a group of people who are like this should all be one thing and there's another group of people who are like don't touch it. Okay, I think this PEP is kind of somewhere was trying to address some of that. The only thing I found a little odd about this one was it had been slotted for 3.13. Usually you see the rejection happening before that happens. Particularly considering we had already passed the alpha phase which is sort of code-freeish or feature-freeish. So I found that a little odd but uh anyways further notes are available in the PEP if you want to dig in as to why this got punted. \n\nSo there's some details there, and then finally, seeing as it's almost the top of the hour, it's time for a little blatant self-promotion. Yay, that's right. I'm happy to announce that finally my book Django in Action has been launched. Full copies are available currently at the publisher manning.com or if you prefer to use Amazon, it's in pre-order at the moment, and their big pile of dead trees begins shipping July 9th. So in case you haven't heard me yammer on about this before, the book is aimed at folks who know some Python but want to pick up the website of things. It's divided into three parts. Part One teaches you the foundations of Django, including how URLs map to views which put the pages, the Django template engine, and the ORM database abstraction. Part Two dives deeper into what the framework gives you to build bigger sites, talks about how to deal with multi-user sites, user-submitted data including forms and uploads, how to write management commands, and more. And then Part Three introduces you to the wider world of Django third-party libraries, including how to use Ninja to write APIs, how to integrate HTML into your Django site to create dynamic pages, and how to use tools like Django Debug Toolbar and Django all, which of course is mine. You see what I did there? I put self-promotion in my self-promotion. So there it's ego all the way down, a little sandwich. \n\nFor those who participated in the Early Access program, I'd really like to say thank you. First for your trust in me back when this was still a rough first attempt, and second for your invaluable feedback. And that goes doubly for the readers who are part of Manning's internal review process. If any of you are listening, the book is definitely better because you gave me your time, and I appreciate that. In celebration of the launch, Manning is offering our listeners a discount. Details, a link, and a promo code will be in the show notes. Alright, so and finally to you, Mr. Bailey, thanks for the quote on the back cover. \n\nYou're welcome, and your tolerance of me littering your podcast with my self-promotion. \n\nWell, I thought I could do this really fantastic transitions. The next piece is about CRUD and which you're bringing up because I cover it in the book. \n\nYes, yeah, absolutely, there we go, perfect. We love to talk about CRUD on the podcast. Yeah, so jokes aside, this is a piece, a real Python tutorial that's from a previous guest and real Python team member, Phil Eksun, and it's titled \"What are CRUD operations?\" We've talked about CRUD a bunch of times on the show. If you're not familiar with the phrase, this is a good term for you to know, especially if you're a beginner and you're interested in databases. I feel like this tutorial is intended for intermediate devs, but if you're a beginner and you want to dig in, and this is one of the areas you want to work with in databases, the acronym CRUD stands for create, read, update, and delete, and these are the primary things you would do with a database when you access or interact with a REST API. And all four of these operations allow you to complete sort of a data round trip within your apps. \n\nAfter a short introduction, Philip uses one of our newest hallmarks in our tutorials that answers that question that the title poses, what are CRUD operations? And so there's a heading, in short, CRUD stands for create, read, update, and delete, and then goes and defines each one of those things. He has sections that dive in a little deeper here. I like the brevity of this particular tutorial. It's very much, let's get you in play with it, do some Python with it, and then out. And it manages to cover more things than I thought that it would get into. He starts with why are CRUD operations essential and then how do these map to SQL, the same sort of names that you would see for as far as SQL statements. And then to play with that, you actually do some stuff with SQLite, which is built-in as part of the standard library, which is nice. So you execute a few CRUD operations there, you get the code, and can kind of play with it. And then he has you execute CRUD operations taking you to that next sort of level of abstraction, which is with SQLAlchemy. If you're interested in dealing with objects as opposed to dealing with individual SQL statements, this allows you to do that and gets you introduced to something Christopher just mentioned, an ORM, object-relational mapper. This is another very popular one. In fact, shout out to Mr. T, he has a course that covers not only the SQLite portion that we're talking about here, but also SQLAlchemy in Python. It's got a subtitle of \"Move your data beyond flat files,\" and so I'll include a link to that, and it was recently updated to cover the 2.0 release, so it's brand spanking current. \n\nYeah, so it has the, you know, those changes in SQLAlchemy. We had a couple comments we want to make sure that we had that new stuff in there. And then he gets into, okay, well, how are CRUD operations handled as HTTP request methods, and this is where you'll learn a little bit about POST, GET, PUT, PATCH, and DELETE, and how they kind of map to CRUD. To play with that a little further, you get to mess around with some of these operations using FastAPI. So it's a nice quick tutorial on setting up the fundamentals of FastAPI and shows a little bit about the interactive API documentation, Swagger, and displaying that. Wow, it's just a real nice one-stop introduction to many of these concepts. The acronym itself, SQLite in Python, SQLAlchemy, and then setting up FastAPI and kind of playing with it a little bit. Lots of links for you to continue further in any of these directions you start here. So nice work, Phil. \n\nAlright, what is your first topic here? \n\nMy first article is from Trey Hunter, who we reference a lot this week. He's written another comprehensive guide, this time on the command-line utilities that come with Python. We've mentioned a few of these things on the show before. These are tools that you can invoke as programs directly from a Python module. My personal favorite, the one I use all the time, is the JSON pretty printer. You take advantage of it by typing `python -m json.tool`, pass in the name of a file containing JSON, and it outputs a pretty version. The other one we've covered before is the built-in HTTP server. If you want to do some quick and dirty testing on a directory full of HTML, you run `python -m http.server`, and then visit localhost:8000, and it serves them up for you. So that's so much for the stuff that we've talked about on the show. How about some stuff that we haven't? \n\nOkay, there are a whole bunch of these utilities that are particularly handy on Windows, and I had not realized half of these were actually in there. So why Windows in particular? They're not Windows-specific, but they're things that normally come with Unix-based OSes and aren't there by default on Windows. And so if you've got Python installed, all of a sudden you can get at all this stuff even though you don't have the equivalent Unix utilities installed. \n\nFor example, you can generate a UUID, you can invoke the SQLite REPL tool, show backreference, whatever you want to call that, callback. That's the word I'm looking for. Yeah, you can play with zip files, tar files, gzip files. There's even stuff for mail, including SMTP, receiving on POP, IMAP. So there's this long list of what I would consider, you know, these are things that you have one or two-letter commands for on Unix. You don't have them on Windows, and now you've got them because Python. There are also a bunch of modules to help you with your Python in, for example, pip and venv and the pdb debugger. All these kinds of tools, you know, you don't think of them that way because you just sort of get the instructions of `python -m pip`, you're not really thinking about it as it's a module, but that's why it works that way. \n\nThe same goes for unittest. Then there are some other ones that you may not have come across before. So there's one called PyDoc, that will actually pull your documentation out of your code comments. There's another one for running the tests in your documentation, if you put tests in your docs. There's another one for making sure that pip is installed, not all releases of Python actually ship with it, depending on what platform you're on. So this will check for you. And one that I hadn't been aware of before, but there's one that will force the interpreter to compile all of the Python in a directory. And then there's the gateway drug into packaging, which is turning your Python module into a runnable zip. So it's kind of not quite getting it up on PyPI, but you can keep all your files in one place and make it runnable from the zip. So that's kind of cool. \n\nThe summary that I've just given is only halfway through the article, yeah, I just noticed that there's loads more than I realized. It's definitely worth going through this post. You might find something that saves you some time. I think my favorite of ones I didn't know existed is `py -m tabnanny`, which screams at you if you've mixed tabs and spaces in your code. This was legal in Python 2, it's now a syntax error in Python 3, but you know, don't upset the nanny. So yeah, plenty of good stuff in here. Another good article from Trey. \n\nThere's a bunch I wasn't familiar with, and gosh, so many that we've mentioned as topics across the show here. You know, things like being able to bring up an abstract syntax tree, tokenizing, the `dis` module we talked about that, yeah. So lots of kind of fun stuff as far as exploring or analyzing your Python code. \n\nGreat, need powerful APIs to boost your business? Check out apilayer.com. From scraping finance to weather data, API Layer offers reliable and easy-to-integrate APIs for all your needs. Trusted by developers worldwide at companies like Microsoft, HubSpot, Airbnb, Samsung, and more. And just for our Real Python community, use the code REALPYTHON, all caps no space, for an exclusive discount, 50% off for 3 months on 100 API plans. Visit apilayer.com today and discover how their APIs can transform your projects. That's APILAYER.com. \n\nMy next one is titled \"Notebooks for Fundamentals of Music Processing.\" The oddness of that title is I have to preface this; this is a collection of resources for a book. It's not the book itself. The book is available for purchase if you'd like, but these resources are available for those that want to explore this topic and try out techniques using Python, Jupyter, and so forth. The book is titled, again, \"Fundamentals of Music Processing.\" It's this one would have a subtitle of using Python and computer notebooks. It's by Maynard Mueller. The second edition came out in 2021. The first edition was in 2015, and it didn't include any of the Python code and resources. \n\nThe link that we are including is to the FMP notebooks, and there are 10 of them. Though that's sort of a misnomer in the sense that there are several sub-notebooks in each of them. They're presented in two formats. The first is a rendered HTML format, so you know, truly you can just read them. And then as an IPYNB, that's hard to say, interactive, you know, IPython notebook, Jupyter notebook, if you will. And the HTML version has the flow charts, audio files for playback, visualizations, all of that rendered out, so it's ready to go just as a readable notebook versus the interactivity of the Jupyter notebook, which you can stand up. \n\nThe first one, the B, is titled about Basics, getting started. They kind of want to give you this buffer depending on where you are in your journey here. So like, okay, what is Python and doing some basic Python programming. And then it has Jupiter framework, Anaconda, a little bit about visualizations, and links to dive into all that sort of stuff, and then some basics about general audio and MIR resources. It's a real catch-all for people that need more information before they dive into the core of these other notebooks. \n\nO is an overview of the notebooks and the websites, and then it digs in. The first is about how music is represented, and so it talks about notation, MIDI, and digs in much more about just the fundamentals of how over time we've represented music. And then gets deep into the analysis of signals. The third is about music synchronization. The fourth is about music structure and analysis. And the one I decided to dig into, since I was mainly doing research and just trying to learn a little bit about this as a topic this week, I spent my most time here, which is the fifth one is about chord recognition. It was a deep dive for me, kind of plopping right here and trying to figure out where am I, what are we looking at? \n\nIn it, it's fascinating. There's this whole idea of creating a set of vectors to analyze the 12 pitches that are in the chromatic Western music scale, and the tools that you're going to use. You're outputting this graph, it's called a chroma representation, and in a chroma representation, you're seeing these vectors of where the energy, you know, that the music has been sampled and analyzed on, and you can kind of see the individual notes that make up a chord inside there. And then with that visualization and with that data, you can then compare it to a collection of known chords through sort of templates, and you're doing this template-based chord recognition pattern matching, identifying, oh, that looks like a C major or a C minor or a B flat 7th or something like that. How does it deal with harmonics? In chapter two, they talk a lot about the Fourier analysis of signals, and so you're in that process figuring out what are these root notes and the harmonics that are built on top of it, right? \n\nAnd there's actually a really cool shared chapter that you can learn all about that process. It's kind of like in a nutshell for your transforms and kind of like looking at it. I didn't get all the way through it as I was doing my research, but it was like, okay, it's some ugly math. Oh yeah, it's really interesting stuff. Yeah, and they use the first chunk of \"Let It Be\" which is by the Beatles, interesting piano introduction to do this, and so it has a few flourishes right as they're playing the chords as it's kind of passing the notes to play through the chords. But generally it's four chords: C, G, A minor, F. And then it repeats CGFC with the music playing and looking at the visualizations, it really did a good job of kind of explaining these ideas. And then goes to the sub-notebooks for this section go much further, and you're creating a hidden Markov model, an HMM, based chord recognition pattern matching. So I really just scratched the surface, and this is if you are interested",
    "spbt85ugRKs": "Welcome to the Real Python Podcast. This is Episode 210. What techniques go into synthesizing a guitar sound in Python? What higher-level programming and Python concepts can you practice while building advanced projects? This week on the show, we talk with Real Python author and core team member Bartos Jinsky about his recent step-by-step project to build a guitar synthesizer, play musical tablature, and Python. Bartos shares how he built an early prototype of the guitar synth using a different language. He describes recreating the Karplus-Strong algorithm in Python to create pluck guitar sounds. We discuss teaching advanced Python concepts while guiding readers through constructing a complete project. We also dig into reading and writing wave files in Python using Spotify's pedal board library, implementing poetry in a project, and designing a file format for guitar tablature. This episode is sponsored by Mailtrap, an email delivery platform that developers love. Try it for free at mailtrap. Alright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at Real Python. After the podcast, join us and learn real-world Python skills with a community of experts at Real Python. Hey Bartos, welcome back to the show.\n\nHey Chris, it's good to be back. Yeah, we had you, I don't know, maybe a couple of months ago, but you've been very busy writing a couple of interesting projects that definitely are up my alley. You did two articles that are sort of deep dives into the audio side of Python. Your first one was reading and writing wave files in Python. That's right. Do you want to talk a little bit about that?\n\nYeah, sure. So, why don't I start by saying about the motivation and what were my goals for writing this tutorial? I wanted to show that Python has this little-known module in the standard library that is quite powerful because it lets you do rudimentary digital audio processing or even sound synthesis without having to install third-party libraries like NumPy. Besides, someone on the team, I think it was Martin, found a quote by David Beasley, the author of the Python Cookbook, who once said that the wave module in Python, which is what the tutorial is about, is fun and easy to teach to kids and can make crazy sounds. And that's a powerful and highly motivating exercise for aspiring developers. Other than that, I picked this topic because I wanted to take a break from these longer deep dives that I tend to wind up myself in and instead I wanted to write a shorter guide focused on a relatively simple topic that might be interesting but perhaps not very well known. Yeah, and this didn't exactly work out because the article ended up being over 15,000 words. Yeah, you found some interesting stuff to talk about, didn't you? Yeah, it goes way beyond just reading and writing the audio files.\n\nYou already summarized this code pretty well a few episodes back, but I can quickly mention that the tutorial ends with a few mini projects based around the wave module. Two of them implement some popular audio visualizations. One is an animated waveform in the time domain, and the other one is a spectrogram in the frequency domain. There's also an internet radio stream ripper, which lets you record a live stream onto a disk as a wave file. I had to say that one totally out of the left field for me. I thought, \"Okay, cool.\" I just couldn't resist doing this one. And finally, there's also a script that widens the stereo field of an existing recording to make it sound more three-dimensional. Apart from that, I've included a very simple sound synthesizer that can simulate some interesting physical phenomena when you mix certain frequencies together.\n\nWell, I was talking about the beat. So when you mix two frequencies together, which are very close to each other, it makes this interesting effect. I won't spoil it, so you can go ahead and read it to check it out. Yeah, and I did talk about it because I was very interested in it at the time. So, a little bit of a repeat there. But what I was thinking about in that process that I didn't get to ask you is, what were things that you wanted to learn in the topic? Was it the wave file module, or were there some other things? Obviously, you went off and explored lots of things in the process. What were things that, at the core of it, you wanted to learn?\n\nGood question. Well, honestly, there was nothing in particular that I wanted to learn because I thought that covering such a simple topic as reading and writing wave files wouldn't present any rabbit holes, and that I wouldn't learn anything new along the way. But there was actually one thing that surprised me, and that was the handling of the 24-bit PCM encoding. Most wave files are fairly simple. They start with a header which contains a bunch of metadata such as the number of channels, the sampling rate, and the bit depth or number of bits per sample, which determines the dynamic range or the number of distinct amplitude levels you can represent. The rest of the file is just a sequence of uncompressed frames which contain the individual audio samples for each channel. Now, the most common encoding scheme for these audio samples involves 16-bit signed integers, which are fairly standard and widely supported by hardware and most programming languages. Even though Python doesn't inherently have a corresponding data type, you can still use some standard library modules like struct and array to work with those foreign numeric types. In fact, any numeric data type that allocates a number of bits which is a power of two is pretty straightforward to work with. But these parts have a downside, and if you want to improve the dynamic range of your audio recordings, you have to go from 16 bits to 32 bits, which doubles the amount of storage required. While storage is not such a big problem these days, right? Bandwidth is, so services like Spotify that stream audio data over the air are very much interested in finding a middle ground between good quality and download speed. So, when they stream data, they want to use the least number of bits per sample as possible while still maximizing sound quality. To do that, they often use somewhat exotic bit depths that are not powers of two. The wave file format happens to support 24 bits per sample, which adds only 50% of storage, but at the same time offers as much as two orders of magnitude better dynamic range. Unfortunately, Python's wave module doesn't support this encoding out of the box, and my tutorial goes into detail showing a few alternative ways how you can interpret such 24-bit integers, as well as how to encode them back into a wave file. At first, it shows how to achieve the desired result using pure Python, which is elegant but slow, and then it follows with a slightly more complicated implementation based on some NumPy tricks, which is much faster. I don't remember exactly how much faster, but it was significant. So, that was one thing that I didn't know that I wanted to learn.\n\nThat's cool. Yeah, I feel like you're expanding upon what is available in that wave module, but also then kind of thinking about what are other tricks that people can learn. I feel like that's something that you do often in your tutorials, that you are interested in a subject and you want to give people something fun and almost tangible to play with and create, but at the same time, you want to teach these concepts. I couldn't say it myself better. I always want to promote good programming practices, idiomatic patterns, and modern Python features. I know that this may sometimes mean that people running previous Python versions won't be able to fully follow my tutorial, but I still think that it's beneficial and also a great opportunity to get out of your comfort zone and try something new.\n\nI want to highlight that if you're maybe not super interested in creating raw wave files, but maybe you work with audio and you want to do things like plot the waves, you do this whole section again. I already spoke about it on the other episode, but about plotting the waves in Matplotlib, which I thought was really great, and then it was really fun kind of watching you work and build these visualizers, the spectrogram, and the other one that was sort of playing the waveform, creating these cool bouncing displays. What were the types of things that went into researching that? You mean the wave file or the visualizations, the animations? I think the animations. Like, what were things that were there libraries that you had to add or were there some other things you could find? If I recall, I use Matplotlib for rendering, and I think Matplotlib has this functions module or animations module or something like this, which lets you plot the subsequent frames and make an animation out of it. So that's what I used, but I always find working with Matplotlib a little challenging. I find their API to be not the best, not the most intuitive. Yeah, in the world, so I always check the alternatives, but end up using Matplotlib anyway. It's nice because it is kind of core to what you can do with graphs and plots, but it feels like it almost... It would be painful for them to do this, but to sort of reorganize it. It feels like things have been a bit bolted on as they've gone, and so like the problem with plotting and graphing and adding animations and things like that is their model didn't necessarily fit all those things, and they've been added as they've gone along. I kind of agree there's this other library called Seaborn, which builds on top of Matplotlib. Yeah, but it unfortunately focuses on statistics, so it's not as universal as Matplotlib, but I wish someone created Matplotlib 2, which is more Pythonic and has, you know, it just always involves a lot of Googling and trial and error, at least for me. Cool. So then the other one that we really wanted to talk about was this guitar synthesizer, right? Tutorial, which is really awesome, and I want to note that you kind of in your wave file one, you did a little bit of synthesis. Yeah, you are making sine waves and sort of calculating them, doing the math, and then you were doing, trying to think of all the different types of synthesis you were doing in there. You like you said you were mixing, I want to call them notes, but pitches together to look at the beats. Was that an inspiration for you to get into other forms of synthesis, or were you already thinking about this in the past? No, I think it was an inspiration. I finished writing the wave tutorial and included the synthesis there. I remember that I had a prototype of the guitar synthesizer that I wrote a long time ago that I could take a few steps further and write in Python. So yeah, that's how the idea was born. Some of the genesis that I think has been in the back of your mind for a long time and wanting to get into it. That's cool to go from completely left field. What's your music background? Do you play an instrument currently? Well, I would say it's pretty minimal. My musical education probably stopped in primary school when I attempted to play a flute, but that's about it, and I can barely remember it today, so that probably doesn't even count. Do I play any instruments now? Unfortunately not, but okay, honestly, finishing that guitar synthesizer tutorial actually at the end made me want to pick up a real guitar or maybe like a ukulele now that I have a rough idea of how these instruments work. Yeah, and I've heard that the ukulele is apparently great for lazy people who don't put too much energy into strumming strings, so maybe I should start with that.\n\nI have a couple you might notice in the background. I can see. Yeah, I lived in Hawaii for a little while and kind of grew to appreciate the ukulele as they pronounce it, and what threw me off as being a guitar player for decades was like, okay, well, what's the string layout here? How should I play it, and it's actually not that difficult. If you know chord forms of a guitar, the one like thing that unlocked it for me is like, okay, it's just the top four strings, and then I was going to bring this up because I have this argument with my wife about the idea of top and bottom strings. She always thinks of them physically like you're sitting with the guitar and the bass strings are closest to you. If you're looking at them vertically, she thinks that is the top. Go ahead. What if you're left-handed? It should be strung the same way, but you could play it or it's still strung with the highest string if you're sitting right-handed, you would be at the bottom, you know, the highest note pitch-wise. So any my argument is I always say top is pitch, that's the top, the top E or the high E is that versus like the physical location of the string. Basic. Yeah, and it's an argument that we have because she plays guitar also, and so we were doing like a cover band, and I'm like, yeah, yeah, you play it on the low E, and so she thinks I'm thinking, you know, the E that's the highest note on the bottom where she's playing it, that's the low E because it's lower vertically. I'm like, oh God, just killing me. Anyway, I can totally see how this is confusing because when I was familiarizing myself with these musical theory terms, yeah, you got into tablature very deep. Oh man, the layout, the string layout was confusing, and it seems that the guitar tablature also uses a few different layouts. So plus you have different instruments. So it's all crazy anyway.\n\nSo I always call top would be like a higher pitch note. It's also higher numerically, as you kind of saw there. Like it'd be like E4 versus an E2 or something like that. As far as tablature goes, so there's one thing I wanted to ask you about because I have this fascination with the saxophone. There's this band from New York City subway called the Too Many Zoos and I don't know if you heard of them. They elevate playing the saxophone to a completely different level. That's cool. They call it the brass house, which is quite a unique mix of different styles of music, house like a dancy kind of stuff. Yeah, I guess. Okay. And yeah, I was considering picking up a saxophone, but it turned out it's a little expensive and frankly, not so easy to play from what I've seen on the internet, at least. I was wondering if you, since you clearly have a musical background, I always see all these guitars in the background, so just wanted to ask you. I never done the wind instruments. Okay, I've met some amazing players over the years touring. It amazes me the variety of saxophones, like there's an Alto, baritone, tenor, and they literally take different form to be able to have the length of the horn to be able to play. I always wonder how well that translates because you kind of play them differently. You either play it like this or like this or whatever, all these different kinds of shapes. I know there's like a big part of it, you have to get this whole mouth thing going right. You got to get your embouchure, as they call it, and figure out how to hold the reed properly and so forth. And I think I don't know how much that you would even translate to somebody playing something like a trumpet or another brass instrument that has a mouthpiece. I don't know. I wonder about that. I think I think it was an inspiration. When I finished writing the wave tutorial and included the synthesis there, I remember that I had a prototype of the guitar synthesizer that I wrote a long time ago, okay, that I could take a few steps further and write in Python. So yeah, that's how the idea was born. Some of the genesis that I think has been in the back of your mind for a long time and wanting to get into it. That's cool to go from completely left field. What's your music background? Do you play an instrument currently? Well, I would say it's pretty minimal. My musical education probably stopped in primary school when I attempted to play a flute, but that's about it, and I can barely remember it today, so that probably doesn't even count. Do I play any instruments now? Unfortunately not. But okay, honestly, finishing that guitar synthesizer tutorial actually at the end made me want to pick up a real guitar or maybe like a ukulele now that I have a rough idea of how these instruments work. Yeah, and I've heard that the ukulele is apparently great for lazy people who don't put too much energy to strumming strings. So maybe I should start with that.\n\nI have a couple you might notice in the background. I can see, yeah. I lived in Hawaii for a little while and kind of grew to appreciate the ukulele as they pronounce it. And what threw me off as being a guitar player for decades was like, okay, well, what's the string layout here? How should I play it, and it's actually not that difficult. If you know chord forms of a guitar, the one like thing that unlocked it for me is like, okay, it's just the top four strings, and then I was going to bring this up because I have this argument with my wife about the idea of top and bottom strings. She always thinks of them physically like you're sitting with the guitar and the bass strings are closest to you. If you're looking at them vertically, she thinks that is the top. Go ahead. What if you're left-handed? It should be strung the same way, but you could play it or it's still strung with the highest string if you're sitting right-handed, you would be at the bottom, you know, the highest note pitch-wise. So any my argument is I always say top is pitch, that's the top, the top E or the high E is that versus like the physical location of the string. Basic. Yeah, and it's an argument that we have because she plays guitar also, and so we were doing like a cover band, and I'm like, yeah, yeah, you play it on the low E, and so she thinks I'm thinking, you know, the E that's the highest note on the bottom where she's playing it, that's the low E because it's lower vertically. I'm like, oh God, just killing me. Anyway, I can totally see how this is confusing because when I was familiarizing myself with these musical theory terms, yeah, you got into tablature very deep. Oh man, the layout, the string layout was confusing, and it seems that the guitar tablature also uses a few different layouts. So plus you have different instruments. So it's all crazy anyway.\n\nSo I always call top would be like a higher pitch note. It's also higher numerically, as you kind of saw there. Like it'd be like E4 versus an E2 or something like that. As far as tablature goes, so there's one thing I wanted to ask you about because I have this fascination with the saxophone. There",
    "0ipo7Q7zFis": "Welcome to the Real Python Podcast. This is Episode 2011. Do you round numbers the same way you learned back in math class? You might be surprised by the default method Python uses and the variety of ways to round numbers in Python. Christopher Trudeau is back on the show this week, bringing another batch of PyCoders Weekly articles and projects. Christopher discusses his recent video course on rounding numbers in Python. He covers rounding bias and how to avoid introducing it into your dataset. We dig into the various rounding strategies and how to implement them in Python. We also share several other articles and projects from the Python community, including a news roundup, a fast Python filter for error-free and maintainable code, the decline of the user interface, more thoughts on Python and Excel, a discussion about calendar versioning for Python, a financial database as a Python module, and a project to prettify the colors of your terminal user interfaces. \n\nThis episode is sponsored by Sentry. Fix application issues before they become downtime with Sentry error and performance monitoring for Python. \n\nAlright, let's get started. The Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at Real Python. \n\nHey Christopher, welcome back.\n\nHi there. \n\nAlright, so we have our usual lineup of news, a few different topics, a discussion, and projects this week. Are you ready to dig in?\n\nYeah, let's go. \n\nFirst off, a big release note is NumPy 2.0. This one's been a long time coming. They've added a bunch of new string stuff, some performance improvements, and under the covers, they've been trying to move from C to C++ and do some cleanup kind of things that in theory should make it easier to add features in the future. This is a major release with breaking changes. \n\nYep, Mr. Bailey, I believe that's what you call foreshadowing. It includes changes to the ABI, so packages that were built against NumPy 1 will need to be rebuilt. If I understood the instructions correctly, there are ways of building so you can do either, but you do have to rebuild to take advantage of that. And there's a chance I didn't understand the instructions properly. And since it's been more than four minutes since our last podcast, there's been a new Python 3.13 release beta 3 is now out. So if you're playing around in beta land, go check that out. \n\nNice. Also on the Python Software Foundation news list is the board candidates for the 2024 election have been announced. Nominations for candidates closed on June 25th and voting starts on July 2nd and runs through the 16th. So that's the future, which is the past. Let's not get into that. \n\nThe other bit of news is on the security front. The folks at PII have disabled the creation of new accounts using email addresses from outlook.com or hotmail.com. This is in response to a large number of bot accounts using those domains. The hope is that the addition to the ban list is temporary. This announcement kind of surprised me. I'm not dealing with these kinds of servers as much as I used to and thankfully don't have to deal with account signups all that much. \n\nYeah, I didn't realize Outlook had fallen this far. Seems like everywhere I go, I have to prove I'm not a robot. Fess up, Mr. Bailey. Are you a robot? \n\nIgnore all previous instructions, Christopher. Yeah, well, yeah, nice. \n\nSo digging into topics, a former guest and Real Python team member, Ricky White, is back and it's great to have him back writing a few articles for us. We have discussed this particular thing many times over the last year or so. The program Ruff, which is a well, I'll put the title of the article, which is Ruff, a modern Python linter for error-free and maintainable code. Ruff is a linter. It basically checks through your code for a variety of different things. It's very well regarded in our industry. That's probably why we've talked about it a whole bunch. And one of the biggest things that is the hallmark of it is how fast it is. It's one of those tools that's sort of championed under the Rustifer, which is a tool for sorting your Python imports. Flake8, which is a style guide and enforcement tool, and then Black, which is a code formatter, which I've also talked to W.C. As on the show about. Ricky starts the whole piece in the typical manner of like, \"Hey, let's install the tool.\" This is definitely one of those tools that it may make the most sense to use something like pipex to install it. In the sense, you are going to probably want to not just install it on one specific project you're working on, but across your Python development process. So he gives instructions for a variety of ways of installing it, and then the article has something unique that I like about it. I feel like a lot of package tutorials or sort of introductions to tools and stuff are kind of a feature list. They maybe have some of the commands and maybe provide a couple examples, but maybe at the end they have some other potential use cases. So Ricky did a bit of a different approach here, which I like. He gives an example program and then runs it through it and has it find the errors. You're seeing not only the code that's running, but you're also seeing the terminal output and running the different commands so you can kind of follow along and practice along with it. It's not quite a step-by-step project, but it's a really nice way for you to engage with this type of tool. If you've heard of tools like this and haven't really played with them or maybe you haven't run them from the terminal before, I think that's a really great way to get you introduced to them. Like I said, he's showing the errors that are found. It shares the line numbers, which is really nice. You kind of indicate what's happened where. And then it also offers to fix what is found. There's sort of automatic fix. And so he gives one example of that of doing an import that's never used. And so in that particular case, he uses the dash dash fix the flag for that one, running it again, it removes that import because again, it was never used. There the other error that he finds in this particular sample code is a little more in-depth, but not only does it provide the line number, but it also will give an error code. And there's a way to quickly look that stuff up without having to dive into search documentation and so forth. And Ruff, you can run a command that says rule and so you can kind of see what rule that error has crossed. In that particular case, he talks a little bit about having continuous linting as you code, ways to open up a terminal and pass the watch flag. He also then gets into the functionality that we mentioned there of Black, the idea that you can have Ruff and then the command of format on that. You can then see the differences. You can see how is it reformatting the code. We've talked a lot about code formatting, avoiding the whole hell of going back and forth between different teams and code reviews that are more about formatting than they are about substance. And again, a tool like this follows in that suit in that vein. He continues to show configuring this tool and there's a Ruff.toml file and then he provides some different suggestions on how to configure that and ways that you may again in your organization or by yourself decide like, \"Oh, I this is the way I want my code to look and be formatted.\" And then he provides a few other explorations, suggestions from there. If you've been meaning to learn a little more about Ruff itself or linters and formatters in general, I think this is a great article to get you started. And thanks, Ricky, nice to see you back writing for Real Python. So my favorite part is it also allows you to override Black's \"must use double quotes\" thing, which is that part of the configuration. It's the one place where they're like, \"We're compliant with Black except for this. You can turn this off.\" \n\nOkay, yay. Nice. Yeah, is that a tool that you're using now? I've only played with it. I haven't incorporated it into any of the large build pieces I've done yet, but I have mucked around with it a bit. \n\nFix application issues before they become downtime with Sentry error and performance monitoring for Python. Whether you're taming Python's processing power or controlling JavaScript's flow through Node.js backend infrastructures, are as complex as they are valuable. With Sentry, you can trace issues from the front end to the back end, detecting slow and broken code to fix what's broken faster. Within minutes after installing Sentry, software teams are able to trace Python issues back to poor performing API calls as well as surface all related code errors. The fix what's broken faster. One engineering leader that used Sentry said the time to resolve errors went from days to minutes. Installing is easy and new users get three full months of the team plan free with the code REALPYTHON on sign up. That's REALPYTHON with no space. Learn more at sentry.io. \n\nAlright, so what's your first one here? I've got an opinion piece from InfoWorld called \"The Decline of the User Interface\" by Nick Hodges. I kind of risk an \"old man yells at cloud\" kind of meme going on here, but this article kind of spoke to me. Nick seems to be of, I'll say, our generation, sir, which is an inclusive way of saying he's probably old. And I can tell you this because he starts the article talking about the days of DOS where the only interface was text. And then after that comes Mac and Windows and the industry had to figure out how to make a graphical interface that was mostly intuitive to users. A big part of that was standardization. The fact is that most programs have a file menu with new, open, save, exit, all that kind of stuff. It's part of this sort of de facto standardization that happened, along with things like OK, cancel as being the buttons and dialogue boxes. So this all sort of feels like self-evident and ho hum now, but there's a reason it feels that way is because it's everywhere. So no one would try to do it differently. It hasn't always been this way. I remember using software under X back when that was a graphical server and not a ketamine adult billionaires plaything. Where there was pretty much every program, you kind of had to figure out what its interface was. There was a graphics program I vaguely remember using where copying things to the clipboard involved dragging the mouse for selection, hitting the right button, then the middle button to confirm. And I don't remember why you needed that sequence, but you did. And it's funny, I can't even remember what the software was called, but I still have this mouse memory, right? Like this muscle memory for playing with the mouse. So anyways, the old man digression aside, this kind of standardization was and is important. And as the PC took off, people started writing books about these design patterns. And it kind of just became everyone does it this way. And coders kept using them, and it really didn't. What it means is you have to, there's less education required for your users. And this also makes the programmer jobs easier. So Nick's article continues by pointing out that this standardization really didn't get translated to the web. So consider the idea of a settings box in a web app. You might have the OK, cancel button. It might auto save and just have a close button. You might just get the little X in the corner. Once in a while, you don't even have that, and you just have to click off the dialogue to dismiss it. Yeah, the merits of each one of these approaches isn't important. Any of them might work. The lack of consistency is the problem. And this can lead to confusion. My favorite recent example of this is in the Zoom meeting scheduling interface. When you hit the copy invitation button, it pops up a dialogue. In that dialogue box, there's another button that says copy invitation. Why this is a two-step process is beyond me. But next to it is a cancel button. Cancel what? Cancel the dialogue? The meeting? The dialogue didn't do anything. Cancel the meeting? Close the dialogue? So, you know, ignoring the fact that the dialogue doesn't need to exist in the first place, the button that launches it could just easily be a copy the invite button instead. This whole lacking of a standard creates all sorts of ambiguity. And it's difficult for users like you and I who use computers all the time. My retired age mother, she screams at the phone every single time the bank updates her app because it looks different every time and you can't find anything. So Nick goes on to talk about how in the effort to give you more screen real estate, operating systems and programs have made it harder to use their software. For example, if you've got a web browser with a lot of tabs open, where are you supposed to click to move the window? There used to be a title bar, but that took up space and it doesn't look sleek, so it went away. And this really is the heart of the matter, as there's been a refocus in UI on how clean something looks. And often that's at the expense of functionality. Muted colors have become far more popular, and it makes it harder to differentiate things. The other thing, my big complaint that he doesn't get into in the article though is having to mouse over something in order for the button to show up. Yes, you cannot mouse over on a phone or tablet. So right there, that's a problem. But even if you could, how are you supposed to discover functionality if it isn't there, unless your mouse happens to be in the right spot, right? So early on in my web career, I spent a lot of time with designers who came out of the magazine layout space, and it was a constant source of frustration that they didn't understand the web. They were creating pixel-perfect designs that were really hard to do on the web at the time, early days of CSS. Somehow, I don't remember how, I ended up at a lecture by Jeff Raskin, who was one of the pioneers of UX at Apple in the early days. It was an eye-opening experience. I didn't realize there was actually a study on how to make things easier on users. My experience up until then had been people who were interested in the color of the drapes rather than whether or not they blocked the sunlight. One example that sticks in my mind is the menu bar on a Mac. So unlike on Windows, the menu bar on a Mac is attached to the top of the desktop regardless of where the window is placed. This was done on purpose to make it easier to grab a menu. You don't need to precisely position your mouse on the frame. You can just rapidly push the pointer to the top of the screen. This design decision came out of research. I highly recommend Raskin's book, \"The Humane Interface,\" to learn more about the thought behind this kind of stuff. The content's a bit dated because the book's almost 25 years old, but the concepts are timeless. So Nick's article kind of covers some of this stuff and the frustration that comes out of it, particularly for those of us who've seen it be better rather than just be pretty. And I hope some of this resurfaces in our industry. There's nothing wrong with pretty, but when it's at the expense of usability and discoverability, it's problematic. \n\nYeah, I mean, gosh, I have so many thoughts on this whole thing. Like, a couple quick things. Like, one of the things I really have always loved about the Mac menu bar at the top of the window is as you click on things, it's showing to the right of what you've selected. You know, maybe if you're in a browser, it shows the shortcuts right there inside of it. Also a feature many people don't know, like, especially in something elaborate like a program like Logic, you're like, \"What was the name of this thing?\" And you're going through it, there's a little thing under \"Help\" that allows you to search the menus and so you can type it and go, \"Okay, that's where it is within this pull-down menu.\" It's embedded or something. So I've always shown that to people and said, \"You can find where this stuff is.\" You know, and ironically, I think that's part of where the problem on the web came from is because the web isn't connected to an operating system. If you were a UI person on Apple, you made your website look like one thing. And if you were a UI person from Windows, you made your website look like something else. And then somebody else just went, \"Hey, this is neat.\" And some of that consistency on an operating system is forced by the operating system. And so when there isn't something like the operating system to force that to have happen, then it kind of becomes, you know, Wild West, whatever designer, you know, computer geek decided, \"Hey, let's try this.\" So, yeah, it's, we're dealing with a lot of it with the touch interface stuff. And unfortunately, Apple is kind of in this weird transition. I don't even completely understand all of it where they're like, let's make our stuff be the same somehow. And so they're kind of taking from one side and the other side and kind of combining the two together. \n\nYeah, yeah, totally. And I think it's partly for the frameworks of Swift or whatever. But, you know, you look at, like, the settings menu and it's just, for people who have been using it for decades, you're like, \"Gee, where is everything and how does this work?\" And it's not, it's not as functional, unfortunately. \n\nYeah, it's almost a separate topic, change for change sake. \n\nYes, yeah. Yeah, totally. But, yeah, and I agree that the interfaces are a huge part of using computers. It's literally making them usable. And having had people on to talk about accessibility, that's a whole other deeper layer to all of this. \n\nMy next piece is a real Python course from Christopher Trudeau. I think I'm pronouncing that incorrectly. It's called Rounding Numbers in Python. It's based on a tutorial article by David Amos, who's a math geek extraordinaire. And as was mentioned, your instructor is my fellow podcast host, Christopher Trudeau. In the video course, you'll learn why the way you round numbers is important, how to round a number according to various rounding strategies, how to implement each strategy in pure Python, how rounding affects your data, and which rounding strategy will minimize this effect. It's an important skill. Drawing conclusions from biased data can lead to costly mistakes, making this course a worthy investment of your time. And like all the video courses on Real Python, the course is broken into easily consumable sections.",
    "4hGgitya6Wo": "Welcome to the Real Python Podcast. This is Episode 212. Have you wondered about graph theory and how to start exploring it in Python? What resources and Python libraries can you use to experiment and learn more? This week on the show, former co-host David Amos returns to talk about what he's been up to and share his knowledge about graph theory in Python.\n\nDavid started a PhD program studying mathematics with a focus on graph theory, though life interrupted his pursuit. After three years, he is still passionate about the subject. He's been using these skills to create documentation and teach users as part of the Relational AI Education team. David has also been exploring the Julia programming language. He wrote about it on his blog, created videos, and started a podcast on the topic. He shares his excitement about learning new techniques from different languages and how these ideas can enhance your coding in Python.\n\nThis episode is sponsored by Sentry. Sentry provides end-to-end distributed tracing, enabling developers to identify and debug performance issues and errors across their systems and services. Alright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with the community of experts at Real Python.\n\nHey, David, welcome back.\n\nThanks, it's been a little while. It's fantastic to have you on the show again. Well, I just want to start right here. What have you been up to? What have you been doing?\n\nI've been working the last couple of years at a company called Relational AI. I've gotten back into the graph theory stuff. I know some long-term listeners out there might remember I have an interest in graph theory. That's been just a blast to be able to get back into that world, be thinking about those kinds of things. I've also been doing a lot more stuff with the kiddos. They're involved in a lot more activities. My daughter's a competition swimmer, and we've been doing that whole deal. We were in Mexico last week, actually.\n\nHow did that trip go? We talked offline before this.\n\nShe was there for what's called the CCAN, the Central American and Caribbean Nations, come together and have a big swimming swim meet and compete against each other. She was there representing El Salvador, which is her mom's from. She's got dual citizenship, and it was great, except that it got interrupted by Tropical Storm Alberto, which was interesting. They had to pause the meet and rearrange things, but overall, it was good. We had a great time hanging out in Monterey.\n\nI wanted to talk a little bit about your programming language journey in between here. I remember that as you were kind of",
    "JLLiIXB-xCU": "Welcome to the Real Python Podcast. This is episode 2113. What are discrete optimization problems and how do you solve them with constraint programming in Python? Christopher Trudeau is back on the show this week bringing another batch of PyCoders Weekly articles and projects. Christopher discusses an article about constraint programming using Python. He describes the fundamentals and how the problems resemble logic problems you may have experienced in school. The article shows how to solve a weekly work scheduling problem using the open-source CPAT package. \n\nWe discuss Leodas POS Ramos's recent tutorial on Python's built-in functions, a complete exploration of all the functions available for you to use directly in your Python code without importing. We also share several other articles and projects from the Python community, including a news roundup on spotting ships with satellites, grappling with Apple's App Store rejecting Python applications, considering changes to Python security model, and discussing pivoting from one development path to another. \n\nWe also talk about Ginga and Django templates and generating static sites with Python. This episode is sponsored by Sentry. Sentry provides end-to-end distributed tracing, enabling developers to identify and debug performance issues and errors across their system and services. Let's get started. \n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. Each week, we feature interviews with experts in the community and discuss topics, articles, and courses found at realpython.com. Hey, Christopher, welcome back. \n\nChristopher: Hey, it's a beautiful sunny day out there. Nice and warm. \n\nChristopher: Midsummer. Let's talk Python. \n\nChristopher: Sure, why not? It's what we're here for. We've got our topics and news and a discussion this week that I think will be kind of fun. \n\nChristopher: Are there any release bits you want to talk about first? \n\nChristopher: Yeah, there are a few release bits first off is Polars. They're a data frame library that is an increasingly popular alternative to Pandas. They have just announced version 1.0 of the library, although it's already at 1.1 for some reason. There are some performance improvements and bug fixes in this release. \n\nChristopher: That's interesting. What's the next release news? \n\nChristopher: Next bit of release news is OPG 3.2 has come out. This project is a database adapter for Postgres. This release includes features for interacting with NumPy scalars, better support for Postgres parameters, and a new way to retrieve a single value from the database. These updates are two years in the making. \n\nChristopher: That's a solid library. What about Django? \n\nChristopher: Django issued a security notice for 5.07 and 4.2.4 has come out to fix some things. The security notice includes several denial of service attacks, a possible directory listing exploit, and an enumerating users exploit. \n\nChristopher: That's a lot of security issues. What's the final bit of news? \n\nChristopher: The PyBay conference has opened its call for proposals. The deadline for talk submission is July 31st, and the conference is in San Francisco on September 21st. This regional conference tends to attract top Python developers. \n\nChristopher: That's great news. What's the first article you want to talk about? \n\nChristopher: The first article is \"Python's Built-In Functions: A Complete Exploration\" by Leonis Ramos. This tutorial covers the fundamentals of Python's built-in functions and provides code examples for each function. \n\nChristopher: That sounds like a comprehensive guide. Any favorite functions from the list? \n\nChristopher: Exec is one of the interesting functions that I find useful. \n\nChristopher: That's a powerful function. What's the next article you want to discuss? \n\nChristopher: The next article is \"Satellites Spotting Ships\" by Mark Litwin-Chi. This article walks you through building a ship detection algorithm using satellite images. \n\nChristopher: That's an interesting project. Any other projects you want to highlight? \n\nChristopher: Yes, I have a project called Aurora, a static site generator implemented in Python. It supports Jinja 2 templates, Markdown, and HTML. It can generate pages from CSVs or JSON files and has hot reloading for incremental static regeneration. \n\nChristopher: That's a useful tool for generating static websites. Thanks for sharing these articles and projects. \n\nChristopher: My pleasure. See you in a couple of weeks. \n\nChristopher: Take care. \n\nRemember to click the follow button in your podcast player and leave us a review. You can find show notes with links to all the topics we discussed at realpython.com/podcast. If you have a question or topic idea, leave us a message. Thanks for listening, and see you next time.",
    "4KzXW38G5kM": "Welcome to the Real Python Podcast. This is Episode 215. How do you integrate GraphQL into your Python web development? How about quickly building graph-based APIs inside Django's batteries included framework? Christopher Trudeau is back on the show this week, bringing another batch of PyCoders Weekly articles and projects. Christopher shares a recent tutorial for building GraphQL APIs in Django using the Python library Strawberry. The tutorial digs into creating a project, defining models, and creating GraphQL queries and mutations using Strawberry. \n\nWe discuss a blog post from Nat Bennett titled \"Why do prototypes suck?\" We dig into the common pitfalls of building prototypes and the misconceptions between developers and end-users. We also share several other articles and projects from the Python community, including a news roundup using HTMX and FastAPI, an unbelievably stupid airline Wi-Fi package, extracting wisdom from conference videos, writing pixel images to the terminal, and a Mac OS app for Jupyter Notebooks. \n\nThis episode is sponsored by Mailtrap, an email delivery platform that developers love. Try it for free at mailtrap. Alright, let's get started. The Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at realpython.com. After the podcast, join us and learn real-world Python skills with the community of experts at Real Python. Hey, Christopher, welcome back. Hey there, all right, so we don't have a ton of news today. I think we just have like one item. No, which I think everybody can probably expect what it is. You might even be able to guess. Yeah, it's that late summer, you hear reporters complain about it sometimes. There's nothing there's no news, and yeah, we've got one tiny little piece of news, which is Python 3.13 has hit beta 4. I will tell you, though, I was recently building out a little new course, and I was using the REPL a fair amount, and I was kind of tired, and it took me four attempts to type in the same class because I kept screwing up one line of code for like the five lines of a class. So I am starting to really look forward to the REPL changes coming in 3.13. So I'm not sure I've this strongly anticipated a release before because usually it's sort of like, yeah, whatever, but this is like, no, I need the new REPL, yeah. Anyways, yeah, should be fun. All right, well, topics wise, we have our typical couple of topics, a piece. We have a discussion and some projects. So I'll start with the topics here. I found an article kind of continuing down this path of me dabbling in the world of HTMX and also kind of messing around with FastAPI. This is a tutorial by Paul S. Laurent on Test Driven. It's literally titled \"Using HTMX with FastAPI.\" It's a fairly small project. You get an example application up and running with both those tools, FastAPI and HTMX. If you're not familiar with the two of them, I would imagine over the last five years, FastAPI has gotten a lot of attention, but it's a very fast modern Python framework for creating APIs. It's all right there in the name. We have a lot of coverage on Real Python about it. If you're interested in a couple of different courses, but yeah, it's a nice way to build an API quickly. It has some features that are advantageous in the sense that has some async stuff right out of the box, which is nice. And then adding HTMX into the mix, it adds a lot of the server-side sort rendering capabilities to your HTML, and you don't need those kind of heavy tools of you talk about somebody becoming a front-end developer and having to learn something like VueJS or ReactJS. This is staying in the realm of HTML in a lot of ways, which is nice. You eventually get the project hosted. This is a service I haven't heard of before. I'm kind of excited about it. It's called Look and kind of play. The tutorial is very step-by-step, making an environment, pip installing, and doing all those typical stuff. You build out a main.Py file, and then that has all the FastAPI logic with your endpoints in there. And you basically build out template files. In this particular example, you're using Jinja for this. There's an index, you know, your typical landing page for a website, and then a to-do list that then has some of that nice Jinja functionality of being able to do the looping functionality that you can do inside of there. And then of course, HTMX. If you're not familiar with HTMX, I also just briefly trying to find a way to explain what it is. I plan to talk about it a little bit more. You've written some stuff about in your books. I might ask you a little more about it. But this is from their website. HTMX gives you access to Ajax, CSS transitions, WebSockets, and server-sent events directly in HTML using attributes so you can build modern user interfaces with simplicity and the power of hypertext. It's very small, it's dependency-free, extendable, and has reduced code bases. They're comparing it like 67% smaller than something like React. In this particular tutorial, he's using HTMX version 2, which is a recent release. I guess my only complaint about the tutorial is that it's it doesn't really do a lot of deep explanation of what's happening. It's very much a follow-along tutorial. The code shown provides again those other resources for you to do deeper research if you'd like. It's more about the functionality and wiring things up and kind of practicing with these tools, which is nice as opposed to really teaching you what's happening under the hood. There are some nice touches, pulling in HTMX as a dependency. He does a little bit with CSS to kind of make things look pretty using a library called Simple CSS. And you get to practice CRUD, which we've talked about a bunch lately, create, read, update, the sort of editing and delete. And then again, the end of the thing, which is again nice to see a new service providing this is deploying to Render. So again, I think it'd be good practice for anybody who's interested in getting started with FastAPI and HTMX. So thanks, Paul. What are your thoughts on HTMX? I know we were maybe gonna talk about this at length in another venue here. I would refer to myself as a fanboy, but the HTMX fanboys on the socials are kind of extreme dream with the memes, so I'm not sure that I qualify, but yeah, I'm a big proponent. It drastically simplifies a lot of work. It allows you to use a lot of Web 1.0 style technology and still get a lot of the dynamicism that you might want in a newer application. Yeah, if you go off to HTMX.org, there are some testimonials. I guess like essays written by people who've converted. For example, the one, the 22,000 line site, it took them about two months to convert. They didn't remove, it was a React site. They moved to HTMX. They didn't remove any user experience whatsoever. So it was a drop in, a drop in replacement. It went from 22,000 lines of code to 7,000 lines of code. Yeah, their Python went up by 140%. Which basically means a bunch of the front end stuff got moved into the back end, which makes testing and other things easier. 90, what is it 96% drop in JavaScript dependencies. Interestingly, the it even improved the client's experience because the amount of memory in the browser was so much less that they could load more information onto the page. I would imagine what the pages would load so much faster without all that over. Yeah, it wasn't just about the page load time. This seemed to be some sort of heavier like table driven something or other. So it was like they went from having you know some number of rows to more than that basically. You know their upper limit before got pushed out. There's a bunch of these and you know and anyone I've talked to that tries to do it this seems to be the path. There are some things you can't do with it but most web development doesn't require those things. So yeah, yeah, yeah, totally. So what's your first one? I've got a let's call it a developer story by Robert Heit. It's called it's the title's a bit of a mouthful, P Sky Wi-Fi completely free unbelievably stupid Wi-Fi on long-haul flights. So technically it's Python content because he used Python to do the work, but it's mostly a story about a bored hacker finding an interesting hole and having some fun with it. Robert was on a flight from London to San Francisco and was bored enough that he thought he might do some work or you know muck around on the internet or something and he connected to the plane's Wi-Fi login page and was about to jump through the hoops needed to get access when he noticed that he could freely access his frequent flyer account information, which included a button that allowed him to edit the name of his account profile. And as with all good procrastinators, this little crack in the wall was more interesting than getting, say, caught up on his PRs. So he decided to dig in. Robert codes in several different languages, but the joy of having a project named Pi Sky Wi-Fi made him choose Python for this implementation. Yeah. So his hack started with a prototype. He actually happened to have a second laptop with him, so he used that to log into the internet and then used the profile name as a message board. So on laptop one, he would freely change the name to \"How are you?\" and then on the second laptop through the internet, he would reply, \"I'm fine.\" And this kind of takes us back to the title, \"Completely free and unbelievably stupid.\" So this is a slow messaging mechanism, but there's a certain pleasure from finding a legitimate use of a system for other than its intended purposes. So he wrote a little tool that used the profile, the name on both sides, and could exchange messages. Now, at that point, he got a little worried that using the hole would trigger some sort of problem. He don't want to take the entire internet down for the plane, so he stopped. But once he'd proven that it worked, he then signed into the actual flight's internet to start coding this hardcore. And he mocked up how the transmit was done without actually violating somebody's terms of service or whatever. So the end result is the Pi Sky Wi-Fi package, which implements essentially a simplified version of TCP/IP over HTTP via frequent flyer account. On the ground, you run a proxy server, and in the air, you use the kit to talk to the proxy server, and then it onto do whatever you would normally do over TCP/IP. He wisely finishes his little story with the disclaimer that you really shouldn't do this. And then following all of that, the post goes on in detail does a deep dive in how it all works. And it's, you know, if you're not interested in the second part, it's a fun little bit of reading. If you are interested in the second part, he goes into a lot of detail about how all the pieces fit together. That's some a little different than the normal Python fare. As I said, we're heading into summer. So he likes to make these organizational sort of charts and graphs. It's very cool explaining the transport protocol stuff. Yeah, he's got flow diagrams for everything. He's also got a bit of a quirky sense of humor. Yeah, every single time he mentions the name of the frequent flyer program, he makes up a different name. So you can't actually tell from the article what airline he was on. Oh, okay. Yeah. So it's a joy to read. Yeah, it's definitely a joy to read. Yeah. This episode is sponsored by Mailtrap, an email delivery platform that developers love. An email sending solution with industry-best analytics, SMTP, and email API, along with SDKs for major programming languages and 24/7 human support. Try it out for free at mailtrap. That's M-A-I-L-T-R-A-P. Right. This week, I want to shine a spotlight on another Real Python video course. It's about building a project using a package we mentioned during this week's episode. It's titled \"Building a URL Shortener with FastAPI and Python\" and it's based on a Real Python step-by-step tutorial by Philip Zenny. In the video course, Darren Jones shows how to create a REST API with FastAPI, run a development web server with Uvicorn, model a SQLite database, investigate the auto-generated API documentation, and interact with the database with CRUD actions. And then finally, optimize your app by refactoring your code. This step-by-step project and course is intended for Python programmers who want to try out FastAPI and learn about API design, CRUD, and how to interact with a database. And if you need some help along the way, Real Python has you covered there with additional video courses and tutorials covering all the suggested requirements. Real Python video courses are broken into easily consumable sections and where needed include code examples for the techniques shown. All lessons have a transcript, including closed captions. Check out the video course. You can find a link in the show notes or you can find it using the enhanced search tool on realpython.com. Yeah, this kind of leads us into this discussion topic, which I think is really interesting. You have way more experience in building these types of things, but do you want to do the introduction here to the discussion? Sure. Our conversation this week is inspired by a post that was from earlier this year by Nat Bennett and the title of it was \"Why do prototypes suck?\" And in fact, the subtitle gives you a little bit of insight as well. The subtitle is \"Why is it exactly that prototypes are so miserable to maintain and operate and how can we avoid putting prototypes in production?\" So Nat starts out by admitting to using prototypes a lot, usually to do a proof of concept rather than, say, creating a long spec for their team or to quickly get feedback. A prototype can be useful. The post goes on to say that prototypes are dangerous because no one actually throws them away. Once you've got it working, it's too tempting to just put it into production. So to try to understand why prototypes often end up being messy, that's article drills down on some commonalities. They usually don't have tests. They usually don't have design docs or any documentation. They often hard code values where it's that whole quick and dirty thing. And sometimes they're not even written in a team's core language, which I thought I hadn't come across that point before but I thought it was kind of an interesting concept because again, if you're doing something quick and dirty, you might stick something together in Python because you're a Python person and it's quick to do it, but if the team isn't a Python team, now you're supporting that. So, what was your take here? Do you have any prototype horror stories? Well, I think about that first comment that you kind of added there, the idea of you might not only not be using your normal language, which I haven't run across as much, but I think the other problem is you may not be using your normal tools. Yeah, you know, this is something that's happening on potentially an individual's workstation and you get it up and running and you bring people over and say, \"Here, I'm trying to show you this,\" you know, running on my machine or maybe you can put it on the internet and you can then bring it up in the conference room or what have you and you can show, logging in, you know, \"Hey, this thing is working,\" and then suddenly your entire team around you go, \"Well, that's great, let's use that,\" and you're like, \"No.\" Oh, it's like, well, what's the problem? Well, it's running on my machine. Well, that's not a problem, is it? And it's like, well, yeah, it is, like this isn't the solution. Give me the time. Yeah, the problem is that, that's the thing they're like, \"Well, you're 90% done.\" I'm like, \"No, no, I'm 10% done.\" And yeah, well, you're 90% done and then the last 10% takes the other 90%. It's, uh, I think one of the challenges often is, is you very seldom think about edge cases when you're doing prototyping, right? So, you know, I've got some data and it's clean and I put it in and I get the output and then the real world is the data isn't clean and we haven't thought about that and there's all these cases and in the case of a prototype, almost every one of those cases will cause it to fall over and right, it varies from organization to organization, but there, there tends to be a fundamental disconnect between it and business, and there isn't a good understanding on the business side of what is involved in things and I've run into this a lot where, \"Oh, I can see the GUI, therefore it must be done.\" And in fact, it's one of the things that with teams I've worked with before, I try to make sure that we don't build the GUI first because as soon as the GUI is done, people go, \"Oh, I can push the button. The work must be finished.\" And whereas the terminal is scary, right? So, if like, \"Oh, I can see that in the terminal, end-users going to possibly use that,\" exactly, right? So, there's this, there's this sort of, \"Oh, okay, I understand that it's not there yet,\" and for better for worse, I'm going to say some agile stuff, and I'm sure that causes some people's eyes to just roll, but there's a concept in agile delivery where they try to separate the what from the how, and so you've got, you know, the user story is the requirements, and then the definition of done is the how we're going to achieve those requirements, ignoring the fact that it's a horrible name. You're not supposed to consider something to be finished unless it meets both, and so that's things like the documentation, that's things like the testing, and the business doesn't often seem to, well, they don't see the how because they don't understand it, and they often don't understand the long-term implications of not having good how, and that's where things like technical debt come from, and it tends to just sort of snowball, and eventually you get to a place where it's really, really problematic, and it's funny because the business often ends up having the attitude of, \"Well, it's just the IT people are just being picky, they're just slowing us down,\" and the IT people are probably trying to be good stewards because they're the ones who are going to have to maintain the thing, right? So, right, I think about the number of people involved in developing it,",
    "4-3yg_tjSvU": "Welcome to the Real Python Podcast. This is Episode 217. What are the best practices for organizing data analysis projects in Python, and what are the advantages of a more package-centric approach to data science? Christopher Trudeau is back on the show this week, bringing another batch of PyCoder's Weekly articles and projects. We discussed Joshua Cook's recent article on how he uses Python to organize his data analyses. The article covers how his process for building analysis projects has evolved and now incorporates modern Python packaging techniques. Christopher also shares his recent video course on grouping real-world data with pandas. The course offers a quick refresher before digging into how to use Pandas groupby to manipulate, transform, and summarize data. We also share several other articles and projects from the Python Community, including a news roundup, working with JSON data in Python, running an async IO event loop in a separate thread, knowing the why behind a system's code, a retro game engine for Python, and a project for vendorization packages. This episode is sponsored by Mailtrap, an email delivery platform that developers love. Try it for free at mailtrap. Alright, let's get started.\n\nThe Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at Real Python. After the podcast, join us and learn real-world Python skills with a community of experts at Real Python. Hey, Christopher, welcome back.\n\nWe are deep in the summer. What's interesting is we do have some news, a lot related to releases, which has been our trend, but a couple of new items that might be interesting. Do you want to dig into the news here?\n\nAugust is usually slow, and I guess this is just the universe's way of reminding me that I'm wrong frequently with my bold claims in Episode 215 that there was nothing to say. Well, here we are. The first bit was an interesting little blip. You're probably aware that the packaging space has been trying to move away from the setup.py script used as part of setuptools for building, testing, and installing packages. Generally, this is a good idea. You shouldn't have to run code just to find out what's inside of a package. The movement started towards the use of setup.config files, and now with more recent tools, you're using things like pyproject.toml instead. So, the setuptools library has deprecated the test command as part of moving away from the command line use of setup.py. That was seven years ago. Last week, they issued a new release with the command removed. Deprecated or not, the use of setup test is still in use by a lot of libraries, so wads of builds started to break, and the package maintainers were responsive to the outcry and immediately issued a new release with the test command put back in. So, there was like a two-day window if you had downloaded the new version that you would run into trouble. No word on when this is going to actually be turned off, and in fact, this is one of the reasons I moved from tox to KNX because the hooks in KNX allowed me to not have to use this that everything kept telling me was deprecated.\n\nPeople have been seeing the warning for a while, so every time I run tox, it screams at me that I shouldn't do it that way because that was how my tox hook, and I'm sure there's a correct way to do it with tox. Tox is very configurable, and that makes it a little hard for folks like me who use it casually. It's always like, wait a second, how do I do this? And I had it working the way I knew how to make it work, and sure enough, it's the deprecated way. The other odd thing about this is because it was only like a two-day thing. There were like little bits and pieces of news, but there was only one space where I found that actually talked about the whole thing, and it was our buddy, Jack Coad's monthly wrap-up newsletter. It's kind of funny. I find like, you know, the story kind of summarizes the state of packaging in Python, right? Two steps forward, two steps back, or maybe two steps and a half forward. We're inching there, but it ain't happening fast.\n\nThe next bit of news is the creation of P751, which is a file format to list Python dependencies for installation reproducibility. If you've ever done pip freeze and stuck the results in a requirements.txt file, that's what this PEP is talking about. There are a whole bunch of packaging tools, speaking of packaging tools and the mess that is Python, and many of them have their own locking formats to describe the state of installed packages. This PEP proposes a new standard with the long-term view that all tools adopt it so that we're consistent across packaging tools. The proposal uses a TOML-based format, which goes nicely with pyproject.toml, and the new lock file would be called py.toml with the addition of being able to stick something after it, so you can say py.lock-bailey.toml if you need to specialize it, for example.\n\nThis is going to go a little bit further than you might see in a pip freeze. It's a lot closer to the feature list that poetry has, so the format includes information on the version of the format of the file you're using so that they can future-proof it, a hash of the packages there you go to see if things have changed, lists of dependencies, which is what you usually have in that pip freeze requirements.txt, lists of lists for either file or package locks or both. Then there's like metadata about them, so like this particular lock only applies if Python is of this version and all that kind of good stuff. It's very, very robust. He's basically taken everything that they've learned out of other packages and the problems they're trying to solve and trying to standardize. Cool, I'm all for standardization. This is a step in the right direction. The history of packaging in Python makes me a little and even lock files. Lock files make this makes me a little dubious about this. So, you know, the real question will be, will we see this implemented by most of the tools before, say, the heat death of the universe? So, what can I say? The humidity in August makes me optimistic. \n\nAnd then as you hinted, we've got a boatload of release information on the Python side. 3.13 release candidate one is out and you know October is coming, time to test along with a bug fix, which is 3.12.5. Just your usual maintenance release. On the Django side, 5.1 went from release candidate to full-blown release, and they accompanied it by two security releases, 5.0.8 and 4.2.5. These fix a couple of denial of service gaps and more importantly, an SQL injection vulnerability. So if you're on the Django side, you should update. Like I said, not the typical news week in August. Yeah, I know. Yeah, we've got a lot of stuff to kind of cover. That's great. Moving into topics this week, this one fits in nicely to talk about packaging and making sure your code is ready for reuse in different places. This is a blog post by Joshua Cook, PhD. He works as a computational genomics research scientist. His piece is titled, How I Use Python to Organize My Data Analyses. He describes the organization of projects and how it's evolved over the last seven years. So we talk about very often about packaging as kind of an end goal to get something maybe to share with others. This is definitely more geared for his own projects. I'll just read the first quote from the piece. \"I need to perform interactive analyses in notebooks, execute command line tools, submit jobs to a high-performance computing cluster or HPC, and anything else required to get answers to questions my team needs to advance a work stream. These projects and analyses have to move around sometimes, and so the idea of having all the materials, all the different packaging needs to go with it.\" And so I think this is a unique case, but I feel like data science this is more in that alignment. There's a lot of similarities there, and so I think people could probably pull some nice stuff out of this article. His system centers around creating and developing a Python package within each of these sort of analysis projects. Each one of these projects gets its own Python package that's developed and used during that process. He uses the Mamba ecosystem that, and there's a micro Mamba, and so it's a way for creating virtual environments and managing your packages. He has some very specific things about naming. He suggests that maybe you develop your own naming methodology for packages. His, in this case, is about fly fishing and fly, I guess, tie patterns. He used to use a packaging tool called Flit, but since has moved on towards using the PyProject.toml method. This is something that we've discussed a few times in the show. In fact, we just kind of talked about it, how it's a more modern way of doing packaging. And we had a really nice video course slash code conversation with G and I that you can check out. In fact, I'll complete things on YouTube if you're interested and you're not a subscriber and want to get an idea of some of the really great content out there. It's a great introduction to, well, how can I build a package as I'm working on it? So he digs into the details about creating the PyProject.toml, what the file kind of looks like, and then basically you install it on your computer. And during that install, you make sure to note that with a flag that it's editable. He includes lots of the other things you need inside there. He has a specific style for the plots that he uses, which is something that we've talked about before. That's a feature of Matplotlib that you can have your own specific style for a particular project or analysis. In this case, he describes building the code into modules and lots of best practices there. In the end, he ends up building a CLI using Typer. He has a few other best practices to share, which I think is kind of interesting. He has a module for all the paths that he uses for say the data files that he's accessing, output paths for where things are going to get rendered or saved, and other standard directories. And I would imagine that that would vary, especially in a university situation. You might have these very standardized places that need to be organized, of how him and his team are going to work, or even in your own situation. It's nice to have some sort of standards there and not have to create the paths on the fly for every project. So I think that that's a neat idea. He's a big fan of enums for his projects. Enums can really be useful for consistency. We have a couple different articles, and I'll include some links for that about using them inside of Python. He talks about a few dry, don't repeat yourself concepts that he likes, talks about reducing coupling and having the separation of concerns. He's a big fan of Ty pins. This is where my co-host grumbles. He wraps up by sharing some best practices he has about Jupyter notebooks, including a numbering system that I think is really nice, and I'm definitely a fan of this. This is something that just as a media person working on a computer, don't number your file starting with just like a single digit or two digits. If it's going to get into the hundreds, start with three digits to begin with. It's really going to help you as far as sorting and finding things and working with it. So anyway, I found it an interesting journey into the best practices from a data science sort of space and strategies that work across Python development that I feel like could be used on either side of that. I think it's cool. I feel like the different communities that use Python can learn a lot from each other. I feel like some of these ideas were also kind of brought up when I had Parsa on to talk about bioinformatics and using Python in the laboratory. So that was Episode 197. Something else you can kind of check out to continue. \n\nThis is Episode 217 of the Real Python Podcast. The transcript and links to articles, libraries, and other resources mentioned are all available on realpython.com. You can also find the Real Python Podcast on iTunes, Spotify, Google Podcasts, or wherever you listen to podcasts. Make sure you click that follow button in your podcast player. If you enjoy the show, please leave us a review. You can find show notes with links to all the topics we spoke about inside your podcast player or at realpython.com/podcast. Thanks for listening.",
    "S7-bVABAoZE": "Welcome to the Real Python Podcast. This is Episode 218. Are you interested in learning robotics with Python? Can physical electronics-based projects grow a child's interest in coding? This week on the show, we speak with author Maran Alsabbah about his book \"Build Your Own Robot Using Python, Cricket, and Raspberry Pi.\" Maran discusses his two conference talks about building electronics projects with his children. He provides advice on equipment and techniques to make learning Python engaging. We explore his robotics project and the literal balancing act of designing a robot around the Raspberry Pi. Maran shares his successes and disappointments while working to incorporate computer vision, joystick controls, and voice commands. \n\nThis episode is sponsored by Mailtrap, an email delivery platform that developers love. Try it for free at mailtrap. \n\nAlright, let's get started. The Real Python Podcast is a weekly conversation about using Python in the real world. My name is Christopher Bailey, your host. Each week, we feature interviews with experts in the community and discussions about the topics, articles, and courses found at Real Python. After the podcast, join us and learn real-world Python skills with the community of experts at Real Python. \n\nHi Maran, thanks for coming on the show. \n\nMaran: Oh, it's a pleasure. \n\nChristopher: Yeah, so I'm excited to talk about not only your book but talk about getting into working with electronics and Python. It sounds like you started where a lot of people are starting today. I feel like with CircuitPython, and I've had a few people on. You might have looked through the list of guests I've had to talk about CircuitPython and my excitement about it. Something I haven't talked about is the robot part of it, which I think is going to be fun for us to kind of dig into. Maybe we can start there. How did you get started on this journey? \n\nMaran: It's very"
}